{"ast":null,"code":"import _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport { mat4, mat3 } from 'gl-matrix';\nimport Constants from './LandmarkTransform/Constants.js';\nimport macro from '../../macros.js';\nimport { p as jacobiN, q as perpendiculars } from '../Core/Math/index.js';\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n  return target;\n}\nvar Mode = Constants.Mode; // ----------------------------------------------------------------------------\n// vtkLandmarkTransform methods\n// ----------------------------------------------------------------------------\n\nfunction vtkLandmarkTransform(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkLandmarkTransform');\n  function update() {\n    mat4.identity(model.matrix);\n    var N_PTS = model.sourceLandmark.getNumberOfPoints();\n    if (model.targetLandmark.getNumberOfPoints() !== N_PTS || model.sourceLandmark === null || model.targetLandmark === null || N_PTS === 0) {\n      console.error('Error : Bad inputs of vtkLandmarkTransform');\n      return model.matrix;\n    } // -- find the centroid of each set --\n\n    var sourceCentroid = [0, 0, 0];\n    var targetCentroid = [0, 0, 0];\n    var p = [0, 0, 0];\n    for (var i = 0; i < N_PTS; i++) {\n      model.sourceLandmark.getPoint(i, p);\n      sourceCentroid[0] += p[0];\n      sourceCentroid[1] += p[1];\n      sourceCentroid[2] += p[2];\n      model.targetLandmark.getPoint(i, p);\n      targetCentroid[0] += p[0];\n      targetCentroid[1] += p[1];\n      targetCentroid[2] += p[2];\n    }\n    sourceCentroid[0] /= N_PTS;\n    sourceCentroid[1] /= N_PTS;\n    sourceCentroid[2] /= N_PTS;\n    targetCentroid[0] /= N_PTS;\n    targetCentroid[1] /= N_PTS;\n    targetCentroid[2] /= N_PTS; // -- if only one point, stop right here\n\n    if (N_PTS === 1) {\n      mat4.identity(model.matrix);\n      model.matrix[12] = targetCentroid[0] - sourceCentroid[0];\n      model.matrix[13] = targetCentroid[1] - sourceCentroid[1];\n      model.matrix[14] = targetCentroid[2] - sourceCentroid[2];\n      return model.matrix;\n    } // -- build the 3x3 matrix M --\n\n    var M = new Float64Array(9);\n    var AAT = new Float64Array(9);\n    var a = [0, 0, 0];\n    var b = [0, 0, 0];\n    var sa = 0.0;\n    var sb = 0.0;\n    for (var pt = 0; pt < N_PTS; pt++) {\n      // get the origin-centred point (a) in the source set\n      model.sourceLandmark.getPoint(pt, a);\n      a[0] -= sourceCentroid[0];\n      a[1] -= sourceCentroid[1];\n      a[2] -= sourceCentroid[2]; // get the origin-centred point (b) in the target set\n\n      model.targetLandmark.getPoint(pt, b);\n      b[0] -= targetCentroid[0];\n      b[1] -= targetCentroid[1];\n      b[2] -= targetCentroid[2]; // accumulate the products a*T(b) into the matrix M\n\n      for (var _i = 0; _i < 3; _i++) {\n        M[3 * 0 + _i] += a[_i] * b[0];\n        M[3 * 1 + _i] += a[_i] * b[1];\n        M[3 * 2 + _i] += a[_i] * b[2]; // for the affine transform, compute ((a.a^t)^-1 . a.b^t)^t.\n        // a.b^t is already in M.  here we put a.a^t in AAT.\n\n        if (model.mode === Mode.AFFINE) {\n          AAT[3 * 0 + _i] += a[_i] * a[0];\n          AAT[3 * 1 + _i] += a[_i] * a[1];\n          AAT[3 * 2 + _i] += a[_i] * a[2];\n        }\n      } // accumulate scale factors (if desired)\n\n      sa += a[0] * a[0] + a[1] * a[1] + a[2] * a[2];\n      sb += b[0] * b[0] + b[1] * b[1] + b[2] * b[2];\n    }\n    if (model.mode === Mode.AFFINE) {\n      // AAT = (a.a^t)^-1\n      mat3.invert(AAT, AAT); // M = (a.a^t)^-1 . a.b^t\n\n      mat3.multiply(M, AAT, M); // this->Matrix = M^t\n\n      for (var _i2 = 0; _i2 < 3; ++_i2) {\n        for (var j = 0; j < 3; ++j) {\n          model.matrix[4 * j + _i2] = M[4 * _i2 + j];\n        }\n      }\n    } else {\n      var scale = Math.sqrt(sb / sa); // -- build the 4x4 matrix N --\n\n      var N = new Float64Array(16); // on-diagonal elements\n\n      N[0] = M[0] + M[4] + M[8];\n      N[5] = M[0] - M[4] - M[8];\n      N[10] = -M[0] + M[4] - M[8];\n      N[15] = -M[0] - M[4] + M[8]; // off-diagonal elements\n\n      /* eslint-disable no-multi-assign */\n\n      N[4] = N[1] = M[7] - M[5];\n      N[8] = N[2] = M[2] - M[6];\n      N[12] = N[3] = M[3] - M[1];\n      N[9] = N[6] = M[3] + M[1];\n      N[13] = N[7] = M[2] + M[6];\n      N[14] = N[11] = M[7] + M[5];\n      /* eslint-enable no-multi-assign */\n      // -- eigen-decompose N (is symmetric) --\n      // prettier-ignore\n\n      var eigenVectors = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0];\n      var eigenValues = [0.0, 0.0, 0.0, 0.0];\n      jacobiN(N, 4, eigenValues, eigenVectors); // The eigenvector with the largest eigenvalue is the quaternion we want\n      // (they are sorted in decreasing order for us by JacobiN)\n\n      var w;\n      var x;\n      var y;\n      var z; // first; if points are collinear, choose the quaternion that\n      // results in the smallest rotation\n\n      if (eigenValues[0] === eigenValues[1] || N_PTS === 2) {\n        var s0 = [0, 0, 0];\n        var t0 = [0, 0, 0];\n        var s1 = [0, 0, 0];\n        var t1 = [0, 0, 0];\n        model.sourceLandmark.getPoint(0, s0);\n        model.targetLandmark.getPoint(0, t0);\n        model.sourceLandmark.getPoint(1, s1);\n        model.targetLandmark.getPoint(1, t1);\n        var ds = [0, 0, 0];\n        var dt = [0, 0, 0];\n        var rs = 0;\n        var rt = 0;\n        for (var _i3 = 0; _i3 < 3; _i3++) {\n          ds[_i3] = s1[_i3] - s0[_i3]; // vector between points\n\n          rs = ds[_i3] * ds[_i3] + rs;\n          dt[_i3] = t1[_i3] - t0[_i3];\n          rt = dt[_i3] * dt[_i3] + rt;\n        } // normalize the two vectors\n\n        rs = Math.sqrt(rs);\n        ds[0] /= rs;\n        ds[1] /= rs;\n        ds[2] /= rs;\n        rt = Math.sqrt(rt);\n        dt[0] /= rt;\n        dt[1] /= rt;\n        dt[2] /= rt; // take dot & cross product\n\n        w = ds[0] * dt[0] + ds[1] * dt[1] + ds[2] * dt[2];\n        x = ds[1] * dt[2] - ds[2] * dt[1];\n        y = ds[2] * dt[0] - ds[0] * dt[2];\n        z = ds[0] * dt[1] - ds[1] * dt[0];\n        var r = Math.sqrt(x * x + y * y + z * z);\n        var theta = Math.atan2(r, w); // construct quaternion\n\n        w = Math.cos(theta / 2);\n        if (r !== 0) {\n          r = Math.sin(theta / 2) / r;\n          x *= r;\n          y *= r;\n          z *= r;\n        } else {\n          // rotation by 180 degrees : special case\n          // Rotate around a vector perpendicular to ds\n          perpendiculars(ds, dt, 0, 0);\n          r = Math.sin(theta / 2);\n          x = dt[0] * r;\n          y = dt[1] * r;\n          z = dt[2] * r;\n        }\n      } else {\n        // points are not collinear\n        w = eigenVectors[0];\n        x = eigenVectors[4];\n        y = eigenVectors[8];\n        z = eigenVectors[12];\n      } // convert quaternion to a rotation matrix\n\n      var ww = w * w;\n      var wx = w * x;\n      var wy = w * y;\n      var wz = w * z;\n      var xx = x * x;\n      var yy = y * y;\n      var zz = z * z;\n      var xy = x * y;\n      var xz = x * z;\n      var yz = y * z;\n      model.matrix[0] = ww + xx - yy - zz;\n      model.matrix[1] = 2.0 * (wz + xy);\n      model.matrix[2] = 2.0 * (-wy + xz);\n      model.matrix[4] = 2.0 * (-wz + xy);\n      model.matrix[5] = ww - xx + yy - zz;\n      model.matrix[6] = 2.0 * (wx + yz);\n      model.matrix[8] = 2.0 * (wy + xz);\n      model.matrix[9] = 2.0 * (-wx + yz);\n      model.matrix[10] = ww - xx - yy + zz; // add in the scale factor (if desired)\n\n      if (model.mode !== Mode.RIGID_BODY) {\n        for (var _i4 = 0; _i4 < 3; _i4++) {\n          model.matrix[4 * 0 + _i4] = model.matrix[4 * 0 + _i4] * scale;\n          model.matrix[4 * 1 + _i4] = model.matrix[4 * 1 + _i4] * scale;\n          model.matrix[4 * 2 + _i4] = model.matrix[4 * 2 + _i4] * scale;\n        }\n      }\n    } // the translation is given by the difference in the transformed source\n    // centroid and the target centroid\n\n    var sx = model.matrix[0] * sourceCentroid[0] + model.matrix[4] * sourceCentroid[1] + model.matrix[8] * sourceCentroid[2];\n    var sy = model.matrix[1] * sourceCentroid[0] + model.matrix[5] * sourceCentroid[1] + model.matrix[9] * sourceCentroid[2];\n    var sz = model.matrix[2] * sourceCentroid[0] + model.matrix[6] * sourceCentroid[1] + model.matrix[10] * sourceCentroid[2];\n    model.matrix[12] = targetCentroid[0] - sx;\n    model.matrix[13] = targetCentroid[1] - sy;\n    model.matrix[14] = targetCentroid[2] - sz; // fill the bottom row of the 4x4 matrix\n\n    model.matrix[3] = 0.0;\n    model.matrix[7] = 0.0;\n    model.matrix[11] = 0.0;\n    model.matrix[15] = 1.0;\n    return model.matrix;\n  } // Expose method\n\n  publicAPI.update = update;\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nvar DEFAULT_VALUES = {\n  mode: Mode.SIMILARITY\n}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n  macro.obj(publicAPI, model); // Internal objects initialization\n\n  model.matrix = mat4.identity(new Float64Array(16));\n  macro.setGet(publicAPI, model, ['sourceLandmark', 'targetLandmark', 'mode']);\n  macro.get(publicAPI, model, ['matrix']);\n  vtkLandmarkTransform(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = macro.newInstance(extend, 'vtkLandmarkTransform'); // ----------------------------------------------------------------------------\n\nvar vtkLandmarkTransform$1 = _objectSpread({\n  newInstance: newInstance,\n  extend: extend\n}, Constants);\nexport { vtkLandmarkTransform$1 as default, extend, newInstance };","map":{"version":3,"names":["_defineProperty","mat4","mat3","Constants","macro","p","jacobiN","q","perpendiculars","ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","getOwnPropertyDescriptors","defineProperties","defineProperty","Mode","vtkLandmarkTransform","publicAPI","model","classHierarchy","update","identity","matrix","N_PTS","sourceLandmark","getNumberOfPoints","targetLandmark","console","error","sourceCentroid","targetCentroid","getPoint","M","Float64Array","AAT","a","b","sa","sb","pt","_i","mode","AFFINE","invert","multiply","_i2","j","scale","Math","sqrt","N","eigenVectors","eigenValues","w","x","y","z","s0","t0","s1","t1","ds","dt","rs","rt","_i3","r","theta","atan2","cos","sin","ww","wx","wy","wz","xx","yy","zz","xy","xz","yz","RIGID_BODY","_i4","sx","sy","sz","DEFAULT_VALUES","SIMILARITY","extend","initialValues","undefined","assign","obj","setGet","get","newInstance","vtkLandmarkTransform$1","default"],"sources":["/home/rakshith/Documents/RemoteRendering/vtk-js-react-app/node_modules/@kitware/vtk.js/Common/Transform/LandmarkTransform.js"],"sourcesContent":["import _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport { mat4, mat3 } from 'gl-matrix';\nimport Constants from './LandmarkTransform/Constants.js';\nimport macro from '../../macros.js';\nimport { p as jacobiN, q as perpendiculars } from '../Core/Math/index.js';\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nvar Mode = Constants.Mode; // ----------------------------------------------------------------------------\n// vtkLandmarkTransform methods\n// ----------------------------------------------------------------------------\n\nfunction vtkLandmarkTransform(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkLandmarkTransform');\n\n  function update() {\n    mat4.identity(model.matrix);\n    var N_PTS = model.sourceLandmark.getNumberOfPoints();\n\n    if (model.targetLandmark.getNumberOfPoints() !== N_PTS || model.sourceLandmark === null || model.targetLandmark === null || N_PTS === 0) {\n      console.error('Error : Bad inputs of vtkLandmarkTransform');\n      return model.matrix;\n    } // -- find the centroid of each set --\n\n\n    var sourceCentroid = [0, 0, 0];\n    var targetCentroid = [0, 0, 0];\n    var p = [0, 0, 0];\n\n    for (var i = 0; i < N_PTS; i++) {\n      model.sourceLandmark.getPoint(i, p);\n      sourceCentroid[0] += p[0];\n      sourceCentroid[1] += p[1];\n      sourceCentroid[2] += p[2];\n      model.targetLandmark.getPoint(i, p);\n      targetCentroid[0] += p[0];\n      targetCentroid[1] += p[1];\n      targetCentroid[2] += p[2];\n    }\n\n    sourceCentroid[0] /= N_PTS;\n    sourceCentroid[1] /= N_PTS;\n    sourceCentroid[2] /= N_PTS;\n    targetCentroid[0] /= N_PTS;\n    targetCentroid[1] /= N_PTS;\n    targetCentroid[2] /= N_PTS; // -- if only one point, stop right here\n\n    if (N_PTS === 1) {\n      mat4.identity(model.matrix);\n      model.matrix[12] = targetCentroid[0] - sourceCentroid[0];\n      model.matrix[13] = targetCentroid[1] - sourceCentroid[1];\n      model.matrix[14] = targetCentroid[2] - sourceCentroid[2];\n      return model.matrix;\n    } // -- build the 3x3 matrix M --\n\n\n    var M = new Float64Array(9);\n    var AAT = new Float64Array(9);\n    var a = [0, 0, 0];\n    var b = [0, 0, 0];\n    var sa = 0.0;\n    var sb = 0.0;\n\n    for (var pt = 0; pt < N_PTS; pt++) {\n      // get the origin-centred point (a) in the source set\n      model.sourceLandmark.getPoint(pt, a);\n      a[0] -= sourceCentroid[0];\n      a[1] -= sourceCentroid[1];\n      a[2] -= sourceCentroid[2]; // get the origin-centred point (b) in the target set\n\n      model.targetLandmark.getPoint(pt, b);\n      b[0] -= targetCentroid[0];\n      b[1] -= targetCentroid[1];\n      b[2] -= targetCentroid[2]; // accumulate the products a*T(b) into the matrix M\n\n      for (var _i = 0; _i < 3; _i++) {\n        M[3 * 0 + _i] += a[_i] * b[0];\n        M[3 * 1 + _i] += a[_i] * b[1];\n        M[3 * 2 + _i] += a[_i] * b[2]; // for the affine transform, compute ((a.a^t)^-1 . a.b^t)^t.\n        // a.b^t is already in M.  here we put a.a^t in AAT.\n\n        if (model.mode === Mode.AFFINE) {\n          AAT[3 * 0 + _i] += a[_i] * a[0];\n          AAT[3 * 1 + _i] += a[_i] * a[1];\n          AAT[3 * 2 + _i] += a[_i] * a[2];\n        }\n      } // accumulate scale factors (if desired)\n\n\n      sa += a[0] * a[0] + a[1] * a[1] + a[2] * a[2];\n      sb += b[0] * b[0] + b[1] * b[1] + b[2] * b[2];\n    }\n\n    if (model.mode === Mode.AFFINE) {\n      // AAT = (a.a^t)^-1\n      mat3.invert(AAT, AAT); // M = (a.a^t)^-1 . a.b^t\n\n      mat3.multiply(M, AAT, M); // this->Matrix = M^t\n\n      for (var _i2 = 0; _i2 < 3; ++_i2) {\n        for (var j = 0; j < 3; ++j) {\n          model.matrix[4 * j + _i2] = M[4 * _i2 + j];\n        }\n      }\n    } else {\n      var scale = Math.sqrt(sb / sa); // -- build the 4x4 matrix N --\n\n      var N = new Float64Array(16); // on-diagonal elements\n\n      N[0] = M[0] + M[4] + M[8];\n      N[5] = M[0] - M[4] - M[8];\n      N[10] = -M[0] + M[4] - M[8];\n      N[15] = -M[0] - M[4] + M[8]; // off-diagonal elements\n\n      /* eslint-disable no-multi-assign */\n\n      N[4] = N[1] = M[7] - M[5];\n      N[8] = N[2] = M[2] - M[6];\n      N[12] = N[3] = M[3] - M[1];\n      N[9] = N[6] = M[3] + M[1];\n      N[13] = N[7] = M[2] + M[6];\n      N[14] = N[11] = M[7] + M[5];\n      /* eslint-enable no-multi-assign */\n      // -- eigen-decompose N (is symmetric) --\n      // prettier-ignore\n\n      var eigenVectors = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0];\n      var eigenValues = [0.0, 0.0, 0.0, 0.0];\n      jacobiN(N, 4, eigenValues, eigenVectors); // The eigenvector with the largest eigenvalue is the quaternion we want\n      // (they are sorted in decreasing order for us by JacobiN)\n\n      var w;\n      var x;\n      var y;\n      var z; // first; if points are collinear, choose the quaternion that\n      // results in the smallest rotation\n\n      if (eigenValues[0] === eigenValues[1] || N_PTS === 2) {\n        var s0 = [0, 0, 0];\n        var t0 = [0, 0, 0];\n        var s1 = [0, 0, 0];\n        var t1 = [0, 0, 0];\n        model.sourceLandmark.getPoint(0, s0);\n        model.targetLandmark.getPoint(0, t0);\n        model.sourceLandmark.getPoint(1, s1);\n        model.targetLandmark.getPoint(1, t1);\n        var ds = [0, 0, 0];\n        var dt = [0, 0, 0];\n        var rs = 0;\n        var rt = 0;\n\n        for (var _i3 = 0; _i3 < 3; _i3++) {\n          ds[_i3] = s1[_i3] - s0[_i3]; // vector between points\n\n          rs = ds[_i3] * ds[_i3] + rs;\n          dt[_i3] = t1[_i3] - t0[_i3];\n          rt = dt[_i3] * dt[_i3] + rt;\n        } // normalize the two vectors\n\n\n        rs = Math.sqrt(rs);\n        ds[0] /= rs;\n        ds[1] /= rs;\n        ds[2] /= rs;\n        rt = Math.sqrt(rt);\n        dt[0] /= rt;\n        dt[1] /= rt;\n        dt[2] /= rt; // take dot & cross product\n\n        w = ds[0] * dt[0] + ds[1] * dt[1] + ds[2] * dt[2];\n        x = ds[1] * dt[2] - ds[2] * dt[1];\n        y = ds[2] * dt[0] - ds[0] * dt[2];\n        z = ds[0] * dt[1] - ds[1] * dt[0];\n        var r = Math.sqrt(x * x + y * y + z * z);\n        var theta = Math.atan2(r, w); // construct quaternion\n\n        w = Math.cos(theta / 2);\n\n        if (r !== 0) {\n          r = Math.sin(theta / 2) / r;\n          x *= r;\n          y *= r;\n          z *= r;\n        } else {\n          // rotation by 180 degrees : special case\n          // Rotate around a vector perpendicular to ds\n          perpendiculars(ds, dt, 0, 0);\n          r = Math.sin(theta / 2);\n          x = dt[0] * r;\n          y = dt[1] * r;\n          z = dt[2] * r;\n        }\n      } else {\n        // points are not collinear\n        w = eigenVectors[0];\n        x = eigenVectors[4];\n        y = eigenVectors[8];\n        z = eigenVectors[12];\n      } // convert quaternion to a rotation matrix\n\n\n      var ww = w * w;\n      var wx = w * x;\n      var wy = w * y;\n      var wz = w * z;\n      var xx = x * x;\n      var yy = y * y;\n      var zz = z * z;\n      var xy = x * y;\n      var xz = x * z;\n      var yz = y * z;\n      model.matrix[0] = ww + xx - yy - zz;\n      model.matrix[1] = 2.0 * (wz + xy);\n      model.matrix[2] = 2.0 * (-wy + xz);\n      model.matrix[4] = 2.0 * (-wz + xy);\n      model.matrix[5] = ww - xx + yy - zz;\n      model.matrix[6] = 2.0 * (wx + yz);\n      model.matrix[8] = 2.0 * (wy + xz);\n      model.matrix[9] = 2.0 * (-wx + yz);\n      model.matrix[10] = ww - xx - yy + zz; // add in the scale factor (if desired)\n\n      if (model.mode !== Mode.RIGID_BODY) {\n        for (var _i4 = 0; _i4 < 3; _i4++) {\n          model.matrix[4 * 0 + _i4] = model.matrix[4 * 0 + _i4] * scale;\n          model.matrix[4 * 1 + _i4] = model.matrix[4 * 1 + _i4] * scale;\n          model.matrix[4 * 2 + _i4] = model.matrix[4 * 2 + _i4] * scale;\n        }\n      }\n    } // the translation is given by the difference in the transformed source\n    // centroid and the target centroid\n\n\n    var sx = model.matrix[0] * sourceCentroid[0] + model.matrix[4] * sourceCentroid[1] + model.matrix[8] * sourceCentroid[2];\n    var sy = model.matrix[1] * sourceCentroid[0] + model.matrix[5] * sourceCentroid[1] + model.matrix[9] * sourceCentroid[2];\n    var sz = model.matrix[2] * sourceCentroid[0] + model.matrix[6] * sourceCentroid[1] + model.matrix[10] * sourceCentroid[2];\n    model.matrix[12] = targetCentroid[0] - sx;\n    model.matrix[13] = targetCentroid[1] - sy;\n    model.matrix[14] = targetCentroid[2] - sz; // fill the bottom row of the 4x4 matrix\n\n    model.matrix[3] = 0.0;\n    model.matrix[7] = 0.0;\n    model.matrix[11] = 0.0;\n    model.matrix[15] = 1.0;\n    return model.matrix;\n  } // Expose method\n\n\n  publicAPI.update = update;\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\n\nvar DEFAULT_VALUES = {\n  mode: Mode.SIMILARITY\n}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n  macro.obj(publicAPI, model); // Internal objects initialization\n\n  model.matrix = mat4.identity(new Float64Array(16));\n  macro.setGet(publicAPI, model, ['sourceLandmark', 'targetLandmark', 'mode']);\n  macro.get(publicAPI, model, ['matrix']);\n  vtkLandmarkTransform(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = macro.newInstance(extend, 'vtkLandmarkTransform'); // ----------------------------------------------------------------------------\n\nvar vtkLandmarkTransform$1 = _objectSpread({\n  newInstance: newInstance,\n  extend: extend\n}, Constants);\n\nexport { vtkLandmarkTransform$1 as default, extend, newInstance };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}