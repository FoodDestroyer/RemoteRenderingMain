{"ast":null,"code":"import _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport _toConsumableArray from '@babel/runtime/helpers/toConsumableArray';\nimport macro from '../../macros.js';\nimport vtkCellArray from '../../Common/Core/CellArray.js';\nimport vtkPolygon from '../../Common/DataModel/Polygon.js';\nimport vtkPolyData from '../../Common/DataModel/PolyData.js';\nimport { VtkDataTypes } from '../../Common/Core/DataArray/Constants.js';\nimport { vtkCCSMakePolysFromLines, vtkCCSJoinLooseEnds, vtkCCSFindTrueEdges, vtkCCSMakeHoleyPolys, vtkCCSCutHoleyPolys, vtkCCSSplitAtPinchPoints, vtkCCSTriangulate } from './ContourTriangulator/helper.js';\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n  return target;\n}\nvar vtkErrorMacro = macro.vtkErrorMacro;\nvar TRIANGULATION_ERROR_DISPLAY = false;\nfunction triangulateContours(polyData, firstLine, numLines, polys, normal) {\n  var triangulatePolys = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;\n  var triangulationFailure = false; // If no cut lines were generated, there's nothing to do\n\n  if (numLines <= 0) {\n    return false;\n  }\n  var points = polyData.getPoints(); // Join all the new lines into connected groups, i.e. polygons.\n  // If we are lucky these will be simple, convex polygons. But\n  // we can't count on that.\n\n  var newPolys = [];\n  var incompletePolys = [];\n  var oriented = (normal === null || normal === void 0 ? void 0 : normal.length) < 3;\n  vtkCCSMakePolysFromLines(polyData, firstLine, firstLine + numLines, oriented, newPolys, incompletePolys); // if no normal specified, then compute one from largest contour\n\n  var computedNormal = normal;\n  if (!oriented) {\n    computedNormal = [0, 0, 1];\n    var maxnorm = 0;\n    var n = [];\n    for (var i = 0; i < newPolys.length; i++) {\n      var norm = vtkPolygon.getNormal(newPolys[i], points, n);\n      if (norm > maxnorm) {\n        maxnorm = norm;\n        computedNormal[0] = n[0];\n        computedNormal[1] = n[1];\n        computedNormal[2] = n[2];\n      }\n    }\n  } // Join any loose ends. If the input was a closed surface then there\n  // will not be any loose ends, so this is provided as a service to users\n  // who want to clip a non-closed surface.\n\n  vtkCCSJoinLooseEnds(newPolys, incompletePolys, points, computedNormal); // Some points might be in the middle of straight line segments.\n  // These points can be removed without changing the shape of the\n  // polys, and removing them makes triangulation more stable.\n  // Unfortunately removing these points also means that the polys\n  // will no longer form a watertight cap over the cut.\n\n  var polyEdges = [];\n  var originalEdges = [];\n  vtkCCSFindTrueEdges(newPolys, points, polyEdges, originalEdges); // Next we have to check for polygons with holes, i.e. polygons that\n  // have other polygons inside. Each polygon is \"grouped\" with the\n  // polygons that make up its holes.\n  // Initialize each group to hold just one polygon.\n\n  var numNewPolys = newPolys.length;\n  var polyGroups = new Array(numNewPolys);\n  for (var _i = 0; _i < numNewPolys; _i++) {\n    polyGroups[_i] = [_i];\n  } // Find out which polys are holes in larger polys. Create a group\n  // for each poly where the first member of the group is the larger\n  // poly, and all other members are the holes. The number of polyGroups\n  // will be the same as the number of polys, and any polys that are\n  // holes will have a matching empty group.\n\n  vtkCCSMakeHoleyPolys(newPolys, points, polyGroups, polyEdges, originalEdges, computedNormal, oriented); // Make cuts to create simple polygons out of the holey polys.\n  // After this is done, each polyGroup will have exactly 1 polygon,\n  // and no polys will be holes. This is currently the most computationally\n  // expensive part of the process.\n\n  if (!vtkCCSCutHoleyPolys(newPolys, points, polyGroups, polyEdges, computedNormal)) {\n    triangulationFailure = true;\n  } // Some polys might be self-intersecting. Split the polys at each intersection point.\n\n  vtkCCSSplitAtPinchPoints(newPolys, points, polyGroups, polyEdges, computedNormal, oriented); // ------ Triangulation code ------\n  // Go through all polys and triangulate them\n\n  for (var polyId = 0; polyId < polyGroups.length; polyId++) {\n    // If group is empty, then poly was a hole without a containing poly\n    if (polyGroups[polyId].length === 0) {\n      // eslint-disable-next-line no-continue\n      continue;\n    }\n    if (!triangulatePolys) {\n      polys.insertNextCell(originalEdges.slice(1, originalEdges.length));\n    } else if (!vtkCCSTriangulate(newPolys[polyId], points, polyEdges[polyId], originalEdges, polys, computedNormal)) {\n      triangulationFailure = false; // Diagnostic code: show the polys as outlines\n    }\n  }\n\n  return !triangulationFailure;\n} // ---------------------------------------------------\n\nfunction triangulatePolygon(polygon, points, triangles) {\n  var poly = _toConsumableArray(polygon);\n  var polys = [poly];\n  var originalEdges = [];\n  var polyEdges = [];\n  vtkCCSFindTrueEdges(polys, points, polyEdges, originalEdges);\n  var edges = polyEdges[0];\n  var success = true;\n  var normal = [];\n  var norm = vtkPolygon.getNormal(poly, points, normal);\n  if (norm !== 0) {\n    success = vtkCCSTriangulate(poly, points, edges, originalEdges, triangles, normal);\n  }\n  return success;\n}\nvar STATIC = {\n  triangulateContours: triangulateContours,\n  triangulatePolygon: triangulatePolygon\n};\nfunction vtkContourTriangulator(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkContourTriangulator');\n  publicAPI.requestData = function (inData, outData) {\n    // implement requestData\n    var input = inData[0]; // FIXME: do not instantiate a new polydata each time the filter is executed.\n\n    var output = vtkPolyData.newInstance();\n    outData[0] = output;\n    if (!input) {\n      vtkErrorMacro('Invalid or missing input');\n      return false;\n    }\n    var triangulationError = false;\n    var lines = input.getLines();\n    if (lines == null || lines.getNumberOfCells() === 0) {\n      return true;\n    }\n    input.buildCells();\n    var polysArray = vtkCellArray.newInstance({\n      dataType: VtkDataTypes.DOUBLE,\n      empty: true\n    });\n    output.setPolys(polysArray);\n    output.setPoints(input.getPoints());\n    output.getPointData().passData(input.getPointData());\n    triangulationError = !triangulateContours(input, input.getNumberOfVerts(), lines.getNumberOfCells(), polysArray, null, model.triangulatePolys);\n    if (triangulationError && TRIANGULATION_ERROR_DISPLAY) {\n      vtkErrorMacro('Triangulation failed, output might have holes.');\n    }\n    return true;\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nvar DEFAULT_VALUES = {\n  triangulatePolys: true\n}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Make this a VTK object\n\n  macro.obj(publicAPI, model); // Also make it an algorithm with one input and one output\n\n  macro.algo(publicAPI, model, 1, 1);\n  macro.setGet(publicAPI, model, ['triangulatePolys']); // Object specific methods\n\n  vtkContourTriangulator(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = macro.newInstance(extend, 'vtkContourTriangulator'); // ----------------------------------------------------------------------------\n\nvar vtkContourTriangulator$1 = _objectSpread({\n  newInstance: newInstance,\n  extend: extend\n}, STATIC);\nexport { STATIC, vtkContourTriangulator$1 as default, extend, newInstance };","map":{"version":3,"names":["_defineProperty","_toConsumableArray","macro","vtkCellArray","vtkPolygon","vtkPolyData","VtkDataTypes","vtkCCSMakePolysFromLines","vtkCCSJoinLooseEnds","vtkCCSFindTrueEdges","vtkCCSMakeHoleyPolys","vtkCCSCutHoleyPolys","vtkCCSSplitAtPinchPoints","vtkCCSTriangulate","ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","getOwnPropertyDescriptors","defineProperties","defineProperty","vtkErrorMacro","TRIANGULATION_ERROR_DISPLAY","triangulateContours","polyData","firstLine","numLines","polys","normal","triangulatePolys","undefined","triangulationFailure","points","getPoints","newPolys","incompletePolys","oriented","computedNormal","maxnorm","n","norm","getNormal","polyEdges","originalEdges","numNewPolys","polyGroups","Array","_i","polyId","insertNextCell","slice","triangulatePolygon","polygon","triangles","poly","edges","success","STATIC","vtkContourTriangulator","publicAPI","model","classHierarchy","requestData","inData","outData","input","output","newInstance","triangulationError","lines","getLines","getNumberOfCells","buildCells","polysArray","dataType","DOUBLE","empty","setPolys","setPoints","getPointData","passData","getNumberOfVerts","DEFAULT_VALUES","extend","initialValues","assign","obj","algo","setGet","vtkContourTriangulator$1","default"],"sources":["/home/rakshith/Documents/RemoteRendering/vtk-js-react-app/node_modules/@kitware/vtk.js/Filters/General/ContourTriangulator.js"],"sourcesContent":["import _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport _toConsumableArray from '@babel/runtime/helpers/toConsumableArray';\nimport macro from '../../macros.js';\nimport vtkCellArray from '../../Common/Core/CellArray.js';\nimport vtkPolygon from '../../Common/DataModel/Polygon.js';\nimport vtkPolyData from '../../Common/DataModel/PolyData.js';\nimport { VtkDataTypes } from '../../Common/Core/DataArray/Constants.js';\nimport { vtkCCSMakePolysFromLines, vtkCCSJoinLooseEnds, vtkCCSFindTrueEdges, vtkCCSMakeHoleyPolys, vtkCCSCutHoleyPolys, vtkCCSSplitAtPinchPoints, vtkCCSTriangulate } from './ContourTriangulator/helper.js';\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nvar vtkErrorMacro = macro.vtkErrorMacro;\nvar TRIANGULATION_ERROR_DISPLAY = false;\n\nfunction triangulateContours(polyData, firstLine, numLines, polys, normal) {\n  var triangulatePolys = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;\n  var triangulationFailure = false; // If no cut lines were generated, there's nothing to do\n\n  if (numLines <= 0) {\n    return false;\n  }\n\n  var points = polyData.getPoints(); // Join all the new lines into connected groups, i.e. polygons.\n  // If we are lucky these will be simple, convex polygons. But\n  // we can't count on that.\n\n  var newPolys = [];\n  var incompletePolys = [];\n  var oriented = (normal === null || normal === void 0 ? void 0 : normal.length) < 3;\n  vtkCCSMakePolysFromLines(polyData, firstLine, firstLine + numLines, oriented, newPolys, incompletePolys); // if no normal specified, then compute one from largest contour\n\n  var computedNormal = normal;\n\n  if (!oriented) {\n    computedNormal = [0, 0, 1];\n    var maxnorm = 0;\n    var n = [];\n\n    for (var i = 0; i < newPolys.length; i++) {\n      var norm = vtkPolygon.getNormal(newPolys[i], points, n);\n\n      if (norm > maxnorm) {\n        maxnorm = norm;\n        computedNormal[0] = n[0];\n        computedNormal[1] = n[1];\n        computedNormal[2] = n[2];\n      }\n    }\n  } // Join any loose ends. If the input was a closed surface then there\n  // will not be any loose ends, so this is provided as a service to users\n  // who want to clip a non-closed surface.\n\n\n  vtkCCSJoinLooseEnds(newPolys, incompletePolys, points, computedNormal); // Some points might be in the middle of straight line segments.\n  // These points can be removed without changing the shape of the\n  // polys, and removing them makes triangulation more stable.\n  // Unfortunately removing these points also means that the polys\n  // will no longer form a watertight cap over the cut.\n\n  var polyEdges = [];\n  var originalEdges = [];\n  vtkCCSFindTrueEdges(newPolys, points, polyEdges, originalEdges); // Next we have to check for polygons with holes, i.e. polygons that\n  // have other polygons inside. Each polygon is \"grouped\" with the\n  // polygons that make up its holes.\n  // Initialize each group to hold just one polygon.\n\n  var numNewPolys = newPolys.length;\n  var polyGroups = new Array(numNewPolys);\n\n  for (var _i = 0; _i < numNewPolys; _i++) {\n    polyGroups[_i] = [_i];\n  } // Find out which polys are holes in larger polys. Create a group\n  // for each poly where the first member of the group is the larger\n  // poly, and all other members are the holes. The number of polyGroups\n  // will be the same as the number of polys, and any polys that are\n  // holes will have a matching empty group.\n\n\n  vtkCCSMakeHoleyPolys(newPolys, points, polyGroups, polyEdges, originalEdges, computedNormal, oriented); // Make cuts to create simple polygons out of the holey polys.\n  // After this is done, each polyGroup will have exactly 1 polygon,\n  // and no polys will be holes. This is currently the most computationally\n  // expensive part of the process.\n\n  if (!vtkCCSCutHoleyPolys(newPolys, points, polyGroups, polyEdges, computedNormal)) {\n    triangulationFailure = true;\n  } // Some polys might be self-intersecting. Split the polys at each intersection point.\n\n\n  vtkCCSSplitAtPinchPoints(newPolys, points, polyGroups, polyEdges, computedNormal, oriented); // ------ Triangulation code ------\n  // Go through all polys and triangulate them\n\n  for (var polyId = 0; polyId < polyGroups.length; polyId++) {\n    // If group is empty, then poly was a hole without a containing poly\n    if (polyGroups[polyId].length === 0) {\n      // eslint-disable-next-line no-continue\n      continue;\n    }\n\n    if (!triangulatePolys) {\n      polys.insertNextCell(originalEdges.slice(1, originalEdges.length));\n    } else if (!vtkCCSTriangulate(newPolys[polyId], points, polyEdges[polyId], originalEdges, polys, computedNormal)) {\n      triangulationFailure = false; // Diagnostic code: show the polys as outlines\n    }\n  }\n\n  return !triangulationFailure;\n} // ---------------------------------------------------\n\n\nfunction triangulatePolygon(polygon, points, triangles) {\n  var poly = _toConsumableArray(polygon);\n\n  var polys = [poly];\n  var originalEdges = [];\n  var polyEdges = [];\n  vtkCCSFindTrueEdges(polys, points, polyEdges, originalEdges);\n  var edges = polyEdges[0];\n  var success = true;\n  var normal = [];\n  var norm = vtkPolygon.getNormal(poly, points, normal);\n\n  if (norm !== 0) {\n    success = vtkCCSTriangulate(poly, points, edges, originalEdges, triangles, normal);\n  }\n\n  return success;\n}\n\nvar STATIC = {\n  triangulateContours: triangulateContours,\n  triangulatePolygon: triangulatePolygon\n};\n\nfunction vtkContourTriangulator(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkContourTriangulator');\n\n  publicAPI.requestData = function (inData, outData) {\n    // implement requestData\n    var input = inData[0]; // FIXME: do not instantiate a new polydata each time the filter is executed.\n\n    var output = vtkPolyData.newInstance();\n    outData[0] = output;\n\n    if (!input) {\n      vtkErrorMacro('Invalid or missing input');\n      return false;\n    }\n\n    var triangulationError = false;\n    var lines = input.getLines();\n\n    if (lines == null || lines.getNumberOfCells() === 0) {\n      return true;\n    }\n\n    input.buildCells();\n    var polysArray = vtkCellArray.newInstance({\n      dataType: VtkDataTypes.DOUBLE,\n      empty: true\n    });\n    output.setPolys(polysArray);\n    output.setPoints(input.getPoints());\n    output.getPointData().passData(input.getPointData());\n    triangulationError = !triangulateContours(input, input.getNumberOfVerts(), lines.getNumberOfCells(), polysArray, null, model.triangulatePolys);\n\n    if (triangulationError && TRIANGULATION_ERROR_DISPLAY) {\n      vtkErrorMacro('Triangulation failed, output might have holes.');\n    }\n\n    return true;\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\n\nvar DEFAULT_VALUES = {\n  triangulatePolys: true\n}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Make this a VTK object\n\n  macro.obj(publicAPI, model); // Also make it an algorithm with one input and one output\n\n  macro.algo(publicAPI, model, 1, 1);\n  macro.setGet(publicAPI, model, ['triangulatePolys']); // Object specific methods\n\n  vtkContourTriangulator(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = macro.newInstance(extend, 'vtkContourTriangulator'); // ----------------------------------------------------------------------------\n\nvar vtkContourTriangulator$1 = _objectSpread({\n  newInstance: newInstance,\n  extend: extend\n}, STATIC);\n\nexport { STATIC, vtkContourTriangulator$1 as default, extend, newInstance };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}