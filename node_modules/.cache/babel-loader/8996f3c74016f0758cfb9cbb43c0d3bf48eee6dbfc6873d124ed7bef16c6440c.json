{"ast":null,"code":"import macro from '../../macros.js';\nimport ITKHelper from '../../Common/DataModel/ITKHelper.js';\nvar convertItkToVtkImage = ITKHelper.convertItkToVtkImage;\nvar readImageArrayBuffer = null;\nvar resultPreprocessor = function resultPreprocessor(result) {\n  return result;\n};\nfunction getArrayName(filename) {\n  var idx = filename.lastIndexOf('.');\n  var name = idx > -1 ? filename.substring(0, idx) : filename;\n  return \"Scalars \".concat(name);\n}\nfunction setReadImageArrayBufferFromITK(fn) {\n  readImageArrayBuffer = fn; // itk.js 9.0.0 introduced breaking changes, which can be detected\n  // by an updated function signature.\n\n  if (readImageArrayBuffer.length === 4) {\n    // first arg is a webworker if reuse is desired.\n    readImageArrayBuffer = function readImageArrayBuffer() {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      return fn.apply(void 0, [null].concat(args));\n    }; // an object is now passed out which includes a webworker which we\n    // should terminate\n\n    resultPreprocessor = function resultPreprocessor(_ref) {\n      var webWorker = _ref.webWorker,\n        image = _ref.image;\n      webWorker.terminate();\n      return image;\n    };\n  }\n} // ----------------------------------------------------------------------------\n// vtkITKImageReader methods\n// ----------------------------------------------------------------------------\n\nfunction vtkITKImageReader(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkITKImageReader'); // Returns a promise to signal when image is ready\n\n  publicAPI.parseAsArrayBuffer = function (arrayBuffer) {\n    if (!arrayBuffer || arrayBuffer === model.rawDataBuffer) {\n      return Promise.resolve();\n    }\n    model.rawDataBuffer = arrayBuffer;\n    return readImageArrayBuffer(arrayBuffer, model.fileName).then(resultPreprocessor).then(function (itkImage) {\n      var imageData = convertItkToVtkImage(itkImage, {\n        scalarArrayName: model.arrayName || getArrayName(model.fileName)\n      });\n      model.output[0] = imageData;\n      publicAPI.modified();\n    });\n  };\n  publicAPI.requestData = function (inData, outData) {\n    publicAPI.parseAsArrayBuffer(model.rawDataBuffer, model.fileName);\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nvar DEFAULT_VALUES = {\n  fileName: '',\n  // If null/undefined a unique array will be generated\n  arrayName: null\n}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Build VTK API\n\n  macro.obj(publicAPI, model);\n  macro.algo(publicAPI, model, 0, 1);\n  macro.setGet(publicAPI, model, ['fileName', 'arrayName']); // vtkITKImageReader methods\n\n  vtkITKImageReader(publicAPI, model); // Check that ITK function has been injected\n\n  if (!readImageArrayBuffer) {\n    console.error(\"\\n      // Dependency needs to be added inside your project\\n      import readImageArrayBuffer from 'itk/readImageArrayBuffer';\\n      vtkITKImageReader.setReadImageArrayBufferFromITK(readImageArrayBuffer);\\n      \");\n  }\n} // ----------------------------------------------------------------------------\n\nvar newInstance = macro.newInstance(extend, 'vtkITKImageReader'); // ----------------------------------------------------------------------------\n\nvar vtkITKImageReader$1 = {\n  newInstance: newInstance,\n  extend: extend,\n  setReadImageArrayBufferFromITK: setReadImageArrayBufferFromITK\n};\nexport { vtkITKImageReader$1 as default, extend, newInstance };","map":{"version":3,"names":["macro","ITKHelper","convertItkToVtkImage","readImageArrayBuffer","resultPreprocessor","result","getArrayName","filename","idx","lastIndexOf","name","substring","concat","setReadImageArrayBufferFromITK","fn","length","_len","arguments","args","Array","_key","apply","_ref","webWorker","image","terminate","vtkITKImageReader","publicAPI","model","classHierarchy","push","parseAsArrayBuffer","arrayBuffer","rawDataBuffer","Promise","resolve","fileName","then","itkImage","imageData","scalarArrayName","arrayName","output","modified","requestData","inData","outData","DEFAULT_VALUES","extend","initialValues","undefined","Object","assign","obj","algo","setGet","console","error","newInstance","vtkITKImageReader$1","default"],"sources":["/home/rakshith/Documents/RemoteRendering/vtk-js-react-app/node_modules/@kitware/vtk.js/IO/Misc/ITKImageReader.js"],"sourcesContent":["import macro from '../../macros.js';\nimport ITKHelper from '../../Common/DataModel/ITKHelper.js';\n\nvar convertItkToVtkImage = ITKHelper.convertItkToVtkImage;\nvar readImageArrayBuffer = null;\n\nvar resultPreprocessor = function resultPreprocessor(result) {\n  return result;\n};\n\nfunction getArrayName(filename) {\n  var idx = filename.lastIndexOf('.');\n  var name = idx > -1 ? filename.substring(0, idx) : filename;\n  return \"Scalars \".concat(name);\n}\n\nfunction setReadImageArrayBufferFromITK(fn) {\n  readImageArrayBuffer = fn; // itk.js 9.0.0 introduced breaking changes, which can be detected\n  // by an updated function signature.\n\n  if (readImageArrayBuffer.length === 4) {\n    // first arg is a webworker if reuse is desired.\n    readImageArrayBuffer = function readImageArrayBuffer() {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      return fn.apply(void 0, [null].concat(args));\n    }; // an object is now passed out which includes a webworker which we\n    // should terminate\n\n\n    resultPreprocessor = function resultPreprocessor(_ref) {\n      var webWorker = _ref.webWorker,\n          image = _ref.image;\n      webWorker.terminate();\n      return image;\n    };\n  }\n} // ----------------------------------------------------------------------------\n// vtkITKImageReader methods\n// ----------------------------------------------------------------------------\n\n\nfunction vtkITKImageReader(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkITKImageReader'); // Returns a promise to signal when image is ready\n\n  publicAPI.parseAsArrayBuffer = function (arrayBuffer) {\n    if (!arrayBuffer || arrayBuffer === model.rawDataBuffer) {\n      return Promise.resolve();\n    }\n\n    model.rawDataBuffer = arrayBuffer;\n    return readImageArrayBuffer(arrayBuffer, model.fileName).then(resultPreprocessor).then(function (itkImage) {\n      var imageData = convertItkToVtkImage(itkImage, {\n        scalarArrayName: model.arrayName || getArrayName(model.fileName)\n      });\n      model.output[0] = imageData;\n      publicAPI.modified();\n    });\n  };\n\n  publicAPI.requestData = function (inData, outData) {\n    publicAPI.parseAsArrayBuffer(model.rawDataBuffer, model.fileName);\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\n\nvar DEFAULT_VALUES = {\n  fileName: '',\n  // If null/undefined a unique array will be generated\n  arrayName: null\n}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Build VTK API\n\n  macro.obj(publicAPI, model);\n  macro.algo(publicAPI, model, 0, 1);\n  macro.setGet(publicAPI, model, ['fileName', 'arrayName']); // vtkITKImageReader methods\n\n  vtkITKImageReader(publicAPI, model); // Check that ITK function has been injected\n\n  if (!readImageArrayBuffer) {\n    console.error(\"\\n      // Dependency needs to be added inside your project\\n      import readImageArrayBuffer from 'itk/readImageArrayBuffer';\\n      vtkITKImageReader.setReadImageArrayBufferFromITK(readImageArrayBuffer);\\n      \");\n  }\n} // ----------------------------------------------------------------------------\n\nvar newInstance = macro.newInstance(extend, 'vtkITKImageReader'); // ----------------------------------------------------------------------------\n\nvar vtkITKImageReader$1 = {\n  newInstance: newInstance,\n  extend: extend,\n  setReadImageArrayBufferFromITK: setReadImageArrayBufferFromITK\n};\n\nexport { vtkITKImageReader$1 as default, extend, newInstance };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}