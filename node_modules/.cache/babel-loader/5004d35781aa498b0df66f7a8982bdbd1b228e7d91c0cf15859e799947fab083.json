{"ast":null,"code":"// Helper borrowed from paraviewweb/src/Common/Core\nimport CompositeClosureHelper from '../CompositeClosureHelper';\nimport JSON5 from 'json5';\nfunction defer() {\n  const deferred = {};\n  deferred.promise = new Promise(function (resolve, reject) {\n    deferred.resolve = resolve;\n    deferred.reject = reject;\n  });\n  return deferred;\n}\nfunction Session(publicAPI, model) {\n  const CLIENT_ERROR = -32099;\n  let msgCount = 0;\n  const inFlightRpc = {};\n  const attachments = [];\n  const attachmentsToSend = {};\n  let attachmentId = 1;\n  const regexAttach = /^wslink_bin[\\d]+$/;\n  // matches 'rpc:client3:21'\n  // client may be dot-separated and include '_'\n  // number is message count - unique.\n  // matches 'publish:dot.separated.topic:42'\n  const regexRPC = /^(rpc|publish|system):(\\w+(?:\\.\\w+)*):(?:\\d+)$/;\n  const subscriptions = {};\n  let clientID = null;\n\n  // --------------------------------------------------------------------------\n  // Private helpers\n  // --------------------------------------------------------------------------\n\n  function sendBinary(key) {\n    if (key in attachmentsToSend) {\n      // binary header\n      model.ws.send(JSON.stringify({\n        wslink: '1.0',\n        method: 'wslink.binary.attachment',\n        args: [key]\n      }));\n\n      // send binary\n      model.ws.send(attachmentsToSend[key], {\n        binary: true\n      });\n      delete attachmentsToSend[key];\n    }\n  }\n\n  // --------------------------------------------------------------------------\n\n  function findBinary(o) {\n    if (o) {\n      if (Array.isArray(o)) {\n        o.forEach(v => findBinary(v));\n      } else if (o.constructor === Object) {\n        Object.keys(o).forEach(k => findBinary(o[k]));\n      } else if (regexAttach.test(o)) {\n        sendBinary(o);\n      }\n    }\n  }\n\n  // --------------------------------------------------------------------------\n  // split out to support a message with a bare binary attachment.\n  // --------------------------------------------------------------------------\n\n  function getAttachment(binaryKey) {\n    // console.log('Adding binary attachment', binaryKey);\n    const index = attachments.findIndex(att => att.key === binaryKey);\n    if (index !== -1) {\n      const result = attachments[index].data;\n      // TODO if attachment is sent mulitple times, we shouldn't remove it yet.\n      attachments.splice(index, 1);\n      return result;\n    }\n    console.error('Binary attachment key found without matching attachment');\n    return null;\n  }\n\n  // --------------------------------------------------------------------------\n  // To do a full traversal of nested objects/lists, we need recursion.\n  // --------------------------------------------------------------------------\n\n  function addAttachment(obj_list) {\n    for (let key in obj_list) {\n      if (typeof obj_list[key] === 'string' && regexAttach.test(obj_list[key])) {\n        const binaryKey = obj_list[key];\n        const replacement = getAttachment(binaryKey);\n        if (replacement !== null) obj_list[key] = replacement;\n      } else if (typeof obj_list[key] === 'object') {\n        // arrays are also 'object' with this test.\n        addAttachment(obj_list[key]);\n      }\n    }\n  }\n\n  // --------------------------------------------------------------------------\n  // Public API\n  // --------------------------------------------------------------------------\n\n  publicAPI.onconnect = event => {\n    // send hello message\n    const deferred = defer();\n    const id = 'system:c0:0';\n    inFlightRpc[id] = deferred;\n    model.ws.send(JSON.stringify({\n      wslink: '1.0',\n      id,\n      method: 'wslink.hello',\n      args: [{\n        secret: model.secret\n      }],\n      kwargs: {}\n    }));\n    return deferred.promise;\n  };\n\n  // --------------------------------------------------------------------------\n\n  publicAPI.call = (method, args = [], kwargs = {}) => {\n    // create a promise that we will use to notify the caller of the result.\n    const deferred = defer();\n    // readyState OPEN === 1\n    if (model.ws && clientID && model.ws.readyState === 1) {\n      const id = `rpc:${clientID}:${msgCount++}`;\n      inFlightRpc[id] = deferred;\n      const msg = JSON.stringify({\n        wslink: '1.0',\n        id,\n        method,\n        args,\n        kwargs\n      });\n      if (Object.keys(attachmentsToSend).length) {\n        findBinary(args);\n        findBinary(kwargs);\n      }\n      model.ws.send(JSON.stringify({\n        wslink: '1.0',\n        id,\n        method,\n        args,\n        kwargs\n      }));\n    } else {\n      deferred.reject({\n        code: CLIENT_ERROR,\n        message: `RPC call ${method} unsuccessful: connection not open`\n      });\n    }\n    return deferred.promise;\n  };\n\n  // --------------------------------------------------------------------------\n\n  publicAPI.subscribe = (topic, callback) => {\n    const deferred = defer();\n    if (model.ws && clientID) {\n      // we needs to track subscriptions, to trigger callback when publish is received.\n      if (!subscriptions[topic]) subscriptions[topic] = [];\n      subscriptions[topic].push(callback);\n      // we can notify the server, but we don't need to, if the server always sends messages unconditionally.\n      // model.ws.send(JSON.stringify({ wslink: '1.0', id: `subscribe:${msgCount++}`, method, args: [] }));\n      deferred.resolve({\n        topic,\n        callback\n      });\n    } else {\n      deferred.reject({\n        code: CLIENT_ERROR,\n        message: `Subscribe call ${topic} unsuccessful: connection not open`\n      });\n    }\n    return {\n      topic,\n      callback,\n      promise: deferred.promise,\n      unsubscribe: () => publicAPI.unsubscribe({\n        topic,\n        callback\n      })\n    };\n  };\n\n  // --------------------------------------------------------------------------\n\n  publicAPI.unsubscribe = info => {\n    const deferred = defer();\n    const {\n      topic,\n      callback\n    } = info;\n    if (!subscriptions[topic]) {\n      deferred.reject({\n        code: CLIENT_ERROR,\n        message: `Unsubscribe call ${topic} unsuccessful: not subscribed`\n      });\n      return deferred.promise;\n    }\n    const index = subscriptions[topic].indexOf(callback);\n    if (index !== -1) {\n      subscriptions[topic].splice(index, 1);\n      deferred.resolve();\n    } else {\n      deferred.reject({\n        code: CLIENT_ERROR,\n        message: `Unsubscribe call ${topic} unsuccessful: callback not found`\n      });\n    }\n    return deferred.promise;\n  };\n\n  // --------------------------------------------------------------------------\n\n  publicAPI.close = () => {\n    const deferred = defer();\n    // some transports might be able to close the session without closing the connection. Not true for websocket...\n    model.ws.close();\n    deferred.resolve();\n    return deferred.promise;\n  };\n\n  // --------------------------------------------------------------------------\n\n  publicAPI.onmessage = event => {\n    if (event.data instanceof ArrayBuffer || event.data instanceof Blob) {\n      // we've gotten a header with the keys for this binary data.\n      // we will soon receive a json message with embedded ids of the binary objects.\n      // Save with it's key, in order.\n      // console.log('Saving binary attachment');\n      let foundIt = false;\n      for (let i = 0; i < attachments.length; i++) {\n        if (attachments[i].data === null) {\n          attachments[i].data = event.data;\n          foundIt = true;\n          break;\n        }\n      }\n      if (!foundIt) {\n        console.error('Missing header for received binary message');\n      }\n    } else {\n      let payload;\n      try {\n        payload = JSON5.parse(event.data);\n      } catch (e) {\n        console.error('Malformed message: ', event.data);\n        // debugger;\n      }\n\n      if (!payload) return;\n      if (!payload.id) {\n        // Notification-only message from the server - should be binary attachment header\n        // console.log('Notify', payload);\n        if (payload.method === 'wslink.binary.attachment') {\n          payload.args.forEach(key => {\n            attachments.push({\n              key,\n              data: null\n            });\n          });\n        }\n        return;\n      }\n      if (payload.error) {\n        // kill any attachments\n        attachments.length = 0;\n        const deferred = inFlightRpc[payload.id];\n        if (deferred) {\n          deferred.reject(payload.error);\n        } else {\n          console.error('Server error:', payload.error);\n        }\n      } else {\n        if (payload.result && attachments.length > 0) {\n          if (typeof payload.result === 'string' && regexAttach.test(payload.result)) {\n            const replacement = getAttachment(payload.result);\n            if (replacement !== null) payload.result = replacement;\n          } else {\n            addAttachment(payload.result);\n          }\n        }\n        const match = regexRPC.exec(payload.id);\n        if (match) {\n          const type = match[1];\n          if (type === 'rpc') {\n            const deferred = inFlightRpc[payload.id];\n            if (!deferred) {\n              console.log('session message id without matching call, dropped', payload);\n              return;\n            }\n            deferred.resolve(payload.result);\n          } else if (type == 'publish') {\n            console.assert(inFlightRpc[payload.id] === undefined, 'publish message received matching in-flight rpc call');\n            // regex extracts the topic for us.\n            const topic = match[2];\n            if (!subscriptions[topic]) {\n              return;\n            }\n            // for each callback, provide the message data. Wrap in an array, for back-compatibility with WAMP\n            subscriptions[topic].forEach(callback => callback([payload.result]));\n          } else if (type == 'system') {\n            // console.log('DBG system:', payload.id, payload.result);\n            const deferred = inFlightRpc[payload.id];\n            if (payload.id === 'system:c0:0') {\n              clientID = payload.result.clientID;\n              if (deferred) deferred.resolve(clientID);\n            } else {\n              console.error('Unknown system message', payload.id);\n              if (deferred) deferred.reject({\n                code: CLIENT_ERROR,\n                message: `Unknown system message ${payload.id}`\n              });\n            }\n          } else {\n            console.error('Unknown rpc id format', payload.id);\n          }\n        }\n      }\n      delete inFlightRpc[payload.id];\n    }\n  };\n\n  // --------------------------------------------------------------------------\n\n  publicAPI.addAttachment = payload => {\n    const binaryId = `wslink_bin${attachmentId}`;\n    attachmentsToSend[binaryId] = payload;\n    attachmentId++;\n    return binaryId;\n  };\n}\nconst DEFAULT_VALUES = {\n  secret: 'wslink-secret',\n  ws: null\n};\nexport function extend(publicAPI, model, initialValues = {}) {\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n  CompositeClosureHelper.destroy(publicAPI, model);\n  CompositeClosureHelper.isA(publicAPI, model, 'Session');\n  Session(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nexport const newInstance = CompositeClosureHelper.newInstance(extend);\n\n// ----------------------------------------------------------------------------\n\nexport default {\n  newInstance,\n  extend\n};","map":{"version":3,"names":["CompositeClosureHelper","JSON5","defer","deferred","promise","Promise","resolve","reject","Session","publicAPI","model","CLIENT_ERROR","msgCount","inFlightRpc","attachments","attachmentsToSend","attachmentId","regexAttach","regexRPC","subscriptions","clientID","sendBinary","key","ws","send","JSON","stringify","wslink","method","args","binary","findBinary","o","Array","isArray","forEach","v","constructor","Object","keys","k","test","getAttachment","binaryKey","index","findIndex","att","result","data","splice","console","error","addAttachment","obj_list","replacement","onconnect","event","id","secret","kwargs","call","readyState","msg","length","code","message","subscribe","topic","callback","push","unsubscribe","info","indexOf","close","onmessage","ArrayBuffer","Blob","foundIt","i","payload","parse","e","match","exec","type","log","assert","undefined","binaryId","DEFAULT_VALUES","extend","initialValues","assign","destroy","isA","newInstance"],"sources":["/home/rakshith/Documents/RemoteRendering/vtk-js-react-app/node_modules/wslink/src/WebsocketConnection/session.js"],"sourcesContent":["// Helper borrowed from paraviewweb/src/Common/Core\nimport CompositeClosureHelper from '../CompositeClosureHelper';\nimport JSON5 from 'json5';\n\nfunction defer() {\n  const deferred = {};\n\n  deferred.promise = new Promise(function (resolve, reject) {\n    deferred.resolve = resolve;\n    deferred.reject = reject;\n  });\n\n  return deferred;\n}\n\nfunction Session(publicAPI, model) {\n  const CLIENT_ERROR = -32099;\n  let msgCount = 0;\n  const inFlightRpc = {};\n  const attachments = [];\n  const attachmentsToSend = {};\n  let attachmentId = 1;\n  const regexAttach = /^wslink_bin[\\d]+$/;\n  // matches 'rpc:client3:21'\n  // client may be dot-separated and include '_'\n  // number is message count - unique.\n  // matches 'publish:dot.separated.topic:42'\n  const regexRPC = /^(rpc|publish|system):(\\w+(?:\\.\\w+)*):(?:\\d+)$/;\n  const subscriptions = {};\n  let clientID = null;\n\n  // --------------------------------------------------------------------------\n  // Private helpers\n  // --------------------------------------------------------------------------\n\n  function sendBinary(key) {\n    if (key in attachmentsToSend) {\n      // binary header\n      model.ws.send(\n        JSON.stringify({\n          wslink: '1.0',\n          method: 'wslink.binary.attachment',\n          args: [key],\n        })\n      );\n\n      // send binary\n      model.ws.send(attachmentsToSend[key], { binary: true });\n      delete attachmentsToSend[key];\n    }\n  }\n\n  // --------------------------------------------------------------------------\n\n  function findBinary(o) {\n    if (o) {\n      if (Array.isArray(o)) {\n        o.forEach((v) => findBinary(v));\n      } else if (o.constructor === Object) {\n        Object.keys(o).forEach((k) => findBinary(o[k]));\n      } else if (regexAttach.test(o)) {\n        sendBinary(o);\n      }\n    }\n  }\n\n  // --------------------------------------------------------------------------\n  // split out to support a message with a bare binary attachment.\n  // --------------------------------------------------------------------------\n\n  function getAttachment(binaryKey) {\n    // console.log('Adding binary attachment', binaryKey);\n    const index = attachments.findIndex((att) => att.key === binaryKey);\n    if (index !== -1) {\n      const result = attachments[index].data;\n      // TODO if attachment is sent mulitple times, we shouldn't remove it yet.\n      attachments.splice(index, 1);\n      return result;\n    }\n    console.error('Binary attachment key found without matching attachment');\n    return null;\n  }\n\n  // --------------------------------------------------------------------------\n  // To do a full traversal of nested objects/lists, we need recursion.\n  // --------------------------------------------------------------------------\n\n  function addAttachment(obj_list) {\n    for (let key in obj_list) {\n      if (\n        typeof obj_list[key] === 'string' &&\n        regexAttach.test(obj_list[key])\n      ) {\n        const binaryKey = obj_list[key];\n        const replacement = getAttachment(binaryKey);\n        if (replacement !== null) obj_list[key] = replacement;\n      } else if (typeof obj_list[key] === 'object') {\n        // arrays are also 'object' with this test.\n        addAttachment(obj_list[key]);\n      }\n    }\n  }\n\n  // --------------------------------------------------------------------------\n  // Public API\n  // --------------------------------------------------------------------------\n\n  publicAPI.onconnect = (event) => {\n    // send hello message\n    const deferred = defer();\n    const id = 'system:c0:0';\n    inFlightRpc[id] = deferred;\n    model.ws.send(\n      JSON.stringify({\n        wslink: '1.0',\n        id,\n        method: 'wslink.hello',\n        args: [{ secret: model.secret }],\n        kwargs: {},\n      })\n    );\n    return deferred.promise;\n  };\n\n  // --------------------------------------------------------------------------\n\n  publicAPI.call = (method, args = [], kwargs = {}) => {\n    // create a promise that we will use to notify the caller of the result.\n    const deferred = defer();\n    // readyState OPEN === 1\n    if (model.ws && clientID && model.ws.readyState === 1) {\n      const id = `rpc:${clientID}:${msgCount++}`;\n      inFlightRpc[id] = deferred;\n      const msg = JSON.stringify({ wslink: '1.0', id, method, args, kwargs });\n\n      if (Object.keys(attachmentsToSend).length) {\n        findBinary(args);\n        findBinary(kwargs);\n      }\n\n      model.ws.send(\n        JSON.stringify({ wslink: '1.0', id, method, args, kwargs })\n      );\n    } else {\n      deferred.reject({\n        code: CLIENT_ERROR,\n        message: `RPC call ${method} unsuccessful: connection not open`,\n      });\n    }\n    return deferred.promise;\n  };\n\n  // --------------------------------------------------------------------------\n\n  publicAPI.subscribe = (topic, callback) => {\n    const deferred = defer();\n    if (model.ws && clientID) {\n      // we needs to track subscriptions, to trigger callback when publish is received.\n      if (!subscriptions[topic]) subscriptions[topic] = [];\n      subscriptions[topic].push(callback);\n      // we can notify the server, but we don't need to, if the server always sends messages unconditionally.\n      // model.ws.send(JSON.stringify({ wslink: '1.0', id: `subscribe:${msgCount++}`, method, args: [] }));\n      deferred.resolve({ topic, callback });\n    } else {\n      deferred.reject({\n        code: CLIENT_ERROR,\n        message: `Subscribe call ${topic} unsuccessful: connection not open`,\n      });\n    }\n    return {\n      topic,\n      callback,\n      promise: deferred.promise,\n      unsubscribe: () => publicAPI.unsubscribe({ topic, callback }),\n    };\n  };\n\n  // --------------------------------------------------------------------------\n\n  publicAPI.unsubscribe = (info) => {\n    const deferred = defer();\n    const { topic, callback } = info;\n    if (!subscriptions[topic]) {\n      deferred.reject({\n        code: CLIENT_ERROR,\n        message: `Unsubscribe call ${topic} unsuccessful: not subscribed`,\n      });\n      return deferred.promise;\n    }\n    const index = subscriptions[topic].indexOf(callback);\n    if (index !== -1) {\n      subscriptions[topic].splice(index, 1);\n      deferred.resolve();\n    } else {\n      deferred.reject({\n        code: CLIENT_ERROR,\n        message: `Unsubscribe call ${topic} unsuccessful: callback not found`,\n      });\n    }\n    return deferred.promise;\n  };\n\n  // --------------------------------------------------------------------------\n\n  publicAPI.close = () => {\n    const deferred = defer();\n    // some transports might be able to close the session without closing the connection. Not true for websocket...\n    model.ws.close();\n    deferred.resolve();\n    return deferred.promise;\n  };\n\n  // --------------------------------------------------------------------------\n\n  publicAPI.onmessage = (event) => {\n    if (event.data instanceof ArrayBuffer || event.data instanceof Blob) {\n      // we've gotten a header with the keys for this binary data.\n      // we will soon receive a json message with embedded ids of the binary objects.\n      // Save with it's key, in order.\n      // console.log('Saving binary attachment');\n      let foundIt = false;\n      for (let i = 0; i < attachments.length; i++) {\n        if (attachments[i].data === null) {\n          attachments[i].data = event.data;\n          foundIt = true;\n          break;\n        }\n      }\n      if (!foundIt) {\n        console.error('Missing header for received binary message');\n      }\n    } else {\n      let payload;\n      try {\n        payload = JSON5.parse(event.data);\n      } catch (e) {\n        console.error('Malformed message: ', event.data);\n        // debugger;\n      }\n      if (!payload) return;\n      if (!payload.id) {\n        // Notification-only message from the server - should be binary attachment header\n        // console.log('Notify', payload);\n        if (payload.method === 'wslink.binary.attachment') {\n          payload.args.forEach((key) => {\n            attachments.push({ key, data: null });\n          });\n        }\n        return;\n      }\n      if (payload.error) {\n        // kill any attachments\n        attachments.length = 0;\n        const deferred = inFlightRpc[payload.id];\n        if (deferred) {\n          deferred.reject(payload.error);\n        } else {\n          console.error('Server error:', payload.error);\n        }\n      } else {\n        if (payload.result && attachments.length > 0) {\n          if (\n            typeof payload.result === 'string' &&\n            regexAttach.test(payload.result)\n          ) {\n            const replacement = getAttachment(payload.result);\n            if (replacement !== null) payload.result = replacement;\n          } else {\n            addAttachment(payload.result);\n          }\n        }\n        const match = regexRPC.exec(payload.id);\n        if (match) {\n          const type = match[1];\n          if (type === 'rpc') {\n            const deferred = inFlightRpc[payload.id];\n            if (!deferred) {\n              console.log(\n                'session message id without matching call, dropped',\n                payload\n              );\n              return;\n            }\n            deferred.resolve(payload.result);\n          } else if (type == 'publish') {\n            console.assert(\n              inFlightRpc[payload.id] === undefined,\n              'publish message received matching in-flight rpc call'\n            );\n            // regex extracts the topic for us.\n            const topic = match[2];\n            if (!subscriptions[topic]) {\n              return;\n            }\n            // for each callback, provide the message data. Wrap in an array, for back-compatibility with WAMP\n            subscriptions[topic].forEach((callback) =>\n              callback([payload.result])\n            );\n          } else if (type == 'system') {\n            // console.log('DBG system:', payload.id, payload.result);\n            const deferred = inFlightRpc[payload.id];\n            if (payload.id === 'system:c0:0') {\n              clientID = payload.result.clientID;\n              if (deferred) deferred.resolve(clientID);\n            } else {\n              console.error('Unknown system message', payload.id);\n              if (deferred)\n                deferred.reject({\n                  code: CLIENT_ERROR,\n                  message: `Unknown system message ${payload.id}`,\n                });\n            }\n          } else {\n            console.error('Unknown rpc id format', payload.id);\n          }\n        }\n      }\n      delete inFlightRpc[payload.id];\n    }\n  };\n\n  // --------------------------------------------------------------------------\n\n  publicAPI.addAttachment = (payload) => {\n    const binaryId = `wslink_bin${attachmentId}`;\n    attachmentsToSend[binaryId] = payload;\n    attachmentId++;\n    return binaryId;\n  };\n}\n\nconst DEFAULT_VALUES = {\n  secret: 'wslink-secret',\n  ws: null,\n};\n\nexport function extend(publicAPI, model, initialValues = {}) {\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  CompositeClosureHelper.destroy(publicAPI, model);\n  CompositeClosureHelper.isA(publicAPI, model, 'Session');\n\n  Session(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nexport const newInstance = CompositeClosureHelper.newInstance(extend);\n\n// ----------------------------------------------------------------------------\n\nexport default { newInstance, extend };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}