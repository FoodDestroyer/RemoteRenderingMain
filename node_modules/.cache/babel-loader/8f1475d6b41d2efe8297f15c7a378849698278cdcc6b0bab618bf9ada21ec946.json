{"ast":null,"code":"import _toConsumableArray from '@babel/runtime/helpers/toConsumableArray';\nimport macro from '../../macros.js';\nimport vtkViewNode from '../SceneGraph/ViewNode.js';\nimport vtkWebGPUBindGroup from './BindGroup.js';\nimport vtkWebGPUPipeline from './Pipeline.js';\nimport vtkWebGPUShaderCache from './ShaderCache.js';\nimport vtkWebGPUShaderDescription from './ShaderDescription.js';\nimport vtkWebGPUVertexInput from './VertexInput.js';\nvar vtkWebGPUSimpleMapperVS = \"\\n//VTK::Renderer::Dec\\n\\n//VTK::Color::Dec\\n\\n//VTK::Normal::Dec\\n\\n//VTK::TCoord::Dec\\n\\n//VTK::Select::Dec\\n\\n//VTK::Mapper::Dec\\n\\n//VTK::IOStructs::Dec\\n\\n@vertex\\nfn main(\\n//VTK::IOStructs::Input\\n)\\n//VTK::IOStructs::Output\\n{\\n  var output : vertexOutput;\\n\\n  // var vertex: vec4<f32> = vertexBC;\\n\\n  //VTK::Color::Impl\\n\\n  //VTK::Normal::Impl\\n\\n  //VTK::TCoord::Impl\\n\\n  //VTK::Select::Impl\\n\\n  //VTK::Position::Impl\\n\\n  return output;\\n}\\n\";\nvar vtkWebGPUSimpleMapperFS = \"\\n//VTK::Renderer::Dec\\n\\n//VTK::Color::Dec\\n\\n//VTK::Normal::Dec\\n\\n//VTK::TCoord::Dec\\n\\n//VTK::Select::Dec\\n\\n//VTK::RenderEncoder::Dec\\n\\n//VTK::Mapper::Dec\\n\\n//VTK::IOStructs::Dec\\n\\n@fragment\\nfn main(\\n//VTK::IOStructs::Input\\n)\\n//VTK::IOStructs::Output\\n{\\n  var output : fragmentOutput;\\n\\n  //VTK::Color::Impl\\n\\n  //VTK::Normal::Impl\\n\\n  //VTK::Light::Impl\\n\\n  //VTK::TCoord::Impl\\n\\n  //VTK::Select::Impl\\n\\n  // var computedColor:vec4<f32> = vec4<f32>(1.0,0.5,0.5,1.0);\\n\\n  //VTK::RenderEncoder::Impl\\n  return output;\\n}\\n\"; // ----------------------------------------------------------------------------\n// vtkWebGPUSimpleMapper methods\n// ----------------------------------------------------------------------------\n\nfunction vtkWebGPUSimpleMapper(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkWebGPUSimpleMapper');\n  publicAPI.generateShaderDescriptions = function (hash, pipeline, vertexInput) {\n    // create the shader descriptions\n    var vDesc = vtkWebGPUShaderDescription.newInstance({\n      type: 'vertex',\n      hash: hash,\n      code: model.vertexShaderTemplate\n    });\n    var fDesc = vtkWebGPUShaderDescription.newInstance({\n      type: 'fragment',\n      hash: hash,\n      code: model.fragmentShaderTemplate\n    }); // add them to the pipeline\n\n    var sdrs = pipeline.getShaderDescriptions();\n    sdrs.push(vDesc);\n    sdrs.push(fDesc); // look for replacements to invoke\n\n    var scode = model.vertexShaderTemplate + model.fragmentShaderTemplate; // eslint-disable-next-line prefer-regex-literals\n\n    var re = new RegExp('//VTK::[^:]*::', 'g');\n    var unique = scode.match(re).filter(function (v, i, a) {\n      return a.indexOf(v) === i;\n    });\n    var fnames = unique.map(function (v) {\n      return \"replaceShader\".concat(v.substring(7, v.length - 2));\n    }); // now invoke shader replacement functions\n\n    for (var i = 0; i < fnames.length; i++) {\n      var fname = fnames[i];\n      if (fname !== 'replaceShaderIOStructs' && model.shaderReplacements.has(fname)) {\n        model.shaderReplacements.get(fname)(hash, pipeline, vertexInput);\n      }\n    } // always replace the IOStructs last as other replacement funcs may\n    // add inputs or outputs\n\n    publicAPI.replaceShaderIOStructs(hash, pipeline, vertexInput); // console.log(vDesc.getCode());\n    // console.log(fDesc.getCode());\n  };\n\n  publicAPI.replaceShaderIOStructs = function (hash, pipeline, vertexInput) {\n    var vDesc = pipeline.getShaderDescription('vertex');\n    vDesc.replaceShaderCode(null, vertexInput);\n    var fDesc = pipeline.getShaderDescription('fragment');\n    fDesc.replaceShaderCode(vDesc);\n  };\n  publicAPI.replaceShaderRenderEncoder = function (hash, pipeline, vertexInput) {\n    model.renderEncoder.replaceShaderCode(pipeline);\n  };\n  model.shaderReplacements.set('replaceShaderRenderEncoder', publicAPI.replaceShaderRenderEncoder);\n  publicAPI.replaceShaderRenderer = function (hash, pipeline, vertexInput) {\n    if (!model.WebGPURenderer) {\n      return;\n    }\n    var ubocode = model.WebGPURenderer.getBindGroup().getShaderCode(pipeline);\n    var vDesc = pipeline.getShaderDescription('vertex');\n    var code = vDesc.getCode();\n    code = vtkWebGPUShaderCache.substitute(code, '//VTK::Renderer::Dec', [ubocode]).result;\n    vDesc.setCode(code);\n    var fDesc = pipeline.getShaderDescription('fragment');\n    code = fDesc.getCode();\n    code = vtkWebGPUShaderCache.substitute(code, '//VTK::Renderer::Dec', [ubocode]).result;\n    fDesc.setCode(code);\n  };\n  model.shaderReplacements.set('replaceShaderRenderer', publicAPI.replaceShaderRenderer);\n  publicAPI.replaceShaderMapper = function (hash, pipeline, vertexInput) {\n    var ubocode = model.bindGroup.getShaderCode(pipeline);\n    var vDesc = pipeline.getShaderDescription('vertex');\n    var code = vDesc.getCode();\n    code = vtkWebGPUShaderCache.substitute(code, '//VTK::Mapper::Dec', [ubocode]).result;\n    vDesc.setCode(code);\n    var fDesc = pipeline.getShaderDescription('fragment');\n    fDesc.addBuiltinInput('bool', '@builtin(front_facing) frontFacing');\n    code = fDesc.getCode();\n    code = vtkWebGPUShaderCache.substitute(code, '//VTK::Mapper::Dec', [ubocode]).result;\n    fDesc.setCode(code);\n  };\n  model.shaderReplacements.set('replaceShaderMapper', publicAPI.replaceShaderMapper);\n  publicAPI.replaceShaderPosition = function (hash, pipeline, vertexInput) {\n    var vDesc = pipeline.getShaderDescription('vertex');\n    vDesc.addBuiltinOutput('vec4<f32>', '@builtin(position) Position');\n    var code = vDesc.getCode();\n    code = vtkWebGPUShaderCache.substitute(code, '//VTK::Position::Impl', ['    output.Position = rendererUBO.SCPCMatrix*vertexBC;']).result;\n    vDesc.setCode(code);\n  };\n  model.shaderReplacements.set('replaceShaderPosition', publicAPI.replaceShaderPosition);\n  publicAPI.replaceShaderTCoord = function (hash, pipeline, vertexInput) {\n    var vDesc = pipeline.getShaderDescription('vertex');\n    vDesc.addOutput('vec2<f32>', 'tcoordVS');\n  };\n  model.shaderReplacements.set('replaceShaderTCoord', publicAPI.replaceShaderTCoord);\n  publicAPI.addTextureView = function (view) {\n    // is it already there?\n    if (model.textureViews.includes(view)) {\n      return;\n    }\n    model.textureViews.push(view);\n  }; // do everything required for this mapper to be rerady to draw\n  // but do not bind or do the actual draw commands as the pipeline\n  // is not neccessarily bound yet\n\n  publicAPI.prepareToDraw = function (renderEncoder) {\n    model.renderEncoder = renderEncoder; // do anything needed to get our input data up to date\n\n    publicAPI.updateInput(); // make sure buffers are created and up to date\n\n    publicAPI.updateBuffers(); // update bindings and bind groups/layouts\n    // does not acutally bind them, that is done in draw(...)\n\n    publicAPI.updateBindings(); // update the pipeline, includes computing the hash, and if needed\n    // creating the pipeline, shader code etc\n\n    publicAPI.updatePipeline();\n  };\n  publicAPI.updateInput = function () {};\n  publicAPI.updateBuffers = function () {};\n  publicAPI.updateBindings = function () {\n    // bindings can change without a pipeline change\n    // as long as their layout remains the same.\n    // That is why this is done even when the pipeline\n    // hash doesn't change.\n    model.bindGroup.setBindables(publicAPI.getBindables());\n  };\n  publicAPI.computePipelineHash = function () {};\n  publicAPI.registerDrawCallback = function (encoder) {\n    encoder.registerDrawCallback(model.pipeline, publicAPI.draw);\n  };\n  publicAPI.prepareAndDraw = function (encoder) {\n    publicAPI.prepareToDraw(encoder);\n    encoder.setPipeline(model.pipeline);\n    publicAPI.draw(encoder);\n  }; // do the rest of the calls required to draw this mapper\n  // at this point the command encouder and pipeline are\n  // created and bound\n\n  publicAPI.draw = function (renderEncoder) {\n    var pipeline = renderEncoder.getBoundPipeline(); // bind the mapper bind group\n\n    renderEncoder.activateBindGroup(model.bindGroup);\n    if (model.WebGPURenderer) {\n      model.WebGPURenderer.bindUBO(renderEncoder);\n    } // bind the vertex input\n\n    pipeline.bindVertexInput(renderEncoder, model.vertexInput);\n    var indexBuffer = model.vertexInput.getIndexBuffer();\n    if (indexBuffer) {\n      renderEncoder.drawIndexed(indexBuffer.getIndexCount(), model.numberOfInstances, 0, 0, 0);\n    } else {\n      renderEncoder.draw(model.numberOfVertices, model.numberOfInstances, 0, 0);\n    }\n  };\n  publicAPI.getBindables = function () {\n    var bindables = _toConsumableArray(model.additionalBindables);\n    if (model.UBO) {\n      bindables.push(model.UBO);\n    }\n    if (model.SSBO) {\n      bindables.push(model.SSBO);\n    } // add texture BindGroupLayouts\n\n    for (var t = 0; t < model.textureViews.length; t++) {\n      bindables.push(model.textureViews[t]);\n      var samp = model.textureViews[t].getSampler();\n      if (samp) {\n        bindables.push(samp);\n      }\n    }\n    return bindables;\n  };\n  publicAPI.updatePipeline = function () {\n    publicAPI.computePipelineHash();\n    model.pipeline = model.device.getPipeline(model.pipelineHash); // build the pipeline if needed\n\n    if (!model.pipeline) {\n      model.pipeline = vtkWebGPUPipeline.newInstance();\n      model.pipeline.setDevice(model.device);\n      if (model.WebGPURenderer) {\n        model.pipeline.addBindGroupLayout(model.WebGPURenderer.getBindGroup());\n      }\n      model.pipeline.addBindGroupLayout(model.bindGroup);\n      publicAPI.generateShaderDescriptions(model.pipelineHash, model.pipeline, model.vertexInput);\n      model.pipeline.setTopology(model.topology);\n      model.pipeline.setRenderEncoder(model.renderEncoder);\n      model.pipeline.setVertexState(model.vertexInput.getVertexInputInformation());\n      model.device.createPipeline(model.pipelineHash, model.pipeline);\n    }\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nvar DEFAULT_VALUES = {\n  additionalBindables: undefined,\n  bindGroup: null,\n  device: null,\n  fragmentShaderTemplate: null,\n  numberOfInstances: 1,\n  numberOfVertices: 0,\n  pipelineHash: null,\n  shaderReplacements: null,\n  SSBO: null,\n  textureViews: null,\n  topology: 'triangle-list',\n  UBO: null,\n  vertexShaderTemplate: null,\n  WebGPURenderer: null\n}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Inheritance\n\n  vtkViewNode.extend(publicAPI, model, initialValues);\n  model.textureViews = [];\n  model.vertexInput = vtkWebGPUVertexInput.newInstance();\n  model.bindGroup = vtkWebGPUBindGroup.newInstance({\n    label: 'mapperBG'\n  });\n  model.additionalBindables = [];\n  model.fragmentShaderTemplate = model.fragmentShaderTemplate || vtkWebGPUSimpleMapperFS;\n  model.vertexShaderTemplate = model.vertexShaderTemplate || vtkWebGPUSimpleMapperVS;\n  model.shaderReplacements = new Map(); // Build VTK API\n\n  macro.get(publicAPI, model, ['pipeline', 'vertexInput']);\n  macro.setGet(publicAPI, model, ['additionalBindables', 'device', 'fragmentShaderTemplate', 'interpolate', 'numberOfInstances', 'numberOfVertices', 'pipelineHash', 'shaderReplacements', 'SSBO', 'textureViews', 'topology', 'UBO', 'vertexShaderTemplate', 'WebGPURenderer']); // Object methods\n\n  vtkWebGPUSimpleMapper(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = macro.newInstance(extend, 'vtkWebGPUSimpleMapper'); // ----------------------------------------------------------------------------\n\nvar vtkWebGPUSimpleMapper$1 = {\n  newInstance: newInstance,\n  extend: extend\n};\nexport { vtkWebGPUSimpleMapper$1 as default, extend, newInstance };","map":{"version":3,"names":["_toConsumableArray","macro","vtkViewNode","vtkWebGPUBindGroup","vtkWebGPUPipeline","vtkWebGPUShaderCache","vtkWebGPUShaderDescription","vtkWebGPUVertexInput","vtkWebGPUSimpleMapperVS","vtkWebGPUSimpleMapperFS","vtkWebGPUSimpleMapper","publicAPI","model","classHierarchy","push","generateShaderDescriptions","hash","pipeline","vertexInput","vDesc","newInstance","type","code","vertexShaderTemplate","fDesc","fragmentShaderTemplate","sdrs","getShaderDescriptions","scode","re","RegExp","unique","match","filter","v","i","a","indexOf","fnames","map","concat","substring","length","fname","shaderReplacements","has","get","replaceShaderIOStructs","getShaderDescription","replaceShaderCode","replaceShaderRenderEncoder","renderEncoder","set","replaceShaderRenderer","WebGPURenderer","ubocode","getBindGroup","getShaderCode","getCode","substitute","result","setCode","replaceShaderMapper","bindGroup","addBuiltinInput","replaceShaderPosition","addBuiltinOutput","replaceShaderTCoord","addOutput","addTextureView","view","textureViews","includes","prepareToDraw","updateInput","updateBuffers","updateBindings","updatePipeline","setBindables","getBindables","computePipelineHash","registerDrawCallback","encoder","draw","prepareAndDraw","setPipeline","getBoundPipeline","activateBindGroup","bindUBO","bindVertexInput","indexBuffer","getIndexBuffer","drawIndexed","getIndexCount","numberOfInstances","numberOfVertices","bindables","additionalBindables","UBO","SSBO","t","samp","getSampler","device","getPipeline","pipelineHash","setDevice","addBindGroupLayout","setTopology","topology","setRenderEncoder","setVertexState","getVertexInputInformation","createPipeline","DEFAULT_VALUES","undefined","extend","initialValues","arguments","Object","assign","label","Map","setGet","vtkWebGPUSimpleMapper$1","default"],"sources":["/home/rakshith/Documents/RemoteRendering/vtk-js-react-app/node_modules/@kitware/vtk.js/Rendering/WebGPU/SimpleMapper.js"],"sourcesContent":["import _toConsumableArray from '@babel/runtime/helpers/toConsumableArray';\nimport macro from '../../macros.js';\nimport vtkViewNode from '../SceneGraph/ViewNode.js';\nimport vtkWebGPUBindGroup from './BindGroup.js';\nimport vtkWebGPUPipeline from './Pipeline.js';\nimport vtkWebGPUShaderCache from './ShaderCache.js';\nimport vtkWebGPUShaderDescription from './ShaderDescription.js';\nimport vtkWebGPUVertexInput from './VertexInput.js';\n\nvar vtkWebGPUSimpleMapperVS = \"\\n//VTK::Renderer::Dec\\n\\n//VTK::Color::Dec\\n\\n//VTK::Normal::Dec\\n\\n//VTK::TCoord::Dec\\n\\n//VTK::Select::Dec\\n\\n//VTK::Mapper::Dec\\n\\n//VTK::IOStructs::Dec\\n\\n@vertex\\nfn main(\\n//VTK::IOStructs::Input\\n)\\n//VTK::IOStructs::Output\\n{\\n  var output : vertexOutput;\\n\\n  // var vertex: vec4<f32> = vertexBC;\\n\\n  //VTK::Color::Impl\\n\\n  //VTK::Normal::Impl\\n\\n  //VTK::TCoord::Impl\\n\\n  //VTK::Select::Impl\\n\\n  //VTK::Position::Impl\\n\\n  return output;\\n}\\n\";\nvar vtkWebGPUSimpleMapperFS = \"\\n//VTK::Renderer::Dec\\n\\n//VTK::Color::Dec\\n\\n//VTK::Normal::Dec\\n\\n//VTK::TCoord::Dec\\n\\n//VTK::Select::Dec\\n\\n//VTK::RenderEncoder::Dec\\n\\n//VTK::Mapper::Dec\\n\\n//VTK::IOStructs::Dec\\n\\n@fragment\\nfn main(\\n//VTK::IOStructs::Input\\n)\\n//VTK::IOStructs::Output\\n{\\n  var output : fragmentOutput;\\n\\n  //VTK::Color::Impl\\n\\n  //VTK::Normal::Impl\\n\\n  //VTK::Light::Impl\\n\\n  //VTK::TCoord::Impl\\n\\n  //VTK::Select::Impl\\n\\n  // var computedColor:vec4<f32> = vec4<f32>(1.0,0.5,0.5,1.0);\\n\\n  //VTK::RenderEncoder::Impl\\n  return output;\\n}\\n\"; // ----------------------------------------------------------------------------\n// vtkWebGPUSimpleMapper methods\n// ----------------------------------------------------------------------------\n\nfunction vtkWebGPUSimpleMapper(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkWebGPUSimpleMapper');\n\n  publicAPI.generateShaderDescriptions = function (hash, pipeline, vertexInput) {\n    // create the shader descriptions\n    var vDesc = vtkWebGPUShaderDescription.newInstance({\n      type: 'vertex',\n      hash: hash,\n      code: model.vertexShaderTemplate\n    });\n    var fDesc = vtkWebGPUShaderDescription.newInstance({\n      type: 'fragment',\n      hash: hash,\n      code: model.fragmentShaderTemplate\n    }); // add them to the pipeline\n\n    var sdrs = pipeline.getShaderDescriptions();\n    sdrs.push(vDesc);\n    sdrs.push(fDesc); // look for replacements to invoke\n\n    var scode = model.vertexShaderTemplate + model.fragmentShaderTemplate; // eslint-disable-next-line prefer-regex-literals\n\n    var re = new RegExp('//VTK::[^:]*::', 'g');\n    var unique = scode.match(re).filter(function (v, i, a) {\n      return a.indexOf(v) === i;\n    });\n    var fnames = unique.map(function (v) {\n      return \"replaceShader\".concat(v.substring(7, v.length - 2));\n    }); // now invoke shader replacement functions\n\n    for (var i = 0; i < fnames.length; i++) {\n      var fname = fnames[i];\n\n      if (fname !== 'replaceShaderIOStructs' && model.shaderReplacements.has(fname)) {\n        model.shaderReplacements.get(fname)(hash, pipeline, vertexInput);\n      }\n    } // always replace the IOStructs last as other replacement funcs may\n    // add inputs or outputs\n\n\n    publicAPI.replaceShaderIOStructs(hash, pipeline, vertexInput); // console.log(vDesc.getCode());\n    // console.log(fDesc.getCode());\n  };\n\n  publicAPI.replaceShaderIOStructs = function (hash, pipeline, vertexInput) {\n    var vDesc = pipeline.getShaderDescription('vertex');\n    vDesc.replaceShaderCode(null, vertexInput);\n    var fDesc = pipeline.getShaderDescription('fragment');\n    fDesc.replaceShaderCode(vDesc);\n  };\n\n  publicAPI.replaceShaderRenderEncoder = function (hash, pipeline, vertexInput) {\n    model.renderEncoder.replaceShaderCode(pipeline);\n  };\n\n  model.shaderReplacements.set('replaceShaderRenderEncoder', publicAPI.replaceShaderRenderEncoder);\n\n  publicAPI.replaceShaderRenderer = function (hash, pipeline, vertexInput) {\n    if (!model.WebGPURenderer) {\n      return;\n    }\n\n    var ubocode = model.WebGPURenderer.getBindGroup().getShaderCode(pipeline);\n    var vDesc = pipeline.getShaderDescription('vertex');\n    var code = vDesc.getCode();\n    code = vtkWebGPUShaderCache.substitute(code, '//VTK::Renderer::Dec', [ubocode]).result;\n    vDesc.setCode(code);\n    var fDesc = pipeline.getShaderDescription('fragment');\n    code = fDesc.getCode();\n    code = vtkWebGPUShaderCache.substitute(code, '//VTK::Renderer::Dec', [ubocode]).result;\n    fDesc.setCode(code);\n  };\n\n  model.shaderReplacements.set('replaceShaderRenderer', publicAPI.replaceShaderRenderer);\n\n  publicAPI.replaceShaderMapper = function (hash, pipeline, vertexInput) {\n    var ubocode = model.bindGroup.getShaderCode(pipeline);\n    var vDesc = pipeline.getShaderDescription('vertex');\n    var code = vDesc.getCode();\n    code = vtkWebGPUShaderCache.substitute(code, '//VTK::Mapper::Dec', [ubocode]).result;\n    vDesc.setCode(code);\n    var fDesc = pipeline.getShaderDescription('fragment');\n    fDesc.addBuiltinInput('bool', '@builtin(front_facing) frontFacing');\n    code = fDesc.getCode();\n    code = vtkWebGPUShaderCache.substitute(code, '//VTK::Mapper::Dec', [ubocode]).result;\n    fDesc.setCode(code);\n  };\n\n  model.shaderReplacements.set('replaceShaderMapper', publicAPI.replaceShaderMapper);\n\n  publicAPI.replaceShaderPosition = function (hash, pipeline, vertexInput) {\n    var vDesc = pipeline.getShaderDescription('vertex');\n    vDesc.addBuiltinOutput('vec4<f32>', '@builtin(position) Position');\n    var code = vDesc.getCode();\n    code = vtkWebGPUShaderCache.substitute(code, '//VTK::Position::Impl', ['    output.Position = rendererUBO.SCPCMatrix*vertexBC;']).result;\n    vDesc.setCode(code);\n  };\n\n  model.shaderReplacements.set('replaceShaderPosition', publicAPI.replaceShaderPosition);\n\n  publicAPI.replaceShaderTCoord = function (hash, pipeline, vertexInput) {\n    var vDesc = pipeline.getShaderDescription('vertex');\n    vDesc.addOutput('vec2<f32>', 'tcoordVS');\n  };\n\n  model.shaderReplacements.set('replaceShaderTCoord', publicAPI.replaceShaderTCoord);\n\n  publicAPI.addTextureView = function (view) {\n    // is it already there?\n    if (model.textureViews.includes(view)) {\n      return;\n    }\n\n    model.textureViews.push(view);\n  }; // do everything required for this mapper to be rerady to draw\n  // but do not bind or do the actual draw commands as the pipeline\n  // is not neccessarily bound yet\n\n\n  publicAPI.prepareToDraw = function (renderEncoder) {\n    model.renderEncoder = renderEncoder; // do anything needed to get our input data up to date\n\n    publicAPI.updateInput(); // make sure buffers are created and up to date\n\n    publicAPI.updateBuffers(); // update bindings and bind groups/layouts\n    // does not acutally bind them, that is done in draw(...)\n\n    publicAPI.updateBindings(); // update the pipeline, includes computing the hash, and if needed\n    // creating the pipeline, shader code etc\n\n    publicAPI.updatePipeline();\n  };\n\n  publicAPI.updateInput = function () {};\n\n  publicAPI.updateBuffers = function () {};\n\n  publicAPI.updateBindings = function () {\n    // bindings can change without a pipeline change\n    // as long as their layout remains the same.\n    // That is why this is done even when the pipeline\n    // hash doesn't change.\n    model.bindGroup.setBindables(publicAPI.getBindables());\n  };\n\n  publicAPI.computePipelineHash = function () {};\n\n  publicAPI.registerDrawCallback = function (encoder) {\n    encoder.registerDrawCallback(model.pipeline, publicAPI.draw);\n  };\n\n  publicAPI.prepareAndDraw = function (encoder) {\n    publicAPI.prepareToDraw(encoder);\n    encoder.setPipeline(model.pipeline);\n    publicAPI.draw(encoder);\n  }; // do the rest of the calls required to draw this mapper\n  // at this point the command encouder and pipeline are\n  // created and bound\n\n\n  publicAPI.draw = function (renderEncoder) {\n    var pipeline = renderEncoder.getBoundPipeline(); // bind the mapper bind group\n\n    renderEncoder.activateBindGroup(model.bindGroup);\n\n    if (model.WebGPURenderer) {\n      model.WebGPURenderer.bindUBO(renderEncoder);\n    } // bind the vertex input\n\n\n    pipeline.bindVertexInput(renderEncoder, model.vertexInput);\n    var indexBuffer = model.vertexInput.getIndexBuffer();\n\n    if (indexBuffer) {\n      renderEncoder.drawIndexed(indexBuffer.getIndexCount(), model.numberOfInstances, 0, 0, 0);\n    } else {\n      renderEncoder.draw(model.numberOfVertices, model.numberOfInstances, 0, 0);\n    }\n  };\n\n  publicAPI.getBindables = function () {\n    var bindables = _toConsumableArray(model.additionalBindables);\n\n    if (model.UBO) {\n      bindables.push(model.UBO);\n    }\n\n    if (model.SSBO) {\n      bindables.push(model.SSBO);\n    } // add texture BindGroupLayouts\n\n\n    for (var t = 0; t < model.textureViews.length; t++) {\n      bindables.push(model.textureViews[t]);\n      var samp = model.textureViews[t].getSampler();\n\n      if (samp) {\n        bindables.push(samp);\n      }\n    }\n\n    return bindables;\n  };\n\n  publicAPI.updatePipeline = function () {\n    publicAPI.computePipelineHash();\n    model.pipeline = model.device.getPipeline(model.pipelineHash); // build the pipeline if needed\n\n    if (!model.pipeline) {\n      model.pipeline = vtkWebGPUPipeline.newInstance();\n      model.pipeline.setDevice(model.device);\n\n      if (model.WebGPURenderer) {\n        model.pipeline.addBindGroupLayout(model.WebGPURenderer.getBindGroup());\n      }\n\n      model.pipeline.addBindGroupLayout(model.bindGroup);\n      publicAPI.generateShaderDescriptions(model.pipelineHash, model.pipeline, model.vertexInput);\n      model.pipeline.setTopology(model.topology);\n      model.pipeline.setRenderEncoder(model.renderEncoder);\n      model.pipeline.setVertexState(model.vertexInput.getVertexInputInformation());\n      model.device.createPipeline(model.pipelineHash, model.pipeline);\n    }\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\n\nvar DEFAULT_VALUES = {\n  additionalBindables: undefined,\n  bindGroup: null,\n  device: null,\n  fragmentShaderTemplate: null,\n  numberOfInstances: 1,\n  numberOfVertices: 0,\n  pipelineHash: null,\n  shaderReplacements: null,\n  SSBO: null,\n  textureViews: null,\n  topology: 'triangle-list',\n  UBO: null,\n  vertexShaderTemplate: null,\n  WebGPURenderer: null\n}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Inheritance\n\n  vtkViewNode.extend(publicAPI, model, initialValues);\n  model.textureViews = [];\n  model.vertexInput = vtkWebGPUVertexInput.newInstance();\n  model.bindGroup = vtkWebGPUBindGroup.newInstance({\n    label: 'mapperBG'\n  });\n  model.additionalBindables = [];\n  model.fragmentShaderTemplate = model.fragmentShaderTemplate || vtkWebGPUSimpleMapperFS;\n  model.vertexShaderTemplate = model.vertexShaderTemplate || vtkWebGPUSimpleMapperVS;\n  model.shaderReplacements = new Map(); // Build VTK API\n\n  macro.get(publicAPI, model, ['pipeline', 'vertexInput']);\n  macro.setGet(publicAPI, model, ['additionalBindables', 'device', 'fragmentShaderTemplate', 'interpolate', 'numberOfInstances', 'numberOfVertices', 'pipelineHash', 'shaderReplacements', 'SSBO', 'textureViews', 'topology', 'UBO', 'vertexShaderTemplate', 'WebGPURenderer']); // Object methods\n\n  vtkWebGPUSimpleMapper(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = macro.newInstance(extend, 'vtkWebGPUSimpleMapper'); // ----------------------------------------------------------------------------\n\nvar vtkWebGPUSimpleMapper$1 = {\n  newInstance: newInstance,\n  extend: extend\n};\n\nexport { vtkWebGPUSimpleMapper$1 as default, extend, newInstance };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}