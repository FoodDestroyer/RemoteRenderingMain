{"ast":null,"code":"import _toConsumableArray from '@babel/runtime/helpers/toConsumableArray';\nimport macro from '../../macros.js';\nimport vtkPolyData from '../../Common/DataModel/PolyData.js';\nimport vtkMatrixBuilder from '../../Common/Core/MatrixBuilder.js';\nimport vtkDataArray from '../../Common/Core/DataArray.js';\n\n// vtkConcentricCylinderSource methods\n// ----------------------------------------------------------------------------\n\nfunction vtkConcentricCylinderSource(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkConcentricCylinderSource'); // Internal private function\n\n  function validateCellFields() {\n    while (model.cellFields.length < model.radius.length) {\n      model.cellFields.push(model.cellFields.length);\n    }\n  }\n  publicAPI.clearRadius = function () {\n    model.radius = [];\n    model.cellFields = [];\n    publicAPI.modified();\n  };\n  publicAPI.addRadius = function (radius, cellField) {\n    model.radius.push(radius);\n    if (cellField !== undefined) {\n      model.cellFields.push(cellField);\n    }\n    validateCellFields();\n    publicAPI.modified();\n  };\n  publicAPI.getNumberOfRadius = function () {\n    return model.radius.length;\n  };\n  publicAPI.getRadius = function () {\n    var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    return model.radius[index];\n  };\n  publicAPI.setRadius = function (index, radius) {\n    model.radius[index] = radius;\n    publicAPI.modified();\n  };\n  publicAPI.setCellField = function (index, field) {\n    model.cellFields[index] = field;\n    publicAPI.modified();\n  };\n  publicAPI.removeMask = function () {\n    model.mask = null;\n    publicAPI.modified();\n  };\n  publicAPI.setMaskLayer = function (index, hidden) {\n    var changeDetected = false;\n    if (!model.mask && hidden) {\n      changeDetected = true;\n      model.mask = [];\n    }\n    if (model.mask) {\n      if (!model.mask[index] !== !hidden) {\n        changeDetected = true;\n      }\n      model.mask[index] = hidden;\n    }\n    if (changeDetected) {\n      publicAPI.modified();\n    }\n  };\n  publicAPI.getMaskLayer = function (index) {\n    return index === undefined ? model.mask : model.mask[index];\n  };\n  function requestData(inData, outData) {\n    var _vtkMatrixBuilder$bui;\n    if (model.deleted || !model.radius.length) {\n      return;\n    } // Make sure we have consistency\n\n    validateCellFields();\n    var dataset = outData[0];\n    var numLayers = model.radius.length;\n    var zRef = model.height / 2.0; // Compute cell count\n\n    var cellArraySize = 0;\n    var numCells = 0;\n    var startTheta = model.startTheta < model.endTheta ? model.startTheta : model.endTheta;\n    startTheta *= Math.PI / 180.0;\n    var endTheta = model.endTheta > model.startTheta ? model.endTheta : model.startTheta;\n    endTheta *= Math.PI / 180.0;\n    var thetaResolution = model.resolution;\n    var partialDisk = false;\n    if (endTheta >= startTheta + 2 * Math.PI) {\n      // complete, closed cylinder\n      endTheta = startTheta + 2 * Math.PI;\n    } else {\n      // We add an extra point at endTheta, since the cylinder isn't closed.\n      // We cap the sides of the partial cylinder, so set the partialDisk flag.\n      ++thetaResolution;\n      partialDisk = true;\n    }\n    var deltaTheta = (endTheta - startTheta) / model.resolution;\n    var numberOfPoints = thetaResolution * numLayers * 2 + 2; // 5 entries per poly, 4 polys (top, bottom, in, out) per resolution\n\n    if (!model.skipInnerFaces && !model.mask) {\n      // We keep everything\n      cellArraySize = 2 * (thetaResolution + 1) + 5 * thetaResolution + (numLayers - 1) * thetaResolution * 20 + (partialDisk ? 10 * numLayers : 0);\n      numCells = 2 + thetaResolution + (numLayers - 1) * 4 * thetaResolution + (partialDisk ? 2 * numLayers : 0);\n    } else if (!model.skipInnerFaces && model.mask) {\n      // We skip some cylinders\n      // Handle core\n      if (!model.mask[0]) {\n        cellArraySize += 2 * (thetaResolution + 1) + 5 * thetaResolution + (partialDisk ? 10 : 0);\n        numCells += 2 + thetaResolution + (partialDisk ? 2 : 0);\n      } // Handle inside cylinders\n\n      for (var layer = 1; layer < numLayers; layer++) {\n        if (!model.mask[layer]) {\n          // Add inside cylinder count\n          cellArraySize += thetaResolution * 20 + (partialDisk ? 10 : 0);\n          numCells += 4 * thetaResolution + (partialDisk ? 2 : 0);\n        }\n      }\n    } else {\n      // We skip cylinders and internal faces\n      if (!model.skipInnerFaces || !model.mask || !model.mask[0]) {\n        // core handling\n        cellArraySize += 2 * (thetaResolution + 1) + (partialDisk ? 10 : 0);\n        numCells += 2 + (partialDisk ? 2 : 0);\n        if (model.radius.length === 1 || !model.skipInnerFaces || model.mask && model.mask[1]) {\n          // add side faces\n          cellArraySize += 5 * thetaResolution;\n          numCells += thetaResolution;\n        }\n      } // Handle inside cylinders\n\n      for (var _layer = 1; _layer < numLayers; _layer++) {\n        if (!model.skipInnerFaces || !model.mask || !model.mask[_layer]) {\n          var lastLayer = numLayers - 1 === _layer; // Add inside cylinder\n\n          cellArraySize += thetaResolution * 10 + (partialDisk ? 10 : 0);\n          numCells += thetaResolution * 2 + (partialDisk ? 2 : 0); // top + bottom + side caps\n          // Do we add innerFaces\n\n          if (!model.skipInnerFaces || model.mask && model.mask[_layer - 1]) {\n            cellArraySize += thetaResolution * 5;\n            numCells += thetaResolution;\n          } // Do we add outerFaces\n\n          if (lastLayer || !model.skipInnerFaces || model.mask && model.mask[_layer + 1]) {\n            cellArraySize += thetaResolution * 5;\n            numCells += thetaResolution;\n          }\n        }\n      }\n    } // Points\n\n    var pointIdx = 0;\n    var points = macro.newTypedArray(model.pointType, numberOfPoints * 3); // Cells\n\n    var cellLocation = 0;\n    var polys = new Uint32Array(cellArraySize); // CellFields\n\n    var fieldLocation = 0;\n    var field = new Float32Array(numCells); // Create points\n    // First two are centered, top and bottom. Used only if partialDisk is true.\n\n    points[pointIdx * 3 + 0] = 0;\n    points[pointIdx * 3 + 1] = 0;\n    points[pointIdx * 3 + 2] = zRef;\n    pointIdx++;\n    points[pointIdx * 3 + 0] = 0;\n    points[pointIdx * 3 + 1] = 0;\n    points[pointIdx * 3 + 2] = -zRef;\n    pointIdx++;\n    for (var _layer2 = 0; _layer2 < numLayers; _layer2++) {\n      var radius = model.radius[_layer2]; // Create top\n\n      for (var i = 0; i < thetaResolution; i++) {\n        var theta = startTheta + i * deltaTheta;\n        points[pointIdx * 3 + 0] = radius * Math.cos(theta);\n        points[pointIdx * 3 + 1] = radius * Math.sin(theta);\n        points[pointIdx * 3 + 2] = zRef;\n        pointIdx++;\n      } // Create bottom\n\n      for (var _i = 0; _i < thetaResolution; _i++) {\n        var _theta = startTheta + _i * deltaTheta;\n        points[pointIdx * 3 + 0] = radius * Math.cos(_theta);\n        points[pointIdx * 3 + 1] = radius * Math.sin(_theta);\n        points[pointIdx * 3 + 2] = -zRef;\n        pointIdx++;\n      }\n    } // Create cells for the core\n\n    var currentField = model.cellFields[0]; // Core: filtering\n\n    if (!model.mask || !model.mask[0]) {\n      // Core: Top disk\n      field[fieldLocation++] = currentField; // partial adds the center point and the last point.\n\n      polys[cellLocation++] = thetaResolution + (partialDisk ? 1 : 0);\n      if (partialDisk) polys[cellLocation++] = 0;\n      for (var _i2 = 0; _i2 < thetaResolution; _i2++) {\n        polys[cellLocation++] = _i2 + 2;\n      } // Core: Bottom disk\n\n      field[fieldLocation++] = currentField;\n      polys[cellLocation++] = thetaResolution + (partialDisk ? 1 : 0);\n      if (partialDisk) polys[cellLocation++] = 1;\n      for (var _i3 = 0; _i3 < thetaResolution; _i3++) {\n        polys[cellLocation++] = 2 * thetaResolution - _i3 - 1 + 2;\n      } // Core: sides\n\n      if (!model.skipInnerFaces || model.mask && model.mask[1] || numLayers === 1) {\n        for (var _i4 = 0; _i4 < model.resolution; _i4++) {\n          polys[cellLocation++] = 4;\n          polys[cellLocation++] = (_i4 + 1) % thetaResolution + 2;\n          polys[cellLocation++] = _i4 + 2;\n          polys[cellLocation++] = _i4 + thetaResolution + 2;\n          polys[cellLocation++] = (_i4 + 1) % thetaResolution + thetaResolution + 2;\n          field[fieldLocation++] = currentField;\n        }\n      }\n      if (partialDisk) {\n        polys[cellLocation++] = 4;\n        polys[cellLocation++] = 2;\n        polys[cellLocation++] = 0;\n        polys[cellLocation++] = 1;\n        polys[cellLocation++] = thetaResolution + 2;\n        field[fieldLocation++] = currentField;\n        polys[cellLocation++] = 4;\n        polys[cellLocation++] = 0;\n        polys[cellLocation++] = thetaResolution + 1;\n        polys[cellLocation++] = 2 * thetaResolution + 1;\n        polys[cellLocation++] = 1;\n        field[fieldLocation++] = currentField;\n      }\n    } // Create cells for the layers\n\n    for (var _layer3 = 1; _layer3 < numLayers; _layer3++) {\n      // Skip layer if masked\n      if (model.mask && model.mask[_layer3]) {\n        /* eslint-disable no-continue */\n        continue;\n        /* eslint-enable no-continue */\n      } // two for center points, then skip previous layer's points\n\n      var offset = thetaResolution * 2 * (_layer3 - 1) + 2;\n      var a = offset + 2 * thetaResolution; // next layer offset\n\n      var _lastLayer = numLayers - 1 === _layer3;\n      currentField = model.cellFields[_layer3]; // Create top\n\n      for (var _i5 = 0; _i5 < model.resolution; _i5++) {\n        polys[cellLocation++] = 4;\n        polys[cellLocation++] = _i5 + offset;\n        polys[cellLocation++] = (_i5 + 1) % thetaResolution + offset;\n        polys[cellLocation++] = (_i5 + 1) % thetaResolution + a;\n        polys[cellLocation++] = _i5 + a;\n        field[fieldLocation++] = currentField;\n      } // Create bottom\n\n      for (var _i6 = 0; _i6 < model.resolution; _i6++) {\n        polys[cellLocation++] = 4;\n        polys[cellLocation++] = (_i6 + 1) % thetaResolution + offset + thetaResolution;\n        polys[cellLocation++] = _i6 + offset + thetaResolution;\n        polys[cellLocation++] = _i6 + a + thetaResolution;\n        polys[cellLocation++] = (_i6 + 1) % thetaResolution + a + thetaResolution;\n        field[fieldLocation++] = currentField;\n      } // Create inner\n\n      if (!model.skipInnerFaces || model.mask && model.mask[_layer3 - 1]) {\n        for (var _i7 = 0; _i7 < model.resolution; _i7++) {\n          polys[cellLocation++] = 4;\n          polys[cellLocation++] = _i7 + offset;\n          polys[cellLocation++] = (_i7 + 1) % thetaResolution + offset;\n          polys[cellLocation++] = (_i7 + 1) % thetaResolution + thetaResolution + offset;\n          polys[cellLocation++] = _i7 + thetaResolution + offset;\n          field[fieldLocation++] = currentField;\n        }\n      } // Create outer\n\n      if (!model.skipInnerFaces || _lastLayer || model.mask && (model.mask[_layer3 + 1] || _lastLayer)) {\n        for (var _i8 = 0; _i8 < model.resolution; _i8++) {\n          polys[cellLocation++] = 4;\n          polys[cellLocation++] = (_i8 + 1) % thetaResolution + a;\n          polys[cellLocation++] = _i8 + a;\n          polys[cellLocation++] = _i8 + thetaResolution + a;\n          polys[cellLocation++] = (_i8 + 1) % thetaResolution + thetaResolution + a;\n          field[fieldLocation++] = currentField;\n        }\n      } // create caps\n\n      if (partialDisk) {\n        polys[cellLocation++] = 4;\n        polys[cellLocation++] = a; // from first outer\n\n        polys[cellLocation++] = offset; // first inner\n\n        polys[cellLocation++] = thetaResolution + offset; // first inner\n\n        polys[cellLocation++] = thetaResolution + a; // first outer\n\n        field[fieldLocation++] = currentField;\n        polys[cellLocation++] = 4;\n        polys[cellLocation++] = model.resolution + a; // last outer\n\n        polys[cellLocation++] = model.resolution + offset; // last inner\n\n        polys[cellLocation++] = model.resolution + thetaResolution + offset; // last inner\n\n        polys[cellLocation++] = model.resolution + thetaResolution + a; // last outer\n\n        field[fieldLocation++] = currentField;\n      }\n    } // Apply transformation to the point coordinates\n\n    (_vtkMatrixBuilder$bui = vtkMatrixBuilder.buildFromRadian()).translate.apply(_vtkMatrixBuilder$bui, _toConsumableArray(model.center)).rotateFromDirections([0, 0, 1], model.direction).apply(points);\n    dataset = vtkPolyData.newInstance();\n    dataset.getPoints().setData(points, 3);\n    dataset.getPolys().setData(polys, 1);\n    dataset.getCellData().setScalars(vtkDataArray.newInstance({\n      name: 'layer',\n      values: field\n    })); // Update output\n\n    outData[0] = dataset;\n  } // Expose methods\n\n  publicAPI.requestData = requestData;\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nvar DEFAULT_VALUES = {\n  height: 1.0,\n  radius: [0.5],\n  cellFields: [1],\n  resolution: 6,\n  startTheta: 0.0,\n  endTheta: 360.0,\n  center: [0, 0, 0],\n  direction: [0.0, 0.0, 1.0],\n  skipInnerFaces: true,\n  mask: null,\n  // If present, array to know if a layer should be skipped(=true)\n  pointType: 'Float64Array'\n}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Build VTK API\n\n  macro.obj(publicAPI, model);\n  macro.setGet(publicAPI, model, ['height', 'resolution', 'startTheta', 'endTheta', 'skipInnerFaces']);\n  macro.setGetArray(publicAPI, model, ['center', 'direction'], 3);\n  macro.getArray(publicAPI, model, ['cellFields']);\n  macro.algo(publicAPI, model, 0, 1);\n  vtkConcentricCylinderSource(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = macro.newInstance(extend, 'vtkConcentricCylinderSource'); // ----------------------------------------------------------------------------\n\nvar vtkConcentricCylinderSource$1 = {\n  newInstance: newInstance,\n  extend: extend\n};\nexport { vtkConcentricCylinderSource$1 as default, extend, newInstance };","map":{"version":3,"names":["_toConsumableArray","macro","vtkPolyData","vtkMatrixBuilder","vtkDataArray","vtkConcentricCylinderSource","publicAPI","model","classHierarchy","push","validateCellFields","cellFields","length","radius","clearRadius","modified","addRadius","cellField","undefined","getNumberOfRadius","getRadius","index","arguments","setRadius","setCellField","field","removeMask","mask","setMaskLayer","hidden","changeDetected","getMaskLayer","requestData","inData","outData","_vtkMatrixBuilder$bui","deleted","dataset","numLayers","zRef","height","cellArraySize","numCells","startTheta","endTheta","Math","PI","thetaResolution","resolution","partialDisk","deltaTheta","numberOfPoints","skipInnerFaces","layer","_layer","lastLayer","pointIdx","points","newTypedArray","pointType","cellLocation","polys","Uint32Array","fieldLocation","Float32Array","_layer2","i","theta","cos","sin","_i","_theta","currentField","_i2","_i3","_i4","_layer3","offset","a","_lastLayer","_i5","_i6","_i7","_i8","buildFromRadian","translate","apply","center","rotateFromDirections","direction","newInstance","getPoints","setData","getPolys","getCellData","setScalars","name","values","DEFAULT_VALUES","extend","initialValues","Object","assign","obj","setGet","setGetArray","getArray","algo","vtkConcentricCylinderSource$1","default"],"sources":["/home/rakshith/Documents/RemoteRendering/vtk-js-react-app/node_modules/@kitware/vtk.js/Filters/Sources/ConcentricCylinderSource.js"],"sourcesContent":["import _toConsumableArray from '@babel/runtime/helpers/toConsumableArray';\nimport macro from '../../macros.js';\nimport vtkPolyData from '../../Common/DataModel/PolyData.js';\nimport vtkMatrixBuilder from '../../Common/Core/MatrixBuilder.js';\nimport vtkDataArray from '../../Common/Core/DataArray.js';\n\n// vtkConcentricCylinderSource methods\n// ----------------------------------------------------------------------------\n\nfunction vtkConcentricCylinderSource(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkConcentricCylinderSource'); // Internal private function\n\n  function validateCellFields() {\n    while (model.cellFields.length < model.radius.length) {\n      model.cellFields.push(model.cellFields.length);\n    }\n  }\n\n  publicAPI.clearRadius = function () {\n    model.radius = [];\n    model.cellFields = [];\n    publicAPI.modified();\n  };\n\n  publicAPI.addRadius = function (radius, cellField) {\n    model.radius.push(radius);\n\n    if (cellField !== undefined) {\n      model.cellFields.push(cellField);\n    }\n\n    validateCellFields();\n    publicAPI.modified();\n  };\n\n  publicAPI.getNumberOfRadius = function () {\n    return model.radius.length;\n  };\n\n  publicAPI.getRadius = function () {\n    var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    return model.radius[index];\n  };\n\n  publicAPI.setRadius = function (index, radius) {\n    model.radius[index] = radius;\n    publicAPI.modified();\n  };\n\n  publicAPI.setCellField = function (index, field) {\n    model.cellFields[index] = field;\n    publicAPI.modified();\n  };\n\n  publicAPI.removeMask = function () {\n    model.mask = null;\n    publicAPI.modified();\n  };\n\n  publicAPI.setMaskLayer = function (index, hidden) {\n    var changeDetected = false;\n\n    if (!model.mask && hidden) {\n      changeDetected = true;\n      model.mask = [];\n    }\n\n    if (model.mask) {\n      if (!model.mask[index] !== !hidden) {\n        changeDetected = true;\n      }\n\n      model.mask[index] = hidden;\n    }\n\n    if (changeDetected) {\n      publicAPI.modified();\n    }\n  };\n\n  publicAPI.getMaskLayer = function (index) {\n    return index === undefined ? model.mask : model.mask[index];\n  };\n\n  function requestData(inData, outData) {\n    var _vtkMatrixBuilder$bui;\n\n    if (model.deleted || !model.radius.length) {\n      return;\n    } // Make sure we have consistency\n\n\n    validateCellFields();\n    var dataset = outData[0];\n    var numLayers = model.radius.length;\n    var zRef = model.height / 2.0; // Compute cell count\n\n    var cellArraySize = 0;\n    var numCells = 0;\n    var startTheta = model.startTheta < model.endTheta ? model.startTheta : model.endTheta;\n    startTheta *= Math.PI / 180.0;\n    var endTheta = model.endTheta > model.startTheta ? model.endTheta : model.startTheta;\n    endTheta *= Math.PI / 180.0;\n    var thetaResolution = model.resolution;\n    var partialDisk = false;\n\n    if (endTheta >= startTheta + 2 * Math.PI) {\n      // complete, closed cylinder\n      endTheta = startTheta + 2 * Math.PI;\n    } else {\n      // We add an extra point at endTheta, since the cylinder isn't closed.\n      // We cap the sides of the partial cylinder, so set the partialDisk flag.\n      ++thetaResolution;\n      partialDisk = true;\n    }\n\n    var deltaTheta = (endTheta - startTheta) / model.resolution;\n    var numberOfPoints = thetaResolution * numLayers * 2 + 2; // 5 entries per poly, 4 polys (top, bottom, in, out) per resolution\n\n    if (!model.skipInnerFaces && !model.mask) {\n      // We keep everything\n      cellArraySize = 2 * (thetaResolution + 1) + 5 * thetaResolution + (numLayers - 1) * thetaResolution * 20 + (partialDisk ? 10 * numLayers : 0);\n      numCells = 2 + thetaResolution + (numLayers - 1) * 4 * thetaResolution + (partialDisk ? 2 * numLayers : 0);\n    } else if (!model.skipInnerFaces && model.mask) {\n      // We skip some cylinders\n      // Handle core\n      if (!model.mask[0]) {\n        cellArraySize += 2 * (thetaResolution + 1) + 5 * thetaResolution + (partialDisk ? 10 : 0);\n        numCells += 2 + thetaResolution + (partialDisk ? 2 : 0);\n      } // Handle inside cylinders\n\n\n      for (var layer = 1; layer < numLayers; layer++) {\n        if (!model.mask[layer]) {\n          // Add inside cylinder count\n          cellArraySize += thetaResolution * 20 + (partialDisk ? 10 : 0);\n          numCells += 4 * thetaResolution + (partialDisk ? 2 : 0);\n        }\n      }\n    } else {\n      // We skip cylinders and internal faces\n      if (!model.skipInnerFaces || !model.mask || !model.mask[0]) {\n        // core handling\n        cellArraySize += 2 * (thetaResolution + 1) + (partialDisk ? 10 : 0);\n        numCells += 2 + (partialDisk ? 2 : 0);\n\n        if (model.radius.length === 1 || !model.skipInnerFaces || model.mask && model.mask[1]) {\n          // add side faces\n          cellArraySize += 5 * thetaResolution;\n          numCells += thetaResolution;\n        }\n      } // Handle inside cylinders\n\n\n      for (var _layer = 1; _layer < numLayers; _layer++) {\n        if (!model.skipInnerFaces || !model.mask || !model.mask[_layer]) {\n          var lastLayer = numLayers - 1 === _layer; // Add inside cylinder\n\n          cellArraySize += thetaResolution * 10 + (partialDisk ? 10 : 0);\n          numCells += thetaResolution * 2 + (partialDisk ? 2 : 0); // top + bottom + side caps\n          // Do we add innerFaces\n\n          if (!model.skipInnerFaces || model.mask && model.mask[_layer - 1]) {\n            cellArraySize += thetaResolution * 5;\n            numCells += thetaResolution;\n          } // Do we add outerFaces\n\n\n          if (lastLayer || !model.skipInnerFaces || model.mask && model.mask[_layer + 1]) {\n            cellArraySize += thetaResolution * 5;\n            numCells += thetaResolution;\n          }\n        }\n      }\n    } // Points\n\n\n    var pointIdx = 0;\n    var points = macro.newTypedArray(model.pointType, numberOfPoints * 3); // Cells\n\n    var cellLocation = 0;\n    var polys = new Uint32Array(cellArraySize); // CellFields\n\n    var fieldLocation = 0;\n    var field = new Float32Array(numCells); // Create points\n    // First two are centered, top and bottom. Used only if partialDisk is true.\n\n    points[pointIdx * 3 + 0] = 0;\n    points[pointIdx * 3 + 1] = 0;\n    points[pointIdx * 3 + 2] = zRef;\n    pointIdx++;\n    points[pointIdx * 3 + 0] = 0;\n    points[pointIdx * 3 + 1] = 0;\n    points[pointIdx * 3 + 2] = -zRef;\n    pointIdx++;\n\n    for (var _layer2 = 0; _layer2 < numLayers; _layer2++) {\n      var radius = model.radius[_layer2]; // Create top\n\n      for (var i = 0; i < thetaResolution; i++) {\n        var theta = startTheta + i * deltaTheta;\n        points[pointIdx * 3 + 0] = radius * Math.cos(theta);\n        points[pointIdx * 3 + 1] = radius * Math.sin(theta);\n        points[pointIdx * 3 + 2] = zRef;\n        pointIdx++;\n      } // Create bottom\n\n\n      for (var _i = 0; _i < thetaResolution; _i++) {\n        var _theta = startTheta + _i * deltaTheta;\n\n        points[pointIdx * 3 + 0] = radius * Math.cos(_theta);\n        points[pointIdx * 3 + 1] = radius * Math.sin(_theta);\n        points[pointIdx * 3 + 2] = -zRef;\n        pointIdx++;\n      }\n    } // Create cells for the core\n\n\n    var currentField = model.cellFields[0]; // Core: filtering\n\n    if (!model.mask || !model.mask[0]) {\n      // Core: Top disk\n      field[fieldLocation++] = currentField; // partial adds the center point and the last point.\n\n      polys[cellLocation++] = thetaResolution + (partialDisk ? 1 : 0);\n      if (partialDisk) polys[cellLocation++] = 0;\n\n      for (var _i2 = 0; _i2 < thetaResolution; _i2++) {\n        polys[cellLocation++] = _i2 + 2;\n      } // Core: Bottom disk\n\n\n      field[fieldLocation++] = currentField;\n      polys[cellLocation++] = thetaResolution + (partialDisk ? 1 : 0);\n      if (partialDisk) polys[cellLocation++] = 1;\n\n      for (var _i3 = 0; _i3 < thetaResolution; _i3++) {\n        polys[cellLocation++] = 2 * thetaResolution - _i3 - 1 + 2;\n      } // Core: sides\n\n\n      if (!model.skipInnerFaces || model.mask && model.mask[1] || numLayers === 1) {\n        for (var _i4 = 0; _i4 < model.resolution; _i4++) {\n          polys[cellLocation++] = 4;\n          polys[cellLocation++] = (_i4 + 1) % thetaResolution + 2;\n          polys[cellLocation++] = _i4 + 2;\n          polys[cellLocation++] = _i4 + thetaResolution + 2;\n          polys[cellLocation++] = (_i4 + 1) % thetaResolution + thetaResolution + 2;\n          field[fieldLocation++] = currentField;\n        }\n      }\n\n      if (partialDisk) {\n        polys[cellLocation++] = 4;\n        polys[cellLocation++] = 2;\n        polys[cellLocation++] = 0;\n        polys[cellLocation++] = 1;\n        polys[cellLocation++] = thetaResolution + 2;\n        field[fieldLocation++] = currentField;\n        polys[cellLocation++] = 4;\n        polys[cellLocation++] = 0;\n        polys[cellLocation++] = thetaResolution + 1;\n        polys[cellLocation++] = 2 * thetaResolution + 1;\n        polys[cellLocation++] = 1;\n        field[fieldLocation++] = currentField;\n      }\n    } // Create cells for the layers\n\n\n    for (var _layer3 = 1; _layer3 < numLayers; _layer3++) {\n      // Skip layer if masked\n      if (model.mask && model.mask[_layer3]) {\n        /* eslint-disable no-continue */\n        continue;\n        /* eslint-enable no-continue */\n      } // two for center points, then skip previous layer's points\n\n\n      var offset = thetaResolution * 2 * (_layer3 - 1) + 2;\n      var a = offset + 2 * thetaResolution; // next layer offset\n\n      var _lastLayer = numLayers - 1 === _layer3;\n\n      currentField = model.cellFields[_layer3]; // Create top\n\n      for (var _i5 = 0; _i5 < model.resolution; _i5++) {\n        polys[cellLocation++] = 4;\n        polys[cellLocation++] = _i5 + offset;\n        polys[cellLocation++] = (_i5 + 1) % thetaResolution + offset;\n        polys[cellLocation++] = (_i5 + 1) % thetaResolution + a;\n        polys[cellLocation++] = _i5 + a;\n        field[fieldLocation++] = currentField;\n      } // Create bottom\n\n\n      for (var _i6 = 0; _i6 < model.resolution; _i6++) {\n        polys[cellLocation++] = 4;\n        polys[cellLocation++] = (_i6 + 1) % thetaResolution + offset + thetaResolution;\n        polys[cellLocation++] = _i6 + offset + thetaResolution;\n        polys[cellLocation++] = _i6 + a + thetaResolution;\n        polys[cellLocation++] = (_i6 + 1) % thetaResolution + a + thetaResolution;\n        field[fieldLocation++] = currentField;\n      } // Create inner\n\n\n      if (!model.skipInnerFaces || model.mask && model.mask[_layer3 - 1]) {\n        for (var _i7 = 0; _i7 < model.resolution; _i7++) {\n          polys[cellLocation++] = 4;\n          polys[cellLocation++] = _i7 + offset;\n          polys[cellLocation++] = (_i7 + 1) % thetaResolution + offset;\n          polys[cellLocation++] = (_i7 + 1) % thetaResolution + thetaResolution + offset;\n          polys[cellLocation++] = _i7 + thetaResolution + offset;\n          field[fieldLocation++] = currentField;\n        }\n      } // Create outer\n\n\n      if (!model.skipInnerFaces || _lastLayer || model.mask && (model.mask[_layer3 + 1] || _lastLayer)) {\n        for (var _i8 = 0; _i8 < model.resolution; _i8++) {\n          polys[cellLocation++] = 4;\n          polys[cellLocation++] = (_i8 + 1) % thetaResolution + a;\n          polys[cellLocation++] = _i8 + a;\n          polys[cellLocation++] = _i8 + thetaResolution + a;\n          polys[cellLocation++] = (_i8 + 1) % thetaResolution + thetaResolution + a;\n          field[fieldLocation++] = currentField;\n        }\n      } // create caps\n\n\n      if (partialDisk) {\n        polys[cellLocation++] = 4;\n        polys[cellLocation++] = a; // from first outer\n\n        polys[cellLocation++] = offset; // first inner\n\n        polys[cellLocation++] = thetaResolution + offset; // first inner\n\n        polys[cellLocation++] = thetaResolution + a; // first outer\n\n        field[fieldLocation++] = currentField;\n        polys[cellLocation++] = 4;\n        polys[cellLocation++] = model.resolution + a; // last outer\n\n        polys[cellLocation++] = model.resolution + offset; // last inner\n\n        polys[cellLocation++] = model.resolution + thetaResolution + offset; // last inner\n\n        polys[cellLocation++] = model.resolution + thetaResolution + a; // last outer\n\n        field[fieldLocation++] = currentField;\n      }\n    } // Apply transformation to the point coordinates\n\n\n    (_vtkMatrixBuilder$bui = vtkMatrixBuilder.buildFromRadian()).translate.apply(_vtkMatrixBuilder$bui, _toConsumableArray(model.center)).rotateFromDirections([0, 0, 1], model.direction).apply(points);\n\n    dataset = vtkPolyData.newInstance();\n    dataset.getPoints().setData(points, 3);\n    dataset.getPolys().setData(polys, 1);\n    dataset.getCellData().setScalars(vtkDataArray.newInstance({\n      name: 'layer',\n      values: field\n    })); // Update output\n\n    outData[0] = dataset;\n  } // Expose methods\n\n\n  publicAPI.requestData = requestData;\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\n\nvar DEFAULT_VALUES = {\n  height: 1.0,\n  radius: [0.5],\n  cellFields: [1],\n  resolution: 6,\n  startTheta: 0.0,\n  endTheta: 360.0,\n  center: [0, 0, 0],\n  direction: [0.0, 0.0, 1.0],\n  skipInnerFaces: true,\n  mask: null,\n  // If present, array to know if a layer should be skipped(=true)\n  pointType: 'Float64Array'\n}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Build VTK API\n\n  macro.obj(publicAPI, model);\n  macro.setGet(publicAPI, model, ['height', 'resolution', 'startTheta', 'endTheta', 'skipInnerFaces']);\n  macro.setGetArray(publicAPI, model, ['center', 'direction'], 3);\n  macro.getArray(publicAPI, model, ['cellFields']);\n  macro.algo(publicAPI, model, 0, 1);\n  vtkConcentricCylinderSource(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = macro.newInstance(extend, 'vtkConcentricCylinderSource'); // ----------------------------------------------------------------------------\n\nvar vtkConcentricCylinderSource$1 = {\n  newInstance: newInstance,\n  extend: extend\n};\n\nexport { vtkConcentricCylinderSource$1 as default, extend, newInstance };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}