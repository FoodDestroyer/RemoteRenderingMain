{"ast":null,"code":"import _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport { newInstance as newInstance$1, obj, algo, setGet, vtkErrorMacro as vtkErrorMacro$1, newTypedArrayFrom } from '../../macros.js';\nimport vtkPolyData from '../../Common/DataModel/PolyData.js';\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n  return target;\n}\nvar vtkErrorMacro = vtkErrorMacro$1;\nfunction initPolyIterator(pd) {\n  var polys = pd.getPolys().getData();\n  var strips = pd.getStrips().getData();\n  var it = {\n    done: false,\n    polyIdx: 0,\n    stripIdx: 0,\n    remainingStripLength: 0,\n    // returns a single poly cell\n    next: function next() {\n      var ret = null;\n      if (it.polyIdx < polys.length) {\n        var cellSize = polys[it.polyIdx];\n        var start = it.polyIdx + 1;\n        var end = start + cellSize;\n        it.polyIdx = end;\n        ret = polys.subarray(start, end);\n      } else if (it.stripIdx < strips.length) {\n        if (it.remainingStripLength === 0) {\n          it.remainingStripLength = strips[it.stripIdx] - 2; // sliding window of 3 points\n          // stripIdx points to the last point in a triangle 3-tuple\n\n          it.stripIdx += 3;\n        }\n        var _start = it.stripIdx - 2;\n        var _end = it.stripIdx + 1;\n        it.stripIdx++;\n        it.remainingStripLength--;\n        ret = strips.subarray(_start, _end);\n      } else if (it.done) {\n        throw new Error('Iterator is done');\n      }\n      it.done = it.polyIdx >= polys.length && it.stripIdx >= strips.length;\n      return ret;\n    }\n  };\n  return it;\n} // ----------------------------------------------------------------------------\n// vtkCutter methods\n// ----------------------------------------------------------------------------\n\nfunction vtkCutter(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkCutter'); // Capture \"parentClass\" api for internal use\n\n  var superClass = _objectSpread({}, publicAPI);\n  publicAPI.getMTime = function () {\n    var mTime = superClass.getMTime();\n    if (!model.cutFunction) {\n      return mTime;\n    }\n    mTime = Math.max(mTime, model.cutFunction.getMTime());\n    return mTime;\n  };\n  function dataSetCutter(input, output) {\n    var points = input.getPoints();\n    var pointsData = points.getData();\n    var numPts = points.getNumberOfPoints();\n    var newPointsData = [];\n    var newLinesData = [];\n    var newPolysData = [];\n    if (!model.cutScalars || model.cutScalars.length < numPts) {\n      model.cutScalars = new Float32Array(numPts);\n    } // Loop over all points evaluating scalar function at each point\n\n    var inOffset = 0;\n    var outOffset = 0;\n    while (inOffset < pointsData.length) {\n      model.cutScalars[outOffset++] = model.cutFunction.evaluateFunction(pointsData[inOffset++], pointsData[inOffset++], pointsData[inOffset++]);\n    }\n    var crossedEdges = [];\n    var x1 = new Array(3);\n    var x2 = new Array(3); // Loop over all cells; get scalar values for all cell points\n    // and process each cell.\n\n    /* eslint-disable no-continue */\n\n    var it = initPolyIterator(input);\n    while (!it.done) {\n      // cell contains the point IDs/indices\n      var cell = it.next(); // Check that cells have at least 3 points\n\n      if (cell.length <= 2) {\n        continue;\n      } // Get associated scalar of points that constitute the current cell\n\n      var cellPointsScalars = [];\n      var pointIndex = void 0;\n      for (var i = 0; i < cell.length; i++) {\n        pointIndex = cell[i];\n        cellPointsScalars.push(model.cutScalars[pointIndex]);\n      } // Check if all cell points are on same side (same side == cell not crossed by cut function)\n      // TODO: won't work if one point scalar is = 0 ?\n\n      var sideFirstPoint = cellPointsScalars[0] > 0;\n      var allPointsSameSide = true;\n      for (var _i = 1; _i < cellPointsScalars.length; _i++) {\n        var sideCurrentPoint = cellPointsScalars[_i] > 0;\n        if (sideCurrentPoint !== sideFirstPoint) {\n          allPointsSameSide = false;\n          break;\n        }\n      } // Go to next cell if cell is not crossed by cut function\n\n      if (allPointsSameSide) {\n        continue;\n      } // Find and compute edges which intersect cells\n\n      var intersectedEdgesList = [];\n      for (var _i2 = 0; _i2 < cell.length; _i2++) {\n        var idNext = _i2 + 1 === cell.length ? 0 : _i2 + 1; // Go to next edge if edge is not crossed\n        // TODO: in most come cases, (numberOfPointsInCell - 1) or 0 edges of the cell\n        // will be crossed, but if it crosses right at a point, it could be intersecting\n        // with (numberOfPoints) or 1 edge(s). Do we account for that?\n\n        var signPoint0 = cellPointsScalars[_i2] > 0;\n        var signPoint1 = cellPointsScalars[idNext] > 0;\n        if (signPoint1 === signPoint0) {\n          continue;\n        } // Compute preferred interpolation direction\n\n        var e1 = _i2;\n        var e2 = idNext;\n        var deltaScalar = cellPointsScalars[e2] - cellPointsScalars[e1];\n        if (deltaScalar <= 0) {\n          e1 = idNext;\n          e2 = _i2;\n          deltaScalar *= -1;\n        } // linear interpolation\n\n        var t = 0.0;\n        if (deltaScalar !== 0.0) {\n          t = (model.cutValue - cellPointsScalars[e1]) / deltaScalar;\n        } // points position\n\n        var pointID1 = cell[e1];\n        var pointID2 = cell[e2];\n        x1[0] = pointsData[pointID1 * 3];\n        x1[1] = pointsData[pointID1 * 3 + 1];\n        x1[2] = pointsData[pointID1 * 3 + 2];\n        x2[0] = pointsData[pointID2 * 3];\n        x2[1] = pointsData[pointID2 * 3 + 1];\n        x2[2] = pointsData[pointID2 * 3 + 2]; // Compute the intersected point on edge\n\n        var computedIntersectedPoint = [x1[0] + t * (x2[0] - x1[0]), x1[1] + t * (x2[1] - x1[1]), x1[2] + t * (x2[2] - x1[2])]; // Keep track of it\n\n        intersectedEdgesList.push({\n          pointEdge1: pointID1,\n          // id of one point of the edge\n          pointEdge2: pointID2,\n          // id of one point of the edge\n          intersectedPoint: computedIntersectedPoint,\n          // 3D coordinate of points that intersected edge\n          newPointID: -1 // id of the intersected point when it will be added into vtkPoints\n        });\n      } // Add points into newPointList\n\n      for (var _i3 = 0; _i3 < intersectedEdgesList.length; _i3++) {\n        var intersectedEdge = intersectedEdgesList[_i3];\n        var alreadyAdded = false; // Check if point/edge already added\n\n        for (var j = 0; j < crossedEdges.length; j++) {\n          var crossedEdge = crossedEdges[j];\n          var sameEdge = intersectedEdge.pointEdge1 === crossedEdge.pointEdge1 && intersectedEdge.pointEdge2 === crossedEdge.pointEdge2;\n          var samePoint = intersectedEdge.intersectedPoint[0] === crossedEdge.intersectedPoint[0] && intersectedEdge.intersectedPoint[1] === crossedEdge.intersectedPoint[1] && intersectedEdge.intersectedPoint[2] === crossedEdge.intersectedPoint[2];\n          if (sameEdge || samePoint) {\n            alreadyAdded = true;\n            intersectedEdgesList[_i3].newPointID = crossedEdges[j].newPointID;\n            break;\n          }\n        }\n        if (!alreadyAdded) {\n          newPointsData.push(intersectedEdge.intersectedPoint[0]);\n          newPointsData.push(intersectedEdge.intersectedPoint[1]);\n          newPointsData.push(intersectedEdge.intersectedPoint[2]);\n          intersectedEdgesList[_i3].newPointID = newPointsData.length / 3 - 1;\n          crossedEdges.push(intersectedEdgesList[_i3]);\n        }\n      } // Store cells\n\n      var cellSize = intersectedEdgesList.length;\n      if (cellSize === 2) {\n        newLinesData.push(cellSize, intersectedEdgesList[0].newPointID, intersectedEdgesList[1].newPointID);\n      } else if (cellSize > 2) {\n        newPolysData.push(cellSize);\n        intersectedEdgesList.forEach(function (edge) {\n          newPolysData.push(edge.newPointID);\n        });\n      }\n    } // Set points\n\n    var outputPoints = output.getPoints();\n    outputPoints.setData(newTypedArrayFrom(points.getDataType(), newPointsData), 3); // Set lines\n\n    if (newLinesData.length !== 0) {\n      output.getLines().setData(Uint16Array.from(newLinesData));\n    } // Set polys\n\n    if (newPolysData.length !== 0) {\n      output.getPolys().setData(Uint16Array.from(newPolysData));\n    }\n  } // expose requestData\n\n  publicAPI.requestData = function (inData, outData) {\n    // implement requestData\n    var input = inData[0];\n    if (!input) {\n      vtkErrorMacro('Invalid or missing input');\n      return;\n    }\n    if (!model.cutFunction) {\n      vtkErrorMacro('Missing cut function');\n      return;\n    }\n    var output = vtkPolyData.newInstance();\n    dataSetCutter(input, output);\n    outData[0] = output;\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nvar DEFAULT_VALUES = {\n  cutFunction: null,\n  // support method with evaluateFunction method\n  cutScalars: null,\n  cutValue: 0.0\n}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Make this a VTK object\n\n  obj(publicAPI, model); // Also make it an algorithm with one input and one output\n\n  algo(publicAPI, model, 1, 1); // Set implicit function use to cut the input data (is vtkPlane)\n\n  setGet(publicAPI, model, ['cutFunction', 'cutValue']); // Object specific methods\n\n  vtkCutter(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = newInstance$1(extend, 'vtkCutter'); // ----------------------------------------------------------------------------\n\nvar vtkCutter$1 = {\n  newInstance: newInstance,\n  extend: extend\n};\nexport { vtkCutter$1 as default, extend, newInstance };","map":{"version":3,"names":["_defineProperty","newInstance","newInstance$1","obj","algo","setGet","vtkErrorMacro","vtkErrorMacro$1","newTypedArrayFrom","vtkPolyData","ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","getOwnPropertyDescriptors","defineProperties","defineProperty","initPolyIterator","pd","polys","getPolys","getData","strips","getStrips","it","done","polyIdx","stripIdx","remainingStripLength","next","ret","cellSize","start","end","subarray","_start","_end","Error","vtkCutter","publicAPI","model","classHierarchy","superClass","getMTime","mTime","cutFunction","Math","max","dataSetCutter","input","output","points","getPoints","pointsData","numPts","getNumberOfPoints","newPointsData","newLinesData","newPolysData","cutScalars","Float32Array","inOffset","outOffset","evaluateFunction","crossedEdges","x1","Array","x2","cell","cellPointsScalars","pointIndex","sideFirstPoint","allPointsSameSide","_i","sideCurrentPoint","intersectedEdgesList","_i2","idNext","signPoint0","signPoint1","e1","e2","deltaScalar","t","cutValue","pointID1","pointID2","computedIntersectedPoint","pointEdge1","pointEdge2","intersectedPoint","newPointID","_i3","intersectedEdge","alreadyAdded","j","crossedEdge","sameEdge","samePoint","edge","outputPoints","setData","getDataType","getLines","Uint16Array","from","requestData","inData","outData","DEFAULT_VALUES","extend","initialValues","undefined","assign","vtkCutter$1","default"],"sources":["/home/rakshith/Documents/RemoteRendering/vtk-js-react-app/node_modules/@kitware/vtk.js/Filters/Core/Cutter.js"],"sourcesContent":["import _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport { newInstance as newInstance$1, obj, algo, setGet, vtkErrorMacro as vtkErrorMacro$1, newTypedArrayFrom } from '../../macros.js';\nimport vtkPolyData from '../../Common/DataModel/PolyData.js';\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nvar vtkErrorMacro = vtkErrorMacro$1;\n\nfunction initPolyIterator(pd) {\n  var polys = pd.getPolys().getData();\n  var strips = pd.getStrips().getData();\n  var it = {\n    done: false,\n    polyIdx: 0,\n    stripIdx: 0,\n    remainingStripLength: 0,\n    // returns a single poly cell\n    next: function next() {\n      var ret = null;\n\n      if (it.polyIdx < polys.length) {\n        var cellSize = polys[it.polyIdx];\n        var start = it.polyIdx + 1;\n        var end = start + cellSize;\n        it.polyIdx = end;\n        ret = polys.subarray(start, end);\n      } else if (it.stripIdx < strips.length) {\n        if (it.remainingStripLength === 0) {\n          it.remainingStripLength = strips[it.stripIdx] - 2; // sliding window of 3 points\n          // stripIdx points to the last point in a triangle 3-tuple\n\n          it.stripIdx += 3;\n        }\n\n        var _start = it.stripIdx - 2;\n\n        var _end = it.stripIdx + 1;\n\n        it.stripIdx++;\n        it.remainingStripLength--;\n        ret = strips.subarray(_start, _end);\n      } else if (it.done) {\n        throw new Error('Iterator is done');\n      }\n\n      it.done = it.polyIdx >= polys.length && it.stripIdx >= strips.length;\n      return ret;\n    }\n  };\n  return it;\n} // ----------------------------------------------------------------------------\n// vtkCutter methods\n// ----------------------------------------------------------------------------\n\n\nfunction vtkCutter(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkCutter'); // Capture \"parentClass\" api for internal use\n\n  var superClass = _objectSpread({}, publicAPI);\n\n  publicAPI.getMTime = function () {\n    var mTime = superClass.getMTime();\n\n    if (!model.cutFunction) {\n      return mTime;\n    }\n\n    mTime = Math.max(mTime, model.cutFunction.getMTime());\n    return mTime;\n  };\n\n  function dataSetCutter(input, output) {\n    var points = input.getPoints();\n    var pointsData = points.getData();\n    var numPts = points.getNumberOfPoints();\n    var newPointsData = [];\n    var newLinesData = [];\n    var newPolysData = [];\n\n    if (!model.cutScalars || model.cutScalars.length < numPts) {\n      model.cutScalars = new Float32Array(numPts);\n    } // Loop over all points evaluating scalar function at each point\n\n\n    var inOffset = 0;\n    var outOffset = 0;\n\n    while (inOffset < pointsData.length) {\n      model.cutScalars[outOffset++] = model.cutFunction.evaluateFunction(pointsData[inOffset++], pointsData[inOffset++], pointsData[inOffset++]);\n    }\n\n    var crossedEdges = [];\n    var x1 = new Array(3);\n    var x2 = new Array(3); // Loop over all cells; get scalar values for all cell points\n    // and process each cell.\n\n    /* eslint-disable no-continue */\n\n    var it = initPolyIterator(input);\n\n    while (!it.done) {\n      // cell contains the point IDs/indices\n      var cell = it.next(); // Check that cells have at least 3 points\n\n      if (cell.length <= 2) {\n        continue;\n      } // Get associated scalar of points that constitute the current cell\n\n\n      var cellPointsScalars = [];\n      var pointIndex = void 0;\n\n      for (var i = 0; i < cell.length; i++) {\n        pointIndex = cell[i];\n        cellPointsScalars.push(model.cutScalars[pointIndex]);\n      } // Check if all cell points are on same side (same side == cell not crossed by cut function)\n      // TODO: won't work if one point scalar is = 0 ?\n\n\n      var sideFirstPoint = cellPointsScalars[0] > 0;\n      var allPointsSameSide = true;\n\n      for (var _i = 1; _i < cellPointsScalars.length; _i++) {\n        var sideCurrentPoint = cellPointsScalars[_i] > 0;\n\n        if (sideCurrentPoint !== sideFirstPoint) {\n          allPointsSameSide = false;\n          break;\n        }\n      } // Go to next cell if cell is not crossed by cut function\n\n\n      if (allPointsSameSide) {\n        continue;\n      } // Find and compute edges which intersect cells\n\n\n      var intersectedEdgesList = [];\n\n      for (var _i2 = 0; _i2 < cell.length; _i2++) {\n        var idNext = _i2 + 1 === cell.length ? 0 : _i2 + 1; // Go to next edge if edge is not crossed\n        // TODO: in most come cases, (numberOfPointsInCell - 1) or 0 edges of the cell\n        // will be crossed, but if it crosses right at a point, it could be intersecting\n        // with (numberOfPoints) or 1 edge(s). Do we account for that?\n\n        var signPoint0 = cellPointsScalars[_i2] > 0;\n        var signPoint1 = cellPointsScalars[idNext] > 0;\n\n        if (signPoint1 === signPoint0) {\n          continue;\n        } // Compute preferred interpolation direction\n\n\n        var e1 = _i2;\n        var e2 = idNext;\n        var deltaScalar = cellPointsScalars[e2] - cellPointsScalars[e1];\n\n        if (deltaScalar <= 0) {\n          e1 = idNext;\n          e2 = _i2;\n          deltaScalar *= -1;\n        } // linear interpolation\n\n\n        var t = 0.0;\n\n        if (deltaScalar !== 0.0) {\n          t = (model.cutValue - cellPointsScalars[e1]) / deltaScalar;\n        } // points position\n\n\n        var pointID1 = cell[e1];\n        var pointID2 = cell[e2];\n        x1[0] = pointsData[pointID1 * 3];\n        x1[1] = pointsData[pointID1 * 3 + 1];\n        x1[2] = pointsData[pointID1 * 3 + 2];\n        x2[0] = pointsData[pointID2 * 3];\n        x2[1] = pointsData[pointID2 * 3 + 1];\n        x2[2] = pointsData[pointID2 * 3 + 2]; // Compute the intersected point on edge\n\n        var computedIntersectedPoint = [x1[0] + t * (x2[0] - x1[0]), x1[1] + t * (x2[1] - x1[1]), x1[2] + t * (x2[2] - x1[2])]; // Keep track of it\n\n        intersectedEdgesList.push({\n          pointEdge1: pointID1,\n          // id of one point of the edge\n          pointEdge2: pointID2,\n          // id of one point of the edge\n          intersectedPoint: computedIntersectedPoint,\n          // 3D coordinate of points that intersected edge\n          newPointID: -1 // id of the intersected point when it will be added into vtkPoints\n\n        });\n      } // Add points into newPointList\n\n\n      for (var _i3 = 0; _i3 < intersectedEdgesList.length; _i3++) {\n        var intersectedEdge = intersectedEdgesList[_i3];\n        var alreadyAdded = false; // Check if point/edge already added\n\n        for (var j = 0; j < crossedEdges.length; j++) {\n          var crossedEdge = crossedEdges[j];\n          var sameEdge = intersectedEdge.pointEdge1 === crossedEdge.pointEdge1 && intersectedEdge.pointEdge2 === crossedEdge.pointEdge2;\n          var samePoint = intersectedEdge.intersectedPoint[0] === crossedEdge.intersectedPoint[0] && intersectedEdge.intersectedPoint[1] === crossedEdge.intersectedPoint[1] && intersectedEdge.intersectedPoint[2] === crossedEdge.intersectedPoint[2];\n\n          if (sameEdge || samePoint) {\n            alreadyAdded = true;\n            intersectedEdgesList[_i3].newPointID = crossedEdges[j].newPointID;\n            break;\n          }\n        }\n\n        if (!alreadyAdded) {\n          newPointsData.push(intersectedEdge.intersectedPoint[0]);\n          newPointsData.push(intersectedEdge.intersectedPoint[1]);\n          newPointsData.push(intersectedEdge.intersectedPoint[2]);\n          intersectedEdgesList[_i3].newPointID = newPointsData.length / 3 - 1;\n          crossedEdges.push(intersectedEdgesList[_i3]);\n        }\n      } // Store cells\n\n\n      var cellSize = intersectedEdgesList.length;\n\n      if (cellSize === 2) {\n        newLinesData.push(cellSize, intersectedEdgesList[0].newPointID, intersectedEdgesList[1].newPointID);\n      } else if (cellSize > 2) {\n        newPolysData.push(cellSize);\n        intersectedEdgesList.forEach(function (edge) {\n          newPolysData.push(edge.newPointID);\n        });\n      }\n    } // Set points\n\n\n    var outputPoints = output.getPoints();\n    outputPoints.setData(newTypedArrayFrom(points.getDataType(), newPointsData), 3); // Set lines\n\n    if (newLinesData.length !== 0) {\n      output.getLines().setData(Uint16Array.from(newLinesData));\n    } // Set polys\n\n\n    if (newPolysData.length !== 0) {\n      output.getPolys().setData(Uint16Array.from(newPolysData));\n    }\n  } // expose requestData\n\n\n  publicAPI.requestData = function (inData, outData) {\n    // implement requestData\n    var input = inData[0];\n\n    if (!input) {\n      vtkErrorMacro('Invalid or missing input');\n      return;\n    }\n\n    if (!model.cutFunction) {\n      vtkErrorMacro('Missing cut function');\n      return;\n    }\n\n    var output = vtkPolyData.newInstance();\n    dataSetCutter(input, output);\n    outData[0] = output;\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\n\nvar DEFAULT_VALUES = {\n  cutFunction: null,\n  // support method with evaluateFunction method\n  cutScalars: null,\n  cutValue: 0.0\n}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Make this a VTK object\n\n  obj(publicAPI, model); // Also make it an algorithm with one input and one output\n\n  algo(publicAPI, model, 1, 1); // Set implicit function use to cut the input data (is vtkPlane)\n\n  setGet(publicAPI, model, ['cutFunction', 'cutValue']); // Object specific methods\n\n  vtkCutter(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = newInstance$1(extend, 'vtkCutter'); // ----------------------------------------------------------------------------\n\nvar vtkCutter$1 = {\n  newInstance: newInstance,\n  extend: extend\n};\n\nexport { vtkCutter$1 as default, extend, newInstance };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}