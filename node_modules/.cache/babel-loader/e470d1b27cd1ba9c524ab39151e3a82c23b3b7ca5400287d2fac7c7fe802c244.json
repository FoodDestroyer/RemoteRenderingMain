{"ast":null,"code":"import _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport { mat4, vec4 } from 'gl-matrix';\nimport macro, { vtkWarningMacro } from '../../macros.js';\nimport vtkDataArray from '../../Common/Core/DataArray.js';\nimport { f as vtkMath } from '../../Common/Core/Math/index.js';\nimport vtkMatrixBuilder from '../../Common/Core/MatrixBuilder.js';\nimport { VtkDataTypes } from '../../Common/Core/DataArray/Constants.js';\nimport vtkBoundingBox from '../../Common/DataModel/BoundingBox.js';\nimport vtkImageData from '../../Common/DataModel/ImageData.js';\nimport vtkImageInterpolator from './ImageInterpolator.js';\nimport vtkImagePointDataIterator from './ImagePointDataIterator.js';\nimport { InterpolationMode, ImageBorderMode } from './AbstractImageInterpolator/Constants.js';\nimport { vtkInterpolationMathRound, vtkInterpolationMathClamp, vtkInterpolationMathFloor } from './AbstractImageInterpolator/InterpolationInfo.js';\nimport Constants from './ImageReslice/Constants.js';\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n  return target;\n}\nvar SlabMode = Constants.SlabMode;\nvar vtkErrorMacro = macro.vtkErrorMacro; // ----------------------------------------------------------------------------\n// vtkImageReslice methods\n// ----------------------------------------------------------------------------\n\nfunction vtkImageReslice(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkImageReslice');\n  var superClass = _objectSpread({}, publicAPI);\n  var indexMatrix = null;\n  var optimizedTransform = null;\n  function getImageResliceSlabTrap(tmpPtr, inComponents, sampleCount, f) {\n    var n = sampleCount - 1;\n    for (var i = 0; i < inComponents; i += 1) {\n      var result = tmpPtr[i] * 0.5;\n      for (var j = 1; j < n; j += 1) {\n        result += tmpPtr[i + j * inComponents];\n      }\n      result += tmpPtr[i + n * inComponents] * 0.5;\n      tmpPtr[i] = result * f;\n    }\n  }\n  function getImageResliceSlabSum(tmpPtr, inComponents, sampleCount, f) {\n    for (var i = 0; i < inComponents; i += 1) {\n      var result = tmpPtr[i];\n      for (var j = 1; j < sampleCount; j += 1) {\n        result += tmpPtr[i + j * inComponents];\n      }\n      tmpPtr[i] = result * f;\n    }\n  }\n  function getImageResliceCompositeMinValue(tmpPtr, inComponents, sampleCount) {\n    for (var i = 0; i < inComponents; i += 1) {\n      var result = tmpPtr[i];\n      for (var j = 1; j < sampleCount; j += 1) {\n        result = Math.min(result, tmpPtr[i + j * inComponents]);\n      }\n      tmpPtr[i] = result;\n    }\n  }\n  function getImageResliceCompositeMaxValue(tmpPtr, inComponents, sampleCount) {\n    for (var i = 0; i < inComponents; i += 1) {\n      var result = tmpPtr[i];\n      for (var j = 1; j < sampleCount; j += 1) {\n        result = Math.max(result, tmpPtr[i + j * inComponents]);\n      }\n      tmpPtr[i] = result;\n    }\n  }\n  function getImageResliceCompositeMeanValue(tmpPtr, inComponents, sampleCount) {\n    var f = 1.0 / sampleCount;\n    getImageResliceSlabSum(tmpPtr, inComponents, sampleCount, f);\n  }\n  function getImageResliceCompositeMeanTrap(tmpPtr, inComponents, sampleCount) {\n    var f = 1.0 / (sampleCount - 1);\n    getImageResliceSlabTrap(tmpPtr, inComponents, sampleCount, f);\n  }\n  function getImageResliceCompositeSumValue(tmpPtr, inComponents, sampleCount) {\n    var f = 1.0;\n    getImageResliceSlabSum(tmpPtr, inComponents, sampleCount, f);\n  }\n  function getImageResliceCompositeSumTrap(tmpPtr, inComponents, sampleCount) {\n    var f = 1.0;\n    getImageResliceSlabTrap(tmpPtr, inComponents, sampleCount, f);\n  }\n  publicAPI.getMTime = function () {\n    var mTime = superClass.getMTime();\n    if (model.resliceTransform) {\n      mTime = Math.max(mTime, model.resliceTransform.getMTime());\n    }\n    return mTime;\n  };\n  publicAPI.setResliceAxes = function (resliceAxes) {\n    if (!model.resliceAxes) {\n      model.resliceAxes = mat4.identity(new Float64Array(16));\n    }\n    if (!mat4.exactEquals(model.resliceAxes, resliceAxes)) {\n      mat4.copy(model.resliceAxes, resliceAxes);\n      publicAPI.modified();\n      return true;\n    }\n    return null;\n  };\n  publicAPI.requestData = function (inData, outData) {\n    // implement requestData\n    var input = inData[0];\n    if (!input) {\n      vtkErrorMacro('Invalid or missing input');\n      return;\n    } // console.time('reslice');\n    // Retrieve output and volume data\n\n    var origin = input.getOrigin();\n    var inSpacing = input.getSpacing();\n    var dims = input.getDimensions();\n    var inScalars = input.getPointData().getScalars();\n    var inWholeExt = [0, dims[0] - 1, 0, dims[1] - 1, 0, dims[2] - 1];\n    var outOrigin = [0, 0, 0];\n    var outSpacing = [1, 1, 1];\n    var outWholeExt = [0, 0, 0, 0, 0, 0];\n    var outDims = [0, 0, 0];\n    var matrix = mat4.identity(new Float64Array(16));\n    if (model.resliceAxes) {\n      mat4.multiply(matrix, matrix, model.resliceAxes);\n    }\n    var imatrix = new Float64Array(16);\n    mat4.invert(imatrix, matrix);\n    var inCenter = [origin[0] + 0.5 * (inWholeExt[0] + inWholeExt[1]) * inSpacing[0], origin[1] + 0.5 * (inWholeExt[2] + inWholeExt[3]) * inSpacing[1], origin[2] + 0.5 * (inWholeExt[4] + inWholeExt[5]) * inSpacing[2]];\n    var maxBounds = null;\n    if (model.autoCropOutput) {\n      maxBounds = publicAPI.getAutoCroppedOutputBounds(input);\n    }\n    for (var i = 0; i < 3; i++) {\n      var s = 0; // default output spacing\n\n      var d = 0; // default linear dimension\n\n      var e = 0; // default extent start\n\n      var c = 0; // transformed center-of-volume\n\n      if (model.transformInputSampling) {\n        var r = 0.0;\n        for (var j = 0; j < 3; j++) {\n          c += imatrix[4 * j + i] * (inCenter[j] - matrix[4 * 3 + j]);\n          var tmp = matrix[4 * i + j] * matrix[4 * i + j];\n          s += tmp * Math.abs(inSpacing[j]);\n          d += tmp * (inWholeExt[2 * j + 1] - inWholeExt[2 * j]) * Math.abs(inSpacing[j]);\n          e += tmp * inWholeExt[2 * j];\n          r += tmp;\n        }\n        s /= r;\n        d /= r * Math.sqrt(r);\n        e /= r;\n      } else {\n        c = inCenter[i];\n        s = inSpacing[i];\n        d = (inWholeExt[2 * i + 1] - inWholeExt[2 * i]) * s;\n        e = inWholeExt[2 * i];\n      }\n      if (model.outputSpacing == null) {\n        outSpacing[i] = s;\n      } else {\n        outSpacing[i] = model.outputSpacing[i];\n      }\n      if (i >= model.outputDimensionality) {\n        outWholeExt[2 * i] = 0;\n        outWholeExt[2 * i + 1] = 0;\n      } else if (model.outputExtent == null) {\n        if (model.autoCropOutput) {\n          d = maxBounds[2 * i + 1] - maxBounds[2 * i];\n        }\n        outWholeExt[2 * i] = Math.round(e);\n        outWholeExt[2 * i + 1] = Math.round(outWholeExt[2 * i] + Math.abs(d / outSpacing[i]));\n      } else {\n        outWholeExt[2 * i] = model.outputExtent[2 * i];\n        outWholeExt[2 * i + 1] = model.outputExtent[2 * i + 1];\n      }\n      if (i >= model.outputDimensionality) {\n        outOrigin[i] = 0;\n      } else if (model.outputOrigin == null) {\n        if (model.autoCropOutput) {\n          // set origin so edge of extent is edge of bounds\n          outOrigin[i] = maxBounds[2 * i] - outWholeExt[2 * i] * outSpacing[i];\n        } else {\n          // center new bounds over center of input bounds\n          outOrigin[i] = c - 0.5 * (outWholeExt[2 * i] + outWholeExt[2 * i + 1]) * outSpacing[i];\n        }\n      } else {\n        outOrigin[i] = model.outputOrigin[i];\n      }\n      outDims[i] = outWholeExt[2 * i + 1] - outWholeExt[2 * i] + 1;\n    }\n    var dataType = inScalars.getDataType();\n    if (model.outputScalarType) {\n      dataType = model.outputScalarType;\n    }\n    var numComponents = input.getPointData().getScalars().getNumberOfComponents(); // or s.numberOfComponents;\n\n    var outScalarsData = macro.newTypedArray(dataType, outDims[0] * outDims[1] * outDims[2] * numComponents);\n    var outScalars = vtkDataArray.newInstance({\n      name: 'Scalars',\n      values: outScalarsData,\n      numberOfComponents: numComponents\n    }); // Update output\n\n    var output = vtkImageData.newInstance();\n    output.setDimensions(outDims);\n    output.setOrigin(outOrigin);\n    output.setSpacing(outSpacing);\n    if (model.outputDirection) {\n      output.setDirection(model.outputDirection);\n    }\n    output.getPointData().setScalars(outScalars);\n    publicAPI.getIndexMatrix(input, output);\n    var interpolationMode = model.interpolationMode;\n    model.usePermuteExecute = false;\n    if (model.optimization) {\n      if (model.slabSliceSpacingFraction === 1.0 && model.interpolator.isSeparable() && publicAPI.isPermutationMatrix(indexMatrix)) {\n        model.usePermuteExecute = true;\n        if (publicAPI.canUseNearestNeighbor(indexMatrix, outWholeExt)) {\n          interpolationMode = InterpolationMode.NEAREST;\n        }\n      }\n    }\n    model.interpolator.setInterpolationMode(interpolationMode);\n    var borderMode = ImageBorderMode.CLAMP;\n    borderMode = model.wrap ? ImageBorderMode.REPEAT : borderMode;\n    borderMode = model.mirror ? ImageBorderMode.MIRROR : borderMode;\n    model.interpolator.setBorderMode(borderMode);\n    var mintol = 7.62939453125e-6;\n    var maxtol = 2.0 * 2147483647;\n    var tol = 0.5 * model.border;\n    tol = borderMode === ImageBorderMode.CLAMP ? tol : maxtol;\n    tol = tol > mintol ? tol : mintol;\n    model.interpolator.setTolerance(tol);\n    model.interpolator.initialize(input);\n    publicAPI.vtkImageResliceExecute(input, output);\n    model.interpolator.releaseData();\n    outData[0] = output; // console.timeEnd('reslice');\n  };\n\n  publicAPI.vtkImageResliceExecute = function (input, output) {\n    // const outDims = output.getDimensions();\n    var inScalars = input.getPointData().getScalars();\n    var outScalars = output.getPointData().getScalars();\n    var outPtr = outScalars.getData();\n    var outExt = output.getExtent();\n    var newmat = indexMatrix;\n    var nsamples = Math.max(model.slabNumberOfSlices, 1); // spacing between slab samples (as a fraction of slice spacing).\n\n    var slabSampleSpacing = model.slabSliceSpacingFraction; // check for perspective transformation\n\n    var perspective = publicAPI.isPerspectiveMatrix(newmat); // extra scalar info for nearest-neighbor optimization\n\n    var inPtr = inScalars.getData();\n    var inputScalarSize = 1; // inScalars.getElementComponentSize(); // inScalars.getDataTypeSize();\n\n    var inputScalarType = inScalars.getDataType();\n    var inComponents = inScalars.getNumberOfComponents(); // interpolator.GetNumberOfComponents();\n\n    var componentOffset = model.interpolator.getComponentOffset();\n    var borderMode = model.interpolator.getBorderMode();\n    var inDims = input.getDimensions();\n    var inExt = [0, inDims[0] - 1, 0, inDims[1] - 1, 0, inDims[2] - 1]; // interpolator->GetExtent();\n\n    var inInc = [0, 0, 0];\n    inInc[0] = inScalars.getNumberOfComponents();\n    inInc[1] = inInc[0] * inDims[0];\n    inInc[2] = inInc[1] * inDims[1];\n    var fullSize = inDims[0] * inDims[1] * inDims[2];\n    if (componentOffset > 0 && componentOffset + inComponents < inInc[0]) {\n      inPtr = inPtr.subarray(inputScalarSize * componentOffset);\n    }\n    var interpolationMode = InterpolationMode.NEAREST;\n    if (model.interpolator.isA('vtkImageInterpolator')) {\n      interpolationMode = model.interpolator.getInterpolationMode();\n    }\n    var convertScalars = null;\n    var rescaleScalars = model.scalarShift !== 0.0 || model.scalarScale !== 1.0; // is nearest neighbor optimization possible?\n\n    var optimizeNearest = interpolationMode === InterpolationMode.NEAREST && borderMode === ImageBorderMode.CLAMP && !(perspective || convertScalars != null || rescaleScalars) && inputScalarType === outScalars.getDataType() && fullSize === inScalars.getNumberOfTuples() && model.border === true && nsamples <= 1; // get pixel information\n\n    var scalarType = outScalars.getDataType();\n    var scalarSize = 1; // outScalars.getElementComponentSize() // outScalars.scalarSize;\n\n    var outComponents = outScalars.getNumberOfComponents(); // break matrix into a set of axes plus an origin\n    // (this allows us to calculate the transform Incrementally)\n\n    var xAxis = [0, 0, 0, 0];\n    var yAxis = [0, 0, 0, 0];\n    var zAxis = [0, 0, 0, 0];\n    var origin = [0, 0, 0, 0];\n    for (var i = 0; i < 4; ++i) {\n      xAxis[i] = newmat[4 * 0 + i];\n      yAxis[i] = newmat[4 * 1 + i];\n      zAxis[i] = newmat[4 * 2 + i];\n      origin[i] = newmat[4 * 3 + i];\n    } // get the input origin and spacing for conversion purposes\n\n    model.interpolator.getOrigin();\n    var inSpacing = model.interpolator.getSpacing();\n    [1.0 / inSpacing[0], 1.0 / inSpacing[1], 1.0 / inSpacing[2]]; // allocate an output row of type double\n\n    var floatPtr = null;\n    if (!optimizeNearest) {\n      floatPtr = new Float64Array(inComponents * (outExt[1] - outExt[0] + nsamples));\n    }\n    var background = macro.newTypedArray(inputScalarType, model.backgroundColor); // set color for area outside of input volume extent\n    // void *background;\n    // vtkAllocBackgroundPixel(&background,\n    //    self->GetBackgroundColor(), scalarType, scalarSize, outComponents);\n    // get various helper functions\n\n    var forceClamping = interpolationMode > InterpolationMode.LINEAR || nsamples > 1 && model.slabMode === SlabMode.SUM;\n    var convertpixels = publicAPI.getConversionFunc(inputScalarType, scalarType, model.scalarShift, model.scalarScale, forceClamping);\n    var setpixels = publicAPI.getSetPixelsFunc(scalarType, scalarSize, outComponents, outPtr);\n    var composite = publicAPI.getCompositeFunc(model.slabMode, model.slabTrapezoidIntegration); // create some variables for when we march through the data\n\n    var idY = outExt[2] - 1;\n    var idZ = outExt[4] - 1;\n    var inPoint0 = [0.0, 0.0, 0.0, 0.0];\n    var inPoint1 = [0.0, 0.0, 0.0, 0.0]; // create an iterator to march through the data\n\n    var iter = vtkImagePointDataIterator.newInstance();\n    iter.initialize(output, outExt, model.stencil, null);\n    var outPtr0 = iter.getScalars(output, 0);\n    var outPtrIndex = 0;\n    var outTmp = macro.newTypedArray(scalarType, vtkBoundingBox.getDiagonalLength(outExt) * outComponents * 2);\n    var interpolatedPtr = new Float64Array(inComponents * nsamples);\n    var interpolatedPoint = new Float64Array(inComponents);\n    for (; !iter.isAtEnd(); iter.nextSpan()) {\n      var span = iter.spanEndId() - iter.getId();\n      outPtrIndex = iter.getId() * scalarSize * outComponents;\n      if (!iter.isInStencil()) {\n        // clear any regions that are outside the stencil\n        var n = setpixels(outTmp, background, outComponents, span);\n        for (var _i = 0; _i < n; ++_i) {\n          outPtr0[outPtrIndex++] = outTmp[_i];\n        }\n      } else {\n        // get output index, and compute position in input image\n        var outIndex = iter.getIndex(); // if Z index increased, then advance position along Z axis\n\n        if (outIndex[2] > idZ) {\n          idZ = outIndex[2];\n          inPoint0[0] = origin[0] + idZ * zAxis[0];\n          inPoint0[1] = origin[1] + idZ * zAxis[1];\n          inPoint0[2] = origin[2] + idZ * zAxis[2];\n          inPoint0[3] = origin[3] + idZ * zAxis[3];\n          idY = outExt[2] - 1;\n        } // if Y index increased, then advance position along Y axis\n\n        if (outIndex[1] > idY) {\n          idY = outIndex[1];\n          inPoint1[0] = inPoint0[0] + idY * yAxis[0];\n          inPoint1[1] = inPoint0[1] + idY * yAxis[1];\n          inPoint1[2] = inPoint0[2] + idY * yAxis[2];\n          inPoint1[3] = inPoint0[3] + idY * yAxis[3];\n        } // march through one row of the output image\n\n        var idXmin = outIndex[0];\n        var idXmax = idXmin + span - 1;\n        if (!optimizeNearest) {\n          var wasInBounds = 1;\n          var isInBounds = 1;\n          var startIdX = idXmin;\n          var idX = idXmin;\n          var tmpPtr = floatPtr;\n          var pixelIndex = 0;\n          while (startIdX <= idXmax) {\n            for (; idX <= idXmax && isInBounds === wasInBounds; idX++) {\n              var inPoint2 = [inPoint1[0] + idX * xAxis[0], inPoint1[1] + idX * xAxis[1], inPoint1[2] + idX * xAxis[2], inPoint1[3] + idX * xAxis[3]];\n              var inPoint3 = [0, 0, 0, 0];\n              var inPoint = inPoint2;\n              isInBounds = false;\n              var interpolatedPtrIndex = 0;\n              for (var sample = 0; sample < nsamples; ++sample) {\n                if (nsamples > 1) {\n                  var s = sample - 0.5 * (nsamples - 1);\n                  s *= slabSampleSpacing;\n                  inPoint3[0] = inPoint2[0] + s * zAxis[0];\n                  inPoint3[1] = inPoint2[1] + s * zAxis[1];\n                  inPoint3[2] = inPoint2[2] + s * zAxis[2];\n                  inPoint3[3] = inPoint2[3] + s * zAxis[3];\n                  inPoint = inPoint3;\n                }\n                if (perspective) {\n                  // only do perspective if necessary\n                  var f = 1 / inPoint[3];\n                  inPoint[0] *= f;\n                  inPoint[1] *= f;\n                  inPoint[2] *= f;\n                }\n                if (model.interpolator.checkBoundsIJK(inPoint)) {\n                  // do the interpolation\n                  isInBounds = 1;\n                  model.interpolator.interpolateIJK(inPoint, interpolatedPoint);\n                  for (var _i2 = 0; _i2 < inComponents; ++_i2) {\n                    interpolatedPtr[interpolatedPtrIndex++] = interpolatedPoint[_i2];\n                  }\n                }\n              }\n              if (interpolatedPtrIndex > inComponents) {\n                composite(interpolatedPtr, inComponents, interpolatedPtrIndex / inComponents);\n              }\n              for (var _i3 = 0; _i3 < inComponents; ++_i3) {\n                tmpPtr[pixelIndex++] = interpolatedPtr[_i3];\n              } // set \"was in\" to \"is in\" if first pixel\n\n              wasInBounds = idX > idXmin ? wasInBounds : isInBounds;\n            } // write a segment to the output\n\n            var endIdX = idX - 1 - (isInBounds !== wasInBounds);\n            var numpixels = endIdX - startIdX + 1;\n            var _n = 0;\n            if (wasInBounds) {\n              if (rescaleScalars) {\n                publicAPI.rescaleScalars(floatPtr, inComponents, idXmax - idXmin + 1, model.scalarShift, model.scalarScale);\n              }\n              {\n                _n = convertpixels(outTmp, floatPtr.subarray(startIdX * inComponents), outComponents, numpixels);\n              }\n            } else {\n              _n = setpixels(outTmp, background, outComponents, numpixels);\n            }\n            for (var _i4 = 0; _i4 < _n; ++_i4) {\n              outPtr0[outPtrIndex++] = outTmp[_i4];\n            }\n            startIdX += numpixels;\n            wasInBounds = isInBounds;\n          }\n        } else {\n          // optimize for nearest-neighbor interpolation\n          var inPtrTmp0 = inPtr;\n          var outPtrTmp = outPtr;\n          var inIncX = inInc[0] * inputScalarSize;\n          var inIncY = inInc[1] * inputScalarSize;\n          var inIncZ = inInc[2] * inputScalarSize;\n          var inExtX = inExt[1] - inExt[0] + 1;\n          var inExtY = inExt[3] - inExt[2] + 1;\n          var inExtZ = inExt[5] - inExt[4] + 1;\n          var _startIdX = idXmin;\n          var _endIdX = idXmin - 1;\n          var _isInBounds = false;\n          var bytesPerPixel = inputScalarSize * inComponents;\n          for (var iidX = idXmin; iidX <= idXmax; iidX++) {\n            var _inPoint = [inPoint1[0] + iidX * xAxis[0], inPoint1[1] + iidX * xAxis[1], inPoint1[2] + iidX * xAxis[2]];\n            var inIdX = vtkInterpolationMathRound(_inPoint[0]) - inExt[0];\n            var inIdY = vtkInterpolationMathRound(_inPoint[1]) - inExt[2];\n            var inIdZ = vtkInterpolationMathRound(_inPoint[2]) - inExt[4];\n            if (inIdX >= 0 && inIdX < inExtX && inIdY >= 0 && inIdY < inExtY && inIdZ >= 0 && inIdZ < inExtZ) {\n              if (!_isInBounds) {\n                // clear leading out-of-bounds pixels\n                _startIdX = iidX;\n                _isInBounds = true;\n                var _n3 = setpixels(outTmp, background, outComponents, _startIdX - idXmin);\n                for (var _i5 = 0; _i5 < _n3; ++_i5) {\n                  outPtr0[outPtrIndex++] = outTmp[_i5];\n                }\n              } // set the final index that was within input bounds\n\n              _endIdX = iidX; // perform nearest-neighbor interpolation via pixel copy\n\n              var offset = inIdX * inIncX + inIdY * inIncY + inIdZ * inIncZ; // when memcpy is used with a constant size, the compiler will\n              // optimize away the function call and use the minimum number\n              // of instructions necessary to perform the copy\n\n              switch (bytesPerPixel) {\n                case 1:\n                  outPtr0[outPtrIndex++] = inPtrTmp0[offset];\n                  break;\n                case 2:\n                case 3:\n                case 4:\n                case 8:\n                case 12:\n                case 16:\n                  for (var _i6 = 0; _i6 < bytesPerPixel; ++_i6) {\n                    outPtr0[outPtrIndex++] = inPtrTmp0[offset + _i6];\n                  }\n                  break;\n                default:\n                  {\n                    // TODO: check bytes\n                    var oc = 0;\n                    do {\n                      outPtr0[outPtrIndex++] = inPtrTmp0[offset++];\n                    } while (++oc !== bytesPerPixel);\n                    break;\n                  }\n              }\n            } else if (_isInBounds) {\n              // leaving input bounds\n              break;\n            }\n          } // clear trailing out-of-bounds pixels\n\n          outPtr = outPtrTmp;\n          var _n2 = setpixels(outTmp, background, outComponents, idXmax - _endIdX);\n          for (var _i7 = 0; _i7 < _n2; ++_i7) {\n            outPtr0[outPtrIndex++] = outTmp[_i7];\n          }\n        }\n      }\n    }\n  };\n  /**\n   * The transform matrix supplied by the user converts output coordinates\n   * to input coordinates.\n   * To speed up the pixel lookup, the following function provides a\n   * matrix which converts output pixel indices to input pixel indices.\n   * This will also concatenate the ResliceAxes and the ResliceTransform\n   * if possible (if the ResliceTransform is a 4x4 matrix transform).\n   * If it does, this->OptimizedTransform will be set to nullptr, otherwise\n   * this->OptimizedTransform will be equal to this->ResliceTransform.\n   * @param {vtkPolyData} input\n   * @param {vtkPolyData} output\n   * @returns\n   */\n\n  publicAPI.getIndexMatrix = function (input, output) {\n    // first verify that we have to update the matrix\n    if (indexMatrix === null) {\n      indexMatrix = mat4.identity(new Float64Array(16));\n    }\n    var inOrigin = input.getOrigin();\n    var inSpacing = input.getSpacing();\n    var inDirection = input.getDirection();\n    var outOrigin = output.getOrigin();\n    var outSpacing = output.getSpacing();\n    var transform = mat4.identity(new Float64Array(16));\n    var inMatrix = mat4.identity(new Float64Array(16));\n    var outMatrix = mat4.identity(new Float64Array(16));\n    if (model.resliceAxes) {\n      mat4.copy(transform, model.resliceAxes);\n    }\n    if (model.resliceTransform) {\n      if (model.resliceTransform.isA('vtkHomogeneousTransform')) {\n        // transform->PostMultiply();\n        // transform->Concatenate(\n        // mat4.multiply(transform, transform, model.resliceTransform.getMatrix());\n        mat4.multiply(transform, model.resliceTransform.getMatrix(), transform);\n      } else {\n        // TODO\n        vtkWarningMacro('Non homogeneous transform have not yet been ported');\n      }\n    }\n    if (!vtkMath.isIdentity3x3(inDirection)) {\n      var imageTransform = vtkMatrixBuilder.buildFromRadian().translate(inOrigin[0], inOrigin[1], inOrigin[2]).multiply3x3(inDirection).translate(-inOrigin[0], -inOrigin[1], -inOrigin[2]);\n      mat4.multiply(transform, imageTransform.getMatrix(), transform);\n    } // check to see if we have an identity matrix\n\n    var isIdentity = vtkMath.isIdentity(transform); // the outMatrix takes OutputData indices to OutputData coordinates,\n    // the inMatrix takes InputData coordinates to InputData indices\n\n    for (var i = 0; i < 3; i++) {\n      if (inSpacing[i] !== outSpacing[i] || inOrigin[i] !== outOrigin[i] || optimizedTransform != null) {\n        isIdentity = false;\n      }\n      inMatrix[4 * i + i] = 1.0 / inSpacing[i];\n      inMatrix[4 * 3 + i] = -inOrigin[i] / inSpacing[i];\n      outMatrix[4 * i + i] = outSpacing[i];\n      outMatrix[4 * 3 + i] = outOrigin[i];\n    }\n    if (!isIdentity) {\n      // transform.PreMultiply();\n      // transform.Concatenate(outMatrix);\n      mat4.multiply(transform, transform, outMatrix); // the optimizedTransform requires data coords, not\n      // index coords, as its input\n\n      {\n        // transform->PostMultiply();\n        // transform->Concatenate(inMatrix);\n        mat4.multiply(transform, inMatrix, transform);\n      }\n    }\n    mat4.copy(indexMatrix, transform);\n    return indexMatrix;\n  };\n  publicAPI.getAutoCroppedOutputBounds = function (input) {\n    var inOrigin = input.getOrigin();\n    var inSpacing = input.getSpacing();\n    var inDirection = input.getDirection();\n    var dims = input.getDimensions();\n    var inWholeExt = [0, dims[0] - 1, 0, dims[1] - 1, 0, dims[2] - 1];\n    var matrix = new Float64Array(16);\n    if (model.resliceAxes) {\n      mat4.invert(matrix, model.resliceAxes);\n    } else {\n      mat4.identity(matrix);\n    }\n    var transform = null;\n    if (model.resliceTransform) {\n      transform = model.resliceTransform.getInverse();\n    }\n    var imageTransform = null;\n    if (!vtkMath.isIdentity3x3(inDirection)) {\n      imageTransform = vtkMatrixBuilder.buildFromRadian().translate(inOrigin[0], inOrigin[1], inOrigin[2]).multiply3x3(inDirection).translate(-inOrigin[0], -inOrigin[1], -inOrigin[2]).invert().getMatrix();\n    }\n    var bounds = [Number.MAX_VALUE, -Number.MAX_VALUE, Number.MAX_VALUE, -Number.MAX_VALUE, Number.MAX_VALUE, -Number.MAX_VALUE];\n    var point = [0, 0, 0, 0];\n    for (var i = 0; i < 8; ++i) {\n      point[0] = inOrigin[0] + inWholeExt[i % 2] * inSpacing[0];\n      point[1] = inOrigin[1] + inWholeExt[2 + Math.floor(i / 2) % 2] * inSpacing[1];\n      point[2] = inOrigin[2] + inWholeExt[4 + Math.floor(i / 4) % 2] * inSpacing[2];\n      point[3] = 1.0;\n      if (imageTransform) {\n        vec4.transformMat4(point, point, imageTransform);\n      }\n      if (model.resliceTransform) {\n        transform.transformPoint(point, point);\n      }\n      vec4.transformMat4(point, point, matrix);\n      var f = 1.0 / point[3];\n      point[0] *= f;\n      point[1] *= f;\n      point[2] *= f;\n      for (var j = 0; j < 3; ++j) {\n        if (point[j] > bounds[2 * j + 1]) {\n          bounds[2 * j + 1] = point[j];\n        }\n        if (point[j] < bounds[2 * j]) {\n          bounds[2 * j] = point[j];\n        }\n      }\n    }\n    return bounds;\n  };\n  publicAPI.getDataTypeMinMax = function (dataType) {\n    switch (dataType) {\n      case 'Int8Array':\n        return {\n          min: -128,\n          max: 127\n        };\n      case 'Int16Array':\n        return {\n          min: -32768,\n          max: 32767\n        };\n      case 'Uint16Array':\n        return {\n          min: 0,\n          max: 65535\n        };\n      case 'Int32Array':\n        return {\n          min: -2147483648,\n          max: 2147483647\n        };\n      case 'Uint32Array':\n        return {\n          min: 0,\n          max: 4294967295\n        };\n      case 'Float32Array':\n        return {\n          min: -1.2e38,\n          max: 1.2e38\n        };\n      case 'Float64Array':\n        return {\n          min: -1.2e38,\n          max: 1.2e38\n        };\n      case 'Uint8Array':\n      case 'Uint8ClampedArray':\n      default:\n        return {\n          min: 0,\n          max: 255\n        };\n    }\n  };\n  publicAPI.clamp = function (outPtr, inPtr, numscalars, n, min, max) {\n    var count = n * numscalars;\n    for (var i = 0; i < count; ++i) {\n      outPtr[i] = vtkInterpolationMathClamp(inPtr[i], min, max);\n    }\n    return count;\n  };\n  publicAPI.convert = function (outPtr, inPtr, numscalars, n) {\n    var count = n * numscalars;\n    for (var i = 0; i < count; ++i) {\n      outPtr[i] = Math.round(inPtr[i]);\n    }\n    return count;\n  };\n  publicAPI.getConversionFunc = function (inputType, dataType, scalarShift, scalarScale, forceClamping) {\n    var useClamping = forceClamping;\n    if (dataType !== VtkDataTypes.FLOAT && dataType !== VtkDataTypes.DOUBLE && !forceClamping) {\n      var inMinMax = publicAPI.getDataTypeMinMax(inputType);\n      var checkMin = (inMinMax.min + scalarShift) * scalarScale;\n      var checkMax = (inMinMax.max + scalarShift) * scalarScale;\n      var outMinMax = publicAPI.getDataTypeMinMax(dataType);\n      var outputMin = outMinMax.min;\n      var outputMax = outMinMax.max;\n      if (checkMin > checkMax) {\n        var tmp = checkMax;\n        checkMax = checkMin;\n        checkMin = tmp;\n      }\n      useClamping = checkMin < outputMin || checkMax > outputMax;\n    }\n    if (useClamping && dataType !== VtkDataTypes.FLOAT && dataType !== VtkDataTypes.DOUBLE) {\n      var minMax = publicAPI.getDataTypeMinMax(dataType);\n      var clamp = function clamp(outPtr, inPtr, numscalars, n) {\n        return publicAPI.clamp(outPtr, inPtr, numscalars, n, minMax.min, minMax.max);\n      };\n      return clamp;\n    }\n    return publicAPI.convert;\n  };\n  publicAPI.set = function (outPtr, inPtr, numscalars, n) {\n    var count = numscalars * n;\n    for (var i = 0; i < n; ++i) {\n      outPtr[i] = inPtr[i];\n    }\n    return count;\n  };\n  publicAPI.set1 = function (outPtr, inPtr, numscalars, n) {\n    outPtr.fill(inPtr[0], 0, n);\n    return n;\n  };\n  publicAPI.getSetPixelsFunc = function (dataType, dataSize, numscalars, dataPtr) {\n    return numscalars === 1 ? publicAPI.set1 : publicAPI.set;\n  };\n  publicAPI.getCompositeFunc = function (slabMode, slabTrapezoidIntegration) {\n    var composite = null; // eslint-disable-next-line default-case\n\n    switch (slabMode) {\n      case SlabMode.MIN:\n        composite = getImageResliceCompositeMinValue;\n        break;\n      case SlabMode.MAX:\n        composite = getImageResliceCompositeMaxValue;\n        break;\n      case SlabMode.MEAN:\n        if (slabTrapezoidIntegration) {\n          composite = getImageResliceCompositeMeanTrap;\n        } else {\n          composite = getImageResliceCompositeMeanValue;\n        }\n        break;\n      case SlabMode.SUM:\n        if (slabTrapezoidIntegration) {\n          composite = getImageResliceCompositeSumTrap;\n        } else {\n          composite = getImageResliceCompositeSumValue;\n        }\n        break;\n    }\n    return composite;\n  };\n  publicAPI.applyTransform = function (newTrans, inPoint, inOrigin, inInvSpacing) {\n    inPoint[3] = 1;\n    vec4.transformMat4(inPoint, inPoint, newTrans);\n    inPoint[0] -= inOrigin[0];\n    inPoint[1] -= inOrigin[1];\n    inPoint[2] -= inOrigin[2];\n    inPoint[0] *= inInvSpacing[0];\n    inPoint[1] *= inInvSpacing[1];\n    inPoint[2] *= inInvSpacing[2];\n  };\n  publicAPI.rescaleScalars = function (floatData, components, n, scalarShift, scalarScale) {\n    var m = n * components;\n    for (var i = 0; i < m; ++i) {\n      floatData[i] = (floatData[i] + scalarShift) * scalarScale;\n    }\n  };\n  publicAPI.isPermutationMatrix = function (matrix) {\n    for (var i = 0; i < 3; i++) {\n      if (matrix[4 * i + 3] !== 0) {\n        return false;\n      }\n    }\n    if (matrix[4 * 3 + 3] !== 1) {\n      return false;\n    }\n    for (var j = 0; j < 3; j++) {\n      var k = 0;\n      for (var _i8 = 0; _i8 < 3; _i8++) {\n        if (matrix[4 * j + _i8] !== 0) {\n          k++;\n        }\n      }\n      if (k !== 1) {\n        return 0;\n      }\n    }\n    return 1;\n  }; // TODO: to move in vtkMath and add tolerance\n\n  publicAPI.isIdentityMatrix = function (matrix) {\n    for (var i = 0; i < 4; ++i) {\n      for (var j = 0; j < 4; ++j) {\n        if ((i === j ? 1.0 : 0.0) !== matrix[4 * j + i]) {\n          return false;\n        }\n      }\n    }\n    return true;\n  };\n  publicAPI.isPerspectiveMatrix = function (matrix) {\n    return matrix[4 * 0 + 3] !== 0 || matrix[4 * 1 + 3] !== 0 || matrix[4 * 2 + 3] !== 0 || matrix[4 * 3 + 3] !== 1;\n  };\n  publicAPI.canUseNearestNeighbor = function (matrix, outExt) {\n    // loop through dimensions\n    for (var i = 0; i < 3; i++) {\n      var j = void 0;\n      for (j = 0; j < 3; j++) {\n        if (matrix[4 * j + i] !== 0) {\n          break;\n        }\n      }\n      if (j >= 3) {\n        return 0;\n      }\n      var x = matrix[4 * j + i];\n      var y = matrix[4 * 3 + i];\n      if (outExt[2 * j] === outExt[2 * j + 1]) {\n        y += x * outExt[2 * i];\n        x = 0;\n      }\n      var fx = vtkInterpolationMathFloor(x).error;\n      var fy = vtkInterpolationMathFloor(y).error;\n      if (fx !== 0 || fy !== 0) {\n        return 0;\n      }\n    }\n    return 1;\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nvar DEFAULT_VALUES = {\n  transformInputSampling: true,\n  autoCropOutput: false,\n  outputDimensionality: 3,\n  outputSpacing: null,\n  // automatically computed if null\n  outputOrigin: null,\n  // automatically computed if null\n  outputDirection: null,\n  // identity if null\n  outputExtent: null,\n  // automatically computed if null\n  outputScalarType: null,\n  wrap: false,\n  // don't wrap\n  mirror: false,\n  // don't mirror\n  border: true,\n  // apply a border\n  interpolationMode: InterpolationMode.NEAREST,\n  // only NEAREST supported so far\n  slabMode: SlabMode.MIN,\n  slabTrapezoidIntegration: false,\n  slabNumberOfSlices: 1,\n  slabSliceSpacingFraction: 1,\n  optimization: false,\n  // not supported yet\n  scalarShift: 0,\n  // for rescaling the data\n  scalarScale: 1,\n  backgroundColor: [0, 0, 0, 0],\n  resliceAxes: null,\n  // resliceTransform: null,\n  interpolator: vtkImageInterpolator.newInstance(),\n  usePermuteExecute: false // no supported yet\n}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Make this a VTK object\n\n  macro.obj(publicAPI, model); // Also make it an algorithm with one input and one output\n\n  macro.algo(publicAPI, model, 1, 1);\n  macro.setGet(publicAPI, model, ['outputDimensionality', 'outputScalarType', 'scalarShift', 'scalarScale', 'transformInputSampling', 'autoCropOutput', 'wrap', 'mirror', 'border', 'interpolationMode', 'resliceTransform', 'slabMode', 'slabTrapezoidIntegration', 'slabNumberOfSlices', 'slabSliceSpacingFraction']);\n  macro.setGetArray(publicAPI, model, ['outputOrigin', 'outputSpacing'], 3);\n  macro.setGetArray(publicAPI, model, ['outputExtent'], 6);\n  macro.setGetArray(publicAPI, model, ['outputDirection'], 9);\n  macro.setGetArray(publicAPI, model, ['backgroundColor'], 4);\n  macro.get(publicAPI, model, ['resliceAxes']); // Object specific methods\n\n  macro.algo(publicAPI, model, 1, 1);\n  vtkImageReslice(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = macro.newInstance(extend, 'vtkImageReslice'); // ----------------------------------------------------------------------------\n\nvar vtkImageReslice$1 = _objectSpread({\n  newInstance: newInstance,\n  extend: extend\n}, Constants);\nexport { vtkImageReslice$1 as default, extend, newInstance };","map":{"version":3,"names":["_defineProperty","mat4","vec4","macro","vtkWarningMacro","vtkDataArray","f","vtkMath","vtkMatrixBuilder","VtkDataTypes","vtkBoundingBox","vtkImageData","vtkImageInterpolator","vtkImagePointDataIterator","InterpolationMode","ImageBorderMode","vtkInterpolationMathRound","vtkInterpolationMathClamp","vtkInterpolationMathFloor","Constants","ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","getOwnPropertyDescriptors","defineProperties","defineProperty","SlabMode","vtkErrorMacro","vtkImageReslice","publicAPI","model","classHierarchy","superClass","indexMatrix","optimizedTransform","getImageResliceSlabTrap","tmpPtr","inComponents","sampleCount","n","result","j","getImageResliceSlabSum","getImageResliceCompositeMinValue","Math","min","getImageResliceCompositeMaxValue","max","getImageResliceCompositeMeanValue","getImageResliceCompositeMeanTrap","getImageResliceCompositeSumValue","getImageResliceCompositeSumTrap","getMTime","mTime","resliceTransform","setResliceAxes","resliceAxes","identity","Float64Array","exactEquals","copy","modified","requestData","inData","outData","input","origin","getOrigin","inSpacing","getSpacing","dims","getDimensions","inScalars","getPointData","getScalars","inWholeExt","outOrigin","outSpacing","outWholeExt","outDims","matrix","multiply","imatrix","invert","inCenter","maxBounds","autoCropOutput","getAutoCroppedOutputBounds","s","d","e","c","transformInputSampling","r","tmp","abs","sqrt","outputSpacing","outputDimensionality","outputExtent","round","outputOrigin","dataType","getDataType","outputScalarType","numComponents","getNumberOfComponents","outScalarsData","newTypedArray","outScalars","newInstance","name","values","numberOfComponents","output","setDimensions","setOrigin","setSpacing","outputDirection","setDirection","setScalars","getIndexMatrix","interpolationMode","usePermuteExecute","optimization","slabSliceSpacingFraction","interpolator","isSeparable","isPermutationMatrix","canUseNearestNeighbor","NEAREST","setInterpolationMode","borderMode","CLAMP","wrap","REPEAT","mirror","MIRROR","setBorderMode","mintol","maxtol","tol","border","setTolerance","initialize","vtkImageResliceExecute","releaseData","outPtr","getData","outExt","getExtent","newmat","nsamples","slabNumberOfSlices","slabSampleSpacing","perspective","isPerspectiveMatrix","inPtr","inputScalarSize","inputScalarType","componentOffset","getComponentOffset","getBorderMode","inDims","inExt","inInc","fullSize","subarray","isA","getInterpolationMode","convertScalars","rescaleScalars","scalarShift","scalarScale","optimizeNearest","getNumberOfTuples","scalarType","scalarSize","outComponents","xAxis","yAxis","zAxis","floatPtr","background","backgroundColor","forceClamping","LINEAR","slabMode","SUM","convertpixels","getConversionFunc","setpixels","getSetPixelsFunc","composite","getCompositeFunc","slabTrapezoidIntegration","idY","idZ","inPoint0","inPoint1","iter","stencil","outPtr0","outPtrIndex","outTmp","getDiagonalLength","interpolatedPtr","interpolatedPoint","isAtEnd","nextSpan","span","spanEndId","getId","isInStencil","_i","outIndex","getIndex","idXmin","idXmax","wasInBounds","isInBounds","startIdX","idX","pixelIndex","inPoint2","inPoint3","inPoint","interpolatedPtrIndex","sample","checkBoundsIJK","interpolateIJK","_i2","_i3","endIdX","numpixels","_n","_i4","inPtrTmp0","outPtrTmp","inIncX","inIncY","inIncZ","inExtX","inExtY","inExtZ","_startIdX","_endIdX","_isInBounds","bytesPerPixel","iidX","_inPoint","inIdX","inIdY","inIdZ","_n3","_i5","offset","_i6","oc","_n2","_i7","inOrigin","inDirection","getDirection","transform","inMatrix","outMatrix","getMatrix","isIdentity3x3","imageTransform","buildFromRadian","translate","multiply3x3","isIdentity","getInverse","bounds","Number","MAX_VALUE","point","floor","transformMat4","transformPoint","getDataTypeMinMax","clamp","numscalars","count","convert","inputType","useClamping","FLOAT","DOUBLE","inMinMax","checkMin","checkMax","outMinMax","outputMin","outputMax","minMax","set","set1","fill","dataSize","dataPtr","MIN","MAX","MEAN","applyTransform","newTrans","inInvSpacing","floatData","components","m","k","_i8","isIdentityMatrix","x","y","fx","error","fy","DEFAULT_VALUES","extend","initialValues","undefined","assign","obj","algo","setGet","setGetArray","get","vtkImageReslice$1","default"],"sources":["/home/rakshith/Documents/RemoteRendering/vtk-js-react-app/node_modules/@kitware/vtk.js/Imaging/Core/ImageReslice.js"],"sourcesContent":["import _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport { mat4, vec4 } from 'gl-matrix';\nimport macro, { vtkWarningMacro } from '../../macros.js';\nimport vtkDataArray from '../../Common/Core/DataArray.js';\nimport { f as vtkMath } from '../../Common/Core/Math/index.js';\nimport vtkMatrixBuilder from '../../Common/Core/MatrixBuilder.js';\nimport { VtkDataTypes } from '../../Common/Core/DataArray/Constants.js';\nimport vtkBoundingBox from '../../Common/DataModel/BoundingBox.js';\nimport vtkImageData from '../../Common/DataModel/ImageData.js';\nimport vtkImageInterpolator from './ImageInterpolator.js';\nimport vtkImagePointDataIterator from './ImagePointDataIterator.js';\nimport { InterpolationMode, ImageBorderMode } from './AbstractImageInterpolator/Constants.js';\nimport { vtkInterpolationMathRound, vtkInterpolationMathClamp, vtkInterpolationMathFloor } from './AbstractImageInterpolator/InterpolationInfo.js';\nimport Constants from './ImageReslice/Constants.js';\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nvar SlabMode = Constants.SlabMode;\nvar vtkErrorMacro = macro.vtkErrorMacro; // ----------------------------------------------------------------------------\n// vtkImageReslice methods\n// ----------------------------------------------------------------------------\n\nfunction vtkImageReslice(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkImageReslice');\n\n  var superClass = _objectSpread({}, publicAPI);\n\n  var indexMatrix = null;\n  var optimizedTransform = null;\n\n  function getImageResliceSlabTrap(tmpPtr, inComponents, sampleCount, f) {\n    var n = sampleCount - 1;\n\n    for (var i = 0; i < inComponents; i += 1) {\n      var result = tmpPtr[i] * 0.5;\n\n      for (var j = 1; j < n; j += 1) {\n        result += tmpPtr[i + j * inComponents];\n      }\n\n      result += tmpPtr[i + n * inComponents] * 0.5;\n      tmpPtr[i] = result * f;\n    }\n  }\n\n  function getImageResliceSlabSum(tmpPtr, inComponents, sampleCount, f) {\n    for (var i = 0; i < inComponents; i += 1) {\n      var result = tmpPtr[i];\n\n      for (var j = 1; j < sampleCount; j += 1) {\n        result += tmpPtr[i + j * inComponents];\n      }\n\n      tmpPtr[i] = result * f;\n    }\n  }\n\n  function getImageResliceCompositeMinValue(tmpPtr, inComponents, sampleCount) {\n    for (var i = 0; i < inComponents; i += 1) {\n      var result = tmpPtr[i];\n\n      for (var j = 1; j < sampleCount; j += 1) {\n        result = Math.min(result, tmpPtr[i + j * inComponents]);\n      }\n\n      tmpPtr[i] = result;\n    }\n  }\n\n  function getImageResliceCompositeMaxValue(tmpPtr, inComponents, sampleCount) {\n    for (var i = 0; i < inComponents; i += 1) {\n      var result = tmpPtr[i];\n\n      for (var j = 1; j < sampleCount; j += 1) {\n        result = Math.max(result, tmpPtr[i + j * inComponents]);\n      }\n\n      tmpPtr[i] = result;\n    }\n  }\n\n  function getImageResliceCompositeMeanValue(tmpPtr, inComponents, sampleCount) {\n    var f = 1.0 / sampleCount;\n    getImageResliceSlabSum(tmpPtr, inComponents, sampleCount, f);\n  }\n\n  function getImageResliceCompositeMeanTrap(tmpPtr, inComponents, sampleCount) {\n    var f = 1.0 / (sampleCount - 1);\n    getImageResliceSlabTrap(tmpPtr, inComponents, sampleCount, f);\n  }\n\n  function getImageResliceCompositeSumValue(tmpPtr, inComponents, sampleCount) {\n    var f = 1.0;\n    getImageResliceSlabSum(tmpPtr, inComponents, sampleCount, f);\n  }\n\n  function getImageResliceCompositeSumTrap(tmpPtr, inComponents, sampleCount) {\n    var f = 1.0;\n    getImageResliceSlabTrap(tmpPtr, inComponents, sampleCount, f);\n  }\n\n  publicAPI.getMTime = function () {\n    var mTime = superClass.getMTime();\n\n    if (model.resliceTransform) {\n      mTime = Math.max(mTime, model.resliceTransform.getMTime());\n    }\n\n    return mTime;\n  };\n\n  publicAPI.setResliceAxes = function (resliceAxes) {\n    if (!model.resliceAxes) {\n      model.resliceAxes = mat4.identity(new Float64Array(16));\n    }\n\n    if (!mat4.exactEquals(model.resliceAxes, resliceAxes)) {\n      mat4.copy(model.resliceAxes, resliceAxes);\n      publicAPI.modified();\n      return true;\n    }\n\n    return null;\n  };\n\n  publicAPI.requestData = function (inData, outData) {\n    // implement requestData\n    var input = inData[0];\n\n    if (!input) {\n      vtkErrorMacro('Invalid or missing input');\n      return;\n    } // console.time('reslice');\n    // Retrieve output and volume data\n\n\n    var origin = input.getOrigin();\n    var inSpacing = input.getSpacing();\n    var dims = input.getDimensions();\n    var inScalars = input.getPointData().getScalars();\n    var inWholeExt = [0, dims[0] - 1, 0, dims[1] - 1, 0, dims[2] - 1];\n    var outOrigin = [0, 0, 0];\n    var outSpacing = [1, 1, 1];\n    var outWholeExt = [0, 0, 0, 0, 0, 0];\n    var outDims = [0, 0, 0];\n    var matrix = mat4.identity(new Float64Array(16));\n\n    if (model.resliceAxes) {\n      mat4.multiply(matrix, matrix, model.resliceAxes);\n    }\n\n    var imatrix = new Float64Array(16);\n    mat4.invert(imatrix, matrix);\n    var inCenter = [origin[0] + 0.5 * (inWholeExt[0] + inWholeExt[1]) * inSpacing[0], origin[1] + 0.5 * (inWholeExt[2] + inWholeExt[3]) * inSpacing[1], origin[2] + 0.5 * (inWholeExt[4] + inWholeExt[5]) * inSpacing[2]];\n    var maxBounds = null;\n\n    if (model.autoCropOutput) {\n      maxBounds = publicAPI.getAutoCroppedOutputBounds(input);\n    }\n\n    for (var i = 0; i < 3; i++) {\n      var s = 0; // default output spacing\n\n      var d = 0; // default linear dimension\n\n      var e = 0; // default extent start\n\n      var c = 0; // transformed center-of-volume\n\n      if (model.transformInputSampling) {\n        var r = 0.0;\n\n        for (var j = 0; j < 3; j++) {\n          c += imatrix[4 * j + i] * (inCenter[j] - matrix[4 * 3 + j]);\n          var tmp = matrix[4 * i + j] * matrix[4 * i + j];\n          s += tmp * Math.abs(inSpacing[j]);\n          d += tmp * (inWholeExt[2 * j + 1] - inWholeExt[2 * j]) * Math.abs(inSpacing[j]);\n          e += tmp * inWholeExt[2 * j];\n          r += tmp;\n        }\n\n        s /= r;\n        d /= r * Math.sqrt(r);\n        e /= r;\n      } else {\n        c = inCenter[i];\n        s = inSpacing[i];\n        d = (inWholeExt[2 * i + 1] - inWholeExt[2 * i]) * s;\n        e = inWholeExt[2 * i];\n      }\n\n      if (model.outputSpacing == null) {\n        outSpacing[i] = s;\n      } else {\n        outSpacing[i] = model.outputSpacing[i];\n      }\n\n      if (i >= model.outputDimensionality) {\n        outWholeExt[2 * i] = 0;\n        outWholeExt[2 * i + 1] = 0;\n      } else if (model.outputExtent == null) {\n        if (model.autoCropOutput) {\n          d = maxBounds[2 * i + 1] - maxBounds[2 * i];\n        }\n\n        outWholeExt[2 * i] = Math.round(e);\n        outWholeExt[2 * i + 1] = Math.round(outWholeExt[2 * i] + Math.abs(d / outSpacing[i]));\n      } else {\n        outWholeExt[2 * i] = model.outputExtent[2 * i];\n        outWholeExt[2 * i + 1] = model.outputExtent[2 * i + 1];\n      }\n\n      if (i >= model.outputDimensionality) {\n        outOrigin[i] = 0;\n      } else if (model.outputOrigin == null) {\n        if (model.autoCropOutput) {\n          // set origin so edge of extent is edge of bounds\n          outOrigin[i] = maxBounds[2 * i] - outWholeExt[2 * i] * outSpacing[i];\n        } else {\n          // center new bounds over center of input bounds\n          outOrigin[i] = c - 0.5 * (outWholeExt[2 * i] + outWholeExt[2 * i + 1]) * outSpacing[i];\n        }\n      } else {\n        outOrigin[i] = model.outputOrigin[i];\n      }\n\n      outDims[i] = outWholeExt[2 * i + 1] - outWholeExt[2 * i] + 1;\n    }\n\n    var dataType = inScalars.getDataType();\n\n    if (model.outputScalarType) {\n      dataType = model.outputScalarType;\n    }\n\n    var numComponents = input.getPointData().getScalars().getNumberOfComponents(); // or s.numberOfComponents;\n\n    var outScalarsData = macro.newTypedArray(dataType, outDims[0] * outDims[1] * outDims[2] * numComponents);\n    var outScalars = vtkDataArray.newInstance({\n      name: 'Scalars',\n      values: outScalarsData,\n      numberOfComponents: numComponents\n    }); // Update output\n\n    var output = vtkImageData.newInstance();\n    output.setDimensions(outDims);\n    output.setOrigin(outOrigin);\n    output.setSpacing(outSpacing);\n\n    if (model.outputDirection) {\n      output.setDirection(model.outputDirection);\n    }\n\n    output.getPointData().setScalars(outScalars);\n    publicAPI.getIndexMatrix(input, output);\n    var interpolationMode = model.interpolationMode;\n    model.usePermuteExecute = false;\n\n    if (model.optimization) {\n      if (model.slabSliceSpacingFraction === 1.0 && model.interpolator.isSeparable() && publicAPI.isPermutationMatrix(indexMatrix)) {\n        model.usePermuteExecute = true;\n\n        if (publicAPI.canUseNearestNeighbor(indexMatrix, outWholeExt)) {\n          interpolationMode = InterpolationMode.NEAREST;\n        }\n      }\n    }\n\n    model.interpolator.setInterpolationMode(interpolationMode);\n    var borderMode = ImageBorderMode.CLAMP;\n    borderMode = model.wrap ? ImageBorderMode.REPEAT : borderMode;\n    borderMode = model.mirror ? ImageBorderMode.MIRROR : borderMode;\n    model.interpolator.setBorderMode(borderMode);\n    var mintol = 7.62939453125e-6;\n    var maxtol = 2.0 * 2147483647;\n    var tol = 0.5 * model.border;\n    tol = borderMode === ImageBorderMode.CLAMP ? tol : maxtol;\n    tol = tol > mintol ? tol : mintol;\n    model.interpolator.setTolerance(tol);\n    model.interpolator.initialize(input);\n    publicAPI.vtkImageResliceExecute(input, output);\n    model.interpolator.releaseData();\n    outData[0] = output; // console.timeEnd('reslice');\n  };\n\n  publicAPI.vtkImageResliceExecute = function (input, output) {\n    // const outDims = output.getDimensions();\n    var inScalars = input.getPointData().getScalars();\n    var outScalars = output.getPointData().getScalars();\n    var outPtr = outScalars.getData();\n    var outExt = output.getExtent();\n    var newmat = indexMatrix;\n\n    var nsamples = Math.max(model.slabNumberOfSlices, 1); // spacing between slab samples (as a fraction of slice spacing).\n\n    var slabSampleSpacing = model.slabSliceSpacingFraction; // check for perspective transformation\n\n    var perspective = publicAPI.isPerspectiveMatrix(newmat); // extra scalar info for nearest-neighbor optimization\n\n    var inPtr = inScalars.getData();\n    var inputScalarSize = 1; // inScalars.getElementComponentSize(); // inScalars.getDataTypeSize();\n\n    var inputScalarType = inScalars.getDataType();\n    var inComponents = inScalars.getNumberOfComponents(); // interpolator.GetNumberOfComponents();\n\n    var componentOffset = model.interpolator.getComponentOffset();\n    var borderMode = model.interpolator.getBorderMode();\n    var inDims = input.getDimensions();\n    var inExt = [0, inDims[0] - 1, 0, inDims[1] - 1, 0, inDims[2] - 1]; // interpolator->GetExtent();\n\n    var inInc = [0, 0, 0];\n    inInc[0] = inScalars.getNumberOfComponents();\n    inInc[1] = inInc[0] * inDims[0];\n    inInc[2] = inInc[1] * inDims[1];\n    var fullSize = inDims[0] * inDims[1] * inDims[2];\n\n    if (componentOffset > 0 && componentOffset + inComponents < inInc[0]) {\n      inPtr = inPtr.subarray(inputScalarSize * componentOffset);\n    }\n\n    var interpolationMode = InterpolationMode.NEAREST;\n\n    if (model.interpolator.isA('vtkImageInterpolator')) {\n      interpolationMode = model.interpolator.getInterpolationMode();\n    }\n\n    var convertScalars = null;\n    var rescaleScalars = model.scalarShift !== 0.0 || model.scalarScale !== 1.0; // is nearest neighbor optimization possible?\n\n    var optimizeNearest = interpolationMode === InterpolationMode.NEAREST && borderMode === ImageBorderMode.CLAMP && !(perspective || convertScalars != null || rescaleScalars) && inputScalarType === outScalars.getDataType() && fullSize === inScalars.getNumberOfTuples() && model.border === true && nsamples <= 1; // get pixel information\n\n    var scalarType = outScalars.getDataType();\n    var scalarSize = 1; // outScalars.getElementComponentSize() // outScalars.scalarSize;\n\n    var outComponents = outScalars.getNumberOfComponents(); // break matrix into a set of axes plus an origin\n    // (this allows us to calculate the transform Incrementally)\n\n    var xAxis = [0, 0, 0, 0];\n    var yAxis = [0, 0, 0, 0];\n    var zAxis = [0, 0, 0, 0];\n    var origin = [0, 0, 0, 0];\n\n    for (var i = 0; i < 4; ++i) {\n      xAxis[i] = newmat[4 * 0 + i];\n      yAxis[i] = newmat[4 * 1 + i];\n      zAxis[i] = newmat[4 * 2 + i];\n      origin[i] = newmat[4 * 3 + i];\n    } // get the input origin and spacing for conversion purposes\n\n\n    model.interpolator.getOrigin();\n    var inSpacing = model.interpolator.getSpacing();\n    [1.0 / inSpacing[0], 1.0 / inSpacing[1], 1.0 / inSpacing[2]]; // allocate an output row of type double\n\n    var floatPtr = null;\n\n    if (!optimizeNearest) {\n      floatPtr = new Float64Array(inComponents * (outExt[1] - outExt[0] + nsamples));\n    }\n\n    var background = macro.newTypedArray(inputScalarType, model.backgroundColor); // set color for area outside of input volume extent\n    // void *background;\n    // vtkAllocBackgroundPixel(&background,\n    //    self->GetBackgroundColor(), scalarType, scalarSize, outComponents);\n    // get various helper functions\n\n    var forceClamping = interpolationMode > InterpolationMode.LINEAR || nsamples > 1 && model.slabMode === SlabMode.SUM;\n    var convertpixels = publicAPI.getConversionFunc(inputScalarType, scalarType, model.scalarShift, model.scalarScale, forceClamping);\n    var setpixels = publicAPI.getSetPixelsFunc(scalarType, scalarSize, outComponents, outPtr);\n    var composite = publicAPI.getCompositeFunc(model.slabMode, model.slabTrapezoidIntegration); // create some variables for when we march through the data\n\n    var idY = outExt[2] - 1;\n    var idZ = outExt[4] - 1;\n    var inPoint0 = [0.0, 0.0, 0.0, 0.0];\n    var inPoint1 = [0.0, 0.0, 0.0, 0.0]; // create an iterator to march through the data\n\n    var iter = vtkImagePointDataIterator.newInstance();\n    iter.initialize(output, outExt, model.stencil, null);\n    var outPtr0 = iter.getScalars(output, 0);\n    var outPtrIndex = 0;\n    var outTmp = macro.newTypedArray(scalarType, vtkBoundingBox.getDiagonalLength(outExt) * outComponents * 2);\n    var interpolatedPtr = new Float64Array(inComponents * nsamples);\n    var interpolatedPoint = new Float64Array(inComponents);\n\n    for (; !iter.isAtEnd(); iter.nextSpan()) {\n      var span = iter.spanEndId() - iter.getId();\n      outPtrIndex = iter.getId() * scalarSize * outComponents;\n\n      if (!iter.isInStencil()) {\n        // clear any regions that are outside the stencil\n        var n = setpixels(outTmp, background, outComponents, span);\n\n        for (var _i = 0; _i < n; ++_i) {\n          outPtr0[outPtrIndex++] = outTmp[_i];\n        }\n      } else {\n        // get output index, and compute position in input image\n        var outIndex = iter.getIndex(); // if Z index increased, then advance position along Z axis\n\n        if (outIndex[2] > idZ) {\n          idZ = outIndex[2];\n          inPoint0[0] = origin[0] + idZ * zAxis[0];\n          inPoint0[1] = origin[1] + idZ * zAxis[1];\n          inPoint0[2] = origin[2] + idZ * zAxis[2];\n          inPoint0[3] = origin[3] + idZ * zAxis[3];\n          idY = outExt[2] - 1;\n        } // if Y index increased, then advance position along Y axis\n\n\n        if (outIndex[1] > idY) {\n          idY = outIndex[1];\n          inPoint1[0] = inPoint0[0] + idY * yAxis[0];\n          inPoint1[1] = inPoint0[1] + idY * yAxis[1];\n          inPoint1[2] = inPoint0[2] + idY * yAxis[2];\n          inPoint1[3] = inPoint0[3] + idY * yAxis[3];\n        } // march through one row of the output image\n\n\n        var idXmin = outIndex[0];\n        var idXmax = idXmin + span - 1;\n\n        if (!optimizeNearest) {\n          var wasInBounds = 1;\n          var isInBounds = 1;\n          var startIdX = idXmin;\n          var idX = idXmin;\n          var tmpPtr = floatPtr;\n          var pixelIndex = 0;\n\n          while (startIdX <= idXmax) {\n            for (; idX <= idXmax && isInBounds === wasInBounds; idX++) {\n              var inPoint2 = [inPoint1[0] + idX * xAxis[0], inPoint1[1] + idX * xAxis[1], inPoint1[2] + idX * xAxis[2], inPoint1[3] + idX * xAxis[3]];\n              var inPoint3 = [0, 0, 0, 0];\n              var inPoint = inPoint2;\n              isInBounds = false;\n              var interpolatedPtrIndex = 0;\n\n              for (var sample = 0; sample < nsamples; ++sample) {\n                if (nsamples > 1) {\n                  var s = sample - 0.5 * (nsamples - 1);\n                  s *= slabSampleSpacing;\n                  inPoint3[0] = inPoint2[0] + s * zAxis[0];\n                  inPoint3[1] = inPoint2[1] + s * zAxis[1];\n                  inPoint3[2] = inPoint2[2] + s * zAxis[2];\n                  inPoint3[3] = inPoint2[3] + s * zAxis[3];\n                  inPoint = inPoint3;\n                }\n\n                if (perspective) {\n                  // only do perspective if necessary\n                  var f = 1 / inPoint[3];\n                  inPoint[0] *= f;\n                  inPoint[1] *= f;\n                  inPoint[2] *= f;\n                }\n\n                if (model.interpolator.checkBoundsIJK(inPoint)) {\n                  // do the interpolation\n                  isInBounds = 1;\n                  model.interpolator.interpolateIJK(inPoint, interpolatedPoint);\n\n                  for (var _i2 = 0; _i2 < inComponents; ++_i2) {\n                    interpolatedPtr[interpolatedPtrIndex++] = interpolatedPoint[_i2];\n                  }\n                }\n              }\n\n              if (interpolatedPtrIndex > inComponents) {\n                composite(interpolatedPtr, inComponents, interpolatedPtrIndex / inComponents);\n              }\n\n              for (var _i3 = 0; _i3 < inComponents; ++_i3) {\n                tmpPtr[pixelIndex++] = interpolatedPtr[_i3];\n              } // set \"was in\" to \"is in\" if first pixel\n\n\n              wasInBounds = idX > idXmin ? wasInBounds : isInBounds;\n            } // write a segment to the output\n\n\n            var endIdX = idX - 1 - (isInBounds !== wasInBounds);\n            var numpixels = endIdX - startIdX + 1;\n            var _n = 0;\n\n            if (wasInBounds) {\n\n              if (rescaleScalars) {\n                publicAPI.rescaleScalars(floatPtr, inComponents, idXmax - idXmin + 1, model.scalarShift, model.scalarScale);\n              }\n\n              {\n                _n = convertpixels(outTmp, floatPtr.subarray(startIdX * inComponents), outComponents, numpixels);\n              }\n            } else {\n              _n = setpixels(outTmp, background, outComponents, numpixels);\n            }\n\n            for (var _i4 = 0; _i4 < _n; ++_i4) {\n              outPtr0[outPtrIndex++] = outTmp[_i4];\n            }\n\n            startIdX += numpixels;\n            wasInBounds = isInBounds;\n          }\n        } else {\n          // optimize for nearest-neighbor interpolation\n          var inPtrTmp0 = inPtr;\n          var outPtrTmp = outPtr;\n          var inIncX = inInc[0] * inputScalarSize;\n          var inIncY = inInc[1] * inputScalarSize;\n          var inIncZ = inInc[2] * inputScalarSize;\n          var inExtX = inExt[1] - inExt[0] + 1;\n          var inExtY = inExt[3] - inExt[2] + 1;\n          var inExtZ = inExt[5] - inExt[4] + 1;\n          var _startIdX = idXmin;\n\n          var _endIdX = idXmin - 1;\n\n          var _isInBounds = false;\n          var bytesPerPixel = inputScalarSize * inComponents;\n\n          for (var iidX = idXmin; iidX <= idXmax; iidX++) {\n            var _inPoint = [inPoint1[0] + iidX * xAxis[0], inPoint1[1] + iidX * xAxis[1], inPoint1[2] + iidX * xAxis[2]];\n            var inIdX = vtkInterpolationMathRound(_inPoint[0]) - inExt[0];\n            var inIdY = vtkInterpolationMathRound(_inPoint[1]) - inExt[2];\n            var inIdZ = vtkInterpolationMathRound(_inPoint[2]) - inExt[4];\n\n            if (inIdX >= 0 && inIdX < inExtX && inIdY >= 0 && inIdY < inExtY && inIdZ >= 0 && inIdZ < inExtZ) {\n              if (!_isInBounds) {\n                // clear leading out-of-bounds pixels\n                _startIdX = iidX;\n                _isInBounds = true;\n\n                var _n3 = setpixels(outTmp, background, outComponents, _startIdX - idXmin);\n\n                for (var _i5 = 0; _i5 < _n3; ++_i5) {\n                  outPtr0[outPtrIndex++] = outTmp[_i5];\n                }\n              } // set the final index that was within input bounds\n\n\n              _endIdX = iidX; // perform nearest-neighbor interpolation via pixel copy\n\n              var offset = inIdX * inIncX + inIdY * inIncY + inIdZ * inIncZ; // when memcpy is used with a constant size, the compiler will\n              // optimize away the function call and use the minimum number\n              // of instructions necessary to perform the copy\n\n              switch (bytesPerPixel) {\n                case 1:\n                  outPtr0[outPtrIndex++] = inPtrTmp0[offset];\n                  break;\n\n                case 2:\n                case 3:\n                case 4:\n                case 8:\n                case 12:\n                case 16:\n                  for (var _i6 = 0; _i6 < bytesPerPixel; ++_i6) {\n                    outPtr0[outPtrIndex++] = inPtrTmp0[offset + _i6];\n                  }\n\n                  break;\n\n                default:\n                  {\n                    // TODO: check bytes\n                    var oc = 0;\n\n                    do {\n                      outPtr0[outPtrIndex++] = inPtrTmp0[offset++];\n                    } while (++oc !== bytesPerPixel);\n\n                    break;\n                  }\n              }\n            } else if (_isInBounds) {\n              // leaving input bounds\n              break;\n            }\n          } // clear trailing out-of-bounds pixels\n\n\n          outPtr = outPtrTmp;\n\n          var _n2 = setpixels(outTmp, background, outComponents, idXmax - _endIdX);\n\n          for (var _i7 = 0; _i7 < _n2; ++_i7) {\n            outPtr0[outPtrIndex++] = outTmp[_i7];\n          }\n        }\n      }\n    }\n  };\n  /**\n   * The transform matrix supplied by the user converts output coordinates\n   * to input coordinates.\n   * To speed up the pixel lookup, the following function provides a\n   * matrix which converts output pixel indices to input pixel indices.\n   * This will also concatenate the ResliceAxes and the ResliceTransform\n   * if possible (if the ResliceTransform is a 4x4 matrix transform).\n   * If it does, this->OptimizedTransform will be set to nullptr, otherwise\n   * this->OptimizedTransform will be equal to this->ResliceTransform.\n   * @param {vtkPolyData} input\n   * @param {vtkPolyData} output\n   * @returns\n   */\n\n\n  publicAPI.getIndexMatrix = function (input, output) {\n    // first verify that we have to update the matrix\n    if (indexMatrix === null) {\n      indexMatrix = mat4.identity(new Float64Array(16));\n    }\n\n    var inOrigin = input.getOrigin();\n    var inSpacing = input.getSpacing();\n    var inDirection = input.getDirection();\n    var outOrigin = output.getOrigin();\n    var outSpacing = output.getSpacing();\n    var transform = mat4.identity(new Float64Array(16));\n    var inMatrix = mat4.identity(new Float64Array(16));\n    var outMatrix = mat4.identity(new Float64Array(16));\n\n    if (model.resliceAxes) {\n      mat4.copy(transform, model.resliceAxes);\n    }\n\n    if (model.resliceTransform) {\n      if (model.resliceTransform.isA('vtkHomogeneousTransform')) {\n        // transform->PostMultiply();\n        // transform->Concatenate(\n        // mat4.multiply(transform, transform, model.resliceTransform.getMatrix());\n        mat4.multiply(transform, model.resliceTransform.getMatrix(), transform);\n      } else {\n        // TODO\n        vtkWarningMacro('Non homogeneous transform have not yet been ported');\n      }\n    }\n\n    if (!vtkMath.isIdentity3x3(inDirection)) {\n      var imageTransform = vtkMatrixBuilder.buildFromRadian().translate(inOrigin[0], inOrigin[1], inOrigin[2]).multiply3x3(inDirection).translate(-inOrigin[0], -inOrigin[1], -inOrigin[2]);\n      mat4.multiply(transform, imageTransform.getMatrix(), transform);\n    } // check to see if we have an identity matrix\n\n\n    var isIdentity = vtkMath.isIdentity(transform); // the outMatrix takes OutputData indices to OutputData coordinates,\n    // the inMatrix takes InputData coordinates to InputData indices\n\n    for (var i = 0; i < 3; i++) {\n      if ((inSpacing[i] !== outSpacing[i] || inOrigin[i] !== outOrigin[i]) || optimizedTransform != null ) {\n        isIdentity = false;\n      }\n\n      inMatrix[4 * i + i] = 1.0 / inSpacing[i];\n      inMatrix[4 * 3 + i] = -inOrigin[i] / inSpacing[i];\n      outMatrix[4 * i + i] = outSpacing[i];\n      outMatrix[4 * 3 + i] = outOrigin[i];\n    }\n\n    if (!isIdentity) {\n      // transform.PreMultiply();\n      // transform.Concatenate(outMatrix);\n      mat4.multiply(transform, transform, outMatrix); // the optimizedTransform requires data coords, not\n      // index coords, as its input\n\n      {\n        // transform->PostMultiply();\n        // transform->Concatenate(inMatrix);\n        mat4.multiply(transform, inMatrix, transform);\n      }\n    }\n\n    mat4.copy(indexMatrix, transform);\n    return indexMatrix;\n  };\n\n  publicAPI.getAutoCroppedOutputBounds = function (input) {\n    var inOrigin = input.getOrigin();\n    var inSpacing = input.getSpacing();\n    var inDirection = input.getDirection();\n    var dims = input.getDimensions();\n    var inWholeExt = [0, dims[0] - 1, 0, dims[1] - 1, 0, dims[2] - 1];\n    var matrix = new Float64Array(16);\n\n    if (model.resliceAxes) {\n      mat4.invert(matrix, model.resliceAxes);\n    } else {\n      mat4.identity(matrix);\n    }\n\n    var transform = null;\n\n    if (model.resliceTransform) {\n      transform = model.resliceTransform.getInverse();\n    }\n\n    var imageTransform = null;\n\n    if (!vtkMath.isIdentity3x3(inDirection)) {\n      imageTransform = vtkMatrixBuilder.buildFromRadian().translate(inOrigin[0], inOrigin[1], inOrigin[2]).multiply3x3(inDirection).translate(-inOrigin[0], -inOrigin[1], -inOrigin[2]).invert().getMatrix();\n    }\n\n    var bounds = [Number.MAX_VALUE, -Number.MAX_VALUE, Number.MAX_VALUE, -Number.MAX_VALUE, Number.MAX_VALUE, -Number.MAX_VALUE];\n    var point = [0, 0, 0, 0];\n\n    for (var i = 0; i < 8; ++i) {\n      point[0] = inOrigin[0] + inWholeExt[i % 2] * inSpacing[0];\n      point[1] = inOrigin[1] + inWholeExt[2 + Math.floor(i / 2) % 2] * inSpacing[1];\n      point[2] = inOrigin[2] + inWholeExt[4 + Math.floor(i / 4) % 2] * inSpacing[2];\n      point[3] = 1.0;\n\n      if (imageTransform) {\n        vec4.transformMat4(point, point, imageTransform);\n      }\n\n      if (model.resliceTransform) {\n        transform.transformPoint(point, point);\n      }\n\n      vec4.transformMat4(point, point, matrix);\n      var f = 1.0 / point[3];\n      point[0] *= f;\n      point[1] *= f;\n      point[2] *= f;\n\n      for (var j = 0; j < 3; ++j) {\n        if (point[j] > bounds[2 * j + 1]) {\n          bounds[2 * j + 1] = point[j];\n        }\n\n        if (point[j] < bounds[2 * j]) {\n          bounds[2 * j] = point[j];\n        }\n      }\n    }\n\n    return bounds;\n  };\n\n  publicAPI.getDataTypeMinMax = function (dataType) {\n    switch (dataType) {\n      case 'Int8Array':\n        return {\n          min: -128,\n          max: 127\n        };\n\n      case 'Int16Array':\n        return {\n          min: -32768,\n          max: 32767\n        };\n\n      case 'Uint16Array':\n        return {\n          min: 0,\n          max: 65535\n        };\n\n      case 'Int32Array':\n        return {\n          min: -2147483648,\n          max: 2147483647\n        };\n\n      case 'Uint32Array':\n        return {\n          min: 0,\n          max: 4294967295\n        };\n\n      case 'Float32Array':\n        return {\n          min: -1.2e38,\n          max: 1.2e38\n        };\n\n      case 'Float64Array':\n        return {\n          min: -1.2e38,\n          max: 1.2e38\n        };\n\n      case 'Uint8Array':\n      case 'Uint8ClampedArray':\n      default:\n        return {\n          min: 0,\n          max: 255\n        };\n    }\n  };\n\n  publicAPI.clamp = function (outPtr, inPtr, numscalars, n, min, max) {\n    var count = n * numscalars;\n\n    for (var i = 0; i < count; ++i) {\n      outPtr[i] = vtkInterpolationMathClamp(inPtr[i], min, max);\n    }\n\n    return count;\n  };\n\n  publicAPI.convert = function (outPtr, inPtr, numscalars, n) {\n    var count = n * numscalars;\n\n    for (var i = 0; i < count; ++i) {\n      outPtr[i] = Math.round(inPtr[i]);\n    }\n\n    return count;\n  };\n\n  publicAPI.getConversionFunc = function (inputType, dataType, scalarShift, scalarScale, forceClamping) {\n    var useClamping = forceClamping;\n\n    if (dataType !== VtkDataTypes.FLOAT && dataType !== VtkDataTypes.DOUBLE && !forceClamping) {\n      var inMinMax = publicAPI.getDataTypeMinMax(inputType);\n      var checkMin = (inMinMax.min + scalarShift) * scalarScale;\n      var checkMax = (inMinMax.max + scalarShift) * scalarScale;\n      var outMinMax = publicAPI.getDataTypeMinMax(dataType);\n      var outputMin = outMinMax.min;\n      var outputMax = outMinMax.max;\n\n      if (checkMin > checkMax) {\n        var tmp = checkMax;\n        checkMax = checkMin;\n        checkMin = tmp;\n      }\n\n      useClamping = checkMin < outputMin || checkMax > outputMax;\n    }\n\n    if (useClamping && dataType !== VtkDataTypes.FLOAT && dataType !== VtkDataTypes.DOUBLE) {\n      var minMax = publicAPI.getDataTypeMinMax(dataType);\n\n      var clamp = function clamp(outPtr, inPtr, numscalars, n) {\n        return publicAPI.clamp(outPtr, inPtr, numscalars, n, minMax.min, minMax.max);\n      };\n\n      return clamp;\n    }\n\n    return publicAPI.convert;\n  };\n\n  publicAPI.set = function (outPtr, inPtr, numscalars, n) {\n    var count = numscalars * n;\n\n    for (var i = 0; i < n; ++i) {\n      outPtr[i] = inPtr[i];\n    }\n\n    return count;\n  };\n\n  publicAPI.set1 = function (outPtr, inPtr, numscalars, n) {\n    outPtr.fill(inPtr[0], 0, n);\n    return n;\n  };\n\n  publicAPI.getSetPixelsFunc = function (dataType, dataSize, numscalars, dataPtr) {\n    return numscalars === 1 ? publicAPI.set1 : publicAPI.set;\n  };\n\n  publicAPI.getCompositeFunc = function (slabMode, slabTrapezoidIntegration) {\n    var composite = null; // eslint-disable-next-line default-case\n\n    switch (slabMode) {\n      case SlabMode.MIN:\n        composite = getImageResliceCompositeMinValue;\n        break;\n\n      case SlabMode.MAX:\n        composite = getImageResliceCompositeMaxValue;\n        break;\n\n      case SlabMode.MEAN:\n        if (slabTrapezoidIntegration) {\n          composite = getImageResliceCompositeMeanTrap;\n        } else {\n          composite = getImageResliceCompositeMeanValue;\n        }\n\n        break;\n\n      case SlabMode.SUM:\n        if (slabTrapezoidIntegration) {\n          composite = getImageResliceCompositeSumTrap;\n        } else {\n          composite = getImageResliceCompositeSumValue;\n        }\n\n        break;\n    }\n\n    return composite;\n  };\n\n  publicAPI.applyTransform = function (newTrans, inPoint, inOrigin, inInvSpacing) {\n    inPoint[3] = 1;\n    vec4.transformMat4(inPoint, inPoint, newTrans);\n    inPoint[0] -= inOrigin[0];\n    inPoint[1] -= inOrigin[1];\n    inPoint[2] -= inOrigin[2];\n    inPoint[0] *= inInvSpacing[0];\n    inPoint[1] *= inInvSpacing[1];\n    inPoint[2] *= inInvSpacing[2];\n  };\n\n  publicAPI.rescaleScalars = function (floatData, components, n, scalarShift, scalarScale) {\n    var m = n * components;\n\n    for (var i = 0; i < m; ++i) {\n      floatData[i] = (floatData[i] + scalarShift) * scalarScale;\n    }\n  };\n\n  publicAPI.isPermutationMatrix = function (matrix) {\n    for (var i = 0; i < 3; i++) {\n      if (matrix[4 * i + 3] !== 0) {\n        return false;\n      }\n    }\n\n    if (matrix[4 * 3 + 3] !== 1) {\n      return false;\n    }\n\n    for (var j = 0; j < 3; j++) {\n      var k = 0;\n\n      for (var _i8 = 0; _i8 < 3; _i8++) {\n        if (matrix[4 * j + _i8] !== 0) {\n          k++;\n        }\n      }\n\n      if (k !== 1) {\n        return 0;\n      }\n    }\n\n    return 1;\n  }; // TODO: to move in vtkMath and add tolerance\n\n\n  publicAPI.isIdentityMatrix = function (matrix) {\n    for (var i = 0; i < 4; ++i) {\n      for (var j = 0; j < 4; ++j) {\n        if ((i === j ? 1.0 : 0.0) !== matrix[4 * j + i]) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  };\n\n  publicAPI.isPerspectiveMatrix = function (matrix) {\n    return matrix[4 * 0 + 3] !== 0 || matrix[4 * 1 + 3] !== 0 || matrix[4 * 2 + 3] !== 0 || matrix[4 * 3 + 3] !== 1;\n  };\n\n  publicAPI.canUseNearestNeighbor = function (matrix, outExt) {\n    // loop through dimensions\n    for (var i = 0; i < 3; i++) {\n      var j = void 0;\n\n      for (j = 0; j < 3; j++) {\n        if (matrix[4 * j + i] !== 0) {\n          break;\n        }\n      }\n\n      if (j >= 3) {\n        return 0;\n      }\n\n      var x = matrix[4 * j + i];\n      var y = matrix[4 * 3 + i];\n\n      if (outExt[2 * j] === outExt[2 * j + 1]) {\n        y += x * outExt[2 * i];\n        x = 0;\n      }\n\n      var fx = vtkInterpolationMathFloor(x).error;\n      var fy = vtkInterpolationMathFloor(y).error;\n\n      if (fx !== 0 || fy !== 0) {\n        return 0;\n      }\n    }\n\n    return 1;\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\n\nvar DEFAULT_VALUES = {\n  transformInputSampling: true,\n  autoCropOutput: false,\n  outputDimensionality: 3,\n  outputSpacing: null,\n  // automatically computed if null\n  outputOrigin: null,\n  // automatically computed if null\n  outputDirection: null,\n  // identity if null\n  outputExtent: null,\n  // automatically computed if null\n  outputScalarType: null,\n  wrap: false,\n  // don't wrap\n  mirror: false,\n  // don't mirror\n  border: true,\n  // apply a border\n  interpolationMode: InterpolationMode.NEAREST,\n  // only NEAREST supported so far\n  slabMode: SlabMode.MIN,\n  slabTrapezoidIntegration: false,\n  slabNumberOfSlices: 1,\n  slabSliceSpacingFraction: 1,\n  optimization: false,\n  // not supported yet\n  scalarShift: 0,\n  // for rescaling the data\n  scalarScale: 1,\n  backgroundColor: [0, 0, 0, 0],\n  resliceAxes: null,\n  // resliceTransform: null,\n  interpolator: vtkImageInterpolator.newInstance(),\n  usePermuteExecute: false // no supported yet\n\n}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Make this a VTK object\n\n  macro.obj(publicAPI, model); // Also make it an algorithm with one input and one output\n\n  macro.algo(publicAPI, model, 1, 1);\n  macro.setGet(publicAPI, model, ['outputDimensionality', 'outputScalarType', 'scalarShift', 'scalarScale', 'transformInputSampling', 'autoCropOutput', 'wrap', 'mirror', 'border', 'interpolationMode', 'resliceTransform', 'slabMode', 'slabTrapezoidIntegration', 'slabNumberOfSlices', 'slabSliceSpacingFraction']);\n  macro.setGetArray(publicAPI, model, ['outputOrigin', 'outputSpacing'], 3);\n  macro.setGetArray(publicAPI, model, ['outputExtent'], 6);\n  macro.setGetArray(publicAPI, model, ['outputDirection'], 9);\n  macro.setGetArray(publicAPI, model, ['backgroundColor'], 4);\n  macro.get(publicAPI, model, ['resliceAxes']); // Object specific methods\n\n  macro.algo(publicAPI, model, 1, 1);\n  vtkImageReslice(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = macro.newInstance(extend, 'vtkImageReslice'); // ----------------------------------------------------------------------------\n\nvar vtkImageReslice$1 = _objectSpread({\n  newInstance: newInstance,\n  extend: extend\n}, Constants);\n\nexport { vtkImageReslice$1 as default, extend, newInstance };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}