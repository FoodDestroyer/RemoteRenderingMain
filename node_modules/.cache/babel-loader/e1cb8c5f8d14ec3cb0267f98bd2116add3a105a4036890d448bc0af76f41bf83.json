{"ast":null,"code":"import _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport macro from '../../macros.js';\nimport Constants from './Line/Constants.js';\nimport vtkCell from './Cell.js';\nimport { d as dot, e as distance2BetweenPoints, s as subtract, g as solveLinearSystem } from '../Core/Math/index.js';\nimport { quat } from 'gl-matrix';\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n  return target;\n}\nvar IntersectionState = Constants.IntersectionState; // ----------------------------------------------------------------------------\n// Global methods\n// ----------------------------------------------------------------------------\n\nfunction distanceToLine(x, p1, p2) {\n  var closestPoint = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  var outObj = {\n    t: Number.MIN_VALUE,\n    distance: 0\n  };\n  var p21 = [];\n  var closest; // Determine appropriate vector\n\n  p21[0] = p2[0] - p1[0];\n  p21[1] = p2[1] - p1[1];\n  p21[2] = p2[2] - p1[2]; // Get parametric location\n\n  var num = p21[0] * (x[0] - p1[0]) + p21[1] * (x[1] - p1[1]) + p21[2] * (x[2] - p1[2]);\n  var denom = dot(p21, p21); // trying to avoid an expensive fabs\n\n  var tolerance = 1e-5 * num;\n  if (denom !== 0.0) {\n    outObj.t = num / denom;\n  }\n  if (tolerance < 0.0) {\n    tolerance = -tolerance;\n  }\n  if (-tolerance < denom && denom < tolerance) {\n    closest = p1;\n  } else if (denom <= 0.0 || outObj.t < 0.0) {\n    // If parametric coordinate is within 0<=p<=1, then the point is closest to\n    // the line.  Otherwise, it's closest to a point at the end of the line.\n    closest = p1;\n  } else if (outObj.t > 1.0) {\n    closest = p2;\n  } else {\n    closest = p21;\n    p21[0] = p1[0] + outObj.t * p21[0];\n    p21[1] = p1[1] + outObj.t * p21[1];\n    p21[2] = p1[2] + outObj.t * p21[2];\n  }\n  if (closestPoint) {\n    closestPoint[0] = closest[0];\n    closestPoint[1] = closest[1];\n    closestPoint[2] = closest[2];\n  }\n  outObj.distance = distance2BetweenPoints(closest, x);\n  return outObj;\n}\nfunction intersection(a1, a2, b1, b2, u, v) {\n  var a21 = [];\n  var b21 = [];\n  var b1a1 = [];\n  u[0] = 0.0;\n  v[0] = 0.0; // Determine line vectors.\n\n  subtract(a2, a1, a21);\n  subtract(b2, b1, b21);\n  subtract(b1, a1, b1a1); // Compute the system (least squares) matrix.\n\n  var A = [dot(a21, a21), -dot(a21, b21), -dot(a21, b21), dot(b21, b21)]; // Compute the least squares system constant term.\n\n  var c = [];\n  c[0] = dot(a21, b1a1);\n  c[1] = -dot(b21, b1a1); // Solve the system of equations\n\n  if (solveLinearSystem(A, c, 2) === 0) {\n    // The lines are colinear. Therefore, one of the four endpoints is the\n    // point of closest approach\n    var minDist = Number.MAX_VALUE;\n    var p = [a1, a2, b1, b2];\n    var l1 = [b1, b1, a1, a1];\n    var l2 = [b2, b2, a2, a2];\n    var uv1 = [v[0], v[0], u[0], u[0]];\n    var uv2 = [u[0], u[0], v[0], v[0]];\n    var obj;\n    for (var i = 0; i < 4; i++) {\n      obj = distanceToLine(p[i], l1[i], l2[i]);\n      if (obj.distance < minDist) {\n        minDist = obj.distance;\n        uv1[i] = obj.t;\n        uv2[i] = i % 2;\n      }\n    }\n    return IntersectionState.ON_LINE;\n  }\n  u[0] = c[0];\n  v[0] = c[1]; // Check parametric coordinates for intersection.\n\n  if (u[0] >= 0.0 && u[0] <= 1.0 && v[0] >= 0.0 && v[0] <= 1.0) {\n    return IntersectionState.YES_INTERSECTION;\n  }\n  return IntersectionState.NO_INTERSECTION;\n} // ----------------------------------------------------------------------------\n// Static API\n// ----------------------------------------------------------------------------\n\nvar STATIC = {\n  distanceToLine: distanceToLine,\n  intersection: intersection\n}; // ----------------------------------------------------------------------------\n// vtkLine methods\n// ----------------------------------------------------------------------------\n\nfunction vtkLine(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkLine');\n  function isBetweenPoints(t) {\n    return t >= 0.0 && t <= 1.0;\n  }\n  publicAPI.getCellDimension = function () {\n    return 1;\n  };\n  publicAPI.intersectWithLine = function (p1, p2, tol, x, pcoords) {\n    var outObj = {\n      intersect: 0,\n      t: Number.MAX_VALUE,\n      subId: 0,\n      betweenPoints: null\n    };\n    pcoords[1] = 0.0;\n    pcoords[2] = 0.0;\n    var projXYZ = [];\n    var a1 = [];\n    var a2 = [];\n    model.points.getPoint(0, a1);\n    model.points.getPoint(1, a2);\n    var u = [];\n    var v = [];\n    var intersect = intersection(p1, p2, a1, a2, u, v);\n    outObj.t = u[0];\n    outObj.betweenPoints = isBetweenPoints(outObj.t);\n    pcoords[0] = v[0];\n    if (intersect === IntersectionState.YES_INTERSECTION) {\n      // make sure we are within tolerance\n      for (var i = 0; i < 3; i++) {\n        x[i] = a1[i] + pcoords[0] * (a2[i] - a1[i]);\n        projXYZ[i] = p1[i] + outObj.t * (p2[i] - p1[i]);\n      }\n      if (distance2BetweenPoints(x, projXYZ) <= tol * tol) {\n        outObj.intersect = 1;\n        return outObj;\n      }\n    } else {\n      var outDistance; // check to see if it lies within tolerance\n      // one of the parametric coords must be outside 0-1\n\n      if (outObj.t < 0.0) {\n        outDistance = distanceToLine(p1, a1, a2, x);\n        if (outDistance.distance <= tol * tol) {\n          outObj.t = 0.0;\n          outObj.intersect = 1;\n          outObj.betweenPoints = true; // Intersection is near p1\n\n          return outObj;\n        }\n        return outObj;\n      }\n      if (outObj.t > 1.0) {\n        outDistance = distanceToLine(p2, a1, a2, x);\n        if (outDistance.distance <= tol * tol) {\n          outObj.t = 1.0;\n          outObj.intersect = 1;\n          outObj.betweenPoints = true; // Intersection is near p2\n\n          return outObj;\n        }\n        return outObj;\n      }\n      if (pcoords[0] < 0.0) {\n        pcoords[0] = 0.0;\n        outDistance = distanceToLine(a1, p1, p2, x);\n        outObj.t = outDistance.t;\n        if (outDistance.distance <= tol * tol) {\n          outObj.intersect = 1;\n          return outObj;\n        }\n        return outObj;\n      }\n      if (pcoords[0] > 1.0) {\n        pcoords[0] = 1.0;\n        outDistance = distanceToLine(a2, p1, p2, x);\n        outObj.t = outDistance.t;\n        if (outDistance.distance <= tol * tol) {\n          outObj.intersect = 1;\n          return outObj;\n        }\n        return outObj;\n      }\n    }\n    return outObj;\n  };\n  publicAPI.evaluateLocation = function (pcoords, x, weights) {\n    var a1 = [];\n    var a2 = [];\n    model.points.getPoint(0, a1);\n    model.points.getPoint(1, a2);\n    for (var i = 0; i < 3; i++) {\n      x[i] = a1[i] + pcoords[0] * (a2[i] - a1[i]);\n    }\n    weights[0] = 1.0 - pcoords[0];\n    weights[1] = pcoords[0];\n  };\n  publicAPI.evaluateOrientation = function (pcoords, q, weights) {\n    if (model.orientations) {\n      quat.slerp(q, model.orientations[0], model.orientations[1], pcoords[0]);\n      weights[0] = 1.0 - pcoords[0];\n      weights[1] = pcoords[0];\n      return true;\n    }\n    return false;\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nvar DEFAULT_VALUES = {\n  orientations: null // an array of two quat or null\n}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n  vtkCell.extend(publicAPI, model, initialValues);\n  macro.setGet(publicAPI, model, ['orientations']);\n  vtkLine(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = macro.newInstance(extend, 'vtkLine'); // ----------------------------------------------------------------------------\n\nvar vtkLine$1 = _objectSpread(_objectSpread({\n  newInstance: newInstance,\n  extend: extend\n}, STATIC), Constants);\nexport { STATIC, vtkLine$1 as default, extend, newInstance };","map":{"version":3,"names":["_defineProperty","macro","Constants","vtkCell","d","dot","e","distance2BetweenPoints","s","subtract","g","solveLinearSystem","quat","ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","getOwnPropertyDescriptors","defineProperties","defineProperty","IntersectionState","distanceToLine","x","p1","p2","closestPoint","undefined","outObj","t","Number","MIN_VALUE","distance","p21","closest","num","denom","tolerance","intersection","a1","a2","b1","b2","u","v","a21","b21","b1a1","A","c","minDist","MAX_VALUE","p","l1","l2","uv1","uv2","obj","ON_LINE","YES_INTERSECTION","NO_INTERSECTION","STATIC","vtkLine","publicAPI","model","classHierarchy","isBetweenPoints","getCellDimension","intersectWithLine","tol","pcoords","intersect","subId","betweenPoints","projXYZ","points","getPoint","outDistance","evaluateLocation","weights","evaluateOrientation","q","orientations","slerp","DEFAULT_VALUES","extend","initialValues","assign","setGet","newInstance","vtkLine$1","default"],"sources":["/home/rakshith/Documents/RemoteRendering/vtk-js-react-app/node_modules/@kitware/vtk.js/Common/DataModel/Line.js"],"sourcesContent":["import _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport macro from '../../macros.js';\nimport Constants from './Line/Constants.js';\nimport vtkCell from './Cell.js';\nimport { d as dot, e as distance2BetweenPoints, s as subtract, g as solveLinearSystem } from '../Core/Math/index.js';\nimport { quat } from 'gl-matrix';\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nvar IntersectionState = Constants.IntersectionState; // ----------------------------------------------------------------------------\n// Global methods\n// ----------------------------------------------------------------------------\n\nfunction distanceToLine(x, p1, p2) {\n  var closestPoint = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  var outObj = {\n    t: Number.MIN_VALUE,\n    distance: 0\n  };\n  var p21 = [];\n  var closest; // Determine appropriate vector\n\n  p21[0] = p2[0] - p1[0];\n  p21[1] = p2[1] - p1[1];\n  p21[2] = p2[2] - p1[2]; // Get parametric location\n\n  var num = p21[0] * (x[0] - p1[0]) + p21[1] * (x[1] - p1[1]) + p21[2] * (x[2] - p1[2]);\n  var denom = dot(p21, p21); // trying to avoid an expensive fabs\n\n  var tolerance = 1e-5 * num;\n\n  if (denom !== 0.0) {\n    outObj.t = num / denom;\n  }\n\n  if (tolerance < 0.0) {\n    tolerance = -tolerance;\n  }\n\n  if (-tolerance < denom && denom < tolerance) {\n    closest = p1;\n  } else if (denom <= 0.0 || outObj.t < 0.0) {\n    // If parametric coordinate is within 0<=p<=1, then the point is closest to\n    // the line.  Otherwise, it's closest to a point at the end of the line.\n    closest = p1;\n  } else if (outObj.t > 1.0) {\n    closest = p2;\n  } else {\n    closest = p21;\n    p21[0] = p1[0] + outObj.t * p21[0];\n    p21[1] = p1[1] + outObj.t * p21[1];\n    p21[2] = p1[2] + outObj.t * p21[2];\n  }\n\n  if (closestPoint) {\n    closestPoint[0] = closest[0];\n    closestPoint[1] = closest[1];\n    closestPoint[2] = closest[2];\n  }\n\n  outObj.distance = distance2BetweenPoints(closest, x);\n  return outObj;\n}\n\nfunction intersection(a1, a2, b1, b2, u, v) {\n  var a21 = [];\n  var b21 = [];\n  var b1a1 = [];\n  u[0] = 0.0;\n  v[0] = 0.0; // Determine line vectors.\n\n  subtract(a2, a1, a21);\n  subtract(b2, b1, b21);\n  subtract(b1, a1, b1a1); // Compute the system (least squares) matrix.\n\n  var A = [dot(a21, a21), -dot(a21, b21), -dot(a21, b21), dot(b21, b21)]; // Compute the least squares system constant term.\n\n  var c = [];\n  c[0] = dot(a21, b1a1);\n  c[1] = -dot(b21, b1a1); // Solve the system of equations\n\n  if (solveLinearSystem(A, c, 2) === 0) {\n    // The lines are colinear. Therefore, one of the four endpoints is the\n    // point of closest approach\n    var minDist = Number.MAX_VALUE;\n    var p = [a1, a2, b1, b2];\n    var l1 = [b1, b1, a1, a1];\n    var l2 = [b2, b2, a2, a2];\n    var uv1 = [v[0], v[0], u[0], u[0]];\n    var uv2 = [u[0], u[0], v[0], v[0]];\n    var obj;\n\n    for (var i = 0; i < 4; i++) {\n      obj = distanceToLine(p[i], l1[i], l2[i]);\n\n      if (obj.distance < minDist) {\n        minDist = obj.distance;\n        uv1[i] = obj.t;\n        uv2[i] = i % 2;\n      }\n    }\n\n    return IntersectionState.ON_LINE;\n  }\n\n  u[0] = c[0];\n  v[0] = c[1]; // Check parametric coordinates for intersection.\n\n  if (u[0] >= 0.0 && u[0] <= 1.0 && v[0] >= 0.0 && v[0] <= 1.0) {\n    return IntersectionState.YES_INTERSECTION;\n  }\n\n  return IntersectionState.NO_INTERSECTION;\n} // ----------------------------------------------------------------------------\n// Static API\n// ----------------------------------------------------------------------------\n\n\nvar STATIC = {\n  distanceToLine: distanceToLine,\n  intersection: intersection\n}; // ----------------------------------------------------------------------------\n// vtkLine methods\n// ----------------------------------------------------------------------------\n\nfunction vtkLine(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkLine');\n\n  function isBetweenPoints(t) {\n    return t >= 0.0 && t <= 1.0;\n  }\n\n  publicAPI.getCellDimension = function () {\n    return 1;\n  };\n\n  publicAPI.intersectWithLine = function (p1, p2, tol, x, pcoords) {\n    var outObj = {\n      intersect: 0,\n      t: Number.MAX_VALUE,\n      subId: 0,\n      betweenPoints: null\n    };\n    pcoords[1] = 0.0;\n    pcoords[2] = 0.0;\n    var projXYZ = [];\n    var a1 = [];\n    var a2 = [];\n    model.points.getPoint(0, a1);\n    model.points.getPoint(1, a2);\n    var u = [];\n    var v = [];\n    var intersect = intersection(p1, p2, a1, a2, u, v);\n    outObj.t = u[0];\n    outObj.betweenPoints = isBetweenPoints(outObj.t);\n    pcoords[0] = v[0];\n\n    if (intersect === IntersectionState.YES_INTERSECTION) {\n      // make sure we are within tolerance\n      for (var i = 0; i < 3; i++) {\n        x[i] = a1[i] + pcoords[0] * (a2[i] - a1[i]);\n        projXYZ[i] = p1[i] + outObj.t * (p2[i] - p1[i]);\n      }\n\n      if (distance2BetweenPoints(x, projXYZ) <= tol * tol) {\n        outObj.intersect = 1;\n        return outObj;\n      }\n    } else {\n      var outDistance; // check to see if it lies within tolerance\n      // one of the parametric coords must be outside 0-1\n\n      if (outObj.t < 0.0) {\n        outDistance = distanceToLine(p1, a1, a2, x);\n\n        if (outDistance.distance <= tol * tol) {\n          outObj.t = 0.0;\n          outObj.intersect = 1;\n          outObj.betweenPoints = true; // Intersection is near p1\n\n          return outObj;\n        }\n\n        return outObj;\n      }\n\n      if (outObj.t > 1.0) {\n        outDistance = distanceToLine(p2, a1, a2, x);\n\n        if (outDistance.distance <= tol * tol) {\n          outObj.t = 1.0;\n          outObj.intersect = 1;\n          outObj.betweenPoints = true; // Intersection is near p2\n\n          return outObj;\n        }\n\n        return outObj;\n      }\n\n      if (pcoords[0] < 0.0) {\n        pcoords[0] = 0.0;\n        outDistance = distanceToLine(a1, p1, p2, x);\n        outObj.t = outDistance.t;\n\n        if (outDistance.distance <= tol * tol) {\n          outObj.intersect = 1;\n          return outObj;\n        }\n\n        return outObj;\n      }\n\n      if (pcoords[0] > 1.0) {\n        pcoords[0] = 1.0;\n        outDistance = distanceToLine(a2, p1, p2, x);\n        outObj.t = outDistance.t;\n\n        if (outDistance.distance <= tol * tol) {\n          outObj.intersect = 1;\n          return outObj;\n        }\n\n        return outObj;\n      }\n    }\n\n    return outObj;\n  };\n\n  publicAPI.evaluateLocation = function (pcoords, x, weights) {\n    var a1 = [];\n    var a2 = [];\n    model.points.getPoint(0, a1);\n    model.points.getPoint(1, a2);\n\n    for (var i = 0; i < 3; i++) {\n      x[i] = a1[i] + pcoords[0] * (a2[i] - a1[i]);\n    }\n\n    weights[0] = 1.0 - pcoords[0];\n    weights[1] = pcoords[0];\n  };\n\n  publicAPI.evaluateOrientation = function (pcoords, q, weights) {\n    if (model.orientations) {\n      quat.slerp(q, model.orientations[0], model.orientations[1], pcoords[0]);\n      weights[0] = 1.0 - pcoords[0];\n      weights[1] = pcoords[0];\n      return true;\n    }\n\n    return false;\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\n\nvar DEFAULT_VALUES = {\n  orientations: null // an array of two quat or null\n\n}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n  vtkCell.extend(publicAPI, model, initialValues);\n  macro.setGet(publicAPI, model, ['orientations']);\n  vtkLine(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = macro.newInstance(extend, 'vtkLine'); // ----------------------------------------------------------------------------\n\nvar vtkLine$1 = _objectSpread(_objectSpread({\n  newInstance: newInstance,\n  extend: extend\n}, STATIC), Constants);\n\nexport { STATIC, vtkLine$1 as default, extend, newInstance };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}