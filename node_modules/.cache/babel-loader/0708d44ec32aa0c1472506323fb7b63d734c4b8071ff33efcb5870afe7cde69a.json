{"ast":null,"code":"// Helper borrowed from paraviewweb/src/Common/Core\nimport CompositeClosureHelper from '../CompositeClosureHelper';\nimport JSON5 from 'json5';\nfunction defer() {\n  var deferred = {};\n  deferred.promise = new Promise(function (resolve, reject) {\n    deferred.resolve = resolve;\n    deferred.reject = reject;\n  });\n  return deferred;\n}\nfunction Session(publicAPI, model) {\n  var CLIENT_ERROR = -32099;\n  var msgCount = 0;\n  var inFlightRpc = {};\n  var attachments = [];\n  var attachmentsToSend = {};\n  var attachmentId = 1;\n  var regexAttach = /^wslink_bin[\\d]+$/;\n  // matches 'rpc:client3:21'\n  // client may be dot-separated and include '_'\n  // number is message count - unique.\n  // matches 'publish:dot.separated.topic:42'\n  var regexRPC = /^(rpc|publish|system):(\\w+(?:\\.\\w+)*):(?:\\d+)$/;\n  var subscriptions = {};\n  var clientID = null;\n\n  // --------------------------------------------------------------------------\n  // Private helpers\n  // --------------------------------------------------------------------------\n\n  function sendBinary(key) {\n    if (key in attachmentsToSend) {\n      // binary header\n      model.ws.send(JSON.stringify({\n        wslink: '1.0',\n        method: 'wslink.binary.attachment',\n        args: [key]\n      }));\n\n      // send binary\n      model.ws.send(attachmentsToSend[key], {\n        binary: true\n      });\n      delete attachmentsToSend[key];\n    }\n  }\n\n  // --------------------------------------------------------------------------\n\n  function findBinary(o) {\n    if (o) {\n      if (Array.isArray(o)) {\n        o.forEach(function (v) {\n          return findBinary(v);\n        });\n      } else if (o.constructor === Object) {\n        Object.keys(o).forEach(function (k) {\n          return findBinary(o[k]);\n        });\n      } else if (regexAttach.test(o)) {\n        sendBinary(o);\n      }\n    }\n  }\n\n  // --------------------------------------------------------------------------\n  // split out to support a message with a bare binary attachment.\n  // --------------------------------------------------------------------------\n\n  function getAttachment(binaryKey) {\n    // console.log('Adding binary attachment', binaryKey);\n    var index = attachments.findIndex(function (att) {\n      return att.key === binaryKey;\n    });\n    if (index !== -1) {\n      var result = attachments[index].data;\n      // TODO if attachment is sent mulitple times, we shouldn't remove it yet.\n      attachments.splice(index, 1);\n      return result;\n    }\n    console.error('Binary attachment key found without matching attachment');\n    return null;\n  }\n\n  // --------------------------------------------------------------------------\n  // To do a full traversal of nested objects/lists, we need recursion.\n  // --------------------------------------------------------------------------\n\n  function addAttachment(obj_list) {\n    for (var key in obj_list) {\n      if (typeof obj_list[key] === 'string' && regexAttach.test(obj_list[key])) {\n        var binaryKey = obj_list[key];\n        var replacement = getAttachment(binaryKey);\n        if (replacement !== null) obj_list[key] = replacement;\n      } else if (typeof obj_list[key] === 'object') {\n        // arrays are also 'object' with this test.\n        addAttachment(obj_list[key]);\n      }\n    }\n  }\n\n  // --------------------------------------------------------------------------\n  // Public API\n  // --------------------------------------------------------------------------\n\n  publicAPI.onconnect = function (event) {\n    // send hello message\n    var deferred = defer();\n    var id = 'system:c0:0';\n    inFlightRpc[id] = deferred;\n    model.ws.send(JSON.stringify({\n      wslink: '1.0',\n      id: id,\n      method: 'wslink.hello',\n      args: [{\n        secret: model.secret\n      }],\n      kwargs: {}\n    }));\n    return deferred.promise;\n  };\n\n  // --------------------------------------------------------------------------\n\n  publicAPI.call = function (method) {\n    var args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    var kwargs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    // create a promise that we will use to notify the caller of the result.\n    var deferred = defer();\n    // readyState OPEN === 1\n    if (model.ws && clientID && model.ws.readyState === 1) {\n      var id = \"rpc:\".concat(clientID, \":\").concat(msgCount++);\n      inFlightRpc[id] = deferred;\n      var msg = JSON.stringify({\n        wslink: '1.0',\n        id: id,\n        method: method,\n        args: args,\n        kwargs: kwargs\n      });\n      if (Object.keys(attachmentsToSend).length) {\n        findBinary(args);\n        findBinary(kwargs);\n      }\n      model.ws.send(JSON.stringify({\n        wslink: '1.0',\n        id: id,\n        method: method,\n        args: args,\n        kwargs: kwargs\n      }));\n    } else {\n      deferred.reject({\n        code: CLIENT_ERROR,\n        message: \"RPC call \".concat(method, \" unsuccessful: connection not open\")\n      });\n    }\n    return deferred.promise;\n  };\n\n  // --------------------------------------------------------------------------\n\n  publicAPI.subscribe = function (topic, callback) {\n    var deferred = defer();\n    if (model.ws && clientID) {\n      // we needs to track subscriptions, to trigger callback when publish is received.\n      if (!subscriptions[topic]) subscriptions[topic] = [];\n      subscriptions[topic].push(callback);\n      // we can notify the server, but we don't need to, if the server always sends messages unconditionally.\n      // model.ws.send(JSON.stringify({ wslink: '1.0', id: `subscribe:${msgCount++}`, method, args: [] }));\n      deferred.resolve({\n        topic: topic,\n        callback: callback\n      });\n    } else {\n      deferred.reject({\n        code: CLIENT_ERROR,\n        message: \"Subscribe call \".concat(topic, \" unsuccessful: connection not open\")\n      });\n    }\n    return {\n      topic: topic,\n      callback: callback,\n      promise: deferred.promise,\n      unsubscribe: function unsubscribe() {\n        return publicAPI.unsubscribe({\n          topic: topic,\n          callback: callback\n        });\n      }\n    };\n  };\n\n  // --------------------------------------------------------------------------\n\n  publicAPI.unsubscribe = function (info) {\n    var deferred = defer();\n    var topic = info.topic,\n      callback = info.callback;\n    if (!subscriptions[topic]) {\n      deferred.reject({\n        code: CLIENT_ERROR,\n        message: \"Unsubscribe call \".concat(topic, \" unsuccessful: not subscribed\")\n      });\n      return deferred.promise;\n    }\n    var index = subscriptions[topic].indexOf(callback);\n    if (index !== -1) {\n      subscriptions[topic].splice(index, 1);\n      deferred.resolve();\n    } else {\n      deferred.reject({\n        code: CLIENT_ERROR,\n        message: \"Unsubscribe call \".concat(topic, \" unsuccessful: callback not found\")\n      });\n    }\n    return deferred.promise;\n  };\n\n  // --------------------------------------------------------------------------\n\n  publicAPI.close = function () {\n    var deferred = defer();\n    // some transports might be able to close the session without closing the connection. Not true for websocket...\n    model.ws.close();\n    deferred.resolve();\n    return deferred.promise;\n  };\n\n  // --------------------------------------------------------------------------\n\n  publicAPI.onmessage = function (event) {\n    if (event.data instanceof ArrayBuffer || event.data instanceof Blob) {\n      // we've gotten a header with the keys for this binary data.\n      // we will soon receive a json message with embedded ids of the binary objects.\n      // Save with it's key, in order.\n      // console.log('Saving binary attachment');\n      var foundIt = false;\n      for (var i = 0; i < attachments.length; i++) {\n        if (attachments[i].data === null) {\n          attachments[i].data = event.data;\n          foundIt = true;\n          break;\n        }\n      }\n      if (!foundIt) {\n        console.error('Missing header for received binary message');\n      }\n    } else {\n      var payload;\n      try {\n        payload = JSON5.parse(event.data);\n      } catch (e) {\n        console.error('Malformed message: ', event.data);\n        // debugger;\n      }\n\n      if (!payload) return;\n      if (!payload.id) {\n        // Notification-only message from the server - should be binary attachment header\n        // console.log('Notify', payload);\n        if (payload.method === 'wslink.binary.attachment') {\n          payload.args.forEach(function (key) {\n            attachments.push({\n              key: key,\n              data: null\n            });\n          });\n        }\n        return;\n      }\n      if (payload.error) {\n        // kill any attachments\n        attachments.length = 0;\n        var deferred = inFlightRpc[payload.id];\n        if (deferred) {\n          deferred.reject(payload.error);\n        } else {\n          console.error('Server error:', payload.error);\n        }\n      } else {\n        if (payload.result && attachments.length > 0) {\n          if (typeof payload.result === 'string' && regexAttach.test(payload.result)) {\n            var replacement = getAttachment(payload.result);\n            if (replacement !== null) payload.result = replacement;\n          } else {\n            addAttachment(payload.result);\n          }\n        }\n        var match = regexRPC.exec(payload.id);\n        if (match) {\n          var type = match[1];\n          if (type === 'rpc') {\n            var _deferred = inFlightRpc[payload.id];\n            if (!_deferred) {\n              console.log('session message id without matching call, dropped', payload);\n              return;\n            }\n            _deferred.resolve(payload.result);\n          } else if (type == 'publish') {\n            console.assert(inFlightRpc[payload.id] === undefined, 'publish message received matching in-flight rpc call');\n            // regex extracts the topic for us.\n            var topic = match[2];\n            if (!subscriptions[topic]) {\n              return;\n            }\n            // for each callback, provide the message data. Wrap in an array, for back-compatibility with WAMP\n            subscriptions[topic].forEach(function (callback) {\n              return callback([payload.result]);\n            });\n          } else if (type == 'system') {\n            // console.log('DBG system:', payload.id, payload.result);\n            var _deferred2 = inFlightRpc[payload.id];\n            if (payload.id === 'system:c0:0') {\n              clientID = payload.result.clientID;\n              if (_deferred2) _deferred2.resolve(clientID);\n            } else {\n              console.error('Unknown system message', payload.id);\n              if (_deferred2) _deferred2.reject({\n                code: CLIENT_ERROR,\n                message: \"Unknown system message \".concat(payload.id)\n              });\n            }\n          } else {\n            console.error('Unknown rpc id format', payload.id);\n          }\n        }\n      }\n      delete inFlightRpc[payload.id];\n    }\n  };\n\n  // --------------------------------------------------------------------------\n\n  publicAPI.addAttachment = function (payload) {\n    var binaryId = \"wslink_bin\".concat(attachmentId);\n    attachmentsToSend[binaryId] = payload;\n    attachmentId++;\n    return binaryId;\n  };\n}\nvar DEFAULT_VALUES = {\n  secret: 'wslink-secret',\n  ws: null\n};\nexport function extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n  CompositeClosureHelper.destroy(publicAPI, model);\n  CompositeClosureHelper.isA(publicAPI, model, 'Session');\n  Session(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nexport var newInstance = CompositeClosureHelper.newInstance(extend);\n\n// ----------------------------------------------------------------------------\n\nexport default {\n  newInstance: newInstance,\n  extend: extend\n};","map":{"version":3,"names":["CompositeClosureHelper","JSON5","defer","deferred","promise","Promise","resolve","reject","Session","publicAPI","model","CLIENT_ERROR","msgCount","inFlightRpc","attachments","attachmentsToSend","attachmentId","regexAttach","regexRPC","subscriptions","clientID","sendBinary","key","ws","send","JSON","stringify","wslink","method","args","binary","findBinary","o","Array","isArray","forEach","v","constructor","Object","keys","k","test","getAttachment","binaryKey","index","findIndex","att","result","data","splice","console","error","addAttachment","obj_list","replacement","onconnect","event","id","secret","kwargs","call","arguments","length","undefined","readyState","concat","msg","code","message","subscribe","topic","callback","push","unsubscribe","info","indexOf","close","onmessage","ArrayBuffer","Blob","foundIt","i","payload","parse","e","match","exec","type","log","assert","binaryId","DEFAULT_VALUES","extend","initialValues","assign","destroy","isA","newInstance"],"sources":["/home/rakshith/Documents/RemoteRendering/vtk-js-react-app/node_modules/wslink/src/WebsocketConnection/session.js"],"sourcesContent":["// Helper borrowed from paraviewweb/src/Common/Core\nimport CompositeClosureHelper from '../CompositeClosureHelper';\nimport JSON5 from 'json5';\n\nfunction defer() {\n  const deferred = {};\n\n  deferred.promise = new Promise(function (resolve, reject) {\n    deferred.resolve = resolve;\n    deferred.reject = reject;\n  });\n\n  return deferred;\n}\n\nfunction Session(publicAPI, model) {\n  const CLIENT_ERROR = -32099;\n  let msgCount = 0;\n  const inFlightRpc = {};\n  const attachments = [];\n  const attachmentsToSend = {};\n  let attachmentId = 1;\n  const regexAttach = /^wslink_bin[\\d]+$/;\n  // matches 'rpc:client3:21'\n  // client may be dot-separated and include '_'\n  // number is message count - unique.\n  // matches 'publish:dot.separated.topic:42'\n  const regexRPC = /^(rpc|publish|system):(\\w+(?:\\.\\w+)*):(?:\\d+)$/;\n  const subscriptions = {};\n  let clientID = null;\n\n  // --------------------------------------------------------------------------\n  // Private helpers\n  // --------------------------------------------------------------------------\n\n  function sendBinary(key) {\n    if (key in attachmentsToSend) {\n      // binary header\n      model.ws.send(\n        JSON.stringify({\n          wslink: '1.0',\n          method: 'wslink.binary.attachment',\n          args: [key],\n        })\n      );\n\n      // send binary\n      model.ws.send(attachmentsToSend[key], { binary: true });\n      delete attachmentsToSend[key];\n    }\n  }\n\n  // --------------------------------------------------------------------------\n\n  function findBinary(o) {\n    if (o) {\n      if (Array.isArray(o)) {\n        o.forEach((v) => findBinary(v));\n      } else if (o.constructor === Object) {\n        Object.keys(o).forEach((k) => findBinary(o[k]));\n      } else if (regexAttach.test(o)) {\n        sendBinary(o);\n      }\n    }\n  }\n\n  // --------------------------------------------------------------------------\n  // split out to support a message with a bare binary attachment.\n  // --------------------------------------------------------------------------\n\n  function getAttachment(binaryKey) {\n    // console.log('Adding binary attachment', binaryKey);\n    const index = attachments.findIndex((att) => att.key === binaryKey);\n    if (index !== -1) {\n      const result = attachments[index].data;\n      // TODO if attachment is sent mulitple times, we shouldn't remove it yet.\n      attachments.splice(index, 1);\n      return result;\n    }\n    console.error('Binary attachment key found without matching attachment');\n    return null;\n  }\n\n  // --------------------------------------------------------------------------\n  // To do a full traversal of nested objects/lists, we need recursion.\n  // --------------------------------------------------------------------------\n\n  function addAttachment(obj_list) {\n    for (let key in obj_list) {\n      if (\n        typeof obj_list[key] === 'string' &&\n        regexAttach.test(obj_list[key])\n      ) {\n        const binaryKey = obj_list[key];\n        const replacement = getAttachment(binaryKey);\n        if (replacement !== null) obj_list[key] = replacement;\n      } else if (typeof obj_list[key] === 'object') {\n        // arrays are also 'object' with this test.\n        addAttachment(obj_list[key]);\n      }\n    }\n  }\n\n  // --------------------------------------------------------------------------\n  // Public API\n  // --------------------------------------------------------------------------\n\n  publicAPI.onconnect = (event) => {\n    // send hello message\n    const deferred = defer();\n    const id = 'system:c0:0';\n    inFlightRpc[id] = deferred;\n    model.ws.send(\n      JSON.stringify({\n        wslink: '1.0',\n        id,\n        method: 'wslink.hello',\n        args: [{ secret: model.secret }],\n        kwargs: {},\n      })\n    );\n    return deferred.promise;\n  };\n\n  // --------------------------------------------------------------------------\n\n  publicAPI.call = (method, args = [], kwargs = {}) => {\n    // create a promise that we will use to notify the caller of the result.\n    const deferred = defer();\n    // readyState OPEN === 1\n    if (model.ws && clientID && model.ws.readyState === 1) {\n      const id = `rpc:${clientID}:${msgCount++}`;\n      inFlightRpc[id] = deferred;\n      const msg = JSON.stringify({ wslink: '1.0', id, method, args, kwargs });\n\n      if (Object.keys(attachmentsToSend).length) {\n        findBinary(args);\n        findBinary(kwargs);\n      }\n\n      model.ws.send(\n        JSON.stringify({ wslink: '1.0', id, method, args, kwargs })\n      );\n    } else {\n      deferred.reject({\n        code: CLIENT_ERROR,\n        message: `RPC call ${method} unsuccessful: connection not open`,\n      });\n    }\n    return deferred.promise;\n  };\n\n  // --------------------------------------------------------------------------\n\n  publicAPI.subscribe = (topic, callback) => {\n    const deferred = defer();\n    if (model.ws && clientID) {\n      // we needs to track subscriptions, to trigger callback when publish is received.\n      if (!subscriptions[topic]) subscriptions[topic] = [];\n      subscriptions[topic].push(callback);\n      // we can notify the server, but we don't need to, if the server always sends messages unconditionally.\n      // model.ws.send(JSON.stringify({ wslink: '1.0', id: `subscribe:${msgCount++}`, method, args: [] }));\n      deferred.resolve({ topic, callback });\n    } else {\n      deferred.reject({\n        code: CLIENT_ERROR,\n        message: `Subscribe call ${topic} unsuccessful: connection not open`,\n      });\n    }\n    return {\n      topic,\n      callback,\n      promise: deferred.promise,\n      unsubscribe: () => publicAPI.unsubscribe({ topic, callback }),\n    };\n  };\n\n  // --------------------------------------------------------------------------\n\n  publicAPI.unsubscribe = (info) => {\n    const deferred = defer();\n    const { topic, callback } = info;\n    if (!subscriptions[topic]) {\n      deferred.reject({\n        code: CLIENT_ERROR,\n        message: `Unsubscribe call ${topic} unsuccessful: not subscribed`,\n      });\n      return deferred.promise;\n    }\n    const index = subscriptions[topic].indexOf(callback);\n    if (index !== -1) {\n      subscriptions[topic].splice(index, 1);\n      deferred.resolve();\n    } else {\n      deferred.reject({\n        code: CLIENT_ERROR,\n        message: `Unsubscribe call ${topic} unsuccessful: callback not found`,\n      });\n    }\n    return deferred.promise;\n  };\n\n  // --------------------------------------------------------------------------\n\n  publicAPI.close = () => {\n    const deferred = defer();\n    // some transports might be able to close the session without closing the connection. Not true for websocket...\n    model.ws.close();\n    deferred.resolve();\n    return deferred.promise;\n  };\n\n  // --------------------------------------------------------------------------\n\n  publicAPI.onmessage = (event) => {\n    if (event.data instanceof ArrayBuffer || event.data instanceof Blob) {\n      // we've gotten a header with the keys for this binary data.\n      // we will soon receive a json message with embedded ids of the binary objects.\n      // Save with it's key, in order.\n      // console.log('Saving binary attachment');\n      let foundIt = false;\n      for (let i = 0; i < attachments.length; i++) {\n        if (attachments[i].data === null) {\n          attachments[i].data = event.data;\n          foundIt = true;\n          break;\n        }\n      }\n      if (!foundIt) {\n        console.error('Missing header for received binary message');\n      }\n    } else {\n      let payload;\n      try {\n        payload = JSON5.parse(event.data);\n      } catch (e) {\n        console.error('Malformed message: ', event.data);\n        // debugger;\n      }\n      if (!payload) return;\n      if (!payload.id) {\n        // Notification-only message from the server - should be binary attachment header\n        // console.log('Notify', payload);\n        if (payload.method === 'wslink.binary.attachment') {\n          payload.args.forEach((key) => {\n            attachments.push({ key, data: null });\n          });\n        }\n        return;\n      }\n      if (payload.error) {\n        // kill any attachments\n        attachments.length = 0;\n        const deferred = inFlightRpc[payload.id];\n        if (deferred) {\n          deferred.reject(payload.error);\n        } else {\n          console.error('Server error:', payload.error);\n        }\n      } else {\n        if (payload.result && attachments.length > 0) {\n          if (\n            typeof payload.result === 'string' &&\n            regexAttach.test(payload.result)\n          ) {\n            const replacement = getAttachment(payload.result);\n            if (replacement !== null) payload.result = replacement;\n          } else {\n            addAttachment(payload.result);\n          }\n        }\n        const match = regexRPC.exec(payload.id);\n        if (match) {\n          const type = match[1];\n          if (type === 'rpc') {\n            const deferred = inFlightRpc[payload.id];\n            if (!deferred) {\n              console.log(\n                'session message id without matching call, dropped',\n                payload\n              );\n              return;\n            }\n            deferred.resolve(payload.result);\n          } else if (type == 'publish') {\n            console.assert(\n              inFlightRpc[payload.id] === undefined,\n              'publish message received matching in-flight rpc call'\n            );\n            // regex extracts the topic for us.\n            const topic = match[2];\n            if (!subscriptions[topic]) {\n              return;\n            }\n            // for each callback, provide the message data. Wrap in an array, for back-compatibility with WAMP\n            subscriptions[topic].forEach((callback) =>\n              callback([payload.result])\n            );\n          } else if (type == 'system') {\n            // console.log('DBG system:', payload.id, payload.result);\n            const deferred = inFlightRpc[payload.id];\n            if (payload.id === 'system:c0:0') {\n              clientID = payload.result.clientID;\n              if (deferred) deferred.resolve(clientID);\n            } else {\n              console.error('Unknown system message', payload.id);\n              if (deferred)\n                deferred.reject({\n                  code: CLIENT_ERROR,\n                  message: `Unknown system message ${payload.id}`,\n                });\n            }\n          } else {\n            console.error('Unknown rpc id format', payload.id);\n          }\n        }\n      }\n      delete inFlightRpc[payload.id];\n    }\n  };\n\n  // --------------------------------------------------------------------------\n\n  publicAPI.addAttachment = (payload) => {\n    const binaryId = `wslink_bin${attachmentId}`;\n    attachmentsToSend[binaryId] = payload;\n    attachmentId++;\n    return binaryId;\n  };\n}\n\nconst DEFAULT_VALUES = {\n  secret: 'wslink-secret',\n  ws: null,\n};\n\nexport function extend(publicAPI, model, initialValues = {}) {\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  CompositeClosureHelper.destroy(publicAPI, model);\n  CompositeClosureHelper.isA(publicAPI, model, 'Session');\n\n  Session(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nexport const newInstance = CompositeClosureHelper.newInstance(extend);\n\n// ----------------------------------------------------------------------------\n\nexport default { newInstance, extend };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}