import _defineProperty from '@babel/runtime/helpers/defineProperty';
import macro from '../../macros.js';
import vtkCubeSource from '../Sources/CubeSource.js';

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
var vtkErrorMacro = macro.vtkErrorMacro; // ----------------------------------------------------------------------------
// vtkImageDataOutlineFilter methods
// ----------------------------------------------------------------------------

function vtkImageDataOutlineFilter(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkImageDataOutlineFilter'); // Capture "parentClass" api for internal use

  var superClass = _objectSpread({}, publicAPI);

  publicAPI.requestData = function (inData, outData) {
    // implement requestData
    var input = inData[0];

    if (!input || !input.isA('vtkImageData')) {
      vtkErrorMacro('Invalid or missing input');
      return;
    } // First create a cube polydata in the index-space of the image.
    // The benefit of using `getSpatialExtent` call is that it automatically
    // takes care of 0.5 voxel padding as required by an vtkImageData representation.


    var spatialExt = input.getSpatialExtent();

    if (!spatialExt) {
      vtkErrorMacro('Unable to fetch spatial extents of input image.');
      return;
    }

    model._cubeSource.setBounds(spatialExt); // Then apply index-to-world transform to the cube to create the outline.


    model._cubeSource.setMatrix(input.getIndexToWorld());

    outData[0] = model._cubeSource.getOutputData();
  };

  publicAPI.getMTime = function () {
    return Math.max(superClass.getMTime(), model._cubeSource.getMTime());
  }; // Forward calls for [set/get]Generate[Faces/Lines] functions to cubeSource:


  publicAPI.setGenerateFaces = model._cubeSource.setGenerateFaces;
  publicAPI.setGenerateLines = model._cubeSource.setGenerateLines;
  publicAPI.getGenerateFaces = model._cubeSource.getGenerateFaces;
  publicAPI.getGenerateLines = model._cubeSource.getGenerateLines;
} // ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------


var DEFAULT_VALUES = {}; // ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues); // Make this a VTK object

  macro.obj(publicAPI, model); // Also make it an algorithm with one input and one output

  macro.algo(publicAPI, model, 1, 1); // Internal persistent objects

  model._cubeSource = vtkCubeSource.newInstance();
  macro.moveToProtected(publicAPI, model, ['cubeSource', 'tmpOut']); // Object specific methods

  vtkImageDataOutlineFilter(publicAPI, model);
} // ----------------------------------------------------------------------------

var newInstance = macro.newInstance(extend, 'vtkImageDataOutlineFilter'); // ----------------------------------------------------------------------------

var vtkImageDataOutlineFilter$1 = {
  newInstance: newInstance,
  extend: extend
};

export { vtkImageDataOutlineFilter$1 as default, extend, newInstance };
