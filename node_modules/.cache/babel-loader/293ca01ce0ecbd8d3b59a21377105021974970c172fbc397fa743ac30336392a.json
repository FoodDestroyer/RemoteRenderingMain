{"ast":null,"code":"import _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport macro from '../../macros.js';\nimport vtkAbstractImageInterpolator from './AbstractImageInterpolator.js';\nimport { vtkInterpolationMathRound, vtkInterpolationMathClamp, vtkInterpolationMathMirror, vtkInterpolationMathWrap, vtkInterpolationMathFloor, vtkInterpolationWeights } from './AbstractImageInterpolator/InterpolationInfo.js';\nimport { InterpolationMode, ImageBorderMode } from './AbstractImageInterpolator/Constants.js';\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n  return target;\n}\n// vtkImageInterpolator methods\n// ----------------------------------------------------------------------------\n\nfunction vtkImageInterpolator(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkImageInterpolator');\n  publicAPI.computeSupportSize = function (matrix) {\n    var s = 1;\n    if (model.interpolationMode === InterpolationMode.LINEAR) {\n      s = 2;\n    } else if (model.interpolationMode === InterpolationMode.CUBIC) {\n      s = 4;\n    }\n    var size = [s, s, s];\n    if (matrix == null) {\n      return size;\n    } // TODO CHECK MATRIX\n\n    if (matrix[12] !== 0 || matrix[13] !== 0 || matrix[14] !== 0 || matrix[15] !== 1) {\n      return size;\n    }\n    for (var i = 0; i < 3; ++i) {\n      var integerRow = true;\n      for (var j = 0; j < 3; ++j) {\n        integerRow = integerRow && Number.isInteger(matrix[4 * i + j]);\n      }\n      if (integerRow) {\n        size[i] = 1;\n      }\n    }\n    return size;\n  };\n  publicAPI.internalUpdate = function () {\n    model.interpolationInfo.interpolationMode = model.interpolationMode;\n  };\n  publicAPI.isSeparable = function () {\n    return true;\n  };\n  publicAPI.interpolateNearest = function (interpolationInfo, point, value) {\n    var inExt = interpolationInfo.extent;\n    var inInc = interpolationInfo.increments;\n    var numscalars = interpolationInfo.numberOfComponents;\n    var inIdX0 = vtkInterpolationMathRound(point[0]);\n    var inIdY0 = vtkInterpolationMathRound(point[1]);\n    var inIdZ0 = vtkInterpolationMathRound(point[2]);\n    switch (interpolationInfo.borderMode) {\n      case ImageBorderMode.REPEAT:\n        inIdX0 = vtkInterpolationMathWrap(inIdX0, inExt[0], inExt[1]);\n        inIdY0 = vtkInterpolationMathWrap(inIdY0, inExt[2], inExt[3]);\n        inIdZ0 = vtkInterpolationMathWrap(inIdZ0, inExt[4], inExt[5]);\n        break;\n      case ImageBorderMode.MIRROR:\n        inIdX0 = vtkInterpolationMathMirror(inIdX0, inExt[0], inExt[1]);\n        inIdY0 = vtkInterpolationMathMirror(inIdY0, inExt[2], inExt[3]);\n        inIdZ0 = vtkInterpolationMathMirror(inIdZ0, inExt[4], inExt[5]);\n        break;\n      default:\n        inIdX0 = vtkInterpolationMathClamp(inIdX0, inExt[0], inExt[1]);\n        inIdY0 = vtkInterpolationMathClamp(inIdY0, inExt[2], inExt[3]);\n        inIdZ0 = vtkInterpolationMathClamp(inIdZ0, inExt[4], inExt[5]);\n        break;\n    }\n    var startId = inIdX0 * inInc[0] + inIdY0 * inInc[1] + inIdZ0 * inInc[2];\n    for (var i = 0; i < numscalars; ++i) {\n      value[i] = interpolationInfo.pointer[startId + i];\n    }\n  };\n  publicAPI.interpolateLinear = function (interpolationInfo, point, value) {\n    var inExt = interpolationInfo.extent;\n    var inInc = interpolationInfo.increments;\n    var numscalars = interpolationInfo.numberOfComponents;\n    var floorX = vtkInterpolationMathFloor(point[0]);\n    var floorY = vtkInterpolationMathFloor(point[1]);\n    var floorZ = vtkInterpolationMathFloor(point[2]);\n    var inIdX0 = floorX.floored;\n    var inIdY0 = floorY.floored;\n    var inIdZ0 = floorZ.floored;\n    var fx = floorX.error;\n    var fy = floorY.error;\n    var fz = floorZ.error;\n    var inIdX1 = inIdX0 + (fx !== 0);\n    var inIdY1 = inIdY0 + (fy !== 0);\n    var inIdZ1 = inIdZ0 + (fz !== 0);\n    switch (interpolationInfo.borderMode) {\n      case ImageBorderMode.REPEAT:\n        inIdX0 = vtkInterpolationMathWrap(inIdX0, inExt[0], inExt[1]);\n        inIdY0 = vtkInterpolationMathWrap(inIdY0, inExt[2], inExt[3]);\n        inIdZ0 = vtkInterpolationMathWrap(inIdZ0, inExt[4], inExt[5]);\n        inIdX1 = vtkInterpolationMathWrap(inIdX1, inExt[0], inExt[1]);\n        inIdY1 = vtkInterpolationMathWrap(inIdY1, inExt[2], inExt[3]);\n        inIdZ1 = vtkInterpolationMathWrap(inIdZ1, inExt[4], inExt[5]);\n        break;\n      case ImageBorderMode.MIRROR:\n        inIdX0 = vtkInterpolationMathMirror(inIdX0, inExt[0], inExt[1]);\n        inIdY0 = vtkInterpolationMathMirror(inIdY0, inExt[2], inExt[3]);\n        inIdZ0 = vtkInterpolationMathMirror(inIdZ0, inExt[4], inExt[5]);\n        inIdX1 = vtkInterpolationMathMirror(inIdX1, inExt[0], inExt[1]);\n        inIdY1 = vtkInterpolationMathMirror(inIdY1, inExt[2], inExt[3]);\n        inIdZ1 = vtkInterpolationMathMirror(inIdZ1, inExt[4], inExt[5]);\n        break;\n      default:\n        inIdX0 = vtkInterpolationMathClamp(inIdX0, inExt[0], inExt[1]);\n        inIdY0 = vtkInterpolationMathClamp(inIdY0, inExt[2], inExt[3]);\n        inIdZ0 = vtkInterpolationMathClamp(inIdZ0, inExt[4], inExt[5]);\n        inIdX1 = vtkInterpolationMathClamp(inIdX1, inExt[0], inExt[1]);\n        inIdY1 = vtkInterpolationMathClamp(inIdY1, inExt[2], inExt[3]);\n        inIdZ1 = vtkInterpolationMathClamp(inIdZ1, inExt[4], inExt[5]);\n        break;\n    }\n    var factX0 = inIdX0 * inInc[0];\n    var factX1 = inIdX1 * inInc[0];\n    var factY0 = inIdY0 * inInc[1];\n    var factY1 = inIdY1 * inInc[1];\n    var factZ0 = inIdZ0 * inInc[2];\n    var factZ1 = inIdZ1 * inInc[2];\n    var i00 = factY0 + factZ0;\n    var i01 = factY0 + factZ1;\n    var i10 = factY1 + factZ0;\n    var i11 = factY1 + factZ1;\n    var rx = 1 - fx;\n    var ry = 1 - fy;\n    var rz = 1 - fz;\n    var ryrz = ry * rz;\n    var fyrz = fy * rz;\n    var ryfz = ry * fz;\n    var fyfz = fy * fz;\n    var inPtr = interpolationInfo.pointer;\n    for (var i = 0; i < numscalars; ++i) {\n      value[i] = rx * (ryrz * inPtr[factX0 + i00 + i * 4] + ryfz * inPtr[factX0 + i01 + i * 4] + fyrz * inPtr[factX0 + i10 + i * 4] + fyfz * inPtr[factX0 + i11 + i * 4]) + fx * (ryrz * inPtr[factX1 + i00 + i * 4] + ryfz * inPtr[factX1 + i01 + i * 4] + fyrz * inPtr[factX1 + i10 + i * 4] + fyfz * inPtr[factX1 + i11 + i * 4]);\n    }\n  };\n  publicAPI.interpolatePoint = function (interpolationInfo, point, value) {\n    switch (model.interpolationMode) {\n      case InterpolationMode.LINEAR:\n        publicAPI.interpolateLinear(interpolationInfo, point, value);\n        break;\n      case InterpolationMode.CUBIC:\n        console.log('CUBIC not implemented');\n        break;\n      case InterpolationMode.NEAREST:\n      default:\n        publicAPI.interpolateNearest(interpolationInfo, point, value);\n        break;\n    }\n  };\n  publicAPI.interpolateRowNearest = function (weights, idX, idY, idZ, outPtr, n) {\n    // TODO check pointers\n    var iX = weights.positions[0].subarray(idX);\n    var iY = weights.positions[1].subarray(idY);\n    var iZ = weights.positions[2].subarray(idZ);\n    var inPtr0 = weights.pointer.subarray(iY[0] + iZ[0]); // get the number of components per pixel\n\n    var numscalars = weights.numberOfComponents; // This is a hot loop.\n\n    for (var i = 0; i < n; ++i) {\n      outPtr.set(inPtr0.subarray(iX[i], numscalars), i * numscalars);\n    }\n  };\n  publicAPI.interpolateRowLinear = function (weights, idX, idY, idZ, outPtr, n) {\n    var stepX = weights.kernelSize[0];\n    var stepY = weights.kernelSize[1];\n    var stepZ = weights.kernelSize[2];\n    var idXtemp = idX * stepX;\n    var idYtemp = idY * stepY;\n    var idZtemp = idZ * stepZ;\n    var fX = weights.weights[0].subarray(idXtemp);\n    var fY = weights.weights[1].subarray(idYtemp);\n    var fZ = weights.weights[2].subarray(idZtemp);\n    var iX = weights.positions[0].subarray(idXtemp);\n    var iY = weights.positions[1].subarray(idYtemp);\n    var iZ = weights.positions[2].subarray(idZtemp);\n    var inPtr = weights.pointer; // get the number of components per pixel\n\n    var numscalars = weights.numberOfComponents; // create a 2x2 bilinear kernel in local variables\n\n    var i00 = iY.subarray(iZ[0]);\n    var i01 = i00;\n    var i10 = i00;\n    var i11 = i00;\n    var ry = 1;\n    var fy = 0;\n    var rz = 1;\n    var fz = 0;\n    if (stepY === 2) {\n      i10 = iY[1].subarray(iZ[0]);\n      i11 = i10;\n      ry = fY[0];\n      fy = fY[1];\n    }\n    if (stepZ === 2) {\n      i01 = iY[0].subarray(iZ[1]);\n      i11 = i01;\n      rz = fZ[0];\n      fz = fZ[1];\n    }\n    if (stepY + stepZ === 4) {\n      i11 = iY[1].subarray(iZ[1]);\n    }\n    var ryrz = ry * rz;\n    var ryfz = ry * fz;\n    var fyrz = fy * rz;\n    var fyfz = fy * fz;\n    if (stepX === 1) {\n      if (fy === 0 && fz === 0) {\n        // no interpolation needed at all\n        for (var i = n; i > 0; --i) {\n          for (var j = 0; j < numscalars; j++) {\n            outPtr[j + n - i] = inPtr[i00 + iX[n - i] + j];\n          }\n        }\n      } else if (fy === 0) {\n        // only need linear z interpolation\n        for (var _i = n; _i > 0; --_i) {\n          for (var _j = 0; _j < numscalars; _j++) {\n            outPtr[_j + n - _i] = rz * inPtr[iX[n - _i] + i00 + _j * 4] + fz * inPtr[iX[n - _i] + i01 + _j * 4];\n          }\n        }\n      } else {\n        // interpolate in y and z but not in x\n        for (var _i2 = n; _i2 > 0; --_i2) {\n          for (var _j2 = 0; _j2 < numscalars; _j2++) {\n            outPtr[_j2 + n - _i2] = ryrz * inPtr[iX[n - _i2] + i00 + _j2 * 4] + ryfz * inPtr[iX[n - _i2] + i01 + _j2 * 4] + fyrz * inPtr[iX[n - _i2] + i10 + _j2 * 4] + fyfz * inPtr[iX[n - _i2] + i11 + _j2 * 4];\n          }\n        }\n      }\n    } else if (fz === 0) {\n      var x = 0; // bilinear interpolation in x,y\n\n      for (var _i3 = n; _i3 > 0; --_i3) {\n        var rx = fX[0 + 2 * x];\n        var fx = fX[1 + 2 * x];\n        var t0 = iX[0 + 2 * x];\n        var t1 = iX[1 + 2 * x];\n        for (var _j3 = 0; _j3 < numscalars; _j3++) {\n          outPtr[_j3 + n - _i3] = rx * (ry * inPtr[t0 + i00 + _j3 * 4] + fy * inPtr[t0 + i10 + _j3 * 4]) + fx * (ry * inPtr[t1 + i00 + _j3 * 4] + fy * inPtr[t1 + i10 + _j3 * 4]);\n        }\n        x++;\n      }\n    } else {\n      var _x = 0; // do full trilinear interpolation\n\n      for (var _i4 = n; _i4 > 0; --_i4) {\n        var _rx = fX[0 + 2 * _x];\n        var _fx = fX[1 + 2 * _x];\n        var _t = iX[0 + 2 * _x];\n        var _t2 = iX[1 + 2 * _x];\n        for (var _j4 = 0; _j4 < numscalars; _j4++) {\n          outPtr[_j4] = _rx * (ryrz * inPtr[_t + i00 + _j4 * 4] + ryfz * inPtr[_t + i01 + _j4 * 4] + fyrz * inPtr[_t + i10 + _j4 * 4] + fyfz * inPtr[_t + i11 + _j4 * 4]) + _fx * (ryrz * inPtr[_t2 + i00 + _j4 * 4] + ryfz * inPtr[_t2 + i01 + _j4 * 4] + fyrz * inPtr[_t2 + i10 + _j4 * 4] + fyfz * inPtr[_t2 + i11 + _j4 * 4]);\n        }\n        _x++;\n      }\n    }\n  };\n  publicAPI.interpolateRow = function (weights, xIdx, yIdx, zIdx, value, n) {\n    switch (model.interpolationMode) {\n      case InterpolationMode.LINEAR:\n        publicAPI.interpolateRowLinear(weights, xIdx, yIdx, zIdx, value, n);\n        break;\n      case InterpolationMode.CUBIC:\n        console.log('CUBIC not implemented');\n        break;\n      case InterpolationMode.NEAREST:\n      default:\n        publicAPI.interpolateRowNearest(weights, xIdx, yIdx, zIdx, value, n);\n        break;\n    }\n  };\n  publicAPI.vtkTricubicInterpWeights = function (f) {\n    var half = 0.5; // cubic interpolation\n\n    var fm1 = f - 1;\n    var fd2 = f * half;\n    var ft3 = f * 3;\n    return [-fd2 * fm1 * fm1, ((ft3 - 2) * fd2 - 1) * fm1, -((ft3 - 4) * f - 1) * fd2, f * fd2 * fm1];\n  };\n  publicAPI.precomputeWeightsForExtent = function (matrix, outExt, clipExt) {\n    var weights = _objectSpread(_objectSpread({}, vtkInterpolationWeights.newInstance()), model.interpolationInfo);\n    weights.weightType = 'Float32Array';\n    var interpMode = weights.interpolationMode;\n    var validClip = true;\n    for (var j = 0; j < 3; ++j) {\n      // set k to the row for which the element in column j is nonzero\n      var k = void 0;\n      for (k = 0; k < 3; ++k) {\n        if (matrix[4 * j + k] !== 0) {\n          break;\n        }\n      } // get the extents\n\n      clipExt[2 * j] = outExt[2 * j];\n      clipExt[2 * j + 1] = outExt[2 * j + 1];\n      var minExt = weights.extent[2 * k];\n      var maxExt = weights.extent[2 * k + 1];\n      var minBounds = model.structuredBounds[2 * k];\n      var maxBounds = model.structuredBounds[2 * k + 1]; // the kernel size should not exceed the input dimension\n\n      var step = 1;\n      step = interpMode < InterpolationMode.LINEAR ? step : 2;\n      step = interpMode < InterpolationMode.CUBIC ? step : 4;\n      var inCount = maxExt - minExt + 1;\n      step = step < inCount ? step : inCount; // if output pixels lie exactly on top of the input pixels\n\n      if (Number.isInteger(matrix[4 * j + k]) && Number.isInteger(matrix[4 * k + k])) {\n        step = 1;\n      }\n      var size = step * (outExt[2 * j + 1] - outExt[2 * j] + 1); // TODO: check pointers\n\n      var positions = new Int16Array(size); // positions -= step*outExt[2 * j];\n\n      var startPositions = step * outExt[2 * j];\n      var constants = null;\n      if (interpMode !== InterpolationMode.NEAREST) {\n        constants = new Int16Array(size); // constants -= step * outExt[2 * j];\n      }\n\n      weights.kernelSize[j] = step;\n      weights.weightExtent[2 * j] = outExt[2 * j];\n      weights.weightExtent[2 * j + 1] = outExt[2 * j + 1];\n      weights.positions[j] = positions; // TODO: check pointers\n\n      weights.weights[j] = constants; // TODO: check pointers\n\n      var region = 0;\n      for (var i = outExt[2 * j]; i <= outExt[2 * j + 1]; ++i) {\n        var point = matrix[4 * 3 + k] + i * matrix[4 * j + k];\n        var lcount = step;\n        var inId0 = 0;\n        var f = 0;\n        if (interpMode === InterpolationMode.NEAREST) {\n          inId0 = Math.round(point);\n        } else {\n          var res = vtkInterpolationMathFloor(point);\n          inId0 = res.integer;\n          f = res.error;\n          if (interpMode === InterpolationMode.CUBIC && step !== 1) {\n            inId0--;\n            lcount = 4;\n          }\n        }\n        var inId = [0, 0, 0, 0];\n        var l = 0;\n        switch (weights.borderMode) {\n          case ImageBorderMode.REPEAT:\n            do {\n              inId[l] = vtkInterpolationMathWrap(inId0, minExt, maxExt);\n              inId0++;\n            } while (++l < lcount);\n            break;\n          case ImageBorderMode.MIRROR:\n            do {\n              inId[l] = vtkInterpolationMathMirror(inId0, minExt, maxExt);\n              inId0++;\n            } while (++l < lcount);\n            break;\n          default:\n            do {\n              inId[l] = vtkInterpolationMathClamp(inId0, minExt, maxExt);\n              inId0++;\n            } while (++l < lcount);\n            break;\n        } // compute the weights and offsets\n\n        var inInc = weights.increments[k];\n        positions[step * i - startPositions] = inId[0] * inInc;\n        if (interpMode !== InterpolationMode.NEAREST) {\n          constants[step * i - startPositions] = 1;\n        }\n        if (step > 1) {\n          if (interpMode === InterpolationMode.LINEAR) {\n            positions[step * i + 1 - startPositions] = inId[1] * inInc;\n            constants[step * i - startPositions] = 1.0 - f;\n            constants[step * i + 1 - startPositions] = f;\n          } else if (interpMode === InterpolationMode.CUBIC) {\n            var g = publicAPI.vtkTricubicInterpWeights(f);\n            if (step === 4) {\n              for (var ll = 0; ll < 4; ll++) {\n                positions[step * i + ll - startPositions] = inId[ll] * inInc;\n                constants[step * i + ll - startPositions] = g[ll];\n              }\n            } else {\n              // it gets tricky if there are fewer than 4 slices\n              var gg = [0, 0, 0, 0];\n              for (var _ll = 0; _ll < 4; _ll++) {\n                var rIdx = inId[_ll] - minExt;\n                gg[rIdx] += g[_ll];\n              }\n              for (var jj = 0; jj < step; jj++) {\n                positions[step * i + jj - startPositions] = minExt + jj;\n                constants[step * i + jj - startPositions] = gg[jj];\n              }\n            }\n          }\n        }\n        if (point >= minBounds && point <= maxBounds) {\n          if (region === 0) {\n            // entering the input extent\n            region = 1;\n            clipExt[2 * j] = i;\n          }\n        } else if (region === 1) {\n          // leaving the input extent\n          region = 2;\n          clipExt[2 * j + 1] = i - 1;\n        }\n      }\n      if (region === 0 || clipExt[2 * j] > clipExt[2 * j + 1]) {\n        // never entered input extent!\n        validClip = false;\n      }\n    }\n    if (!validClip) {\n      // output extent doesn't itersect input extent\n      for (var _j5 = 0; _j5 < 3; _j5++) {\n        clipExt[2 * _j5] = outExt[2 * _j5];\n        clipExt[2 * _j5 + 1] = outExt[2 * _j5] - 1;\n      }\n    }\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nvar DEFAULT_VALUES = {\n  interpolationMode: InterpolationMode.NEAREST\n}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Inheritance\n\n  vtkAbstractImageInterpolator.extend(publicAPI, model, initialValues);\n  macro.setGet(publicAPI, model, ['interpolationMode']); // Object specific methods\n\n  vtkImageInterpolator(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = macro.newInstance(extend, 'vtkImageInterpolator'); // ----------------------------------------------------------------------------\n\nvar vtkImageInterpolator$1 = {\n  newInstance: newInstance,\n  extend: extend\n};\nexport { vtkImageInterpolator$1 as default, extend, newInstance };","map":{"version":3,"names":["_defineProperty","macro","vtkAbstractImageInterpolator","vtkInterpolationMathRound","vtkInterpolationMathClamp","vtkInterpolationMathMirror","vtkInterpolationMathWrap","vtkInterpolationMathFloor","vtkInterpolationWeights","InterpolationMode","ImageBorderMode","ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","getOwnPropertyDescriptors","defineProperties","defineProperty","vtkImageInterpolator","publicAPI","model","classHierarchy","computeSupportSize","matrix","s","interpolationMode","LINEAR","CUBIC","size","integerRow","j","Number","isInteger","internalUpdate","interpolationInfo","isSeparable","interpolateNearest","point","value","inExt","extent","inInc","increments","numscalars","numberOfComponents","inIdX0","inIdY0","inIdZ0","borderMode","REPEAT","MIRROR","startId","pointer","interpolateLinear","floorX","floorY","floorZ","floored","fx","error","fy","fz","inIdX1","inIdY1","inIdZ1","factX0","factX1","factY0","factY1","factZ0","factZ1","i00","i01","i10","i11","rx","ry","rz","ryrz","fyrz","ryfz","fyfz","inPtr","interpolatePoint","console","log","NEAREST","interpolateRowNearest","weights","idX","idY","idZ","outPtr","n","iX","positions","subarray","iY","iZ","inPtr0","set","interpolateRowLinear","stepX","kernelSize","stepY","stepZ","idXtemp","idYtemp","idZtemp","fX","fY","fZ","_i","_j","_i2","_j2","x","_i3","t0","t1","_j3","_x","_i4","_rx","_fx","_t","_t2","_j4","interpolateRow","xIdx","yIdx","zIdx","vtkTricubicInterpWeights","f","half","fm1","fd2","ft3","precomputeWeightsForExtent","outExt","clipExt","newInstance","weightType","interpMode","validClip","k","minExt","maxExt","minBounds","structuredBounds","maxBounds","step","inCount","Int16Array","startPositions","constants","weightExtent","region","lcount","inId0","Math","round","res","integer","inId","l","g","ll","gg","_ll","rIdx","jj","_j5","DEFAULT_VALUES","extend","initialValues","undefined","assign","setGet","vtkImageInterpolator$1","default"],"sources":["/home/rakshith/Documents/RemoteRendering/vtk-js-react-app/node_modules/@kitware/vtk.js/Imaging/Core/ImageInterpolator.js"],"sourcesContent":["import _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport macro from '../../macros.js';\nimport vtkAbstractImageInterpolator from './AbstractImageInterpolator.js';\nimport { vtkInterpolationMathRound, vtkInterpolationMathClamp, vtkInterpolationMathMirror, vtkInterpolationMathWrap, vtkInterpolationMathFloor, vtkInterpolationWeights } from './AbstractImageInterpolator/InterpolationInfo.js';\nimport { InterpolationMode, ImageBorderMode } from './AbstractImageInterpolator/Constants.js';\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n// vtkImageInterpolator methods\n// ----------------------------------------------------------------------------\n\nfunction vtkImageInterpolator(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkImageInterpolator');\n\n  publicAPI.computeSupportSize = function (matrix) {\n    var s = 1;\n\n    if (model.interpolationMode === InterpolationMode.LINEAR) {\n      s = 2;\n    } else if (model.interpolationMode === InterpolationMode.CUBIC) {\n      s = 4;\n    }\n\n    var size = [s, s, s];\n\n    if (matrix == null) {\n      return size;\n    } // TODO CHECK MATRIX\n\n\n    if (matrix[12] !== 0 || matrix[13] !== 0 || matrix[14] !== 0 || matrix[15] !== 1) {\n      return size;\n    }\n\n    for (var i = 0; i < 3; ++i) {\n      var integerRow = true;\n\n      for (var j = 0; j < 3; ++j) {\n        integerRow = integerRow && Number.isInteger(matrix[4 * i + j]);\n      }\n\n      if (integerRow) {\n        size[i] = 1;\n      }\n    }\n\n    return size;\n  };\n\n  publicAPI.internalUpdate = function () {\n    model.interpolationInfo.interpolationMode = model.interpolationMode;\n  };\n\n  publicAPI.isSeparable = function () {\n    return true;\n  };\n\n  publicAPI.interpolateNearest = function (interpolationInfo, point, value) {\n    var inExt = interpolationInfo.extent;\n    var inInc = interpolationInfo.increments;\n    var numscalars = interpolationInfo.numberOfComponents;\n    var inIdX0 = vtkInterpolationMathRound(point[0]);\n    var inIdY0 = vtkInterpolationMathRound(point[1]);\n    var inIdZ0 = vtkInterpolationMathRound(point[2]);\n\n    switch (interpolationInfo.borderMode) {\n      case ImageBorderMode.REPEAT:\n        inIdX0 = vtkInterpolationMathWrap(inIdX0, inExt[0], inExt[1]);\n        inIdY0 = vtkInterpolationMathWrap(inIdY0, inExt[2], inExt[3]);\n        inIdZ0 = vtkInterpolationMathWrap(inIdZ0, inExt[4], inExt[5]);\n        break;\n\n      case ImageBorderMode.MIRROR:\n        inIdX0 = vtkInterpolationMathMirror(inIdX0, inExt[0], inExt[1]);\n        inIdY0 = vtkInterpolationMathMirror(inIdY0, inExt[2], inExt[3]);\n        inIdZ0 = vtkInterpolationMathMirror(inIdZ0, inExt[4], inExt[5]);\n        break;\n\n      default:\n        inIdX0 = vtkInterpolationMathClamp(inIdX0, inExt[0], inExt[1]);\n        inIdY0 = vtkInterpolationMathClamp(inIdY0, inExt[2], inExt[3]);\n        inIdZ0 = vtkInterpolationMathClamp(inIdZ0, inExt[4], inExt[5]);\n        break;\n    }\n\n    var startId = inIdX0 * inInc[0] + inIdY0 * inInc[1] + inIdZ0 * inInc[2];\n\n    for (var i = 0; i < numscalars; ++i) {\n      value[i] = interpolationInfo.pointer[startId + i];\n    }\n  };\n\n  publicAPI.interpolateLinear = function (interpolationInfo, point, value) {\n    var inExt = interpolationInfo.extent;\n    var inInc = interpolationInfo.increments;\n    var numscalars = interpolationInfo.numberOfComponents;\n    var floorX = vtkInterpolationMathFloor(point[0]);\n    var floorY = vtkInterpolationMathFloor(point[1]);\n    var floorZ = vtkInterpolationMathFloor(point[2]);\n    var inIdX0 = floorX.floored;\n    var inIdY0 = floorY.floored;\n    var inIdZ0 = floorZ.floored;\n    var fx = floorX.error;\n    var fy = floorY.error;\n    var fz = floorZ.error;\n    var inIdX1 = inIdX0 + (fx !== 0);\n    var inIdY1 = inIdY0 + (fy !== 0);\n    var inIdZ1 = inIdZ0 + (fz !== 0);\n\n    switch (interpolationInfo.borderMode) {\n      case ImageBorderMode.REPEAT:\n        inIdX0 = vtkInterpolationMathWrap(inIdX0, inExt[0], inExt[1]);\n        inIdY0 = vtkInterpolationMathWrap(inIdY0, inExt[2], inExt[3]);\n        inIdZ0 = vtkInterpolationMathWrap(inIdZ0, inExt[4], inExt[5]);\n        inIdX1 = vtkInterpolationMathWrap(inIdX1, inExt[0], inExt[1]);\n        inIdY1 = vtkInterpolationMathWrap(inIdY1, inExt[2], inExt[3]);\n        inIdZ1 = vtkInterpolationMathWrap(inIdZ1, inExt[4], inExt[5]);\n        break;\n\n      case ImageBorderMode.MIRROR:\n        inIdX0 = vtkInterpolationMathMirror(inIdX0, inExt[0], inExt[1]);\n        inIdY0 = vtkInterpolationMathMirror(inIdY0, inExt[2], inExt[3]);\n        inIdZ0 = vtkInterpolationMathMirror(inIdZ0, inExt[4], inExt[5]);\n        inIdX1 = vtkInterpolationMathMirror(inIdX1, inExt[0], inExt[1]);\n        inIdY1 = vtkInterpolationMathMirror(inIdY1, inExt[2], inExt[3]);\n        inIdZ1 = vtkInterpolationMathMirror(inIdZ1, inExt[4], inExt[5]);\n        break;\n\n      default:\n        inIdX0 = vtkInterpolationMathClamp(inIdX0, inExt[0], inExt[1]);\n        inIdY0 = vtkInterpolationMathClamp(inIdY0, inExt[2], inExt[3]);\n        inIdZ0 = vtkInterpolationMathClamp(inIdZ0, inExt[4], inExt[5]);\n        inIdX1 = vtkInterpolationMathClamp(inIdX1, inExt[0], inExt[1]);\n        inIdY1 = vtkInterpolationMathClamp(inIdY1, inExt[2], inExt[3]);\n        inIdZ1 = vtkInterpolationMathClamp(inIdZ1, inExt[4], inExt[5]);\n        break;\n    }\n\n    var factX0 = inIdX0 * inInc[0];\n    var factX1 = inIdX1 * inInc[0];\n    var factY0 = inIdY0 * inInc[1];\n    var factY1 = inIdY1 * inInc[1];\n    var factZ0 = inIdZ0 * inInc[2];\n    var factZ1 = inIdZ1 * inInc[2];\n    var i00 = factY0 + factZ0;\n    var i01 = factY0 + factZ1;\n    var i10 = factY1 + factZ0;\n    var i11 = factY1 + factZ1;\n    var rx = 1 - fx;\n    var ry = 1 - fy;\n    var rz = 1 - fz;\n    var ryrz = ry * rz;\n    var fyrz = fy * rz;\n    var ryfz = ry * fz;\n    var fyfz = fy * fz;\n    var inPtr = interpolationInfo.pointer;\n\n    for (var i = 0; i < numscalars; ++i) {\n      value[i] = rx * (ryrz * inPtr[factX0 + i00 + i * 4] + ryfz * inPtr[factX0 + i01 + i * 4] + fyrz * inPtr[factX0 + i10 + i * 4] + fyfz * inPtr[factX0 + i11 + i * 4]) + fx * (ryrz * inPtr[factX1 + i00 + i * 4] + ryfz * inPtr[factX1 + i01 + i * 4] + fyrz * inPtr[factX1 + i10 + i * 4] + fyfz * inPtr[factX1 + i11 + i * 4]);\n    }\n  };\n\n  publicAPI.interpolatePoint = function (interpolationInfo, point, value) {\n    switch (model.interpolationMode) {\n      case InterpolationMode.LINEAR:\n        publicAPI.interpolateLinear(interpolationInfo, point, value);\n        break;\n\n      case InterpolationMode.CUBIC:\n        console.log('CUBIC not implemented');\n        break;\n\n      case InterpolationMode.NEAREST:\n      default:\n        publicAPI.interpolateNearest(interpolationInfo, point, value);\n        break;\n    }\n  };\n\n  publicAPI.interpolateRowNearest = function (weights, idX, idY, idZ, outPtr, n) {\n    // TODO check pointers\n    var iX = weights.positions[0].subarray(idX);\n    var iY = weights.positions[1].subarray(idY);\n    var iZ = weights.positions[2].subarray(idZ);\n    var inPtr0 = weights.pointer.subarray(iY[0] + iZ[0]); // get the number of components per pixel\n\n    var numscalars = weights.numberOfComponents; // This is a hot loop.\n\n    for (var i = 0; i < n; ++i) {\n      outPtr.set(inPtr0.subarray(iX[i], numscalars), i * numscalars);\n    }\n  };\n\n  publicAPI.interpolateRowLinear = function (weights, idX, idY, idZ, outPtr, n) {\n    var stepX = weights.kernelSize[0];\n    var stepY = weights.kernelSize[1];\n    var stepZ = weights.kernelSize[2];\n    var idXtemp = idX * stepX;\n    var idYtemp = idY * stepY;\n    var idZtemp = idZ * stepZ;\n    var fX = weights.weights[0].subarray(idXtemp);\n    var fY = weights.weights[1].subarray(idYtemp);\n    var fZ = weights.weights[2].subarray(idZtemp);\n    var iX = weights.positions[0].subarray(idXtemp);\n    var iY = weights.positions[1].subarray(idYtemp);\n    var iZ = weights.positions[2].subarray(idZtemp);\n    var inPtr = weights.pointer; // get the number of components per pixel\n\n    var numscalars = weights.numberOfComponents; // create a 2x2 bilinear kernel in local variables\n\n    var i00 = iY.subarray(iZ[0]);\n    var i01 = i00;\n    var i10 = i00;\n    var i11 = i00;\n    var ry = 1;\n    var fy = 0;\n    var rz = 1;\n    var fz = 0;\n\n    if (stepY === 2) {\n      i10 = iY[1].subarray(iZ[0]);\n      i11 = i10;\n      ry = fY[0];\n      fy = fY[1];\n    }\n\n    if (stepZ === 2) {\n      i01 = iY[0].subarray(iZ[1]);\n      i11 = i01;\n      rz = fZ[0];\n      fz = fZ[1];\n    }\n\n    if (stepY + stepZ === 4) {\n      i11 = iY[1].subarray(iZ[1]);\n    }\n\n    var ryrz = ry * rz;\n    var ryfz = ry * fz;\n    var fyrz = fy * rz;\n    var fyfz = fy * fz;\n\n    if (stepX === 1) {\n      if (fy === 0 && fz === 0) {\n        // no interpolation needed at all\n        for (var i = n; i > 0; --i) {\n          for (var j = 0; j < numscalars; j++) {\n            outPtr[j + n - i] = inPtr[i00 + iX[n - i] + j];\n          }\n        }\n      } else if (fy === 0) {\n        // only need linear z interpolation\n        for (var _i = n; _i > 0; --_i) {\n          for (var _j = 0; _j < numscalars; _j++) {\n            outPtr[_j + n - _i] = rz * inPtr[iX[n - _i] + i00 + _j * 4] + fz * inPtr[iX[n - _i] + i01 + _j * 4];\n          }\n        }\n      } else {\n        // interpolate in y and z but not in x\n        for (var _i2 = n; _i2 > 0; --_i2) {\n          for (var _j2 = 0; _j2 < numscalars; _j2++) {\n            outPtr[_j2 + n - _i2] = ryrz * inPtr[iX[n - _i2] + i00 + _j2 * 4] + ryfz * inPtr[iX[n - _i2] + i01 + _j2 * 4] + fyrz * inPtr[iX[n - _i2] + i10 + _j2 * 4] + fyfz * inPtr[iX[n - _i2] + i11 + _j2 * 4];\n          }\n        }\n      }\n    } else if (fz === 0) {\n      var x = 0; // bilinear interpolation in x,y\n\n      for (var _i3 = n; _i3 > 0; --_i3) {\n        var rx = fX[0 + 2 * x];\n        var fx = fX[1 + 2 * x];\n        var t0 = iX[0 + 2 * x];\n        var t1 = iX[1 + 2 * x];\n\n        for (var _j3 = 0; _j3 < numscalars; _j3++) {\n          outPtr[_j3 + n - _i3] = rx * (ry * inPtr[t0 + i00 + _j3 * 4] + fy * inPtr[t0 + i10 + _j3 * 4]) + fx * (ry * inPtr[t1 + i00 + _j3 * 4] + fy * inPtr[t1 + i10 + _j3 * 4]);\n        }\n\n        x++;\n      }\n    } else {\n      var _x = 0; // do full trilinear interpolation\n\n      for (var _i4 = n; _i4 > 0; --_i4) {\n        var _rx = fX[0 + 2 * _x];\n        var _fx = fX[1 + 2 * _x];\n        var _t = iX[0 + 2 * _x];\n        var _t2 = iX[1 + 2 * _x];\n\n        for (var _j4 = 0; _j4 < numscalars; _j4++) {\n          outPtr[_j4] = _rx * (ryrz * inPtr[_t + i00 + _j4 * 4] + ryfz * inPtr[_t + i01 + _j4 * 4] + fyrz * inPtr[_t + i10 + _j4 * 4] + fyfz * inPtr[_t + i11 + _j4 * 4]) + _fx * (ryrz * inPtr[_t2 + i00 + _j4 * 4] + ryfz * inPtr[_t2 + i01 + _j4 * 4] + fyrz * inPtr[_t2 + i10 + _j4 * 4] + fyfz * inPtr[_t2 + i11 + _j4 * 4]);\n        }\n\n        _x++;\n      }\n    }\n  };\n\n  publicAPI.interpolateRow = function (weights, xIdx, yIdx, zIdx, value, n) {\n    switch (model.interpolationMode) {\n      case InterpolationMode.LINEAR:\n        publicAPI.interpolateRowLinear(weights, xIdx, yIdx, zIdx, value, n);\n        break;\n\n      case InterpolationMode.CUBIC:\n        console.log('CUBIC not implemented');\n        break;\n\n      case InterpolationMode.NEAREST:\n      default:\n        publicAPI.interpolateRowNearest(weights, xIdx, yIdx, zIdx, value, n);\n        break;\n    }\n  };\n\n  publicAPI.vtkTricubicInterpWeights = function (f) {\n    var half = 0.5; // cubic interpolation\n\n    var fm1 = f - 1;\n    var fd2 = f * half;\n    var ft3 = f * 3;\n    return [-fd2 * fm1 * fm1, ((ft3 - 2) * fd2 - 1) * fm1, -((ft3 - 4) * f - 1) * fd2, f * fd2 * fm1];\n  };\n\n  publicAPI.precomputeWeightsForExtent = function (matrix, outExt, clipExt) {\n    var weights = _objectSpread(_objectSpread({}, vtkInterpolationWeights.newInstance()), model.interpolationInfo);\n\n    weights.weightType = 'Float32Array';\n    var interpMode = weights.interpolationMode;\n    var validClip = true;\n\n    for (var j = 0; j < 3; ++j) {\n      // set k to the row for which the element in column j is nonzero\n      var k = void 0;\n\n      for (k = 0; k < 3; ++k) {\n        if (matrix[4 * j + k] !== 0) {\n          break;\n        }\n      } // get the extents\n\n\n      clipExt[2 * j] = outExt[2 * j];\n      clipExt[2 * j + 1] = outExt[2 * j + 1];\n      var minExt = weights.extent[2 * k];\n      var maxExt = weights.extent[2 * k + 1];\n      var minBounds = model.structuredBounds[2 * k];\n      var maxBounds = model.structuredBounds[2 * k + 1]; // the kernel size should not exceed the input dimension\n\n      var step = 1;\n      step = interpMode < InterpolationMode.LINEAR ? step : 2;\n      step = interpMode < InterpolationMode.CUBIC ? step : 4;\n      var inCount = maxExt - minExt + 1;\n      step = step < inCount ? step : inCount; // if output pixels lie exactly on top of the input pixels\n\n      if (Number.isInteger(matrix[4 * j + k]) && Number.isInteger(matrix[4 * k + k])) {\n        step = 1;\n      }\n\n      var size = step * (outExt[2 * j + 1] - outExt[2 * j] + 1); // TODO: check pointers\n\n      var positions = new Int16Array(size); // positions -= step*outExt[2 * j];\n\n      var startPositions = step * outExt[2 * j];\n      var constants = null;\n\n      if (interpMode !== InterpolationMode.NEAREST) {\n        constants = new Int16Array(size); // constants -= step * outExt[2 * j];\n      }\n\n      weights.kernelSize[j] = step;\n      weights.weightExtent[2 * j] = outExt[2 * j];\n      weights.weightExtent[2 * j + 1] = outExt[2 * j + 1];\n      weights.positions[j] = positions; // TODO: check pointers\n\n      weights.weights[j] = constants; // TODO: check pointers\n\n      var region = 0;\n\n      for (var i = outExt[2 * j]; i <= outExt[2 * j + 1]; ++i) {\n        var point = matrix[4 * 3 + k] + i * matrix[4 * j + k];\n        var lcount = step;\n        var inId0 = 0;\n        var f = 0;\n\n        if (interpMode === InterpolationMode.NEAREST) {\n          inId0 = Math.round(point);\n        } else {\n          var res = vtkInterpolationMathFloor(point);\n          inId0 = res.integer;\n          f = res.error;\n\n          if (interpMode === InterpolationMode.CUBIC && step !== 1) {\n            inId0--;\n            lcount = 4;\n          }\n        }\n\n        var inId = [0, 0, 0, 0];\n        var l = 0;\n\n        switch (weights.borderMode) {\n          case ImageBorderMode.REPEAT:\n            do {\n              inId[l] = vtkInterpolationMathWrap(inId0, minExt, maxExt);\n              inId0++;\n            } while (++l < lcount);\n\n            break;\n\n          case ImageBorderMode.MIRROR:\n            do {\n              inId[l] = vtkInterpolationMathMirror(inId0, minExt, maxExt);\n              inId0++;\n            } while (++l < lcount);\n\n            break;\n\n          default:\n            do {\n              inId[l] = vtkInterpolationMathClamp(inId0, minExt, maxExt);\n              inId0++;\n            } while (++l < lcount);\n\n            break;\n        } // compute the weights and offsets\n\n\n        var inInc = weights.increments[k];\n        positions[step * i - startPositions] = inId[0] * inInc;\n\n        if (interpMode !== InterpolationMode.NEAREST) {\n          constants[step * i - startPositions] = 1;\n        }\n\n        if (step > 1) {\n          if (interpMode === InterpolationMode.LINEAR) {\n            positions[step * i + 1 - startPositions] = inId[1] * inInc;\n            constants[step * i - startPositions] = 1.0 - f;\n            constants[step * i + 1 - startPositions] = f;\n          } else if (interpMode === InterpolationMode.CUBIC) {\n            var g = publicAPI.vtkTricubicInterpWeights(f);\n\n            if (step === 4) {\n              for (var ll = 0; ll < 4; ll++) {\n                positions[step * i + ll - startPositions] = inId[ll] * inInc;\n                constants[step * i + ll - startPositions] = g[ll];\n              }\n            } else {\n              // it gets tricky if there are fewer than 4 slices\n              var gg = [0, 0, 0, 0];\n\n              for (var _ll = 0; _ll < 4; _ll++) {\n                var rIdx = inId[_ll] - minExt;\n                gg[rIdx] += g[_ll];\n              }\n\n              for (var jj = 0; jj < step; jj++) {\n                positions[step * i + jj - startPositions] = minExt + jj;\n                constants[step * i + jj - startPositions] = gg[jj];\n              }\n            }\n          }\n        }\n\n        if (point >= minBounds && point <= maxBounds) {\n          if (region === 0) {\n            // entering the input extent\n            region = 1;\n            clipExt[2 * j] = i;\n          }\n        } else if (region === 1) {\n          // leaving the input extent\n          region = 2;\n          clipExt[2 * j + 1] = i - 1;\n        }\n      }\n\n      if (region === 0 || clipExt[2 * j] > clipExt[2 * j + 1]) {\n        // never entered input extent!\n        validClip = false;\n      }\n    }\n\n    if (!validClip) {\n      // output extent doesn't itersect input extent\n      for (var _j5 = 0; _j5 < 3; _j5++) {\n        clipExt[2 * _j5] = outExt[2 * _j5];\n        clipExt[2 * _j5 + 1] = outExt[2 * _j5] - 1;\n      }\n    }\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\n\nvar DEFAULT_VALUES = {\n  interpolationMode: InterpolationMode.NEAREST\n}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Inheritance\n\n  vtkAbstractImageInterpolator.extend(publicAPI, model, initialValues);\n  macro.setGet(publicAPI, model, ['interpolationMode']); // Object specific methods\n\n  vtkImageInterpolator(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = macro.newInstance(extend, 'vtkImageInterpolator'); // ----------------------------------------------------------------------------\n\nvar vtkImageInterpolator$1 = {\n  newInstance: newInstance,\n  extend: extend\n};\n\nexport { vtkImageInterpolator$1 as default, extend, newInstance };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}