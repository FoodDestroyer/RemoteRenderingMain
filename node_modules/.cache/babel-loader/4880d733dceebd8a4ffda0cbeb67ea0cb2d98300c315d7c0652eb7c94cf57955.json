{"ast":null,"code":"import _toConsumableArray from '@babel/runtime/helpers/toConsumableArray';\nimport _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport { vec3, mat4 } from 'gl-matrix';\nimport * as d3 from 'd3-scale';\nimport { M as normalize2D, N as nearestPowerOfTwo } from '../../Common/Core/Math/index.js';\nimport macro from '../../macros.js';\nimport vtkActor from './Actor.js';\nimport vtkBoundingBox from '../../Common/DataModel/BoundingBox.js';\nimport vtkDataArray from '../../Common/Core/DataArray.js';\nimport vtkMapper from './Mapper.js';\nimport vtkPolyData from '../../Common/DataModel/PolyData.js';\nimport vtkTexture from './Texture.js';\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n  return target;\n}\n// vtkCubeAxesActor\n// ----------------------------------------------------------------------------\n// faces are -x x -y y -z z\n// point 0 is 0,0,0 and then +x fastest changing, +y then +z\n\nvar faceNormals = [[-1, 0, 0], [1, 0, 0], [0, -1, 0], [0, 1, 0], [0, 0, -1], [0, 0, 1]];\nvar faceEdges = [[8, 7, 11, 3], [9, 1, 10, 5], [4, 9, 0, 8], [2, 11, 6, 10], [0, 3, 2, 1], [4, 5, 6, 7]];\nvar edgePoints = [[0, 1], [1, 3], [2, 3], [0, 2], [4, 5], [5, 7], [6, 7], [4, 6], [0, 4], [1, 5], [3, 7], [2, 6]];\nvar edgeAxes = [0, 1, 0, 1, 0, 1, 0, 1, 2, 2, 2, 2];\nvar faceAxes = [[1, 2], [1, 2], [0, 2], [0, 2], [0, 1], [0, 1]]; //\n// Developer note: This class is broken into the main class and a helper\n// class. The main class holds view independent properties (those properties\n// that do not change as the view's resolution/aspect ratio change). The\n// helper class is instantiated one per view and holds properties that can\n// depend on view specific values such as resolution. The helper class code\n// could have been left to the View specific implementation (such as\n// vtkWebGPUCubeAxesActor) but is instead placed here to it can be shared by\n// multiple rendering backends.\n//\n// some shared temp variables to reduce heap allocs\n\nvar ptv3 = new Float64Array(3);\nvar pt2v3 = new Float64Array(3);\nvar tmpv3 = new Float64Array(3);\nvar tmp2v3 = new Float64Array(3);\nvar xDir = new Float64Array(3);\nvar yDir = new Float64Array(3);\nvar invmat = new Float64Array(16);\nfunction applyTextStyle(ctx, style) {\n  ctx.strokeStyle = style.strokeColor;\n  ctx.lineWidth = style.strokeSize;\n  ctx.fillStyle = style.fontColor;\n  ctx.font = \"\".concat(style.fontStyle, \" \").concat(style.fontSize, \"px \").concat(style.fontFamily);\n} // many properties of this actor depend on the API specific view The main\n// dependency being the resolution as that drives what font sizes to use.\n// Bacause of this we need to do some of the calculations in a API specific\n// subclass. But... we don't want a lot of duplicated code between WebGL and\n// WebGPU for example so we have this helper class, that is designed to be\n// fairly API independent so that API specific views can call this to do\n// most of the work.\n\nfunction vtkCubeAxesActorHelper(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkCubeAxesActorHelper');\n  publicAPI.setRenderable = function (renderable) {\n    if (model.renderable === renderable) {\n      return;\n    }\n    model.renderable = renderable;\n    model.tmActor.addTexture(model.renderable.getTmTexture());\n    model.tmActor.setProperty(renderable.getProperty());\n    model.tmActor.setParentProp(renderable);\n    publicAPI.modified();\n  }; // called by updateTexturePolyData\n\n  publicAPI.createPolyDataForOneLabel = function (text, pos, cmat, imat, dir, offset, results) {\n    var value = model.renderable.get_tmAtlas().get(text);\n    if (!value) {\n      return;\n    }\n    var coords = model.renderable.getTextPolyData().getPoints().getData(); // compute pixel to distance factors\n\n    var size = model.lastSize;\n    ptv3[0] = coords[pos * 3];\n    ptv3[1] = coords[pos * 3 + 1];\n    ptv3[2] = coords[pos * 3 + 2];\n    vec3.transformMat4(tmpv3, ptv3, cmat); // moving 0.1 in NDC\n\n    tmpv3[0] += 0.1;\n    vec3.transformMat4(pt2v3, tmpv3, imat); // results in WC move of\n\n    vec3.subtract(xDir, pt2v3, ptv3);\n    tmpv3[0] -= 0.1;\n    tmpv3[1] += 0.1;\n    vec3.transformMat4(pt2v3, tmpv3, imat); // results in WC move of\n\n    vec3.subtract(yDir, pt2v3, ptv3);\n    for (var i = 0; i < 3; i++) {\n      xDir[i] /= 0.5 * 0.1 * size[0];\n      yDir[i] /= 0.5 * 0.1 * size[1];\n    } // have to find the four corners of the texture polygon for this label\n    // convert anchor point to View Coords\n\n    var ptIdx = results.ptIdx;\n    var cellIdx = results.cellIdx;\n    ptv3[0] = coords[pos * 3];\n    ptv3[1] = coords[pos * 3 + 1];\n    ptv3[2] = coords[pos * 3 + 2]; // horizontal left, right, or middle alignment based on dir[0]\n\n    if (dir[0] < -0.5) {\n      vec3.scale(tmpv3, xDir, dir[0] * offset - value.width);\n    } else if (dir[0] > 0.5) {\n      vec3.scale(tmpv3, xDir, dir[0] * offset);\n    } else {\n      vec3.scale(tmpv3, xDir, dir[0] * offset - value.width / 2.0);\n    }\n    vec3.add(ptv3, ptv3, tmpv3);\n    vec3.scale(tmpv3, yDir, dir[1] * offset - value.height / 2.0);\n    vec3.add(ptv3, ptv3, tmpv3);\n    results.points[ptIdx * 3] = ptv3[0];\n    results.points[ptIdx * 3 + 1] = ptv3[1];\n    results.points[ptIdx * 3 + 2] = ptv3[2];\n    results.tcoords[ptIdx * 2] = value.tcoords[0];\n    results.tcoords[ptIdx * 2 + 1] = value.tcoords[1];\n    ptIdx++;\n    vec3.scale(tmpv3, xDir, value.width);\n    vec3.add(ptv3, ptv3, tmpv3);\n    results.points[ptIdx * 3] = ptv3[0];\n    results.points[ptIdx * 3 + 1] = ptv3[1];\n    results.points[ptIdx * 3 + 2] = ptv3[2];\n    results.tcoords[ptIdx * 2] = value.tcoords[2];\n    results.tcoords[ptIdx * 2 + 1] = value.tcoords[3];\n    ptIdx++;\n    vec3.scale(tmpv3, yDir, value.height);\n    vec3.add(ptv3, ptv3, tmpv3);\n    results.points[ptIdx * 3] = ptv3[0];\n    results.points[ptIdx * 3 + 1] = ptv3[1];\n    results.points[ptIdx * 3 + 2] = ptv3[2];\n    results.tcoords[ptIdx * 2] = value.tcoords[4];\n    results.tcoords[ptIdx * 2 + 1] = value.tcoords[5];\n    ptIdx++;\n    vec3.scale(tmpv3, xDir, value.width);\n    vec3.subtract(ptv3, ptv3, tmpv3);\n    results.points[ptIdx * 3] = ptv3[0];\n    results.points[ptIdx * 3 + 1] = ptv3[1];\n    results.points[ptIdx * 3 + 2] = ptv3[2];\n    results.tcoords[ptIdx * 2] = value.tcoords[6];\n    results.tcoords[ptIdx * 2 + 1] = value.tcoords[7];\n    ptIdx++; // add the two triangles to represent the quad\n\n    results.polys[cellIdx * 4] = 3;\n    results.polys[cellIdx * 4 + 1] = ptIdx - 4;\n    results.polys[cellIdx * 4 + 2] = ptIdx - 3;\n    results.polys[cellIdx * 4 + 3] = ptIdx - 2;\n    cellIdx++;\n    results.polys[cellIdx * 4] = 3;\n    results.polys[cellIdx * 4 + 1] = ptIdx - 4;\n    results.polys[cellIdx * 4 + 2] = ptIdx - 2;\n    results.polys[cellIdx * 4 + 3] = ptIdx - 1;\n    results.ptIdx += 4;\n    results.cellIdx += 2;\n  }; // update the polydata associated with drawing the text labels\n  // specifically the quads used for each label and their associated tcoords\n  // etc. This changes every time the camera viewpoint changes\n\n  publicAPI.updateTexturePolyData = function () {\n    var cmat = model.camera.getCompositeProjectionMatrix(model.lastAspectRatio, -1, 1);\n    mat4.transpose(cmat, cmat); // update the polydata\n\n    var numLabels = model.renderable.getTextValues().length;\n    var numPts = numLabels * 4;\n    var numTris = numLabels * 2;\n    var points = new Float64Array(numPts * 3);\n    var polys = new Uint16Array(numTris * 4);\n    var tcoords = new Float32Array(numPts * 2);\n    mat4.invert(invmat, cmat);\n    var results = {\n      ptIdx: 0,\n      cellIdx: 0,\n      polys: polys,\n      points: points,\n      tcoords: tcoords\n    };\n    var ptIdx = 0;\n    var textIdx = 0;\n    var axisIdx = 0;\n    var coords = model.renderable.getTextPolyData().getPoints().getData();\n    var textValues = model.renderable.getTextValues();\n    while (ptIdx < coords.length / 3) {\n      // compute the direction to move out\n      ptv3[0] = coords[ptIdx * 3];\n      ptv3[1] = coords[ptIdx * 3 + 1];\n      ptv3[2] = coords[ptIdx * 3 + 2];\n      vec3.transformMat4(tmpv3, ptv3, cmat);\n      ptv3[0] = coords[ptIdx * 3 + 3];\n      ptv3[1] = coords[ptIdx * 3 + 4];\n      ptv3[2] = coords[ptIdx * 3 + 5];\n      vec3.transformMat4(tmp2v3, ptv3, cmat);\n      vec3.subtract(tmpv3, tmpv3, tmp2v3);\n      var dir = [tmpv3[0], tmpv3[1]];\n      normalize2D(dir); // write the axis label\n\n      publicAPI.createPolyDataForOneLabel(textValues[textIdx], ptIdx, cmat, invmat, dir, model.renderable.getAxisTitlePixelOffset(), results);\n      ptIdx += 2;\n      textIdx++; // write the tick labels\n\n      for (var t = 0; t < model.renderable.getTickCounts()[axisIdx]; t++) {\n        publicAPI.createPolyDataForOneLabel(textValues[textIdx], ptIdx, cmat, invmat, dir, model.renderable.getTickLabelPixelOffset(), results);\n        ptIdx++;\n        textIdx++;\n      }\n      axisIdx++;\n    }\n    var tcoordDA = vtkDataArray.newInstance({\n      numberOfComponents: 2,\n      values: tcoords,\n      name: 'TextureCoordinates'\n    });\n    model.tmPolyData.getPointData().setTCoords(tcoordDA);\n    model.tmPolyData.getPoints().setData(points, 3);\n    model.tmPolyData.getPoints().modified();\n    model.tmPolyData.getPolys().setData(polys, 1);\n    model.tmPolyData.getPolys().modified();\n    model.tmPolyData.modified();\n  };\n  publicAPI.updateAPISpecificData = function (size, camera, renderWindow) {\n    // has the size changed?\n    if (model.lastSize[0] !== size[0] || model.lastSize[1] !== size[1]) {\n      model.lastSize[0] = size[0];\n      model.lastSize[1] = size[1];\n      model.lastAspectRatio = size[0] / size[1];\n      model.forceUpdate = true;\n    }\n    model.camera = camera; // compute bounds for label quads whenever the camera changes\n\n    publicAPI.updateTexturePolyData();\n  };\n}\nvar newCubeAxesActorHelper = macro.newInstance(function (publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {\n    renderable: null\n  };\n  Object.assign(model, {}, initialValues); // Inheritance\n\n  macro.obj(publicAPI, model);\n  model.tmPolyData = vtkPolyData.newInstance();\n  model.tmMapper = vtkMapper.newInstance();\n  model.tmMapper.setInputData(model.tmPolyData);\n  model.tmActor = vtkActor.newInstance({\n    parentProp: publicAPI\n  });\n  model.tmActor.setMapper(model.tmMapper);\n  macro.setGet(publicAPI, model, ['renderable']);\n  macro.get(publicAPI, model, ['lastSize', 'lastAspectRatio', 'axisTextStyle', 'tickTextStyle', 'tmActor', 'ticks']);\n  model.forceUpdate = false;\n  model.lastRedrawTime = {};\n  macro.obj(model.lastRedrawTime, {\n    mtime: 0\n  });\n  model.lastRebuildTime = {};\n  macro.obj(model.lastRebuildTime, {\n    mtime: 0\n  });\n  model.lastSize = [-1, -1]; // internal variables\n\n  model.lastTickBounds = [];\n  vtkCubeAxesActorHelper(publicAPI, model);\n}, 'vtkCubeAxesActorHelper');\nfunction vtkCubeAxesActor(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkCubeAxesActor');\n  publicAPI.setCamera = function (cam) {\n    if (model.camera === cam) {\n      return;\n    }\n    if (model.cameraModifiedSub) {\n      model.cameraModifiedSub.unsubscribe();\n      model.cameraModifiedSub = null;\n    }\n    model.camera = cam;\n    if (cam) {\n      model.cameraModifiedSub = cam.onModified(publicAPI.update);\n    }\n    publicAPI.update();\n    publicAPI.modified();\n  }; // estimate from a camera model what faces to draw\n  // return true if the list of faces to draw has changed\n\n  publicAPI.computeFacesToDraw = function () {\n    var cmat = model.camera.getViewMatrix();\n    mat4.transpose(cmat, cmat);\n    var changed = false;\n    var length = vtkBoundingBox.getDiagonalLength(model.dataBounds);\n    var faceDot = Math.sin(model.faceVisibilityAngle * Math.PI / 180.0);\n    for (var f = 0; f < 6; f++) {\n      var drawit = false;\n      var faceAxis = Math.floor(f / 2);\n      var otherAxis1 = (faceAxis + 1) % 3;\n      var otherAxis2 = (faceAxis + 2) % 3; // only for non degenerate axes\n\n      if (model.dataBounds[otherAxis1 * 2] !== model.dataBounds[otherAxis1 * 2 + 1] && model.dataBounds[otherAxis2 * 2] !== model.dataBounds[otherAxis2 * 2 + 1]) {\n        // for each face transform the center and off center to get a direction vector\n        ptv3[faceAxis] = model.dataBounds[f] - 0.1 * length * faceNormals[f][faceAxis];\n        ptv3[otherAxis1] = 0.5 * (model.dataBounds[otherAxis1 * 2] + model.dataBounds[otherAxis1 * 2 + 1]);\n        ptv3[otherAxis2] = 0.5 * (model.dataBounds[otherAxis2 * 2] + model.dataBounds[otherAxis2 * 2 + 1]);\n        vec3.transformMat4(tmpv3, ptv3, cmat);\n        ptv3[faceAxis] = model.dataBounds[f];\n        vec3.transformMat4(tmp2v3, ptv3, cmat);\n        vec3.subtract(tmpv3, tmp2v3, tmpv3);\n        vec3.normalize(tmpv3, tmpv3); // tmpv3 now holds the face normal vector\n\n        drawit = tmpv3[2] > faceDot; // for perspctive we need the view direction to the plane\n\n        if (!model.camera.getParallelProjection()) {\n          vec3.normalize(tmp2v3, tmp2v3);\n          drawit = vec3.dot(tmp2v3, tmpv3) > faceDot;\n        }\n      }\n      if (drawit !== model.lastFacesToDraw[f]) {\n        model.lastFacesToDraw[f] = drawit;\n        changed = true;\n      }\n    }\n    return changed;\n  }; // update the polydata that represents the boundingd edges and gridlines\n\n  publicAPI.updatePolyData = function (facesToDraw, edgesToDraw, ticks) {\n    // compute the number of points and lines required\n    var numPts = 0;\n    var numLines = 0;\n    numPts += 8; // always start with the 8 cube points\n    // count edgesToDraw\n\n    var numEdgesToDraw = 0;\n    for (var e = 0; e < 12; e++) {\n      if (edgesToDraw[e] > 0) {\n        numEdgesToDraw++;\n      }\n    }\n    numLines += numEdgesToDraw; // add values for gridlines\n\n    if (model.gridLines) {\n      for (var f = 0; f < 6; f++) {\n        if (facesToDraw[f]) {\n          numPts += ticks[faceAxes[f][0]].length * 2 + ticks[faceAxes[f][1]].length * 2;\n          numLines += ticks[faceAxes[f][0]].length + ticks[faceAxes[f][1]].length;\n        }\n      }\n    } // now allocate the memory\n\n    var points = new Float64Array(numPts * 3);\n    var lines = new Uint32Array(numLines * 3);\n    var ptIdx = 0;\n    var lineIdx = 0; // add the 8 corner points\n\n    for (var z = 0; z < 2; z++) {\n      for (var y = 0; y < 2; y++) {\n        for (var x = 0; x < 2; x++) {\n          points[ptIdx * 3] = model.dataBounds[x];\n          points[ptIdx * 3 + 1] = model.dataBounds[2 + y];\n          points[ptIdx * 3 + 2] = model.dataBounds[4 + z];\n          ptIdx++;\n        }\n      }\n    } // draw the edges\n\n    for (var _e = 0; _e < 12; _e++) {\n      if (edgesToDraw[_e] > 0) {\n        lines[lineIdx * 3] = 2;\n        lines[lineIdx * 3 + 1] = edgePoints[_e][0];\n        lines[lineIdx * 3 + 2] = edgePoints[_e][1];\n        lineIdx++;\n      }\n    } // now handle gridlines\n    // grid lines are tick[axis1] + ticks[axes2] lines each having two points\n    // for simplicity we don;t worry about duplicating points, this is tiny\n\n    if (model.gridLines) {\n      // for each visible face\n      // add the points\n      for (var _f = 0; _f < 6; _f++) {\n        if (facesToDraw[_f]) {\n          var faceIdx = Math.floor(_f / 2);\n          var aticks = ticks[faceAxes[_f][0]];\n          for (var t = 0; t < aticks.length; t++) {\n            points[ptIdx * 3 + faceIdx] = model.dataBounds[_f];\n            points[ptIdx * 3 + faceAxes[_f][0]] = aticks[t];\n            points[ptIdx * 3 + faceAxes[_f][1]] = model.dataBounds[faceAxes[_f][1] * 2];\n            ptIdx++;\n            points[ptIdx * 3 + faceIdx] = model.dataBounds[_f];\n            points[ptIdx * 3 + faceAxes[_f][0]] = aticks[t];\n            points[ptIdx * 3 + faceAxes[_f][1]] = model.dataBounds[faceAxes[_f][1] * 2 + 1];\n            ptIdx++;\n            lines[lineIdx * 3] = 2;\n            lines[lineIdx * 3 + 1] = ptIdx - 2;\n            lines[lineIdx * 3 + 2] = ptIdx - 1;\n            lineIdx++;\n          }\n          aticks = ticks[faceAxes[_f][1]];\n          for (var _t = 0; _t < aticks.length; _t++) {\n            points[ptIdx * 3 + faceIdx] = model.dataBounds[_f];\n            points[ptIdx * 3 + faceAxes[_f][1]] = aticks[_t];\n            points[ptIdx * 3 + faceAxes[_f][0]] = model.dataBounds[faceAxes[_f][0] * 2];\n            ptIdx++;\n            points[ptIdx * 3 + faceIdx] = model.dataBounds[_f];\n            points[ptIdx * 3 + faceAxes[_f][1]] = aticks[_t];\n            points[ptIdx * 3 + faceAxes[_f][0]] = model.dataBounds[faceAxes[_f][0] * 2 + 1];\n            ptIdx++;\n            lines[lineIdx * 3] = 2;\n            lines[lineIdx * 3 + 1] = ptIdx - 2;\n            lines[lineIdx * 3 + 2] = ptIdx - 1;\n            lineIdx++;\n          }\n        }\n      }\n    }\n    model.polyData.getPoints().setData(points, 3);\n    model.polyData.getPoints().modified();\n    model.polyData.getLines().setData(lines, 1);\n    model.polyData.getLines().modified();\n    model.polyData.modified();\n  }; // update the data that represents where to put the labels\n  // in world coordinates. This only changes when faces to draw changes\n  // of dataBounds changes\n\n  publicAPI.updateTextData = function (facesToDraw, edgesToDraw, ticks, tickStrings) {\n    // count outside edgesToDraw\n    var textPointCount = 0;\n    for (var e = 0; e < 12; e++) {\n      if (edgesToDraw[e] === 1) {\n        textPointCount += 2;\n        textPointCount += ticks[edgeAxes[e]].length;\n      }\n    }\n    var points = model.polyData.getPoints().getData();\n    var textPoints = new Float64Array(textPointCount * 3);\n    var ptIdx = 0;\n    var textIdx = 0;\n    var axisCount = 0;\n    for (var f = 0; f < 6; f++) {\n      if (facesToDraw[f]) {\n        for (var _e2 = 0; _e2 < 4; _e2++) {\n          var edgeIdx = faceEdges[f][_e2];\n          if (edgesToDraw[edgeIdx] === 1) {\n            var edgeAxis = edgeAxes[edgeIdx]; // add a middle point on the edge\n\n            var ptIdx1 = edgePoints[edgeIdx][0] * 3;\n            var ptIdx2 = edgePoints[edgeIdx][1] * 3;\n            textPoints[ptIdx * 3] = 0.5 * (points[ptIdx1] + points[ptIdx2]);\n            textPoints[ptIdx * 3 + 1] = 0.5 * (points[ptIdx1 + 1] + points[ptIdx2 + 1]);\n            textPoints[ptIdx * 3 + 2] = 0.5 * (points[ptIdx1 + 2] + points[ptIdx2 + 2]);\n            ptIdx++; // add a middle face point, we use this to\n            // move the labels away from the edge in the right direction\n\n            var faceIdx = Math.floor(f / 2);\n            textPoints[ptIdx * 3 + faceIdx] = model.dataBounds[f];\n            textPoints[ptIdx * 3 + faceAxes[f][0]] = 0.5 * (model.dataBounds[faceAxes[f][0] * 2] + model.dataBounds[faceAxes[f][0] * 2 + 1]);\n            textPoints[ptIdx * 3 + faceAxes[f][1]] = 0.5 * (model.dataBounds[faceAxes[f][1] * 2] + model.dataBounds[faceAxes[f][1] * 2 + 1]);\n            ptIdx++; // set the text\n\n            model.textValues[textIdx] = model.axisLabels[edgeAxis];\n            textIdx++; // now add the tick marks along the edgeAxis\n\n            var otherAxis1 = (edgeAxis + 1) % 3;\n            var otherAxis2 = (edgeAxis + 2) % 3;\n            var aticks = ticks[edgeAxis];\n            var atickStrings = tickStrings[edgeAxis];\n            model.tickCounts[axisCount] = aticks.length;\n            for (var t = 0; t < aticks.length; t++) {\n              textPoints[ptIdx * 3 + edgeAxis] = aticks[t];\n              textPoints[ptIdx * 3 + otherAxis1] = points[ptIdx1 + otherAxis1];\n              textPoints[ptIdx * 3 + otherAxis2] = points[ptIdx1 + otherAxis2];\n              ptIdx++; // set the text\n\n              model.textValues[textIdx] = atickStrings[t];\n              textIdx++;\n            }\n            axisCount++;\n          }\n        }\n      }\n    }\n    model.textPolyData.getPoints().setData(textPoints, 3);\n    model.textPolyData.modified();\n  }; // main method to rebuild the cube axes, gets called on camera modify\n  // and changes to key members\n\n  publicAPI.update = function () {\n    // Can't do anything if we don't have a camera...\n    if (!model.camera) {\n      return;\n    } // compute what faces to draw\n\n    var facesChanged = publicAPI.computeFacesToDraw();\n    var facesToDraw = model.lastFacesToDraw; // have the bounds changed?\n\n    var boundsChanged = false;\n    for (var i = 0; i < 6; i++) {\n      if (model.dataBounds[i] !== model.lastTickBounds[i]) {\n        boundsChanged = true;\n        model.lastTickBounds[i] = model.dataBounds[i];\n      }\n    } // did something significant change? If so rebuild a lot of things\n\n    if (facesChanged || boundsChanged || model.forceUpdate) {\n      // compute the edges to draw\n      // for each drawn face, mark edges, all single mark edges we draw\n      var edgesToDraw = new Array(12).fill(0);\n      for (var f = 0; f < 6; f++) {\n        if (facesToDraw[f]) {\n          for (var e = 0; e < 4; e++) {\n            edgesToDraw[faceEdges[f][e]]++;\n          }\n        }\n      } // compute tick marks for axes\n\n      var ticks = [];\n      var tickStrings = [];\n      for (var _i = 0; _i < 3; _i++) {\n        var scale = d3.scaleLinear().domain([model.dataBounds[_i * 2], model.dataBounds[_i * 2 + 1]]);\n        ticks[_i] = scale.ticks(5);\n        var format = scale.tickFormat(5);\n        tickStrings[_i] = ticks[_i].map(format);\n      } // update gridlines / edge lines\n\n      publicAPI.updatePolyData(facesToDraw, edgesToDraw, ticks); // compute label world coords and text\n\n      publicAPI.updateTextData(facesToDraw, edgesToDraw, ticks, tickStrings); // rebuild the texture only when force or changed bounds, face\n      // visibility changes do to change the atlas\n\n      if (boundsChanged || model.forceUpdate) {\n        publicAPI.updateTextureAtlas(tickStrings);\n      }\n    }\n    model.forceUpdate = false;\n  }; // create the texture map atlas that contains the rendering of\n  // all the text strings. Only needs to be called when the text strings\n  // have changed (labels and ticks)\n\n  publicAPI.updateTextureAtlas = function (tickStrings) {\n    // compute the width and height we need\n    // set the text properties\n    model.tmContext.textBaseline = 'bottom';\n    model.tmContext.textAlign = 'left'; // first the three labels\n\n    model._tmAtlas.clear();\n    var maxWidth = 0;\n    var totalHeight = 1; // start one pixel in so we have a border\n\n    for (var i = 0; i < 3; i++) {\n      if (!model._tmAtlas.has(model.axisLabels[i])) {\n        applyTextStyle(model.tmContext, model.axisTextStyle);\n        var metrics = model.tmContext.measureText(model.axisLabels[i]);\n        var entry = {\n          height: metrics.actualBoundingBoxAscent + 2,\n          startingHeight: totalHeight,\n          width: metrics.width + 2,\n          textStyle: model.axisTextStyle\n        };\n        model._tmAtlas.set(model.axisLabels[i], entry);\n        totalHeight += entry.height;\n        if (maxWidth < entry.width) {\n          maxWidth = entry.width;\n        }\n      } // and the ticks\n\n      applyTextStyle(model.tmContext, model.tickTextStyle);\n      for (var t = 0; t < tickStrings[i].length; t++) {\n        if (!model._tmAtlas.has(tickStrings[i][t])) {\n          var _metrics = model.tmContext.measureText(tickStrings[i][t]);\n          var _entry = {\n            height: _metrics.actualBoundingBoxAscent + 2,\n            startingHeight: totalHeight,\n            width: _metrics.width + 2,\n            textStyle: model.tickTextStyle\n          };\n          model._tmAtlas.set(tickStrings[i][t], _entry);\n          totalHeight += _entry.height;\n          if (maxWidth < _entry.width) {\n            maxWidth = _entry.width;\n          }\n        }\n      }\n    } // always use power of two to avoid interpolation\n    // in cases where PO2 is required\n\n    maxWidth = nearestPowerOfTwo(maxWidth);\n    totalHeight = nearestPowerOfTwo(totalHeight); // set the tcoord values\n\n    model._tmAtlas.forEach(function (value) {\n      value.tcoords = [0.0, (totalHeight - value.startingHeight - value.height) / totalHeight, value.width / maxWidth, (totalHeight - value.startingHeight - value.height) / totalHeight, value.width / maxWidth, (totalHeight - value.startingHeight) / totalHeight, 0.0, (totalHeight - value.startingHeight) / totalHeight];\n    }); // make sure we have power of two dimensions\n\n    model.tmCanvas.width = maxWidth;\n    model.tmCanvas.height = totalHeight;\n    model.tmContext.textBaseline = 'bottom';\n    model.tmContext.textAlign = 'left';\n    model.tmContext.clearRect(0, 0, maxWidth, totalHeight); // draw the text onto the texture\n\n    model._tmAtlas.forEach(function (value, key) {\n      applyTextStyle(model.tmContext, value.textStyle);\n      model.tmContext.fillText(key, 1, value.startingHeight + value.height - 1);\n    });\n    model.tmTexture.setCanvas(model.tmCanvas);\n    model.tmTexture.modified();\n  }; // Make sure the data is correct\n\n  publicAPI.onModified(function () {\n    model.forceUpdate = true;\n    publicAPI.update();\n  });\n  publicAPI.setTickTextStyle = function (tickStyle) {\n    model.tickTextStyle = _objectSpread(_objectSpread({}, model.tickTextStyle), tickStyle);\n    publicAPI.modified();\n  };\n  publicAPI.setAxisTextStyle = function (axisStyle) {\n    model.axisTextStyle = _objectSpread(_objectSpread({}, model.axisTextStyle), axisStyle);\n    publicAPI.modified();\n  };\n  publicAPI.get_tmAtlas = function () {\n    return model._tmAtlas;\n  }; // try to get the bounds for the annotation. This is complicated\n  // as it relies on the pixel size of the window. Every time the camera\n  // changes the bounds change. This method simplifies by just expanding\n  // the grid bounds by a user specified factor.\n\n  publicAPI.getBounds = function () {\n    publicAPI.update();\n    vtkBoundingBox.setBounds(model.bounds, model.gridActor.getBounds());\n    vtkBoundingBox.scaleAboutCenter(model.bounds, model.boundsScaleFactor, model.boundsScaleFactor, model.boundsScaleFactor);\n    return model.bounds;\n  }; // Make sure the grid share the actor property\n\n  var _setProp = macro.chain(publicAPI.setProperty, model.gridActor.setProperty);\n  publicAPI.setProperty = function (p) {\n    return _setProp(p)[0];\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nfunction defaultValues(initialValues) {\n  return _objectSpread({\n    boundsScaleFactor: 1.3,\n    camera: null,\n    dataBounds: _toConsumableArray(vtkBoundingBox.INIT_BOUNDS),\n    faceVisibilityAngle: 8,\n    gridLines: true,\n    axisLabels: null,\n    axisTitlePixelOffset: 35.0,\n    axisTextStyle: {\n      fontColor: 'white',\n      fontStyle: 'normal',\n      fontSize: 18,\n      fontFamily: 'serif'\n    },\n    tickLabelPixelOffset: 12.0,\n    tickTextStyle: {\n      fontColor: 'white',\n      fontStyle: 'normal',\n      fontSize: 14,\n      fontFamily: 'serif'\n    }\n  }, initialValues);\n} // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, defaultValues(initialValues)); // Inheritance\n\n  vtkActor.extend(publicAPI, model, initialValues); // internal variables\n\n  model.lastFacesToDraw = [false, false, false, false, false, false];\n  model.axisLabels = ['X-Axis', 'Y-Axis', 'Z-Axis'];\n  model.tickCounts = [];\n  model.textValues = [];\n  model.lastTickBounds = [];\n  model.tmCanvas = document.createElement('canvas');\n  model.tmContext = model.tmCanvas.getContext('2d');\n  model._tmAtlas = new Map(); // for texture atlas\n\n  model.tmTexture = vtkTexture.newInstance();\n  model.tmTexture.setInterpolate(false);\n  publicAPI.getProperty().setDiffuse(0.0);\n  publicAPI.getProperty().setAmbient(1.0);\n  model.gridMapper = vtkMapper.newInstance();\n  model.polyData = vtkPolyData.newInstance();\n  model.gridMapper.setInputData(model.polyData);\n  model.gridActor = vtkActor.newInstance();\n  model.gridActor.setMapper(model.gridMapper);\n  model.gridActor.setProperty(publicAPI.getProperty());\n  model.gridActor.setParentProp(publicAPI);\n  model.textPolyData = vtkPolyData.newInstance();\n  macro.setGet(publicAPI, model, ['axisTitlePixelOffset', 'boundsScaleFactor', 'faceVisibilityAngle', 'gridLines', 'tickLabelPixelOffset']);\n  macro.setGetArray(publicAPI, model, ['dataBounds'], 6);\n  macro.setGetArray(publicAPI, model, ['axisLabels'], 3);\n  macro.get(publicAPI, model, ['axisTextStyle', 'tickTextStyle', 'camera', 'tmTexture', 'textValues', 'textPolyData', 'tickCounts', 'gridActor']); // Object methods\n\n  vtkCubeAxesActor(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = macro.newInstance(extend, 'vtkCubeAxesActor'); // ----------------------------------------------------------------------------\n\nvar vtkCubeAxesActor$1 = {\n  newInstance: newInstance,\n  extend: extend,\n  newCubeAxesActorHelper: newCubeAxesActorHelper\n};\nexport { vtkCubeAxesActor$1 as default, extend, newInstance };","map":{"version":3,"names":["_toConsumableArray","_defineProperty","vec3","mat4","d3","M","normalize2D","N","nearestPowerOfTwo","macro","vtkActor","vtkBoundingBox","vtkDataArray","vtkMapper","vtkPolyData","vtkTexture","ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","getOwnPropertyDescriptors","defineProperties","defineProperty","faceNormals","faceEdges","edgePoints","edgeAxes","faceAxes","ptv3","Float64Array","pt2v3","tmpv3","tmp2v3","xDir","yDir","invmat","applyTextStyle","ctx","style","strokeStyle","strokeColor","lineWidth","strokeSize","fillStyle","fontColor","font","concat","fontStyle","fontSize","fontFamily","vtkCubeAxesActorHelper","publicAPI","model","classHierarchy","setRenderable","renderable","tmActor","addTexture","getTmTexture","setProperty","getProperty","setParentProp","modified","createPolyDataForOneLabel","text","pos","cmat","imat","dir","offset","results","value","get_tmAtlas","get","coords","getTextPolyData","getPoints","getData","size","lastSize","transformMat4","subtract","ptIdx","cellIdx","scale","width","add","height","points","tcoords","polys","updateTexturePolyData","camera","getCompositeProjectionMatrix","lastAspectRatio","transpose","numLabels","getTextValues","numPts","numTris","Uint16Array","Float32Array","invert","textIdx","axisIdx","textValues","getAxisTitlePixelOffset","t","getTickCounts","getTickLabelPixelOffset","tcoordDA","newInstance","numberOfComponents","values","name","tmPolyData","getPointData","setTCoords","setData","getPolys","updateAPISpecificData","renderWindow","forceUpdate","newCubeAxesActorHelper","initialValues","undefined","assign","obj","tmMapper","setInputData","parentProp","setMapper","setGet","lastRedrawTime","mtime","lastRebuildTime","lastTickBounds","vtkCubeAxesActor","setCamera","cam","cameraModifiedSub","unsubscribe","onModified","update","computeFacesToDraw","getViewMatrix","changed","getDiagonalLength","dataBounds","faceDot","Math","sin","faceVisibilityAngle","PI","f","drawit","faceAxis","floor","otherAxis1","otherAxis2","normalize","getParallelProjection","dot","lastFacesToDraw","updatePolyData","facesToDraw","edgesToDraw","ticks","numLines","numEdgesToDraw","e","gridLines","lines","Uint32Array","lineIdx","z","y","x","_e","_f","faceIdx","aticks","_t","polyData","getLines","updateTextData","tickStrings","textPointCount","textPoints","axisCount","_e2","edgeIdx","edgeAxis","ptIdx1","ptIdx2","axisLabels","atickStrings","tickCounts","textPolyData","facesChanged","boundsChanged","Array","fill","_i","scaleLinear","domain","format","tickFormat","map","updateTextureAtlas","tmContext","textBaseline","textAlign","_tmAtlas","clear","maxWidth","totalHeight","has","axisTextStyle","metrics","measureText","entry","actualBoundingBoxAscent","startingHeight","textStyle","set","tickTextStyle","_metrics","_entry","tmCanvas","clearRect","fillText","tmTexture","setCanvas","setTickTextStyle","tickStyle","setAxisTextStyle","axisStyle","getBounds","setBounds","bounds","gridActor","scaleAboutCenter","boundsScaleFactor","_setProp","chain","p","defaultValues","INIT_BOUNDS","axisTitlePixelOffset","tickLabelPixelOffset","extend","document","createElement","getContext","Map","setInterpolate","setDiffuse","setAmbient","gridMapper","setGetArray","vtkCubeAxesActor$1","default"],"sources":["/home/rakshith/Documents/RemoteRendering/vtk-js-react-app/node_modules/@kitware/vtk.js/Rendering/Core/CubeAxesActor.js"],"sourcesContent":["import _toConsumableArray from '@babel/runtime/helpers/toConsumableArray';\nimport _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport { vec3, mat4 } from 'gl-matrix';\nimport * as d3 from 'd3-scale';\nimport { M as normalize2D, N as nearestPowerOfTwo } from '../../Common/Core/Math/index.js';\nimport macro from '../../macros.js';\nimport vtkActor from './Actor.js';\nimport vtkBoundingBox from '../../Common/DataModel/BoundingBox.js';\nimport vtkDataArray from '../../Common/Core/DataArray.js';\nimport vtkMapper from './Mapper.js';\nimport vtkPolyData from '../../Common/DataModel/PolyData.js';\nimport vtkTexture from './Texture.js';\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n// vtkCubeAxesActor\n// ----------------------------------------------------------------------------\n// faces are -x x -y y -z z\n// point 0 is 0,0,0 and then +x fastest changing, +y then +z\n\nvar faceNormals = [[-1, 0, 0], [1, 0, 0], [0, -1, 0], [0, 1, 0], [0, 0, -1], [0, 0, 1]];\nvar faceEdges = [[8, 7, 11, 3], [9, 1, 10, 5], [4, 9, 0, 8], [2, 11, 6, 10], [0, 3, 2, 1], [4, 5, 6, 7]];\nvar edgePoints = [[0, 1], [1, 3], [2, 3], [0, 2], [4, 5], [5, 7], [6, 7], [4, 6], [0, 4], [1, 5], [3, 7], [2, 6]];\nvar edgeAxes = [0, 1, 0, 1, 0, 1, 0, 1, 2, 2, 2, 2];\nvar faceAxes = [[1, 2], [1, 2], [0, 2], [0, 2], [0, 1], [0, 1]]; //\n// Developer note: This class is broken into the main class and a helper\n// class. The main class holds view independent properties (those properties\n// that do not change as the view's resolution/aspect ratio change). The\n// helper class is instantiated one per view and holds properties that can\n// depend on view specific values such as resolution. The helper class code\n// could have been left to the View specific implementation (such as\n// vtkWebGPUCubeAxesActor) but is instead placed here to it can be shared by\n// multiple rendering backends.\n//\n// some shared temp variables to reduce heap allocs\n\nvar ptv3 = new Float64Array(3);\nvar pt2v3 = new Float64Array(3);\nvar tmpv3 = new Float64Array(3);\nvar tmp2v3 = new Float64Array(3);\nvar xDir = new Float64Array(3);\nvar yDir = new Float64Array(3);\nvar invmat = new Float64Array(16);\n\nfunction applyTextStyle(ctx, style) {\n  ctx.strokeStyle = style.strokeColor;\n  ctx.lineWidth = style.strokeSize;\n  ctx.fillStyle = style.fontColor;\n  ctx.font = \"\".concat(style.fontStyle, \" \").concat(style.fontSize, \"px \").concat(style.fontFamily);\n} // many properties of this actor depend on the API specific view The main\n// dependency being the resolution as that drives what font sizes to use.\n// Bacause of this we need to do some of the calculations in a API specific\n// subclass. But... we don't want a lot of duplicated code between WebGL and\n// WebGPU for example so we have this helper class, that is designed to be\n// fairly API independent so that API specific views can call this to do\n// most of the work.\n\n\nfunction vtkCubeAxesActorHelper(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkCubeAxesActorHelper');\n\n  publicAPI.setRenderable = function (renderable) {\n    if (model.renderable === renderable) {\n      return;\n    }\n\n    model.renderable = renderable;\n    model.tmActor.addTexture(model.renderable.getTmTexture());\n    model.tmActor.setProperty(renderable.getProperty());\n    model.tmActor.setParentProp(renderable);\n    publicAPI.modified();\n  }; // called by updateTexturePolyData\n\n\n  publicAPI.createPolyDataForOneLabel = function (text, pos, cmat, imat, dir, offset, results) {\n    var value = model.renderable.get_tmAtlas().get(text);\n\n    if (!value) {\n      return;\n    }\n\n    var coords = model.renderable.getTextPolyData().getPoints().getData(); // compute pixel to distance factors\n\n    var size = model.lastSize;\n    ptv3[0] = coords[pos * 3];\n    ptv3[1] = coords[pos * 3 + 1];\n    ptv3[2] = coords[pos * 3 + 2];\n    vec3.transformMat4(tmpv3, ptv3, cmat); // moving 0.1 in NDC\n\n    tmpv3[0] += 0.1;\n    vec3.transformMat4(pt2v3, tmpv3, imat); // results in WC move of\n\n    vec3.subtract(xDir, pt2v3, ptv3);\n    tmpv3[0] -= 0.1;\n    tmpv3[1] += 0.1;\n    vec3.transformMat4(pt2v3, tmpv3, imat); // results in WC move of\n\n    vec3.subtract(yDir, pt2v3, ptv3);\n\n    for (var i = 0; i < 3; i++) {\n      xDir[i] /= 0.5 * 0.1 * size[0];\n      yDir[i] /= 0.5 * 0.1 * size[1];\n    } // have to find the four corners of the texture polygon for this label\n    // convert anchor point to View Coords\n\n\n    var ptIdx = results.ptIdx;\n    var cellIdx = results.cellIdx;\n    ptv3[0] = coords[pos * 3];\n    ptv3[1] = coords[pos * 3 + 1];\n    ptv3[2] = coords[pos * 3 + 2]; // horizontal left, right, or middle alignment based on dir[0]\n\n    if (dir[0] < -0.5) {\n      vec3.scale(tmpv3, xDir, dir[0] * offset - value.width);\n    } else if (dir[0] > 0.5) {\n      vec3.scale(tmpv3, xDir, dir[0] * offset);\n    } else {\n      vec3.scale(tmpv3, xDir, dir[0] * offset - value.width / 2.0);\n    }\n\n    vec3.add(ptv3, ptv3, tmpv3);\n    vec3.scale(tmpv3, yDir, dir[1] * offset - value.height / 2.0);\n    vec3.add(ptv3, ptv3, tmpv3);\n    results.points[ptIdx * 3] = ptv3[0];\n    results.points[ptIdx * 3 + 1] = ptv3[1];\n    results.points[ptIdx * 3 + 2] = ptv3[2];\n    results.tcoords[ptIdx * 2] = value.tcoords[0];\n    results.tcoords[ptIdx * 2 + 1] = value.tcoords[1];\n    ptIdx++;\n    vec3.scale(tmpv3, xDir, value.width);\n    vec3.add(ptv3, ptv3, tmpv3);\n    results.points[ptIdx * 3] = ptv3[0];\n    results.points[ptIdx * 3 + 1] = ptv3[1];\n    results.points[ptIdx * 3 + 2] = ptv3[2];\n    results.tcoords[ptIdx * 2] = value.tcoords[2];\n    results.tcoords[ptIdx * 2 + 1] = value.tcoords[3];\n    ptIdx++;\n    vec3.scale(tmpv3, yDir, value.height);\n    vec3.add(ptv3, ptv3, tmpv3);\n    results.points[ptIdx * 3] = ptv3[0];\n    results.points[ptIdx * 3 + 1] = ptv3[1];\n    results.points[ptIdx * 3 + 2] = ptv3[2];\n    results.tcoords[ptIdx * 2] = value.tcoords[4];\n    results.tcoords[ptIdx * 2 + 1] = value.tcoords[5];\n    ptIdx++;\n    vec3.scale(tmpv3, xDir, value.width);\n    vec3.subtract(ptv3, ptv3, tmpv3);\n    results.points[ptIdx * 3] = ptv3[0];\n    results.points[ptIdx * 3 + 1] = ptv3[1];\n    results.points[ptIdx * 3 + 2] = ptv3[2];\n    results.tcoords[ptIdx * 2] = value.tcoords[6];\n    results.tcoords[ptIdx * 2 + 1] = value.tcoords[7];\n    ptIdx++; // add the two triangles to represent the quad\n\n    results.polys[cellIdx * 4] = 3;\n    results.polys[cellIdx * 4 + 1] = ptIdx - 4;\n    results.polys[cellIdx * 4 + 2] = ptIdx - 3;\n    results.polys[cellIdx * 4 + 3] = ptIdx - 2;\n    cellIdx++;\n    results.polys[cellIdx * 4] = 3;\n    results.polys[cellIdx * 4 + 1] = ptIdx - 4;\n    results.polys[cellIdx * 4 + 2] = ptIdx - 2;\n    results.polys[cellIdx * 4 + 3] = ptIdx - 1;\n    results.ptIdx += 4;\n    results.cellIdx += 2;\n  }; // update the polydata associated with drawing the text labels\n  // specifically the quads used for each label and their associated tcoords\n  // etc. This changes every time the camera viewpoint changes\n\n\n  publicAPI.updateTexturePolyData = function () {\n    var cmat = model.camera.getCompositeProjectionMatrix(model.lastAspectRatio, -1, 1);\n    mat4.transpose(cmat, cmat); // update the polydata\n\n    var numLabels = model.renderable.getTextValues().length;\n    var numPts = numLabels * 4;\n    var numTris = numLabels * 2;\n    var points = new Float64Array(numPts * 3);\n    var polys = new Uint16Array(numTris * 4);\n    var tcoords = new Float32Array(numPts * 2);\n    mat4.invert(invmat, cmat);\n    var results = {\n      ptIdx: 0,\n      cellIdx: 0,\n      polys: polys,\n      points: points,\n      tcoords: tcoords\n    };\n    var ptIdx = 0;\n    var textIdx = 0;\n    var axisIdx = 0;\n    var coords = model.renderable.getTextPolyData().getPoints().getData();\n    var textValues = model.renderable.getTextValues();\n\n    while (ptIdx < coords.length / 3) {\n      // compute the direction to move out\n      ptv3[0] = coords[ptIdx * 3];\n      ptv3[1] = coords[ptIdx * 3 + 1];\n      ptv3[2] = coords[ptIdx * 3 + 2];\n      vec3.transformMat4(tmpv3, ptv3, cmat);\n      ptv3[0] = coords[ptIdx * 3 + 3];\n      ptv3[1] = coords[ptIdx * 3 + 4];\n      ptv3[2] = coords[ptIdx * 3 + 5];\n      vec3.transformMat4(tmp2v3, ptv3, cmat);\n      vec3.subtract(tmpv3, tmpv3, tmp2v3);\n      var dir = [tmpv3[0], tmpv3[1]];\n      normalize2D(dir); // write the axis label\n\n      publicAPI.createPolyDataForOneLabel(textValues[textIdx], ptIdx, cmat, invmat, dir, model.renderable.getAxisTitlePixelOffset(), results);\n      ptIdx += 2;\n      textIdx++; // write the tick labels\n\n      for (var t = 0; t < model.renderable.getTickCounts()[axisIdx]; t++) {\n        publicAPI.createPolyDataForOneLabel(textValues[textIdx], ptIdx, cmat, invmat, dir, model.renderable.getTickLabelPixelOffset(), results);\n        ptIdx++;\n        textIdx++;\n      }\n\n      axisIdx++;\n    }\n\n    var tcoordDA = vtkDataArray.newInstance({\n      numberOfComponents: 2,\n      values: tcoords,\n      name: 'TextureCoordinates'\n    });\n    model.tmPolyData.getPointData().setTCoords(tcoordDA);\n    model.tmPolyData.getPoints().setData(points, 3);\n    model.tmPolyData.getPoints().modified();\n    model.tmPolyData.getPolys().setData(polys, 1);\n    model.tmPolyData.getPolys().modified();\n    model.tmPolyData.modified();\n  };\n\n  publicAPI.updateAPISpecificData = function (size, camera, renderWindow) {\n    // has the size changed?\n    if (model.lastSize[0] !== size[0] || model.lastSize[1] !== size[1]) {\n      model.lastSize[0] = size[0];\n      model.lastSize[1] = size[1];\n      model.lastAspectRatio = size[0] / size[1];\n      model.forceUpdate = true;\n    }\n\n    model.camera = camera; // compute bounds for label quads whenever the camera changes\n\n    publicAPI.updateTexturePolyData();\n  };\n}\n\nvar newCubeAxesActorHelper = macro.newInstance(function (publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {\n    renderable: null\n  };\n  Object.assign(model, {}, initialValues); // Inheritance\n\n  macro.obj(publicAPI, model);\n  model.tmPolyData = vtkPolyData.newInstance();\n  model.tmMapper = vtkMapper.newInstance();\n  model.tmMapper.setInputData(model.tmPolyData);\n  model.tmActor = vtkActor.newInstance({\n    parentProp: publicAPI\n  });\n  model.tmActor.setMapper(model.tmMapper);\n  macro.setGet(publicAPI, model, ['renderable']);\n  macro.get(publicAPI, model, ['lastSize', 'lastAspectRatio', 'axisTextStyle', 'tickTextStyle', 'tmActor', 'ticks']);\n  model.forceUpdate = false;\n  model.lastRedrawTime = {};\n  macro.obj(model.lastRedrawTime, {\n    mtime: 0\n  });\n  model.lastRebuildTime = {};\n  macro.obj(model.lastRebuildTime, {\n    mtime: 0\n  });\n  model.lastSize = [-1, -1]; // internal variables\n\n  model.lastTickBounds = [];\n  vtkCubeAxesActorHelper(publicAPI, model);\n}, 'vtkCubeAxesActorHelper');\n\nfunction vtkCubeAxesActor(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkCubeAxesActor');\n\n  publicAPI.setCamera = function (cam) {\n    if (model.camera === cam) {\n      return;\n    }\n\n    if (model.cameraModifiedSub) {\n      model.cameraModifiedSub.unsubscribe();\n      model.cameraModifiedSub = null;\n    }\n\n    model.camera = cam;\n\n    if (cam) {\n      model.cameraModifiedSub = cam.onModified(publicAPI.update);\n    }\n\n    publicAPI.update();\n    publicAPI.modified();\n  }; // estimate from a camera model what faces to draw\n  // return true if the list of faces to draw has changed\n\n\n  publicAPI.computeFacesToDraw = function () {\n    var cmat = model.camera.getViewMatrix();\n    mat4.transpose(cmat, cmat);\n    var changed = false;\n    var length = vtkBoundingBox.getDiagonalLength(model.dataBounds);\n    var faceDot = Math.sin(model.faceVisibilityAngle * Math.PI / 180.0);\n\n    for (var f = 0; f < 6; f++) {\n      var drawit = false;\n      var faceAxis = Math.floor(f / 2);\n      var otherAxis1 = (faceAxis + 1) % 3;\n      var otherAxis2 = (faceAxis + 2) % 3; // only for non degenerate axes\n\n      if (model.dataBounds[otherAxis1 * 2] !== model.dataBounds[otherAxis1 * 2 + 1] && model.dataBounds[otherAxis2 * 2] !== model.dataBounds[otherAxis2 * 2 + 1]) {\n        // for each face transform the center and off center to get a direction vector\n        ptv3[faceAxis] = model.dataBounds[f] - 0.1 * length * faceNormals[f][faceAxis];\n        ptv3[otherAxis1] = 0.5 * (model.dataBounds[otherAxis1 * 2] + model.dataBounds[otherAxis1 * 2 + 1]);\n        ptv3[otherAxis2] = 0.5 * (model.dataBounds[otherAxis2 * 2] + model.dataBounds[otherAxis2 * 2 + 1]);\n        vec3.transformMat4(tmpv3, ptv3, cmat);\n        ptv3[faceAxis] = model.dataBounds[f];\n        vec3.transformMat4(tmp2v3, ptv3, cmat);\n        vec3.subtract(tmpv3, tmp2v3, tmpv3);\n        vec3.normalize(tmpv3, tmpv3); // tmpv3 now holds the face normal vector\n\n        drawit = tmpv3[2] > faceDot; // for perspctive we need the view direction to the plane\n\n        if (!model.camera.getParallelProjection()) {\n          vec3.normalize(tmp2v3, tmp2v3);\n          drawit = vec3.dot(tmp2v3, tmpv3) > faceDot;\n        }\n      }\n\n      if (drawit !== model.lastFacesToDraw[f]) {\n        model.lastFacesToDraw[f] = drawit;\n        changed = true;\n      }\n    }\n\n    return changed;\n  }; // update the polydata that represents the boundingd edges and gridlines\n\n\n  publicAPI.updatePolyData = function (facesToDraw, edgesToDraw, ticks) {\n    // compute the number of points and lines required\n    var numPts = 0;\n    var numLines = 0;\n    numPts += 8; // always start with the 8 cube points\n    // count edgesToDraw\n\n    var numEdgesToDraw = 0;\n\n    for (var e = 0; e < 12; e++) {\n      if (edgesToDraw[e] > 0) {\n        numEdgesToDraw++;\n      }\n    }\n\n    numLines += numEdgesToDraw; // add values for gridlines\n\n    if (model.gridLines) {\n      for (var f = 0; f < 6; f++) {\n        if (facesToDraw[f]) {\n          numPts += ticks[faceAxes[f][0]].length * 2 + ticks[faceAxes[f][1]].length * 2;\n          numLines += ticks[faceAxes[f][0]].length + ticks[faceAxes[f][1]].length;\n        }\n      }\n    } // now allocate the memory\n\n\n    var points = new Float64Array(numPts * 3);\n    var lines = new Uint32Array(numLines * 3);\n    var ptIdx = 0;\n    var lineIdx = 0; // add the 8 corner points\n\n    for (var z = 0; z < 2; z++) {\n      for (var y = 0; y < 2; y++) {\n        for (var x = 0; x < 2; x++) {\n          points[ptIdx * 3] = model.dataBounds[x];\n          points[ptIdx * 3 + 1] = model.dataBounds[2 + y];\n          points[ptIdx * 3 + 2] = model.dataBounds[4 + z];\n          ptIdx++;\n        }\n      }\n    } // draw the edges\n\n\n    for (var _e = 0; _e < 12; _e++) {\n      if (edgesToDraw[_e] > 0) {\n        lines[lineIdx * 3] = 2;\n        lines[lineIdx * 3 + 1] = edgePoints[_e][0];\n        lines[lineIdx * 3 + 2] = edgePoints[_e][1];\n        lineIdx++;\n      }\n    } // now handle gridlines\n    // grid lines are tick[axis1] + ticks[axes2] lines each having two points\n    // for simplicity we don;t worry about duplicating points, this is tiny\n\n\n    if (model.gridLines) {\n      // for each visible face\n      // add the points\n      for (var _f = 0; _f < 6; _f++) {\n        if (facesToDraw[_f]) {\n          var faceIdx = Math.floor(_f / 2);\n          var aticks = ticks[faceAxes[_f][0]];\n\n          for (var t = 0; t < aticks.length; t++) {\n            points[ptIdx * 3 + faceIdx] = model.dataBounds[_f];\n            points[ptIdx * 3 + faceAxes[_f][0]] = aticks[t];\n            points[ptIdx * 3 + faceAxes[_f][1]] = model.dataBounds[faceAxes[_f][1] * 2];\n            ptIdx++;\n            points[ptIdx * 3 + faceIdx] = model.dataBounds[_f];\n            points[ptIdx * 3 + faceAxes[_f][0]] = aticks[t];\n            points[ptIdx * 3 + faceAxes[_f][1]] = model.dataBounds[faceAxes[_f][1] * 2 + 1];\n            ptIdx++;\n            lines[lineIdx * 3] = 2;\n            lines[lineIdx * 3 + 1] = ptIdx - 2;\n            lines[lineIdx * 3 + 2] = ptIdx - 1;\n            lineIdx++;\n          }\n\n          aticks = ticks[faceAxes[_f][1]];\n\n          for (var _t = 0; _t < aticks.length; _t++) {\n            points[ptIdx * 3 + faceIdx] = model.dataBounds[_f];\n            points[ptIdx * 3 + faceAxes[_f][1]] = aticks[_t];\n            points[ptIdx * 3 + faceAxes[_f][0]] = model.dataBounds[faceAxes[_f][0] * 2];\n            ptIdx++;\n            points[ptIdx * 3 + faceIdx] = model.dataBounds[_f];\n            points[ptIdx * 3 + faceAxes[_f][1]] = aticks[_t];\n            points[ptIdx * 3 + faceAxes[_f][0]] = model.dataBounds[faceAxes[_f][0] * 2 + 1];\n            ptIdx++;\n            lines[lineIdx * 3] = 2;\n            lines[lineIdx * 3 + 1] = ptIdx - 2;\n            lines[lineIdx * 3 + 2] = ptIdx - 1;\n            lineIdx++;\n          }\n        }\n      }\n    }\n\n    model.polyData.getPoints().setData(points, 3);\n    model.polyData.getPoints().modified();\n    model.polyData.getLines().setData(lines, 1);\n    model.polyData.getLines().modified();\n    model.polyData.modified();\n  }; // update the data that represents where to put the labels\n  // in world coordinates. This only changes when faces to draw changes\n  // of dataBounds changes\n\n\n  publicAPI.updateTextData = function (facesToDraw, edgesToDraw, ticks, tickStrings) {\n    // count outside edgesToDraw\n    var textPointCount = 0;\n\n    for (var e = 0; e < 12; e++) {\n      if (edgesToDraw[e] === 1) {\n        textPointCount += 2;\n        textPointCount += ticks[edgeAxes[e]].length;\n      }\n    }\n\n    var points = model.polyData.getPoints().getData();\n    var textPoints = new Float64Array(textPointCount * 3);\n    var ptIdx = 0;\n    var textIdx = 0;\n    var axisCount = 0;\n\n    for (var f = 0; f < 6; f++) {\n      if (facesToDraw[f]) {\n        for (var _e2 = 0; _e2 < 4; _e2++) {\n          var edgeIdx = faceEdges[f][_e2];\n\n          if (edgesToDraw[edgeIdx] === 1) {\n            var edgeAxis = edgeAxes[edgeIdx]; // add a middle point on the edge\n\n            var ptIdx1 = edgePoints[edgeIdx][0] * 3;\n            var ptIdx2 = edgePoints[edgeIdx][1] * 3;\n            textPoints[ptIdx * 3] = 0.5 * (points[ptIdx1] + points[ptIdx2]);\n            textPoints[ptIdx * 3 + 1] = 0.5 * (points[ptIdx1 + 1] + points[ptIdx2 + 1]);\n            textPoints[ptIdx * 3 + 2] = 0.5 * (points[ptIdx1 + 2] + points[ptIdx2 + 2]);\n            ptIdx++; // add a middle face point, we use this to\n            // move the labels away from the edge in the right direction\n\n            var faceIdx = Math.floor(f / 2);\n            textPoints[ptIdx * 3 + faceIdx] = model.dataBounds[f];\n            textPoints[ptIdx * 3 + faceAxes[f][0]] = 0.5 * (model.dataBounds[faceAxes[f][0] * 2] + model.dataBounds[faceAxes[f][0] * 2 + 1]);\n            textPoints[ptIdx * 3 + faceAxes[f][1]] = 0.5 * (model.dataBounds[faceAxes[f][1] * 2] + model.dataBounds[faceAxes[f][1] * 2 + 1]);\n            ptIdx++; // set the text\n\n            model.textValues[textIdx] = model.axisLabels[edgeAxis];\n            textIdx++; // now add the tick marks along the edgeAxis\n\n            var otherAxis1 = (edgeAxis + 1) % 3;\n            var otherAxis2 = (edgeAxis + 2) % 3;\n            var aticks = ticks[edgeAxis];\n            var atickStrings = tickStrings[edgeAxis];\n            model.tickCounts[axisCount] = aticks.length;\n\n            for (var t = 0; t < aticks.length; t++) {\n              textPoints[ptIdx * 3 + edgeAxis] = aticks[t];\n              textPoints[ptIdx * 3 + otherAxis1] = points[ptIdx1 + otherAxis1];\n              textPoints[ptIdx * 3 + otherAxis2] = points[ptIdx1 + otherAxis2];\n              ptIdx++; // set the text\n\n              model.textValues[textIdx] = atickStrings[t];\n              textIdx++;\n            }\n\n            axisCount++;\n          }\n        }\n      }\n    }\n\n    model.textPolyData.getPoints().setData(textPoints, 3);\n    model.textPolyData.modified();\n  }; // main method to rebuild the cube axes, gets called on camera modify\n  // and changes to key members\n\n\n  publicAPI.update = function () {\n    // Can't do anything if we don't have a camera...\n    if (!model.camera) {\n      return;\n    } // compute what faces to draw\n\n\n    var facesChanged = publicAPI.computeFacesToDraw();\n    var facesToDraw = model.lastFacesToDraw; // have the bounds changed?\n\n    var boundsChanged = false;\n\n    for (var i = 0; i < 6; i++) {\n      if (model.dataBounds[i] !== model.lastTickBounds[i]) {\n        boundsChanged = true;\n        model.lastTickBounds[i] = model.dataBounds[i];\n      }\n    } // did something significant change? If so rebuild a lot of things\n\n\n    if (facesChanged || boundsChanged || model.forceUpdate) {\n      // compute the edges to draw\n      // for each drawn face, mark edges, all single mark edges we draw\n      var edgesToDraw = new Array(12).fill(0);\n\n      for (var f = 0; f < 6; f++) {\n        if (facesToDraw[f]) {\n          for (var e = 0; e < 4; e++) {\n            edgesToDraw[faceEdges[f][e]]++;\n          }\n        }\n      } // compute tick marks for axes\n\n\n      var ticks = [];\n      var tickStrings = [];\n\n      for (var _i = 0; _i < 3; _i++) {\n        var scale = d3.scaleLinear().domain([model.dataBounds[_i * 2], model.dataBounds[_i * 2 + 1]]);\n        ticks[_i] = scale.ticks(5);\n        var format = scale.tickFormat(5);\n        tickStrings[_i] = ticks[_i].map(format);\n      } // update gridlines / edge lines\n\n\n      publicAPI.updatePolyData(facesToDraw, edgesToDraw, ticks); // compute label world coords and text\n\n      publicAPI.updateTextData(facesToDraw, edgesToDraw, ticks, tickStrings); // rebuild the texture only when force or changed bounds, face\n      // visibility changes do to change the atlas\n\n      if (boundsChanged || model.forceUpdate) {\n        publicAPI.updateTextureAtlas(tickStrings);\n      }\n    }\n\n    model.forceUpdate = false;\n  }; // create the texture map atlas that contains the rendering of\n  // all the text strings. Only needs to be called when the text strings\n  // have changed (labels and ticks)\n\n\n  publicAPI.updateTextureAtlas = function (tickStrings) {\n    // compute the width and height we need\n    // set the text properties\n    model.tmContext.textBaseline = 'bottom';\n    model.tmContext.textAlign = 'left'; // first the three labels\n\n    model._tmAtlas.clear();\n\n    var maxWidth = 0;\n    var totalHeight = 1; // start one pixel in so we have a border\n\n    for (var i = 0; i < 3; i++) {\n      if (!model._tmAtlas.has(model.axisLabels[i])) {\n        applyTextStyle(model.tmContext, model.axisTextStyle);\n        var metrics = model.tmContext.measureText(model.axisLabels[i]);\n        var entry = {\n          height: metrics.actualBoundingBoxAscent + 2,\n          startingHeight: totalHeight,\n          width: metrics.width + 2,\n          textStyle: model.axisTextStyle\n        };\n\n        model._tmAtlas.set(model.axisLabels[i], entry);\n\n        totalHeight += entry.height;\n\n        if (maxWidth < entry.width) {\n          maxWidth = entry.width;\n        }\n      } // and the ticks\n\n\n      applyTextStyle(model.tmContext, model.tickTextStyle);\n\n      for (var t = 0; t < tickStrings[i].length; t++) {\n        if (!model._tmAtlas.has(tickStrings[i][t])) {\n          var _metrics = model.tmContext.measureText(tickStrings[i][t]);\n\n          var _entry = {\n            height: _metrics.actualBoundingBoxAscent + 2,\n            startingHeight: totalHeight,\n            width: _metrics.width + 2,\n            textStyle: model.tickTextStyle\n          };\n\n          model._tmAtlas.set(tickStrings[i][t], _entry);\n\n          totalHeight += _entry.height;\n\n          if (maxWidth < _entry.width) {\n            maxWidth = _entry.width;\n          }\n        }\n      }\n    } // always use power of two to avoid interpolation\n    // in cases where PO2 is required\n\n\n    maxWidth = nearestPowerOfTwo(maxWidth);\n    totalHeight = nearestPowerOfTwo(totalHeight); // set the tcoord values\n\n    model._tmAtlas.forEach(function (value) {\n      value.tcoords = [0.0, (totalHeight - value.startingHeight - value.height) / totalHeight, value.width / maxWidth, (totalHeight - value.startingHeight - value.height) / totalHeight, value.width / maxWidth, (totalHeight - value.startingHeight) / totalHeight, 0.0, (totalHeight - value.startingHeight) / totalHeight];\n    }); // make sure we have power of two dimensions\n\n\n    model.tmCanvas.width = maxWidth;\n    model.tmCanvas.height = totalHeight;\n    model.tmContext.textBaseline = 'bottom';\n    model.tmContext.textAlign = 'left';\n    model.tmContext.clearRect(0, 0, maxWidth, totalHeight); // draw the text onto the texture\n\n    model._tmAtlas.forEach(function (value, key) {\n      applyTextStyle(model.tmContext, value.textStyle);\n      model.tmContext.fillText(key, 1, value.startingHeight + value.height - 1);\n    });\n\n    model.tmTexture.setCanvas(model.tmCanvas);\n    model.tmTexture.modified();\n  }; // Make sure the data is correct\n\n\n  publicAPI.onModified(function () {\n    model.forceUpdate = true;\n    publicAPI.update();\n  });\n\n  publicAPI.setTickTextStyle = function (tickStyle) {\n    model.tickTextStyle = _objectSpread(_objectSpread({}, model.tickTextStyle), tickStyle);\n    publicAPI.modified();\n  };\n\n  publicAPI.setAxisTextStyle = function (axisStyle) {\n    model.axisTextStyle = _objectSpread(_objectSpread({}, model.axisTextStyle), axisStyle);\n    publicAPI.modified();\n  };\n\n  publicAPI.get_tmAtlas = function () {\n    return model._tmAtlas;\n  }; // try to get the bounds for the annotation. This is complicated\n  // as it relies on the pixel size of the window. Every time the camera\n  // changes the bounds change. This method simplifies by just expanding\n  // the grid bounds by a user specified factor.\n\n\n  publicAPI.getBounds = function () {\n    publicAPI.update();\n    vtkBoundingBox.setBounds(model.bounds, model.gridActor.getBounds());\n    vtkBoundingBox.scaleAboutCenter(model.bounds, model.boundsScaleFactor, model.boundsScaleFactor, model.boundsScaleFactor);\n    return model.bounds;\n  }; // Make sure the grid share the actor property\n\n\n  var _setProp = macro.chain(publicAPI.setProperty, model.gridActor.setProperty);\n\n  publicAPI.setProperty = function (p) {\n    return _setProp(p)[0];\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\n\nfunction defaultValues(initialValues) {\n  return _objectSpread({\n    boundsScaleFactor: 1.3,\n    camera: null,\n    dataBounds: _toConsumableArray(vtkBoundingBox.INIT_BOUNDS),\n    faceVisibilityAngle: 8,\n    gridLines: true,\n    axisLabels: null,\n    axisTitlePixelOffset: 35.0,\n    axisTextStyle: {\n      fontColor: 'white',\n      fontStyle: 'normal',\n      fontSize: 18,\n      fontFamily: 'serif'\n    },\n    tickLabelPixelOffset: 12.0,\n    tickTextStyle: {\n      fontColor: 'white',\n      fontStyle: 'normal',\n      fontSize: 14,\n      fontFamily: 'serif'\n    }\n  }, initialValues);\n} // ----------------------------------------------------------------------------\n\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, defaultValues(initialValues)); // Inheritance\n\n  vtkActor.extend(publicAPI, model, initialValues); // internal variables\n\n  model.lastFacesToDraw = [false, false, false, false, false, false];\n  model.axisLabels = ['X-Axis', 'Y-Axis', 'Z-Axis'];\n  model.tickCounts = [];\n  model.textValues = [];\n  model.lastTickBounds = [];\n  model.tmCanvas = document.createElement('canvas');\n  model.tmContext = model.tmCanvas.getContext('2d');\n  model._tmAtlas = new Map(); // for texture atlas\n\n  model.tmTexture = vtkTexture.newInstance();\n  model.tmTexture.setInterpolate(false);\n  publicAPI.getProperty().setDiffuse(0.0);\n  publicAPI.getProperty().setAmbient(1.0);\n  model.gridMapper = vtkMapper.newInstance();\n  model.polyData = vtkPolyData.newInstance();\n  model.gridMapper.setInputData(model.polyData);\n  model.gridActor = vtkActor.newInstance();\n  model.gridActor.setMapper(model.gridMapper);\n  model.gridActor.setProperty(publicAPI.getProperty());\n  model.gridActor.setParentProp(publicAPI);\n  model.textPolyData = vtkPolyData.newInstance();\n  macro.setGet(publicAPI, model, ['axisTitlePixelOffset', 'boundsScaleFactor', 'faceVisibilityAngle', 'gridLines', 'tickLabelPixelOffset']);\n  macro.setGetArray(publicAPI, model, ['dataBounds'], 6);\n  macro.setGetArray(publicAPI, model, ['axisLabels'], 3);\n  macro.get(publicAPI, model, ['axisTextStyle', 'tickTextStyle', 'camera', 'tmTexture', 'textValues', 'textPolyData', 'tickCounts', 'gridActor']); // Object methods\n\n  vtkCubeAxesActor(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = macro.newInstance(extend, 'vtkCubeAxesActor'); // ----------------------------------------------------------------------------\n\nvar vtkCubeAxesActor$1 = {\n  newInstance: newInstance,\n  extend: extend,\n  newCubeAxesActorHelper: newCubeAxesActorHelper\n};\n\nexport { vtkCubeAxesActor$1 as default, extend, newInstance };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}