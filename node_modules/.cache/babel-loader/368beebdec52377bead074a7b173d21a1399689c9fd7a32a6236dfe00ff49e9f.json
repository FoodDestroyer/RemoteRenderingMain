{"ast":null,"code":"import macro from '../../macros.js';\nimport vtkBoundingBox from '../../Common/DataModel/BoundingBox.js';\nimport vtkDataArray from '../../Common/Core/DataArray.js';\nimport { f as vtkMath } from '../../Common/Core/Math/index.js';\nimport { AttributeTypes } from '../../Common/DataModel/DataSetAttributes/Constants.js';\nimport vtkPoints from '../../Common/Core/Points.js';\nimport vtkPolyData from '../../Common/DataModel/PolyData.js';\nimport vtkTriangle from '../../Common/DataModel/Triangle.js';\nvar VertexType = {\n  VTK_SIMPLE_VERTEX: 0,\n  VTK_FIXED_VERTEX: 1,\n  VTK_FEATURE_EDGE_VERTEX: 2,\n  VTK_BOUNDARY_EDGE_VERTEX: 3\n}; // ----------------------------------------------------------------------------\n// vtkWindowedSincPolyDataFilter methods\n// ----------------------------------------------------------------------------\n\nfunction vtkWindowedSincPolyDataFilter(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkWindowedSincPolyDataFilter');\n  publicAPI.vtkWindowedSincPolyDataFilterExecute = function (inPts, inputPolyData, output) {\n    if (!inPts || model.numberOfIterations <= 0) {\n      return inPts;\n    }\n    var inPtsData = inPts.getData();\n    var inVerts = inputPolyData.getVerts().getData();\n    var inLines = inputPolyData.getLines().getData();\n    var inPolys = inputPolyData.getPolys().getData();\n    var inStrips = inputPolyData.getStrips().getData();\n    var cosFeatureAngle = Math.cos(vtkMath.radiansFromDegrees(model.featureAngle));\n    var cosEdgeAngle = Math.cos(vtkMath.radiansFromDegrees(model.edgeAngle));\n    var numPts = inPts.getNumberOfPoints(); // Perform topological analysis. What we're going to do is build a connectivity\n    // array of connected vertices. The outcome will be one of three\n    // classifications for a vertex: VTK_SIMPLE_VERTEX, VTK_FIXED_VERTEX. or\n    // VTK_EDGE_VERTEX. Simple vertices are smoothed using all connected\n    // vertices. FIXED vertices are never smoothed. Edge vertices are smoothed\n    // using a subset of the attached vertices.\n\n    var verts = new Array(numPts);\n    for (var i = 0; i < numPts; ++i) {\n      verts[i] = {\n        type: VertexType.VTK_SIMPLE_VERTEX,\n        edges: null\n      };\n    } // check vertices first. Vertices are never smoothed_--------------\n\n    var npts = 0;\n    for (var _i = 0; _i < inVerts.length; _i += npts + 1) {\n      npts = inVerts[_i];\n      var pts = inVerts.slice(_i + 1, _i + 1 + npts);\n      for (var j = 0; j < pts.length; ++j) {\n        verts[pts[j]].type = VertexType.VTK_FIXED_VERTEX;\n      }\n    } // now check lines. Only manifold lines can be smoothed------------\n\n    for (var _i2 = 0; _i2 < inLines.length; _i2 += npts + 1) {\n      npts = inLines[_i2];\n      var _pts = inLines.slice(_i2 + 1, _i2 + 1 + npts); // Check for closed loop which are treated specially. Basically the\n      // last point is ignored (set to fixed).\n\n      var closedLoop = _pts[0] === _pts[npts - 1] && npts > 3;\n      for (var _j = 0; _j < npts; ++_j) {\n        if (verts[_pts[_j]].type === VertexType.VTK_SIMPLE_VERTEX) {\n          // First point\n          if (_j === 0) {\n            if (!closedLoop) {\n              verts[_pts[0]].type = VertexType.VTK_FIXED_VERTEX;\n            } else {\n              verts[_pts[0]].type = VertexType.VTK_FEATURE_EDGE_VERTEX;\n              verts[_pts[0]].edges = [_pts[npts - 2], _pts[1]];\n            }\n          } // Last point\n          else if (_j === npts - 1 && !closedLoop) {\n            verts[_pts[_j]].type = VertexType.VTK_FIXED_VERTEX;\n          } // In between point // is edge vertex (unless already edge vertex!)\n          else {\n            verts[_pts[_j]].type = VertexType.VTK_FEATURE_EDGE_VERTEX;\n            verts[_pts[_j]].edges = [_pts[_j - 1], _pts[closedLoop && _j === npts - 2 ? 0 : _j + 1]];\n          }\n        } // if simple vertex\n        // Vertex has been visited before, need to fix it. Special case\n        // when working on closed loop.\n        else if (verts[_pts[_j]].type === VertexType.VTK_FEATURE_EDGE_VERTEX && !(closedLoop && _j === npts - 1)) {\n          verts[_pts[_j]].type = VertexType.VTK_FIXED_VERTEX;\n          verts[_pts[_j]].edges = null;\n        }\n      } // for all points in this line\n    } // for all lines\n    // now polygons and triangle strips-------------------------------\n\n    var numPolys = inPolys.length;\n    var numStrips = inStrips.length;\n    if (numPolys > 0 || numStrips > 0) {\n      var inMesh = vtkPolyData.newInstance();\n      inMesh.setPoints(inputPolyData.getPoints());\n      inMesh.setPolys(inputPolyData.getPolys());\n      var mesh = inMesh;\n      var neighbors = [];\n      var nei = 0; // const numNeiPts = 0;\n\n      var normal = [];\n      var neiNormal = [];\n      /* TODO: Add vtkTriangleFilter\n      if ( (numStrips = inputPolyData.getStrips().GetNumberOfCells()) > 0 )\n      { // convert data to triangles\n        inMesh.setStrips(inputPolyData.getStrips());\n        const toTris = vtkTriangleFilter.newInstance();\n        toTris.setInputData(inMesh);\n        toTris.update();\n        mesh = toTris.getOutput();\n      }\n      */\n\n      mesh.buildLinks(); // to do neighborhood searching\n\n      var polys = mesh.getPolys().getData();\n      var cellId = 0;\n      for (var _c = 0; _c < polys.length; _c += npts + 1, ++cellId) {\n        npts = polys[_c];\n        var _pts2 = polys.slice(_c + 1, _c + 1 + npts);\n        for (var _i3 = 0; _i3 < npts; ++_i3) {\n          var p1 = _pts2[_i3];\n          var p2 = _pts2[(_i3 + 1) % npts];\n          if (verts[p1].edges === null) {\n            verts[p1].edges = [];\n          }\n          if (verts[p2].edges == null) {\n            verts[p2].edges = [];\n          }\n          neighbors = mesh.getCellEdgeNeighbors(cellId, p1, p2);\n          var numNei = neighbors.length; // neighbors->GetNumberOfIds();\n\n          var edge = VertexType.VTK_SIMPLE_VERTEX;\n          if (numNei === 0) {\n            edge = VertexType.VTK_BOUNDARY_EDGE_VERTEX;\n          } else if (numNei >= 2) {\n            // non-manifold case, check nonmanifold smoothing state\n            if (!model.nonManifoldSmoothing) {\n              // check to make sure that this edge hasn't been marked already\n              var _j2 = 0;\n              for (; _j2 < numNei; ++_j2) {\n                if (neighbors[_j2] < cellId) {\n                  break;\n                }\n              }\n              if (_j2 >= numNei) {\n                edge = VertexType.VTK_FEATURE_EDGE_VERTEX;\n              }\n            }\n            /* eslint-disable no-cond-assign */\n          } else if (numNei === 1 && (nei = neighbors[0]) > cellId) {\n            if (model.featureEdgeSmoothing) {\n              // TODO: support polygons\n              // vtkPolygon::ComputeNormal(inPts,npts,pts,normal);\n              vtkTriangle.computeNormal(inPts.getPoint(_pts2[0]), inPts.getPoint(_pts2[1]), inPts.getPoint(_pts2[2]), normal);\n              var _mesh$getCellPoints = mesh.getCellPoints(nei),\n                cellPointIds = _mesh$getCellPoints.cellPointIds; // vtkPolygon::ComputeNormal(inPts,numNeiPts,neiPts,neiNormal);\n\n              vtkTriangle.computeNormal(inPts.getPoint(cellPointIds[0]), inPts.getPoint(cellPointIds[1]), inPts.getPoint(cellPointIds[2]), neiNormal);\n              if (vtkMath.dot(normal, neiNormal) <= cosFeatureAngle) {\n                edge = VertexType.VTK_FEATURE_EDGE_VERTEX;\n              }\n            }\n          } // a visited edge; skip rest of analysis\n          else {\n            /* eslint-disable no-continue */\n            continue;\n          }\n          if (edge && verts[p1].type === VertexType.VTK_SIMPLE_VERTEX) {\n            verts[p1].edges = [p2];\n            verts[p1].type = edge;\n          } else if (edge && verts[p1].type === VertexType.VTK_BOUNDARY_EDGE_VERTEX || edge && verts[p1].type === VertexType.VTK_FEATURE_EDGE_VERTEX || !edge && verts[p1].type === VertexType.VTK_SIMPLE_VERTEX) {\n            verts[p1].edges.push(p2);\n            if (verts[p1].type && edge === VertexType.VTK_BOUNDARY_EDGE_VERTEX) {\n              verts[p1].type = VertexType.VTK_BOUNDARY_EDGE_VERTEX;\n            }\n          }\n          if (edge && verts[p2].type === VertexType.VTK_SIMPLE_VERTEX) {\n            verts[p2].edges = [p1];\n            verts[p2].type = edge;\n          } else if (edge && verts[p2].type === VertexType.VTK_BOUNDARY_EDGE_VERTEX || edge && verts[p2].type === VertexType.VTK_FEATURE_EDGE_VERTEX || !edge && verts[p2].type === VertexType.VTK_SIMPLE_VERTEX) {\n            verts[p2].edges.push(p1);\n            if (verts[p2].type && edge === VertexType.VTK_BOUNDARY_EDGE_VERTEX) {\n              verts[p2].type = VertexType.VTK_BOUNDARY_EDGE_VERTEX;\n            }\n          }\n        }\n      }\n    } // if strips or polys\n\n    for (var _i4 = 0; _i4 < numPts; ++_i4) {\n      if (verts[_i4].type === VertexType.VTK_SIMPLE_VERTEX) ;else if (verts[_i4].type === VertexType.VTK_FIXED_VERTEX) ;else if (verts[_i4].type === VertexType.VTK_FEATURE_EDGE_VERTEX || verts[_i4].type === VertexType.VTK_BOUNDARY_EDGE_VERTEX) {\n        // see how many edges; if two, what the angle is\n        if (!model.boundarySmoothing && verts[_i4].type === VertexType.VTK_BOUNDARY_EDGE_VERTEX) {\n          verts[_i4].type = VertexType.VTK_FIXED_VERTEX;\n        } else if ((npts = verts[_i4].edges.length) !== 2) {\n          // can only smooth edges on 2-manifold surfaces\n          verts[_i4].type = VertexType.VTK_FIXED_VERTEX;\n        } // check angle between edges\n        else {\n          var _x = inPts.getPoint(verts[_i4].edges[0]);\n          var _x2 = inPts.getPoint(_i4);\n          var x3 = inPts.getPoint(verts[_i4].edges[1]);\n          var l1 = [0, 0, 0];\n          var l2 = [0, 0, 0];\n          for (var k = 0; k < 3; ++k) {\n            l1[k] = _x2[k] - _x[k];\n            l2[k] = x3[k] - _x2[k];\n          }\n          if (vtkMath.normalize(l1) >= 0.0 && vtkMath.normalize(l2) >= 0.0 && vtkMath.dot(l1, l2) < cosEdgeAngle) {\n            verts[_i4].type = VertexType.VTK_FIXED_VERTEX;\n          } else if (verts[_i4].type === VertexType.VTK_FEATURE_EDGE_VERTEX) ;else ;\n        } // if along edge\n      } // if edge vertex\n    } // for all points\n    // Perform Windowed Sinc function interpolation\n    //\n    // console.log('Beginning smoothing iterations...');\n    // need 4 vectors of points\n\n    var zero = 0;\n    var one = 1;\n    var two = 2;\n    var three = 3;\n    var newPts = [];\n    newPts.push(vtkPoints.newInstance());\n    newPts[zero].setNumberOfPoints(numPts);\n    newPts.push(vtkPoints.newInstance());\n    newPts[one].setNumberOfPoints(numPts);\n    newPts.push(vtkPoints.newInstance());\n    newPts[two].setNumberOfPoints(numPts);\n    newPts.push(vtkPoints.newInstance());\n    newPts[three].setNumberOfPoints(numPts); // Get the center and length of the input dataset\n\n    var inCenter = vtkBoundingBox.getCenter(inputPolyData.getBounds());\n    var inLength = vtkBoundingBox.getDiagonalLength(inputPolyData.getBounds());\n    if (!model.normalizeCoordinates) {\n      // initialize to old coordinates\n      // for (let i = 0; i < numPts; ++i) {\n      //   newPts[zero].setPoint(i, inPts.subarray(i));\n      // }\n      var copy = macro.newTypedArray(newPts[zero].getDataType(), inPtsData);\n      newPts[zero].setData(copy, 3);\n    } else {\n      // center the data and scale to be within unit cube [-1, 1]\n      // initialize to old coordinates\n      var normalizedPoint = [0, 0, 0];\n      for (var _i5 = 0; _i5 < numPts; ++_i5) {\n        var _newPts$zero;\n        inPts.getPoint(_i5, normalizedPoint);\n        normalizedPoint[0] = (normalizedPoint[0] - inCenter[0]) / inLength;\n        normalizedPoint[1] = (normalizedPoint[1] - inCenter[1]) / inLength;\n        normalizedPoint[2] = (normalizedPoint[2] - inCenter[2]) / inLength;\n        (_newPts$zero = newPts[zero]).setPoint.apply(_newPts$zero, [_i5].concat(normalizedPoint));\n      }\n    } // Smooth with a low pass filter defined as a windowed sinc function.\n    // Taubin describes this methodology is the IBM tech report RC-20404\n    // (#90237, dated 3/12/96) \"Optimal Surface Smoothing as Filter Design\"\n    // G. Taubin, T. Zhang and G. Golub. (Zhang and Golub are at Stanford\n    // University)\n    // The formulas here follow the notation of Taubin's TR, i.e.\n    // newPts[zero], newPts[one], etc.\n    // calculate weights and filter coefficients\n\n    var kPb = model.passBand; // reasonable default for kPb in [0, 2] is 0.1\n\n    var thetaPb = Math.acos(1.0 - 0.5 * kPb); // thetaPb in [0, M_PI/2]\n    // vtkDebugMacro(<< \"thetaPb = \" << thetaPb);\n\n    var w = new Array(model.numberOfIterations + 1);\n    var c = new Array(model.numberOfIterations + 1);\n    var cprime = new Array(model.numberOfIterations + 1);\n    var zerovector = [0, 0, 0]; // Calculate the weights and the Chebychev coefficients c.\n    //\n    // Windowed sinc function weights. This is for a Hamming window. Other\n    // windowing function could be implemented here.\n\n    for (var _i6 = 0; _i6 <= model.numberOfIterations; ++_i6) {\n      w[_i6] = 0.54 + 0.46 * Math.cos(_i6 * Math.PI / (model.numberOfIterations + 1));\n    } // Calculate the optimal sigma (offset or fudge factor for the filter).\n    // This is a Newton-Raphson Search.\n\n    var fKpb = 0;\n    var fPrimeKpb = 0;\n    var done = false;\n    var sigma = 0.0;\n    for (var _j3 = 0; !done && _j3 < 500; ++_j3) {\n      // Chebyshev coefficients\n      c[0] = w[0] * (thetaPb + sigma) / Math.PI;\n      for (var _i7 = 1; _i7 <= model.numberOfIterations; ++_i7) {\n        c[_i7] = 2.0 * w[_i7] * Math.sin(_i7 * (thetaPb + sigma)) / (_i7 * Math.PI);\n      } // calculate the Chebyshev coefficients for the derivative of the filter\n\n      cprime[model.numberOfIterations] = 0.0;\n      cprime[model.numberOfIterations - 1] = 0.0;\n      if (model.numberOfIterations > 1) {\n        cprime[model.numberOfIterations - 2] = 2.0 * (model.numberOfIterations - 1) * c[model.numberOfIterations - 1];\n      }\n      for (var _i8 = model.numberOfIterations - 3; _i8 >= 0; --_i8) {\n        cprime[_i8] = cprime[_i8 + 2] + 2.0 * (_i8 + 1) * c[_i8 + 1];\n      } // Evaluate the filter and its derivative at kPb (note the discrepancy\n      // of calculating the c's based on thetaPb + sigma and evaluating the\n      // filter at kPb (which is equivalent to thetaPb)\n\n      fKpb = 0.0;\n      fPrimeKpb = 0.0;\n      fKpb += c[0];\n      fPrimeKpb += cprime[0];\n      for (var _i9 = 1; _i9 <= model.numberOfIterations; ++_i9) {\n        if (_i9 === 1) {\n          fKpb += c[_i9] * (1.0 - 0.5 * kPb);\n          fPrimeKpb += cprime[_i9] * (1.0 - 0.5 * kPb);\n        } else {\n          fKpb += c[_i9] * Math.cos(_i9 * Math.acos(1.0 - 0.5 * kPb));\n          fPrimeKpb += cprime[_i9] * Math.cos(_i9 * Math.acos(1.0 - 0.5 * kPb));\n        }\n      } // if fKpb is not close enough to 1.0, then adjust sigma\n\n      if (model.numberOfIterations > 1) {\n        if (Math.abs(fKpb - 1.0) >= 1e-3) {\n          sigma -= (fKpb - 1.0) / fPrimeKpb; // Newton-Rhapson (want f=1)\n        } else {\n          done = true;\n        }\n      } else {\n        // Order of Chebyshev is 1. Can't use Newton-Raphson to find an\n        // optimal sigma. Object will most likely shrink.\n        done = true;\n        sigma = 0.0;\n      }\n    }\n    if (Math.abs(fKpb - 1.0) >= 1e-3) {\n      console.log('An optimal offset for the smoothing filter could not be found.  Unpredictable smoothing/shrinkage may result.');\n    }\n    var x = [0, 0, 0];\n    var y = [0, 0, 0];\n    var deltaX = [0, 0, 0];\n    var xNew = [0, 0, 0];\n    var x1 = [0, 0, 0];\n    var x2 = [0, 0, 0]; // first iteration\n\n    for (var _i10 = 0; _i10 < numPts; ++_i10) {\n      if (verts[_i10].edges != null && (npts = verts[_i10].edges.length) > 0) {\n        var _newPts$one, _newPts$three;\n\n        // point is allowed to move\n        newPts[zero].getPoint(_i10, x); // use current points\n\n        deltaX[0] = 0.0;\n        deltaX[1] = 0.0;\n        deltaX[2] = 0.0; // calculate the negative of the laplacian\n        // for all connected points\n\n        for (var _j4 = 0; _j4 < npts; ++_j4) {\n          newPts[zero].getPoint(verts[_i10].edges[_j4], y);\n          for (var _k = 0; _k < 3; ++_k) {\n            deltaX[_k] += (x[_k] - y[_k]) / npts;\n          }\n        } // newPts[one] = newPts[zero] - 0.5 newPts[one]\n\n        for (var _k2 = 0; _k2 < 3; ++_k2) {\n          deltaX[_k2] = x[_k2] - 0.5 * deltaX[_k2];\n        }\n        (_newPts$one = newPts[one]).setPoint.apply(_newPts$one, [_i10].concat(deltaX));\n        if (verts[_i10].type === VertexType.VTK_FIXED_VERTEX) {\n          newPts[zero].getPoint(_i10, deltaX);\n        } else {\n          // calculate newPts[three] = c0 newPts[zero] + c1 newPts[one]\n          for (var _k3 = 0; _k3 < 3; ++_k3) {\n            deltaX[_k3] = c[0] * x[_k3] + c[1] * deltaX[_k3];\n          }\n        }\n        (_newPts$three = newPts[three]).setPoint.apply(_newPts$three, [_i10].concat(deltaX));\n      } // if can move point\n      else {\n        var _newPts$one2, _newPts$three2;\n\n        // point is not allowed to move, just use the old point...\n        // (zero out the Laplacian)\n        (_newPts$one2 = newPts[one]).setPoint.apply(_newPts$one2, [_i10].concat(zerovector));\n        newPts[zero].getPoint(_i10, deltaX);\n        (_newPts$three2 = newPts[three]).setPoint.apply(_newPts$three2, [_i10].concat(deltaX));\n      }\n    } // for all points\n    // for the rest of the iterations\n\n    var pX0 = [0, 0, 0];\n    var pX1 = [0, 0, 0];\n    var pX3 = [0, 0, 0];\n    var iterationNumber = 2;\n    for (; iterationNumber <= model.numberOfIterations; iterationNumber++) {\n      for (var _i11 = 0; _i11 < numPts; ++_i11) {\n        npts = verts[_i11].edges != null ? verts[_i11].edges.length : 0;\n        if (npts > 0) {\n          var _newPts$two;\n\n          // point is allowed to move\n          newPts[zero].getPoint(_i11, pX0); // use current points\n\n          newPts[one].getPoint(_i11, pX1);\n          deltaX[0] = 0.0;\n          deltaX[1] = 0.0;\n          deltaX[2] = 0.0; // calculate the negative laplacian of x1\n\n          for (var _j5 = 0; _j5 < npts; ++_j5) {\n            newPts[one].getPoint(verts[_i11].edges[_j5], y);\n            for (var _k4 = 0; _k4 < 3; ++_k4) {\n              deltaX[_k4] += (pX1[_k4] - y[_k4]) / npts;\n            }\n          } // for all connected points\n          // Taubin:  x2 = (x1 - x0) + (x1 - x2)\n\n          for (var _k5 = 0; _k5 < 3; ++_k5) {\n            deltaX[_k5] = pX1[_k5] - pX0[_k5] + pX1[_k5] - deltaX[_k5];\n          }\n          (_newPts$two = newPts[two]).setPoint.apply(_newPts$two, [_i11].concat(deltaX)); // smooth the vertex (x3 = x3 + cj x2)\n\n          newPts[three].getPoint(_i11, pX3);\n          for (var _k6 = 0; _k6 < 3; ++_k6) {\n            xNew[_k6] = pX3[_k6] + c[iterationNumber] * deltaX[_k6];\n          }\n          if (verts[_i11].type !== VertexType.VTK_FIXED_VERTEX) {\n            var _newPts$three3;\n            (_newPts$three3 = newPts[three]).setPoint.apply(_newPts$three3, [_i11].concat(xNew));\n          }\n        } // if can move point\n        else {\n          var _newPts$one3, _newPts$two2;\n\n          // point is not allowed to move, just use the old point...\n          // (zero out the Laplacian)\n          (_newPts$one3 = newPts[one]).setPoint.apply(_newPts$one3, [_i11].concat(zerovector));\n          (_newPts$two2 = newPts[two]).setPoint.apply(_newPts$two2, [_i11].concat(zerovector));\n        }\n      } // for all points\n      // update the pointers. three is always three. all other pointers\n      // shift by one and wrap.\n\n      zero = (1 + zero) % 3;\n      one = (1 + one) % 3;\n      two = (1 + two) % 3;\n    } // for all iterations or until converge\n    // move the iteration count back down so that it matches the\n    // actual number of iterations executed\n\n    --iterationNumber; // set zero to three so the correct set of positions is outputted\n\n    zero = three; // console.log('Performed', iterationNumber, 'smoothing passes');\n    // if we scaled the data down to the unit cube, then scale data back\n    // up to the original space\n\n    if (model.normalizeCoordinates) {\n      // Re-position the coordinated\n      var repositionedPoint = [0, 0, 0];\n      for (var _i12 = 0; _i12 < numPts; ++_i12) {\n        var _newPts$zero2;\n        newPts[zero].getPoint(_i12, repositionedPoint);\n        for (var _j6 = 0; _j6 < 3; ++_j6) {\n          repositionedPoint[_j6] = repositionedPoint[_j6] * inLength + inCenter[_j6];\n        }\n        (_newPts$zero2 = newPts[zero]).setPoint.apply(_newPts$zero2, [_i12].concat(repositionedPoint));\n      }\n    }\n    if (model.generateErrorScalars) {\n      var newScalars = new Float32Array(numPts);\n      for (var _i13 = 0; _i13 < numPts; ++_i13) {\n        inPts.getPoint(_i13, x1);\n        newPts[zero].getPoint(_i13, x2);\n        newScalars[_i13] = Math.sqrt(Math.distance2BetweenPoints(x1, x2));\n      }\n      var newScalarsArray = vtkDataArray.newInstance({\n        numberOfComponents: 1,\n        values: newScalars\n      });\n      var idx = output.getPointData().addArray(newScalarsArray);\n      output.getPointData().setActiveAttribute(idx, AttributeTypes.SCALARS);\n    }\n    if (model.generateErrorVectors) {\n      var newVectors = new Float32Array(3 * numPts);\n      for (var _i14 = 0; _i14 < numPts; ++_i14) {\n        inPts.getPoint(_i14, x1);\n        newPts[zero].getPoint(_i14, x2);\n        for (var _j7 = 0; _j7 < 3; ++_j7) {\n          newVectors[3 * _i14 + _j7] = x2[_j7] - x1[_j7];\n        }\n      }\n      var newVectorsArray = vtkDataArray.newInstance({\n        numberOfComponents: 3,\n        values: newVectors\n      });\n      output.getPointData().setVectors(newVectorsArray);\n    }\n    return newPts[zero];\n  };\n  publicAPI.requestData = function (inData, outData) {\n    var numberOfInputs = publicAPI.getNumberOfInputPorts();\n    if (!numberOfInputs) {\n      return;\n    }\n    var input = inData[0];\n    if (!input) {\n      return;\n    }\n    var output = vtkPolyData.newInstance();\n    var outputPoints = publicAPI.vtkWindowedSincPolyDataFilterExecute(input.getPoints(), input, output);\n    output.setPointData(input.getPointData());\n    output.setCellData(input.getCellData());\n    output.setFieldData(input.getFieldData());\n    output.setPoints(outputPoints);\n    output.setVerts(input.getVerts());\n    output.setLines(input.getLines());\n    output.setPolys(input.getPolys());\n    output.setStrips(input.getStrips());\n    outData[0] = output;\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nvar DEFAULT_VALUES = {\n  numberOfIterations: 20,\n  passBand: 0.1,\n  featureAngle: 45.0,\n  edgeAngle: 15.0,\n  featureEdgeSmoothing: 0,\n  boundarySmoothing: 1,\n  nonManifoldSmoothing: 0,\n  generateErrorScalars: 0,\n  generateErrorVectors: 0,\n  normalizeCoordinates: 0\n}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n  /* Make this a VTK object */\n\n  macro.obj(publicAPI, model);\n  /* Also make it an algorithm with one input and one output */\n\n  macro.algo(publicAPI, model, 1, 1);\n  /* Setters */\n\n  macro.setGet(publicAPI, model, ['numberOfIterations', 'passBand', 'featureAngle', 'edgeAngle', 'featureEdgeSmoothing', 'boundarySmoothing', 'nonManifoldSmoothing', 'generateErrorScalars', 'generateErrorVectors', 'normalizeCoordinates']);\n  /* Object specific methods */\n\n  vtkWindowedSincPolyDataFilter(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = macro.newInstance(extend, 'vtkWindowedSincPolyDataFilter'); // ----------------------------------------------------------------------------\n\nvar vtkWindowedSincPolyDataFilter$1 = {\n  newInstance: newInstance,\n  extend: extend\n};\nexport { vtkWindowedSincPolyDataFilter$1 as default, extend, newInstance };","map":{"version":3,"names":["macro","vtkBoundingBox","vtkDataArray","f","vtkMath","AttributeTypes","vtkPoints","vtkPolyData","vtkTriangle","VertexType","VTK_SIMPLE_VERTEX","VTK_FIXED_VERTEX","VTK_FEATURE_EDGE_VERTEX","VTK_BOUNDARY_EDGE_VERTEX","vtkWindowedSincPolyDataFilter","publicAPI","model","classHierarchy","push","vtkWindowedSincPolyDataFilterExecute","inPts","inputPolyData","output","numberOfIterations","inPtsData","getData","inVerts","getVerts","inLines","getLines","inPolys","getPolys","inStrips","getStrips","cosFeatureAngle","Math","cos","radiansFromDegrees","featureAngle","cosEdgeAngle","edgeAngle","numPts","getNumberOfPoints","verts","Array","i","type","edges","npts","_i","length","pts","slice","j","_i2","_pts","closedLoop","_j","numPolys","numStrips","inMesh","newInstance","setPoints","getPoints","setPolys","mesh","neighbors","nei","normal","neiNormal","buildLinks","polys","cellId","_c","_pts2","_i3","p1","p2","getCellEdgeNeighbors","numNei","edge","nonManifoldSmoothing","_j2","featureEdgeSmoothing","computeNormal","getPoint","_mesh$getCellPoints","getCellPoints","cellPointIds","dot","_i4","boundarySmoothing","_x","_x2","x3","l1","l2","k","normalize","zero","one","two","three","newPts","setNumberOfPoints","inCenter","getCenter","getBounds","inLength","getDiagonalLength","normalizeCoordinates","copy","newTypedArray","getDataType","setData","normalizedPoint","_i5","_newPts$zero","setPoint","apply","concat","kPb","passBand","thetaPb","acos","w","c","cprime","zerovector","_i6","PI","fKpb","fPrimeKpb","done","sigma","_j3","_i7","sin","_i8","_i9","abs","console","log","x","y","deltaX","xNew","x1","x2","_i10","_newPts$one","_newPts$three","_j4","_k","_k2","_k3","_newPts$one2","_newPts$three2","pX0","pX1","pX3","iterationNumber","_i11","_newPts$two","_j5","_k4","_k5","_k6","_newPts$three3","_newPts$one3","_newPts$two2","repositionedPoint","_i12","_newPts$zero2","_j6","generateErrorScalars","newScalars","Float32Array","_i13","sqrt","distance2BetweenPoints","newScalarsArray","numberOfComponents","values","idx","getPointData","addArray","setActiveAttribute","SCALARS","generateErrorVectors","newVectors","_i14","_j7","newVectorsArray","setVectors","requestData","inData","outData","numberOfInputs","getNumberOfInputPorts","input","outputPoints","setPointData","setCellData","getCellData","setFieldData","getFieldData","setVerts","setLines","setStrips","DEFAULT_VALUES","extend","initialValues","arguments","undefined","Object","assign","obj","algo","setGet","vtkWindowedSincPolyDataFilter$1","default"],"sources":["/home/rakshith/Documents/RemoteRendering/vtk-js-react-app/node_modules/@kitware/vtk.js/Filters/General/WindowedSincPolyDataFilter.js"],"sourcesContent":["import macro from '../../macros.js';\nimport vtkBoundingBox from '../../Common/DataModel/BoundingBox.js';\nimport vtkDataArray from '../../Common/Core/DataArray.js';\nimport { f as vtkMath } from '../../Common/Core/Math/index.js';\nimport { AttributeTypes } from '../../Common/DataModel/DataSetAttributes/Constants.js';\nimport vtkPoints from '../../Common/Core/Points.js';\nimport vtkPolyData from '../../Common/DataModel/PolyData.js';\nimport vtkTriangle from '../../Common/DataModel/Triangle.js';\n\nvar VertexType = {\n  VTK_SIMPLE_VERTEX: 0,\n  VTK_FIXED_VERTEX: 1,\n  VTK_FEATURE_EDGE_VERTEX: 2,\n  VTK_BOUNDARY_EDGE_VERTEX: 3\n}; // ----------------------------------------------------------------------------\n// vtkWindowedSincPolyDataFilter methods\n// ----------------------------------------------------------------------------\n\nfunction vtkWindowedSincPolyDataFilter(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkWindowedSincPolyDataFilter');\n\n  publicAPI.vtkWindowedSincPolyDataFilterExecute = function (inPts, inputPolyData, output) {\n    if (!inPts || model.numberOfIterations <= 0) {\n      return inPts;\n    }\n\n    var inPtsData = inPts.getData();\n    var inVerts = inputPolyData.getVerts().getData();\n    var inLines = inputPolyData.getLines().getData();\n    var inPolys = inputPolyData.getPolys().getData();\n    var inStrips = inputPolyData.getStrips().getData();\n    var cosFeatureAngle = Math.cos(vtkMath.radiansFromDegrees(model.featureAngle));\n    var cosEdgeAngle = Math.cos(vtkMath.radiansFromDegrees(model.edgeAngle));\n    var numPts = inPts.getNumberOfPoints(); // Perform topological analysis. What we're going to do is build a connectivity\n    // array of connected vertices. The outcome will be one of three\n    // classifications for a vertex: VTK_SIMPLE_VERTEX, VTK_FIXED_VERTEX. or\n    // VTK_EDGE_VERTEX. Simple vertices are smoothed using all connected\n    // vertices. FIXED vertices are never smoothed. Edge vertices are smoothed\n    // using a subset of the attached vertices.\n\n    var verts = new Array(numPts);\n\n    for (var i = 0; i < numPts; ++i) {\n      verts[i] = {\n        type: VertexType.VTK_SIMPLE_VERTEX,\n        edges: null\n      };\n    } // check vertices first. Vertices are never smoothed_--------------\n\n\n    var npts = 0;\n\n    for (var _i = 0; _i < inVerts.length; _i += npts + 1) {\n      npts = inVerts[_i];\n      var pts = inVerts.slice(_i + 1, _i + 1 + npts);\n\n      for (var j = 0; j < pts.length; ++j) {\n        verts[pts[j]].type = VertexType.VTK_FIXED_VERTEX;\n      }\n    } // now check lines. Only manifold lines can be smoothed------------\n\n\n    for (var _i2 = 0; _i2 < inLines.length; _i2 += npts + 1) {\n      npts = inLines[_i2];\n\n      var _pts = inLines.slice(_i2 + 1, _i2 + 1 + npts); // Check for closed loop which are treated specially. Basically the\n      // last point is ignored (set to fixed).\n\n\n      var closedLoop = _pts[0] === _pts[npts - 1] && npts > 3;\n\n      for (var _j = 0; _j < npts; ++_j) {\n        if (verts[_pts[_j]].type === VertexType.VTK_SIMPLE_VERTEX) {\n          // First point\n          if (_j === 0) {\n            if (!closedLoop) {\n              verts[_pts[0]].type = VertexType.VTK_FIXED_VERTEX;\n            } else {\n              verts[_pts[0]].type = VertexType.VTK_FEATURE_EDGE_VERTEX;\n              verts[_pts[0]].edges = [_pts[npts - 2], _pts[1]];\n            }\n          } // Last point\n          else if (_j === npts - 1 && !closedLoop) {\n            verts[_pts[_j]].type = VertexType.VTK_FIXED_VERTEX;\n          } // In between point // is edge vertex (unless already edge vertex!)\n          else {\n            verts[_pts[_j]].type = VertexType.VTK_FEATURE_EDGE_VERTEX;\n            verts[_pts[_j]].edges = [_pts[_j - 1], _pts[closedLoop && _j === npts - 2 ? 0 : _j + 1]];\n          }\n        } // if simple vertex\n        // Vertex has been visited before, need to fix it. Special case\n        // when working on closed loop.\n        else if (verts[_pts[_j]].type === VertexType.VTK_FEATURE_EDGE_VERTEX && !(closedLoop && _j === npts - 1)) {\n          verts[_pts[_j]].type = VertexType.VTK_FIXED_VERTEX;\n          verts[_pts[_j]].edges = null;\n        }\n      } // for all points in this line\n\n    } // for all lines\n    // now polygons and triangle strips-------------------------------\n\n\n    var numPolys = inPolys.length;\n    var numStrips = inStrips.length;\n\n    if (numPolys > 0 || numStrips > 0) {\n      var inMesh = vtkPolyData.newInstance();\n      inMesh.setPoints(inputPolyData.getPoints());\n      inMesh.setPolys(inputPolyData.getPolys());\n      var mesh = inMesh;\n      var neighbors = [];\n      var nei = 0; // const numNeiPts = 0;\n\n      var normal = [];\n      var neiNormal = [];\n      /* TODO: Add vtkTriangleFilter\n      if ( (numStrips = inputPolyData.getStrips().GetNumberOfCells()) > 0 )\n      { // convert data to triangles\n        inMesh.setStrips(inputPolyData.getStrips());\n        const toTris = vtkTriangleFilter.newInstance();\n        toTris.setInputData(inMesh);\n        toTris.update();\n        mesh = toTris.getOutput();\n      }\n      */\n\n      mesh.buildLinks(); // to do neighborhood searching\n\n      var polys = mesh.getPolys().getData();\n      var cellId = 0;\n\n      for (var _c = 0; _c < polys.length; _c += npts + 1, ++cellId) {\n        npts = polys[_c];\n\n        var _pts2 = polys.slice(_c + 1, _c + 1 + npts);\n\n        for (var _i3 = 0; _i3 < npts; ++_i3) {\n          var p1 = _pts2[_i3];\n          var p2 = _pts2[(_i3 + 1) % npts];\n\n          if (verts[p1].edges === null) {\n            verts[p1].edges = [];\n          }\n\n          if (verts[p2].edges == null) {\n            verts[p2].edges = [];\n          }\n\n          neighbors = mesh.getCellEdgeNeighbors(cellId, p1, p2);\n          var numNei = neighbors.length; // neighbors->GetNumberOfIds();\n\n          var edge = VertexType.VTK_SIMPLE_VERTEX;\n\n          if (numNei === 0) {\n            edge = VertexType.VTK_BOUNDARY_EDGE_VERTEX;\n          } else if (numNei >= 2) {\n            // non-manifold case, check nonmanifold smoothing state\n            if (!model.nonManifoldSmoothing) {\n              // check to make sure that this edge hasn't been marked already\n              var _j2 = 0;\n\n              for (; _j2 < numNei; ++_j2) {\n                if (neighbors[_j2] < cellId) {\n                  break;\n                }\n              }\n\n              if (_j2 >= numNei) {\n                edge = VertexType.VTK_FEATURE_EDGE_VERTEX;\n              }\n            }\n            /* eslint-disable no-cond-assign */\n\n          } else if (numNei === 1 && (nei = neighbors[0]) > cellId) {\n            if (model.featureEdgeSmoothing) {\n              // TODO: support polygons\n              // vtkPolygon::ComputeNormal(inPts,npts,pts,normal);\n              vtkTriangle.computeNormal(inPts.getPoint(_pts2[0]), inPts.getPoint(_pts2[1]), inPts.getPoint(_pts2[2]), normal);\n\n              var _mesh$getCellPoints = mesh.getCellPoints(nei),\n                  cellPointIds = _mesh$getCellPoints.cellPointIds; // vtkPolygon::ComputeNormal(inPts,numNeiPts,neiPts,neiNormal);\n\n\n              vtkTriangle.computeNormal(inPts.getPoint(cellPointIds[0]), inPts.getPoint(cellPointIds[1]), inPts.getPoint(cellPointIds[2]), neiNormal);\n\n              if (vtkMath.dot(normal, neiNormal) <= cosFeatureAngle) {\n                edge = VertexType.VTK_FEATURE_EDGE_VERTEX;\n              }\n            }\n          } // a visited edge; skip rest of analysis\n          else {\n            /* eslint-disable no-continue */\n            continue;\n          }\n\n          if (edge && verts[p1].type === VertexType.VTK_SIMPLE_VERTEX) {\n            verts[p1].edges = [p2];\n            verts[p1].type = edge;\n          } else if (edge && verts[p1].type === VertexType.VTK_BOUNDARY_EDGE_VERTEX || edge && verts[p1].type === VertexType.VTK_FEATURE_EDGE_VERTEX || !edge && verts[p1].type === VertexType.VTK_SIMPLE_VERTEX) {\n            verts[p1].edges.push(p2);\n\n            if (verts[p1].type && edge === VertexType.VTK_BOUNDARY_EDGE_VERTEX) {\n              verts[p1].type = VertexType.VTK_BOUNDARY_EDGE_VERTEX;\n            }\n          }\n\n          if (edge && verts[p2].type === VertexType.VTK_SIMPLE_VERTEX) {\n            verts[p2].edges = [p1];\n            verts[p2].type = edge;\n          } else if (edge && verts[p2].type === VertexType.VTK_BOUNDARY_EDGE_VERTEX || edge && verts[p2].type === VertexType.VTK_FEATURE_EDGE_VERTEX || !edge && verts[p2].type === VertexType.VTK_SIMPLE_VERTEX) {\n            verts[p2].edges.push(p1);\n\n            if (verts[p2].type && edge === VertexType.VTK_BOUNDARY_EDGE_VERTEX) {\n              verts[p2].type = VertexType.VTK_BOUNDARY_EDGE_VERTEX;\n            }\n          }\n        }\n      }\n    } // if strips or polys\n\n    for (var _i4 = 0; _i4 < numPts; ++_i4) {\n      if (verts[_i4].type === VertexType.VTK_SIMPLE_VERTEX) ; else if (verts[_i4].type === VertexType.VTK_FIXED_VERTEX) ; else if (verts[_i4].type === VertexType.VTK_FEATURE_EDGE_VERTEX || verts[_i4].type === VertexType.VTK_BOUNDARY_EDGE_VERTEX) {\n        // see how many edges; if two, what the angle is\n        if (!model.boundarySmoothing && verts[_i4].type === VertexType.VTK_BOUNDARY_EDGE_VERTEX) {\n          verts[_i4].type = VertexType.VTK_FIXED_VERTEX;\n        } else if ((npts = verts[_i4].edges.length) !== 2) {\n          // can only smooth edges on 2-manifold surfaces\n          verts[_i4].type = VertexType.VTK_FIXED_VERTEX;\n        } // check angle between edges\n        else {\n          var _x = inPts.getPoint(verts[_i4].edges[0]);\n\n          var _x2 = inPts.getPoint(_i4);\n\n          var x3 = inPts.getPoint(verts[_i4].edges[1]);\n          var l1 = [0, 0, 0];\n          var l2 = [0, 0, 0];\n\n          for (var k = 0; k < 3; ++k) {\n            l1[k] = _x2[k] - _x[k];\n            l2[k] = x3[k] - _x2[k];\n          }\n\n          if (vtkMath.normalize(l1) >= 0.0 && vtkMath.normalize(l2) >= 0.0 && vtkMath.dot(l1, l2) < cosEdgeAngle) {\n            verts[_i4].type = VertexType.VTK_FIXED_VERTEX;\n          } else if (verts[_i4].type === VertexType.VTK_FEATURE_EDGE_VERTEX) ; else ;\n        } // if along edge\n\n      } // if edge vertex\n\n    } // for all points\n    // Perform Windowed Sinc function interpolation\n    //\n    // console.log('Beginning smoothing iterations...');\n    // need 4 vectors of points\n\n\n    var zero = 0;\n    var one = 1;\n    var two = 2;\n    var three = 3;\n    var newPts = [];\n    newPts.push(vtkPoints.newInstance());\n    newPts[zero].setNumberOfPoints(numPts);\n    newPts.push(vtkPoints.newInstance());\n    newPts[one].setNumberOfPoints(numPts);\n    newPts.push(vtkPoints.newInstance());\n    newPts[two].setNumberOfPoints(numPts);\n    newPts.push(vtkPoints.newInstance());\n    newPts[three].setNumberOfPoints(numPts); // Get the center and length of the input dataset\n\n    var inCenter = vtkBoundingBox.getCenter(inputPolyData.getBounds());\n    var inLength = vtkBoundingBox.getDiagonalLength(inputPolyData.getBounds());\n\n    if (!model.normalizeCoordinates) {\n      // initialize to old coordinates\n      // for (let i = 0; i < numPts; ++i) {\n      //   newPts[zero].setPoint(i, inPts.subarray(i));\n      // }\n      var copy = macro.newTypedArray(newPts[zero].getDataType(), inPtsData);\n      newPts[zero].setData(copy, 3);\n    } else {\n      // center the data and scale to be within unit cube [-1, 1]\n      // initialize to old coordinates\n      var normalizedPoint = [0, 0, 0];\n\n      for (var _i5 = 0; _i5 < numPts; ++_i5) {\n        var _newPts$zero;\n\n        inPts.getPoint(_i5, normalizedPoint);\n        normalizedPoint[0] = (normalizedPoint[0] - inCenter[0]) / inLength;\n        normalizedPoint[1] = (normalizedPoint[1] - inCenter[1]) / inLength;\n        normalizedPoint[2] = (normalizedPoint[2] - inCenter[2]) / inLength;\n\n        (_newPts$zero = newPts[zero]).setPoint.apply(_newPts$zero, [_i5].concat(normalizedPoint));\n      }\n    } // Smooth with a low pass filter defined as a windowed sinc function.\n    // Taubin describes this methodology is the IBM tech report RC-20404\n    // (#90237, dated 3/12/96) \"Optimal Surface Smoothing as Filter Design\"\n    // G. Taubin, T. Zhang and G. Golub. (Zhang and Golub are at Stanford\n    // University)\n    // The formulas here follow the notation of Taubin's TR, i.e.\n    // newPts[zero], newPts[one], etc.\n    // calculate weights and filter coefficients\n\n\n    var kPb = model.passBand; // reasonable default for kPb in [0, 2] is 0.1\n\n    var thetaPb = Math.acos(1.0 - 0.5 * kPb); // thetaPb in [0, M_PI/2]\n    // vtkDebugMacro(<< \"thetaPb = \" << thetaPb);\n\n    var w = new Array(model.numberOfIterations + 1);\n    var c = new Array(model.numberOfIterations + 1);\n    var cprime = new Array(model.numberOfIterations + 1);\n    var zerovector = [0, 0, 0]; // Calculate the weights and the Chebychev coefficients c.\n    //\n    // Windowed sinc function weights. This is for a Hamming window. Other\n    // windowing function could be implemented here.\n\n    for (var _i6 = 0; _i6 <= model.numberOfIterations; ++_i6) {\n      w[_i6] = 0.54 + 0.46 * Math.cos(_i6 * Math.PI / (model.numberOfIterations + 1));\n    } // Calculate the optimal sigma (offset or fudge factor for the filter).\n    // This is a Newton-Raphson Search.\n\n\n    var fKpb = 0;\n    var fPrimeKpb = 0;\n    var done = false;\n    var sigma = 0.0;\n\n    for (var _j3 = 0; !done && _j3 < 500; ++_j3) {\n      // Chebyshev coefficients\n      c[0] = w[0] * (thetaPb + sigma) / Math.PI;\n\n      for (var _i7 = 1; _i7 <= model.numberOfIterations; ++_i7) {\n        c[_i7] = 2.0 * w[_i7] * Math.sin(_i7 * (thetaPb + sigma)) / (_i7 * Math.PI);\n      } // calculate the Chebyshev coefficients for the derivative of the filter\n\n\n      cprime[model.numberOfIterations] = 0.0;\n      cprime[model.numberOfIterations - 1] = 0.0;\n\n      if (model.numberOfIterations > 1) {\n        cprime[model.numberOfIterations - 2] = 2.0 * (model.numberOfIterations - 1) * c[model.numberOfIterations - 1];\n      }\n\n      for (var _i8 = model.numberOfIterations - 3; _i8 >= 0; --_i8) {\n        cprime[_i8] = cprime[_i8 + 2] + 2.0 * (_i8 + 1) * c[_i8 + 1];\n      } // Evaluate the filter and its derivative at kPb (note the discrepancy\n      // of calculating the c's based on thetaPb + sigma and evaluating the\n      // filter at kPb (which is equivalent to thetaPb)\n\n\n      fKpb = 0.0;\n      fPrimeKpb = 0.0;\n      fKpb += c[0];\n      fPrimeKpb += cprime[0];\n\n      for (var _i9 = 1; _i9 <= model.numberOfIterations; ++_i9) {\n        if (_i9 === 1) {\n          fKpb += c[_i9] * (1.0 - 0.5 * kPb);\n          fPrimeKpb += cprime[_i9] * (1.0 - 0.5 * kPb);\n        } else {\n          fKpb += c[_i9] * Math.cos(_i9 * Math.acos(1.0 - 0.5 * kPb));\n          fPrimeKpb += cprime[_i9] * Math.cos(_i9 * Math.acos(1.0 - 0.5 * kPb));\n        }\n      } // if fKpb is not close enough to 1.0, then adjust sigma\n\n\n      if (model.numberOfIterations > 1) {\n        if (Math.abs(fKpb - 1.0) >= 1e-3) {\n          sigma -= (fKpb - 1.0) / fPrimeKpb; // Newton-Rhapson (want f=1)\n        } else {\n          done = true;\n        }\n      } else {\n        // Order of Chebyshev is 1. Can't use Newton-Raphson to find an\n        // optimal sigma. Object will most likely shrink.\n        done = true;\n        sigma = 0.0;\n      }\n    }\n\n    if (Math.abs(fKpb - 1.0) >= 1e-3) {\n      console.log('An optimal offset for the smoothing filter could not be found.  Unpredictable smoothing/shrinkage may result.');\n    }\n\n    var x = [0, 0, 0];\n    var y = [0, 0, 0];\n    var deltaX = [0, 0, 0];\n    var xNew = [0, 0, 0];\n    var x1 = [0, 0, 0];\n    var x2 = [0, 0, 0]; // first iteration\n\n    for (var _i10 = 0; _i10 < numPts; ++_i10) {\n      if (verts[_i10].edges != null && (npts = verts[_i10].edges.length) > 0) {\n        var _newPts$one, _newPts$three;\n\n        // point is allowed to move\n        newPts[zero].getPoint(_i10, x); // use current points\n\n        deltaX[0] = 0.0;\n        deltaX[1] = 0.0;\n        deltaX[2] = 0.0; // calculate the negative of the laplacian\n        // for all connected points\n\n        for (var _j4 = 0; _j4 < npts; ++_j4) {\n          newPts[zero].getPoint(verts[_i10].edges[_j4], y);\n\n          for (var _k = 0; _k < 3; ++_k) {\n            deltaX[_k] += (x[_k] - y[_k]) / npts;\n          }\n        } // newPts[one] = newPts[zero] - 0.5 newPts[one]\n\n\n        for (var _k2 = 0; _k2 < 3; ++_k2) {\n          deltaX[_k2] = x[_k2] - 0.5 * deltaX[_k2];\n        }\n\n        (_newPts$one = newPts[one]).setPoint.apply(_newPts$one, [_i10].concat(deltaX));\n\n        if (verts[_i10].type === VertexType.VTK_FIXED_VERTEX) {\n          newPts[zero].getPoint(_i10, deltaX);\n        } else {\n          // calculate newPts[three] = c0 newPts[zero] + c1 newPts[one]\n          for (var _k3 = 0; _k3 < 3; ++_k3) {\n            deltaX[_k3] = c[0] * x[_k3] + c[1] * deltaX[_k3];\n          }\n        }\n\n        (_newPts$three = newPts[three]).setPoint.apply(_newPts$three, [_i10].concat(deltaX));\n      } // if can move point\n      else {\n        var _newPts$one2, _newPts$three2;\n\n        // point is not allowed to move, just use the old point...\n        // (zero out the Laplacian)\n        (_newPts$one2 = newPts[one]).setPoint.apply(_newPts$one2, [_i10].concat(zerovector));\n\n        newPts[zero].getPoint(_i10, deltaX);\n\n        (_newPts$three2 = newPts[three]).setPoint.apply(_newPts$three2, [_i10].concat(deltaX));\n      }\n    } // for all points\n    // for the rest of the iterations\n\n\n    var pX0 = [0, 0, 0];\n    var pX1 = [0, 0, 0];\n    var pX3 = [0, 0, 0];\n    var iterationNumber = 2;\n\n    for (; iterationNumber <= model.numberOfIterations; iterationNumber++) {\n\n      for (var _i11 = 0; _i11 < numPts; ++_i11) {\n        npts = verts[_i11].edges != null ? verts[_i11].edges.length : 0;\n\n        if (npts > 0) {\n          var _newPts$two;\n\n          // point is allowed to move\n          newPts[zero].getPoint(_i11, pX0); // use current points\n\n          newPts[one].getPoint(_i11, pX1);\n          deltaX[0] = 0.0;\n          deltaX[1] = 0.0;\n          deltaX[2] = 0.0; // calculate the negative laplacian of x1\n\n          for (var _j5 = 0; _j5 < npts; ++_j5) {\n            newPts[one].getPoint(verts[_i11].edges[_j5], y);\n\n            for (var _k4 = 0; _k4 < 3; ++_k4) {\n              deltaX[_k4] += (pX1[_k4] - y[_k4]) / npts;\n            }\n          } // for all connected points\n          // Taubin:  x2 = (x1 - x0) + (x1 - x2)\n\n\n          for (var _k5 = 0; _k5 < 3; ++_k5) {\n            deltaX[_k5] = pX1[_k5] - pX0[_k5] + pX1[_k5] - deltaX[_k5];\n          }\n\n          (_newPts$two = newPts[two]).setPoint.apply(_newPts$two, [_i11].concat(deltaX)); // smooth the vertex (x3 = x3 + cj x2)\n\n\n          newPts[three].getPoint(_i11, pX3);\n\n          for (var _k6 = 0; _k6 < 3; ++_k6) {\n            xNew[_k6] = pX3[_k6] + c[iterationNumber] * deltaX[_k6];\n          }\n\n          if (verts[_i11].type !== VertexType.VTK_FIXED_VERTEX) {\n            var _newPts$three3;\n\n            (_newPts$three3 = newPts[three]).setPoint.apply(_newPts$three3, [_i11].concat(xNew));\n          }\n        } // if can move point\n        else {\n          var _newPts$one3, _newPts$two2;\n\n          // point is not allowed to move, just use the old point...\n          // (zero out the Laplacian)\n          (_newPts$one3 = newPts[one]).setPoint.apply(_newPts$one3, [_i11].concat(zerovector));\n\n          (_newPts$two2 = newPts[two]).setPoint.apply(_newPts$two2, [_i11].concat(zerovector));\n        }\n      } // for all points\n      // update the pointers. three is always three. all other pointers\n      // shift by one and wrap.\n\n\n      zero = (1 + zero) % 3;\n      one = (1 + one) % 3;\n      two = (1 + two) % 3;\n    } // for all iterations or until converge\n    // move the iteration count back down so that it matches the\n    // actual number of iterations executed\n\n\n    --iterationNumber; // set zero to three so the correct set of positions is outputted\n\n    zero = three; // console.log('Performed', iterationNumber, 'smoothing passes');\n    // if we scaled the data down to the unit cube, then scale data back\n    // up to the original space\n\n    if (model.normalizeCoordinates) {\n      // Re-position the coordinated\n      var repositionedPoint = [0, 0, 0];\n\n      for (var _i12 = 0; _i12 < numPts; ++_i12) {\n        var _newPts$zero2;\n\n        newPts[zero].getPoint(_i12, repositionedPoint);\n\n        for (var _j6 = 0; _j6 < 3; ++_j6) {\n          repositionedPoint[_j6] = repositionedPoint[_j6] * inLength + inCenter[_j6];\n        }\n\n        (_newPts$zero2 = newPts[zero]).setPoint.apply(_newPts$zero2, [_i12].concat(repositionedPoint));\n      }\n    }\n\n    if (model.generateErrorScalars) {\n      var newScalars = new Float32Array(numPts);\n\n      for (var _i13 = 0; _i13 < numPts; ++_i13) {\n        inPts.getPoint(_i13, x1);\n        newPts[zero].getPoint(_i13, x2);\n        newScalars[_i13] = Math.sqrt(Math.distance2BetweenPoints(x1, x2));\n      }\n\n      var newScalarsArray = vtkDataArray.newInstance({\n        numberOfComponents: 1,\n        values: newScalars\n      });\n      var idx = output.getPointData().addArray(newScalarsArray);\n      output.getPointData().setActiveAttribute(idx, AttributeTypes.SCALARS);\n    }\n\n    if (model.generateErrorVectors) {\n      var newVectors = new Float32Array(3 * numPts);\n\n      for (var _i14 = 0; _i14 < numPts; ++_i14) {\n        inPts.getPoint(_i14, x1);\n        newPts[zero].getPoint(_i14, x2);\n\n        for (var _j7 = 0; _j7 < 3; ++_j7) {\n          newVectors[3 * _i14 + _j7] = x2[_j7] - x1[_j7];\n        }\n      }\n\n      var newVectorsArray = vtkDataArray.newInstance({\n        numberOfComponents: 3,\n        values: newVectors\n      });\n      output.getPointData().setVectors(newVectorsArray);\n    }\n\n    return newPts[zero];\n  };\n\n  publicAPI.requestData = function (inData, outData) {\n    var numberOfInputs = publicAPI.getNumberOfInputPorts();\n\n    if (!numberOfInputs) {\n      return;\n    }\n\n    var input = inData[0];\n\n    if (!input) {\n      return;\n    }\n\n    var output = vtkPolyData.newInstance();\n    var outputPoints = publicAPI.vtkWindowedSincPolyDataFilterExecute(input.getPoints(), input, output);\n    output.setPointData(input.getPointData());\n    output.setCellData(input.getCellData());\n    output.setFieldData(input.getFieldData());\n    output.setPoints(outputPoints);\n    output.setVerts(input.getVerts());\n    output.setLines(input.getLines());\n    output.setPolys(input.getPolys());\n    output.setStrips(input.getStrips());\n    outData[0] = output;\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\n\nvar DEFAULT_VALUES = {\n  numberOfIterations: 20,\n  passBand: 0.1,\n  featureAngle: 45.0,\n  edgeAngle: 15.0,\n  featureEdgeSmoothing: 0,\n  boundarySmoothing: 1,\n  nonManifoldSmoothing: 0,\n  generateErrorScalars: 0,\n  generateErrorVectors: 0,\n  normalizeCoordinates: 0\n}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n  /* Make this a VTK object */\n\n  macro.obj(publicAPI, model);\n  /* Also make it an algorithm with one input and one output */\n\n  macro.algo(publicAPI, model, 1, 1);\n  /* Setters */\n\n  macro.setGet(publicAPI, model, ['numberOfIterations', 'passBand', 'featureAngle', 'edgeAngle', 'featureEdgeSmoothing', 'boundarySmoothing', 'nonManifoldSmoothing', 'generateErrorScalars', 'generateErrorVectors', 'normalizeCoordinates']);\n  /* Object specific methods */\n\n  vtkWindowedSincPolyDataFilter(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = macro.newInstance(extend, 'vtkWindowedSincPolyDataFilter'); // ----------------------------------------------------------------------------\n\nvar vtkWindowedSincPolyDataFilter$1 = {\n  newInstance: newInstance,\n  extend: extend\n};\n\nexport { vtkWindowedSincPolyDataFilter$1 as default, extend, newInstance };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}