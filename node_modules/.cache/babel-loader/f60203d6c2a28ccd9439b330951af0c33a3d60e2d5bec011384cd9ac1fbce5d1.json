{"ast":null,"code":"import macro, { vtkWarningMacro } from '../../macros.js';\nimport vtkCompositeMouseManipulator from './CompositeMouseManipulator.js';\n\n// vtkMouseRangeManipulator methods\n// ----------------------------------------------------------------------------\n\nfunction vtkMouseRangeManipulator(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkMouseRangeManipulator'); // Keep track of delta that is below the value\n  // of one step to progressively increment it\n\n  var incrementalDelta = new Map(); // Internal methods\n  //-------------------------------------------------------------------------\n\n  function scaleDeltaToRange(listener, normalizedDelta) {\n    return normalizedDelta * ((listener.max - listener.min) / (listener.step + 1));\n  } //-------------------------------------------------------------------------\n\n  function processDelta(listener, delta) {\n    var oldValue = listener.getValue(); // if exponential scroll is enabled, we raise our scale to the\n    //  exponent of the net delta of the interaction. The further away\n    // the user's cursor is from the start of the interaction, the more\n    // their movements will effect the value.\n\n    var scalingFactor = listener.exponentialScroll ? Math.pow(listener.scale, Math.log2(Math.abs(model.interactionNetDelta) + 2)) : listener.scale; // Preserve the sign of scale (which can be used to invert the scrolling direction)\n    // after the power operation above (in case of exponentialScroll).\n\n    scalingFactor = Math.abs(scalingFactor) * Math.sign(listener.scale);\n    var newDelta = delta * scalingFactor + incrementalDelta.get(listener); // Compute new value based on step\n    // In the following line, Math.abs is required so that the floor function\n    // consistently rounds to the lowest absolute integer.\n\n    var stepsToDifference = Math.floor(Math.abs(newDelta / listener.step));\n    var value = oldValue + listener.step * stepsToDifference * Math.sign(newDelta);\n    value = Math.max(value, listener.min);\n    value = Math.min(value, listener.max);\n    if (value !== oldValue) {\n      // Update value\n      listener.setValue(value);\n      incrementalDelta.set(listener, 0);\n    } else if (value === listener.min && newDelta < 0 || value === listener.max && newDelta > 0) {\n      // Do not allow incremental delta to go past range\n      incrementalDelta.set(listener, 0);\n    } else {\n      // Store delta for the next iteration\n      incrementalDelta.set(listener, newDelta);\n    }\n  } // Public API methods\n  // min:number = minimum allowable value\n  // max:number = maximum allowable value\n  // step:number = value per step -- smaller = more steps over a given distance, larger = fewer steps over a given distance\n  // getValue:fn = function that returns current value\n  // setValue:fn = function to set value\n  // scale:number = scale value is applied to mouse event to allow users accelerate or decelerate delta without emitting more events\n  //-------------------------------------------------------------------------\n\n  publicAPI.setHorizontalListener = function (min, max, step, getValue, setValue) {\n    var scale = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 1;\n    var exponentialScroll = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;\n    var getFn = Number.isFinite(getValue) ? function () {\n      return getValue;\n    } : getValue;\n    model.horizontalListener = {\n      min: min,\n      max: max,\n      step: step,\n      getValue: getFn,\n      setValue: setValue,\n      scale: scale,\n      exponentialScroll: exponentialScroll\n    };\n    incrementalDelta.set(model.horizontalListener, 0);\n    publicAPI.modified();\n  }; //-------------------------------------------------------------------------\n\n  publicAPI.setVerticalListener = function (min, max, step, getValue, setValue) {\n    var scale = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 1;\n    var exponentialScroll = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;\n    var getFn = Number.isFinite(getValue) ? function () {\n      return getValue;\n    } : getValue;\n    model.verticalListener = {\n      min: min,\n      max: max,\n      step: step,\n      getValue: getFn,\n      setValue: setValue,\n      scale: scale,\n      exponentialScroll: exponentialScroll\n    };\n    incrementalDelta.set(model.verticalListener, 0);\n    publicAPI.modified();\n  }; //-------------------------------------------------------------------------\n\n  publicAPI.setScrollListener = function (min, max, step, getValue, setValue) {\n    var scale = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 1;\n    var exponentialScroll = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;\n    if (step < 0) {\n      vtkWarningMacro('Value of step cannot be negative. If you want to invert the scrolling direction, use a negative scale value instead.');\n    }\n    var stepSize = Math.abs(step);\n    var getFn = Number.isFinite(getValue) ? function () {\n      return getValue;\n    } : getValue;\n    model.scrollListener = {\n      min: min,\n      max: max,\n      step: stepSize,\n      getValue: getFn,\n      setValue: setValue,\n      scale: scale,\n      exponentialScroll: exponentialScroll\n    };\n    incrementalDelta.set(model.scrollListener, 0);\n    publicAPI.modified();\n  }; //-------------------------------------------------------------------------\n\n  publicAPI.removeHorizontalListener = function () {\n    if (model.horizontalListener) {\n      incrementalDelta.delete(model.horizontalListener);\n      delete model.horizontalListener;\n      publicAPI.modified();\n    }\n  }; //-------------------------------------------------------------------------\n\n  publicAPI.removeVerticalListener = function () {\n    if (model.verticalListener) {\n      incrementalDelta.delete(model.verticalListener);\n      delete model.verticalListener;\n      publicAPI.modified();\n    }\n  }; //-------------------------------------------------------------------------\n\n  publicAPI.removeScrollListener = function () {\n    if (model.scrollListener) {\n      incrementalDelta.delete(model.scrollListener);\n      delete model.scrollListener;\n      publicAPI.modified();\n    }\n  }; //-------------------------------------------------------------------------\n\n  publicAPI.removeAllListeners = function () {\n    publicAPI.removeHorizontalListener();\n    publicAPI.removeVerticalListener();\n    publicAPI.removeScrollListener();\n  }; //-------------------------------------------------------------------------\n\n  publicAPI.onButtonDown = function (interactor, renderer, position) {\n    model.previousPosition = position;\n    model.interactionNetDelta = 0;\n    var glRenderWindow = interactor.getView(); // Ratio is the dom size vs renderwindow size\n\n    var ratio = glRenderWindow.getContainerSize()[0] / glRenderWindow.getSize()[0]; // Get proper pixel range used by viewport in rw size space\n\n    var size = glRenderWindow.getViewportSize(renderer); // rescale size to match mouse event position\n\n    model.containerSize = size.map(function (v) {\n      return v * ratio;\n    });\n  };\n  publicAPI.onButtonUp = function (interactor) {\n    interactor.exitPointerLock();\n  }; //--------------------------------------------------------------------------\n  // TODO: at some point, this should perhaps be done in\n  // RenderWindowInteractor instead of here.\n  // We need to hook into mousemove directly for two reasons:\n  // 1. We need to keep receiving mouse move events after the mouse button\n  //    is released. This is currently not possible with\n  //    vtkInteractorStyleManipulator.\n  // 2. Since the mouse is stationary in pointer lock mode, we need the\n  //    event.movementX and event.movementY info, which are not currently\n  //    passed via interactor.onMouseMove.\n\n  publicAPI.startPointerLockEvent = function (interactor, renderer) {\n    var handlePointerLockMove = function handlePointerLockMove(event) {\n      publicAPI.onPointerLockMove(interactor, renderer, event);\n    };\n    document.addEventListener('mousemove', handlePointerLockMove);\n    var subscription = null;\n    var endInteraction = function endInteraction() {\n      var _subscription;\n      document.removeEventListener('mousemove', handlePointerLockMove);\n      (_subscription = subscription) === null || _subscription === void 0 ? void 0 : _subscription.unsubscribe();\n    };\n    subscription = interactor === null || interactor === void 0 ? void 0 : interactor.onEndPointerLock(endInteraction);\n  };\n  publicAPI.onPointerLockMove = function (interactor, renderer, event) {\n    // There is a slight delay between the `onEndPointerLock` call\n    // and the last `onMouseMove` event, we must make sure the pointer\n    // is still locked before we run this logic otherwise we may\n    // get a `onMouseMove` call after the pointer has been unlocked.\n    if (!interactor.isPointerLocked()) return; // previousPosition could be undefined if for some reason the\n    // `startPointerLockEvent` method is called before the `onButtonDown` one.\n\n    if (model.previousPosition == null) return;\n    model.previousPosition.x += event.movementX;\n    model.previousPosition.y += event.movementY;\n    publicAPI.onMouseMove(interactor, renderer, model.previousPosition);\n  }; //-------------------------------------------------------------------------\n\n  publicAPI.onMouseMove = function (interactor, renderer, position) {\n    if (!model.verticalListener && !model.horizontalListener) {\n      return;\n    } // We only want to initialize the pointer lock listener\n    // after the user starts moving their mouse, this way\n    // we don't interfere with other events such as doubleClick,\n    // for this reason we don't call this from `onButtonDown`\n\n    if (model.usePointerLock && !interactor.isPointerLocked()) {\n      interactor.requestPointerLock();\n      publicAPI.startPointerLockEvent(interactor, renderer);\n    }\n    if (!position) {\n      return;\n    }\n    if (model.horizontalListener) {\n      var dxNorm = (position.x - model.previousPosition.x) / model.containerSize[0];\n      var dx = scaleDeltaToRange(model.horizontalListener, dxNorm);\n      model.interactionNetDelta += dx;\n      processDelta(model.horizontalListener, dx);\n    }\n    if (model.verticalListener) {\n      var dyNorm = (position.y - model.previousPosition.y) / model.containerSize[1];\n      var dy = scaleDeltaToRange(model.verticalListener, dyNorm);\n      model.interactionNetDelta += dy;\n      processDelta(model.verticalListener, dy);\n    }\n    model.previousPosition = position;\n  }; //-------------------------------------------------------------------------\n\n  publicAPI.onScroll = function (interactor, renderer, delta) {\n    if (!model.scrollListener || !delta) {\n      return;\n    }\n    model.interactionNetDelta += delta * model.scrollListener.step;\n    processDelta(model.scrollListener, delta * model.scrollListener.step);\n  };\n  publicAPI.onStartScroll = function () {\n    model.interactionNetDelta = 0;\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nvar DEFAULT_VALUES = {\n  horizontalListener: null,\n  verticalListener: null,\n  scrollListener: null\n}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Inheritance\n\n  macro.obj(publicAPI, model);\n  vtkCompositeMouseManipulator.extend(publicAPI, model, initialValues); // Create get-set macros\n\n  macro.setGet(publicAPI, model, ['usePointerLock']); // Object specific methods\n\n  vtkMouseRangeManipulator(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = macro.newInstance(extend, 'vtkMouseRangeManipulator'); // ----------------------------------------------------------------------------\n\nvar vtkMouseRangeManipulator$1 = {\n  newInstance: newInstance,\n  extend: extend\n};\nexport { vtkMouseRangeManipulator$1 as default, extend, newInstance };","map":{"version":3,"names":["macro","vtkWarningMacro","vtkCompositeMouseManipulator","vtkMouseRangeManipulator","publicAPI","model","classHierarchy","push","incrementalDelta","Map","scaleDeltaToRange","listener","normalizedDelta","max","min","step","processDelta","delta","oldValue","getValue","scalingFactor","exponentialScroll","Math","pow","scale","log2","abs","interactionNetDelta","sign","newDelta","get","stepsToDifference","floor","value","setValue","set","setHorizontalListener","arguments","length","undefined","getFn","Number","isFinite","horizontalListener","modified","setVerticalListener","verticalListener","setScrollListener","stepSize","scrollListener","removeHorizontalListener","delete","removeVerticalListener","removeScrollListener","removeAllListeners","onButtonDown","interactor","renderer","position","previousPosition","glRenderWindow","getView","ratio","getContainerSize","getSize","size","getViewportSize","containerSize","map","v","onButtonUp","exitPointerLock","startPointerLockEvent","handlePointerLockMove","event","onPointerLockMove","document","addEventListener","subscription","endInteraction","_subscription","removeEventListener","unsubscribe","onEndPointerLock","isPointerLocked","x","movementX","y","movementY","onMouseMove","usePointerLock","requestPointerLock","dxNorm","dx","dyNorm","dy","onScroll","onStartScroll","DEFAULT_VALUES","extend","initialValues","Object","assign","obj","setGet","newInstance","vtkMouseRangeManipulator$1","default"],"sources":["/home/rakshith/Documents/RemoteRendering/vtk-js-react-app/node_modules/@kitware/vtk.js/Interaction/Manipulators/MouseRangeManipulator.js"],"sourcesContent":["import macro, { vtkWarningMacro } from '../../macros.js';\nimport vtkCompositeMouseManipulator from './CompositeMouseManipulator.js';\n\n// vtkMouseRangeManipulator methods\n// ----------------------------------------------------------------------------\n\nfunction vtkMouseRangeManipulator(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkMouseRangeManipulator'); // Keep track of delta that is below the value\n  // of one step to progressively increment it\n\n  var incrementalDelta = new Map(); // Internal methods\n  //-------------------------------------------------------------------------\n\n  function scaleDeltaToRange(listener, normalizedDelta) {\n    return normalizedDelta * ((listener.max - listener.min) / (listener.step + 1));\n  } //-------------------------------------------------------------------------\n\n\n  function processDelta(listener, delta) {\n    var oldValue = listener.getValue(); // if exponential scroll is enabled, we raise our scale to the\n    //  exponent of the net delta of the interaction. The further away\n    // the user's cursor is from the start of the interaction, the more\n    // their movements will effect the value.\n\n    var scalingFactor = listener.exponentialScroll ? Math.pow(listener.scale, Math.log2(Math.abs(model.interactionNetDelta) + 2)) : listener.scale; // Preserve the sign of scale (which can be used to invert the scrolling direction)\n    // after the power operation above (in case of exponentialScroll).\n\n    scalingFactor = Math.abs(scalingFactor) * Math.sign(listener.scale);\n    var newDelta = delta * scalingFactor + incrementalDelta.get(listener); // Compute new value based on step\n    // In the following line, Math.abs is required so that the floor function\n    // consistently rounds to the lowest absolute integer.\n\n    var stepsToDifference = Math.floor(Math.abs(newDelta / listener.step));\n    var value = oldValue + listener.step * stepsToDifference * Math.sign(newDelta);\n    value = Math.max(value, listener.min);\n    value = Math.min(value, listener.max);\n\n    if (value !== oldValue) {\n      // Update value\n      listener.setValue(value);\n      incrementalDelta.set(listener, 0);\n    } else if (value === listener.min && newDelta < 0 || value === listener.max && newDelta > 0) {\n      // Do not allow incremental delta to go past range\n      incrementalDelta.set(listener, 0);\n    } else {\n      // Store delta for the next iteration\n      incrementalDelta.set(listener, newDelta);\n    }\n  } // Public API methods\n  // min:number = minimum allowable value\n  // max:number = maximum allowable value\n  // step:number = value per step -- smaller = more steps over a given distance, larger = fewer steps over a given distance\n  // getValue:fn = function that returns current value\n  // setValue:fn = function to set value\n  // scale:number = scale value is applied to mouse event to allow users accelerate or decelerate delta without emitting more events\n  //-------------------------------------------------------------------------\n\n\n  publicAPI.setHorizontalListener = function (min, max, step, getValue, setValue) {\n    var scale = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 1;\n    var exponentialScroll = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;\n    var getFn = Number.isFinite(getValue) ? function () {\n      return getValue;\n    } : getValue;\n    model.horizontalListener = {\n      min: min,\n      max: max,\n      step: step,\n      getValue: getFn,\n      setValue: setValue,\n      scale: scale,\n      exponentialScroll: exponentialScroll\n    };\n    incrementalDelta.set(model.horizontalListener, 0);\n    publicAPI.modified();\n  }; //-------------------------------------------------------------------------\n\n\n  publicAPI.setVerticalListener = function (min, max, step, getValue, setValue) {\n    var scale = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 1;\n    var exponentialScroll = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;\n    var getFn = Number.isFinite(getValue) ? function () {\n      return getValue;\n    } : getValue;\n    model.verticalListener = {\n      min: min,\n      max: max,\n      step: step,\n      getValue: getFn,\n      setValue: setValue,\n      scale: scale,\n      exponentialScroll: exponentialScroll\n    };\n    incrementalDelta.set(model.verticalListener, 0);\n    publicAPI.modified();\n  }; //-------------------------------------------------------------------------\n\n\n  publicAPI.setScrollListener = function (min, max, step, getValue, setValue) {\n    var scale = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 1;\n    var exponentialScroll = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;\n\n    if (step < 0) {\n      vtkWarningMacro('Value of step cannot be negative. If you want to invert the scrolling direction, use a negative scale value instead.');\n    }\n\n    var stepSize = Math.abs(step);\n    var getFn = Number.isFinite(getValue) ? function () {\n      return getValue;\n    } : getValue;\n    model.scrollListener = {\n      min: min,\n      max: max,\n      step: stepSize,\n      getValue: getFn,\n      setValue: setValue,\n      scale: scale,\n      exponentialScroll: exponentialScroll\n    };\n    incrementalDelta.set(model.scrollListener, 0);\n    publicAPI.modified();\n  }; //-------------------------------------------------------------------------\n\n\n  publicAPI.removeHorizontalListener = function () {\n    if (model.horizontalListener) {\n      incrementalDelta.delete(model.horizontalListener);\n      delete model.horizontalListener;\n      publicAPI.modified();\n    }\n  }; //-------------------------------------------------------------------------\n\n\n  publicAPI.removeVerticalListener = function () {\n    if (model.verticalListener) {\n      incrementalDelta.delete(model.verticalListener);\n      delete model.verticalListener;\n      publicAPI.modified();\n    }\n  }; //-------------------------------------------------------------------------\n\n\n  publicAPI.removeScrollListener = function () {\n    if (model.scrollListener) {\n      incrementalDelta.delete(model.scrollListener);\n      delete model.scrollListener;\n      publicAPI.modified();\n    }\n  }; //-------------------------------------------------------------------------\n\n\n  publicAPI.removeAllListeners = function () {\n    publicAPI.removeHorizontalListener();\n    publicAPI.removeVerticalListener();\n    publicAPI.removeScrollListener();\n  }; //-------------------------------------------------------------------------\n\n\n  publicAPI.onButtonDown = function (interactor, renderer, position) {\n    model.previousPosition = position;\n    model.interactionNetDelta = 0;\n    var glRenderWindow = interactor.getView(); // Ratio is the dom size vs renderwindow size\n\n    var ratio = glRenderWindow.getContainerSize()[0] / glRenderWindow.getSize()[0]; // Get proper pixel range used by viewport in rw size space\n\n    var size = glRenderWindow.getViewportSize(renderer); // rescale size to match mouse event position\n\n    model.containerSize = size.map(function (v) {\n      return v * ratio;\n    });\n  };\n\n  publicAPI.onButtonUp = function (interactor) {\n    interactor.exitPointerLock();\n  }; //--------------------------------------------------------------------------\n  // TODO: at some point, this should perhaps be done in\n  // RenderWindowInteractor instead of here.\n  // We need to hook into mousemove directly for two reasons:\n  // 1. We need to keep receiving mouse move events after the mouse button\n  //    is released. This is currently not possible with\n  //    vtkInteractorStyleManipulator.\n  // 2. Since the mouse is stationary in pointer lock mode, we need the\n  //    event.movementX and event.movementY info, which are not currently\n  //    passed via interactor.onMouseMove.\n\n\n  publicAPI.startPointerLockEvent = function (interactor, renderer) {\n    var handlePointerLockMove = function handlePointerLockMove(event) {\n      publicAPI.onPointerLockMove(interactor, renderer, event);\n    };\n\n    document.addEventListener('mousemove', handlePointerLockMove);\n    var subscription = null;\n\n    var endInteraction = function endInteraction() {\n      var _subscription;\n\n      document.removeEventListener('mousemove', handlePointerLockMove);\n      (_subscription = subscription) === null || _subscription === void 0 ? void 0 : _subscription.unsubscribe();\n    };\n\n    subscription = interactor === null || interactor === void 0 ? void 0 : interactor.onEndPointerLock(endInteraction);\n  };\n\n  publicAPI.onPointerLockMove = function (interactor, renderer, event) {\n    // There is a slight delay between the `onEndPointerLock` call\n    // and the last `onMouseMove` event, we must make sure the pointer\n    // is still locked before we run this logic otherwise we may\n    // get a `onMouseMove` call after the pointer has been unlocked.\n    if (!interactor.isPointerLocked()) return; // previousPosition could be undefined if for some reason the\n    // `startPointerLockEvent` method is called before the `onButtonDown` one.\n\n    if (model.previousPosition == null) return;\n    model.previousPosition.x += event.movementX;\n    model.previousPosition.y += event.movementY;\n    publicAPI.onMouseMove(interactor, renderer, model.previousPosition);\n  }; //-------------------------------------------------------------------------\n\n\n  publicAPI.onMouseMove = function (interactor, renderer, position) {\n    if (!model.verticalListener && !model.horizontalListener) {\n      return;\n    } // We only want to initialize the pointer lock listener\n    // after the user starts moving their mouse, this way\n    // we don't interfere with other events such as doubleClick,\n    // for this reason we don't call this from `onButtonDown`\n\n\n    if (model.usePointerLock && !interactor.isPointerLocked()) {\n      interactor.requestPointerLock();\n      publicAPI.startPointerLockEvent(interactor, renderer);\n    }\n\n    if (!position) {\n      return;\n    }\n\n    if (model.horizontalListener) {\n      var dxNorm = (position.x - model.previousPosition.x) / model.containerSize[0];\n      var dx = scaleDeltaToRange(model.horizontalListener, dxNorm);\n      model.interactionNetDelta += dx;\n      processDelta(model.horizontalListener, dx);\n    }\n\n    if (model.verticalListener) {\n      var dyNorm = (position.y - model.previousPosition.y) / model.containerSize[1];\n      var dy = scaleDeltaToRange(model.verticalListener, dyNorm);\n      model.interactionNetDelta += dy;\n      processDelta(model.verticalListener, dy);\n    }\n\n    model.previousPosition = position;\n  }; //-------------------------------------------------------------------------\n\n\n  publicAPI.onScroll = function (interactor, renderer, delta) {\n    if (!model.scrollListener || !delta) {\n      return;\n    }\n\n    model.interactionNetDelta += delta * model.scrollListener.step;\n    processDelta(model.scrollListener, delta * model.scrollListener.step);\n  };\n\n  publicAPI.onStartScroll = function () {\n    model.interactionNetDelta = 0;\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\n\nvar DEFAULT_VALUES = {\n  horizontalListener: null,\n  verticalListener: null,\n  scrollListener: null\n}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Inheritance\n\n  macro.obj(publicAPI, model);\n  vtkCompositeMouseManipulator.extend(publicAPI, model, initialValues); // Create get-set macros\n\n  macro.setGet(publicAPI, model, ['usePointerLock']); // Object specific methods\n\n  vtkMouseRangeManipulator(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = macro.newInstance(extend, 'vtkMouseRangeManipulator'); // ----------------------------------------------------------------------------\n\nvar vtkMouseRangeManipulator$1 = {\n  newInstance: newInstance,\n  extend: extend\n};\n\nexport { vtkMouseRangeManipulator$1 as default, extend, newInstance };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}