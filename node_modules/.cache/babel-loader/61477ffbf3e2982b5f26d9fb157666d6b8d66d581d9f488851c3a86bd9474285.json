{"ast":null,"code":"import _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport macro from '../../macros.js';\nimport vtkCell from './Cell.js';\nimport { d as dot, j as cross, l as normalize, m as multiplyAccumulate, e as distance2BetweenPoints, o as determinant2x2 } from '../Core/Math/index.js';\nimport vtkLine from './Line.js';\nimport vtkPlane from './Plane.js';\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n  return target;\n}\n// Global methods\n// ----------------------------------------------------------------------------\n\nfunction computeNormalDirection(v1, v2, v3, n) {\n  // order is important!!! maintain consistency with triangle vertex order\n  var ax = v3[0] - v2[0];\n  var ay = v3[1] - v2[1];\n  var az = v3[2] - v2[2];\n  var bx = v1[0] - v2[0];\n  var by = v1[1] - v2[1];\n  var bz = v1[2] - v2[2];\n  n[0] = ay * bz - az * by;\n  n[1] = az * bx - ax * bz;\n  n[2] = ax * by - ay * bx;\n}\nfunction computeNormal(v1, v2, v3, n) {\n  computeNormalDirection(v1, v2, v3, n);\n  var length = Math.sqrt(n[0] * n[0] + n[1] * n[1] + n[2] * n[2]);\n  if (length !== 0.0) {\n    n[0] /= length;\n    n[1] /= length;\n    n[2] /= length;\n  }\n}\nfunction intersectWithTriangle(p1, q1, r1, p2, q2, r2) {\n  var tolerance = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 1e-6;\n  var coplanar = false;\n  var pt1 = [];\n  var pt2 = [];\n  var surfaceId = [];\n  var n1 = [];\n  var n2 = []; // Compute supporting plane normals.\n\n  computeNormal(p1, q1, r1, n1);\n  computeNormal(p2, q2, r2, n2);\n  var s1 = -dot(n1, p1);\n  var s2 = -dot(n2, p2); // Compute signed distances of points p1, q1, r1 from supporting\n  // plane of second triangle.\n\n  var dist1 = [dot(n2, p1) + s2, dot(n2, q1) + s2, dot(n2, r1) + s2]; // If signs of all points are the same, all the points lie on the\n  // same side of the supporting plane, and we can exit early.\n\n  if (dist1[0] * dist1[1] > tolerance && dist1[0] * dist1[2] > tolerance) {\n    // vtkDebugMacro(<<\"Same side supporting plane 1!\");\n    return {\n      intersect: false,\n      coplanar: coplanar,\n      pt1: pt1,\n      pt2: pt2,\n      surfaceId: surfaceId\n    };\n  } // Do the same for p2, q2, r2 and supporting plane of first\n  // triangle.\n\n  var dist2 = [dot(n1, p2) + s1, dot(n1, q2) + s1, dot(n1, r2) + s1]; // If signs of all points are the same, all the points lie on the\n  // same side of the supporting plane, and we can exit early.\n\n  if (dist2[0] * dist2[1] > tolerance && dist2[0] * dist2[2] > tolerance) {\n    // vtkDebugMacro(<<\"Same side supporting plane 2!\");\n    return {\n      intersect: false,\n      coplanar: coplanar,\n      pt1: pt1,\n      pt2: pt2,\n      surfaceId: surfaceId\n    };\n  } // Check for coplanarity of the supporting planes.\n\n  if (Math.abs(n1[0] - n2[0]) < 1e-9 && Math.abs(n1[1] - n2[1]) < 1e-9 && Math.abs(n1[2] - n2[2]) < 1e-9 && Math.abs(s1 - s2) < 1e-9) {\n    coplanar = true; // vtkDebugMacro(<<\"Coplanar!\");\n\n    return {\n      intersect: false,\n      coplanar: coplanar,\n      pt1: pt1,\n      pt2: pt2,\n      surfaceId: surfaceId\n    };\n  } // There are more efficient ways to find the intersection line (if\n  // it exists), but this is clear enough.\n\n  var pts1 = [p1, q1, r1];\n  var pts2 = [p2, q2, r2]; // Find line of intersection (L = p + t*v) between two planes.\n\n  var n1n2 = dot(n1, n2);\n  var a = (s1 - s2 * n1n2) / (n1n2 * n1n2 - 1.0);\n  var b = (s2 - s1 * n1n2) / (n1n2 * n1n2 - 1.0);\n  var p = [a * n1[0] + b * n2[0], a * n1[1] + b * n2[1], a * n1[2] + b * n2[2]];\n  var v = cross(n1, n2, []);\n  normalize(v);\n  var index1 = 0;\n  var index2 = 0;\n  var t1 = [];\n  var t2 = [];\n  var ts1 = 50;\n  var ts2 = 50;\n  for (var i = 0; i < 3; i++) {\n    var id1 = i;\n    var id2 = (i + 1) % 3; // Find t coordinate on line of intersection between two planes.\n\n    var val1 = vtkPlane.intersectWithLine(pts1[id1], pts1[id2], p2, n2);\n    if (val1.intersection && val1.t > 0 - tolerance && val1.t < 1 + tolerance) {\n      if (val1.t < 1 + tolerance && val1.t > 1 - tolerance) {\n        ts1 = index1;\n      }\n      t1[index1++] = dot(val1.x, v) - dot(p, v);\n    }\n    var val2 = vtkPlane.intersectWithLine(pts2[id1], pts2[id2], p1, n1);\n    if (val2.intersection && val2.t > 0 - tolerance && val2.t < 1 + tolerance) {\n      if (val2.t < 1 + tolerance && val2.t > 1 - tolerance) {\n        ts2 = index2;\n      }\n      t2[index2++] = dot(val2.x, v) - dot(p, v);\n    }\n  } // If the value of the index is greater than 2, the intersecting point\n  // actually is intersected by all three edges. In this case, set the two\n  // edges to the two edges where the intersecting point is not the end point\n\n  if (index1 > 2) {\n    index1--; // swap\n\n    var t12 = t1[2];\n    t1[2] = t1[ts1];\n    t1[ts1] = t12;\n  }\n  if (index2 > 2) {\n    index2--;\n    var t22 = t2[2];\n    t2[2] = t2[ts2];\n    t2[ts2] = t22;\n  } // Check if only one edge or all edges intersect the supporting\n  // planes intersection.\n\n  if (index1 !== 2 || index2 !== 2) {\n    // vtkDebugMacro(<<\"Only one edge intersecting!\");\n    return {\n      intersect: false,\n      coplanar: coplanar,\n      pt1: pt1,\n      pt2: pt2,\n      surfaceId: surfaceId\n    };\n  } // Check for NaNs\n\n  if (Number.isNaN(t1[0]) || Number.isNaN(t1[1]) || Number.isNaN(t2[0]) || Number.isNaN(t2[1])) {\n    // vtkWarningMacro(<<\"NaNs!\");\n    return {\n      intersect: false,\n      coplanar: coplanar,\n      pt1: pt1,\n      pt2: pt2,\n      surfaceId: surfaceId\n    };\n  }\n  if (t1[0] > t1[1]) {\n    // swap\n    var t11 = t1[1];\n    t1[1] = t1[0];\n    t1[0] = t11;\n  }\n  if (t2[0] > t2[1]) {\n    // swap\n    var t21 = t2[1];\n    t2[1] = t2[0];\n    t2[0] = t21;\n  } // Handle the different interval configuration cases.\n\n  var tt1;\n  var tt2;\n  if (t1[1] < t2[0] || t2[1] < t1[0]) {\n    // vtkDebugMacro(<<\"No Overlap!\");\n    return {\n      intersect: false,\n      coplanar: coplanar,\n      pt1: pt1,\n      pt2: pt2,\n      surfaceId: surfaceId\n    }; // No overlap\n  }\n\n  if (t1[0] < t2[0]) {\n    if (t1[1] < t2[1]) {\n      // First point on surface 2, second point on surface 1\n      surfaceId[0] = 2;\n      surfaceId[1] = 1;\n      tt1 = t2[0];\n      tt2 = t1[1];\n    } else {\n      // Both points belong to lines on surface 2\n      surfaceId[0] = 2;\n      surfaceId[1] = 2;\n      tt1 = t2[0];\n      tt2 = t2[1];\n    }\n  } // t1[0] >= t2[0]\n  else if (t1[1] < t2[1]) {\n    // Both points belong to lines on surface 1\n    surfaceId[0] = 1;\n    surfaceId[1] = 1;\n    tt1 = t1[0];\n    tt2 = t1[1];\n  } else {\n    // First point on surface 1, second point on surface 2\n    surfaceId[0] = 1;\n    surfaceId[1] = 2;\n    tt1 = t1[0];\n    tt2 = t2[1];\n  } // Create actual intersection points.\n\n  multiplyAccumulate(p, v, tt1, pt1);\n  multiplyAccumulate(p, v, tt2, pt2);\n  return {\n    intersect: true,\n    coplanar: coplanar,\n    pt1: pt1,\n    pt2: pt2,\n    surfaceId: surfaceId\n  };\n} // ----------------------------------------------------------------------------\n// Static API\n// ----------------------------------------------------------------------------\n\nvar STATIC = {\n  computeNormalDirection: computeNormalDirection,\n  computeNormal: computeNormal,\n  intersectWithTriangle: intersectWithTriangle\n}; // ----------------------------------------------------------------------------\n// vtkTriangle methods\n// ----------------------------------------------------------------------------\n\nfunction vtkTriangle(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkTriangle');\n  publicAPI.getCellDimension = function () {\n    return 2;\n  };\n  publicAPI.intersectWithLine = function (p1, p2, tol, x, pcoords) {\n    var outObj = {\n      subId: 0,\n      t: Number.MAX_VALUE,\n      intersect: 0,\n      betweenPoints: false\n    };\n    pcoords[2] = 0.0;\n    var closestPoint = [];\n    var tol2 = tol * tol; // Get normal for triangle\n\n    var pt1 = [];\n    var pt2 = [];\n    var pt3 = [];\n    model.points.getPoint(0, pt1);\n    model.points.getPoint(1, pt2);\n    model.points.getPoint(2, pt3);\n    var n = [];\n    var weights = [];\n    computeNormal(pt1, pt2, pt3, n);\n    if (n[0] !== 0 || n[1] !== 0 || n[2] !== 0) {\n      // Intersect plane of triangle with line\n      var plane = vtkPlane.intersectWithLine(p1, p2, pt1, n);\n      outObj.betweenPoints = plane.betweenPoints;\n      outObj.t = plane.t;\n      x[0] = plane.x[0];\n      x[1] = plane.x[1];\n      x[2] = plane.x[2];\n      if (!plane.intersection) {\n        pcoords[0] = 0.0;\n        pcoords[1] = 0.0;\n        outObj.intersect = 0;\n        return outObj;\n      } // Evaluate position\n\n      var inside = publicAPI.evaluatePosition(x, closestPoint, pcoords, weights);\n      if (inside.evaluation >= 0) {\n        if (inside.dist2 <= tol2) {\n          outObj.intersect = 1;\n          return outObj;\n        }\n        outObj.intersect = inside.evaluation;\n        return outObj;\n      }\n    } // Normals are null, so the triangle is degenerated and\n    // we still need to check intersection between line and\n    // the longest edge.\n\n    var dist2Pt1Pt2 = distance2BetweenPoints(pt1, pt2);\n    var dist2Pt2Pt3 = distance2BetweenPoints(pt2, pt3);\n    var dist2Pt3Pt1 = distance2BetweenPoints(pt3, pt1);\n    if (!model.line) {\n      model.line = vtkLine.newInstance();\n    }\n    if (dist2Pt1Pt2 > dist2Pt2Pt3 && dist2Pt1Pt2 > dist2Pt3Pt1) {\n      model.line.getPoints().setPoint(0, pt1);\n      model.line.getPoints().setPoint(1, pt2);\n    } else if (dist2Pt2Pt3 > dist2Pt3Pt1 && dist2Pt2Pt3 > dist2Pt1Pt2) {\n      model.line.getPoints().setPoint(0, pt2);\n      model.line.getPoints().setPoint(1, pt3);\n    } else {\n      model.line.getPoints().setPoint(0, pt3);\n      model.line.getPoints().setPoint(1, pt1);\n    }\n    var intersectLine = model.line.intersectWithLine(p1, p2, tol, x, pcoords);\n    outObj.betweenPoints = intersectLine.betweenPoints;\n    outObj.t = intersectLine.t;\n    if (intersectLine.intersect) {\n      var pt3Pt1 = [];\n      var pt3Pt2 = [];\n      var pt3X = []; // Compute r and s manually, using dot and norm.\n\n      for (var i = 0; i < 3; i++) {\n        pt3Pt1[i] = pt1[i] - pt3[i];\n        pt3Pt2[i] = pt2[i] - pt3[i];\n        pt3X[i] = x[i] - pt3[i];\n      }\n      pcoords[0] = dot(pt3X, pt3Pt1) / dist2Pt3Pt1;\n      pcoords[1] = dot(pt3X, pt3Pt2) / dist2Pt2Pt3;\n      outObj.intersect = 1;\n      return outObj;\n    }\n    pcoords[0] = 0.0;\n    pcoords[1] = 0.0;\n    outObj.intersect = 0;\n    return outObj;\n  };\n  publicAPI.evaluatePosition = function (x, closestPoint, pcoords, weights) {\n    // will return obj\n    var outObj = {\n      subId: 0,\n      dist2: 0,\n      evaluation: -1\n    };\n    var i;\n    var j;\n    var pt1 = [];\n    var pt2 = [];\n    var pt3 = [];\n    var n = [];\n    var fabsn;\n    var rhs = [];\n    var c1 = [];\n    var c2 = [];\n    var det = 0;\n    var idx = 0;\n    var indices = [];\n    var dist2Point;\n    var dist2Line1;\n    var dist2Line2;\n    var closest = [];\n    var closestPoint1 = [];\n    var closestPoint2 = [];\n    var cp = [];\n    outObj.subId = 0;\n    pcoords[2] = 0.0; // Get normal for triangle, only the normal direction is needed, i.e. the\n    // normal need not be normalized (unit length)\n    //\n\n    model.points.getPoint(1, pt1);\n    model.points.getPoint(2, pt2);\n    model.points.getPoint(0, pt3);\n    computeNormalDirection(pt1, pt2, pt3, n); // Project point to plane\n\n    vtkPlane.generalizedProjectPoint(x, pt1, n, cp); // Construct matrices.  Since we have over determined system, need to find\n    // which 2 out of 3 equations to use to develop equations. (Any 2 should\n    // work since we've projected point to plane.)\n\n    var maxComponent = 0.0;\n    for (i = 0; i < 3; i++) {\n      // trying to avoid an expensive call to fabs()\n      if (n[i] < 0) {\n        fabsn = -n[i];\n      } else {\n        fabsn = n[i];\n      }\n      if (fabsn > maxComponent) {\n        maxComponent = fabsn;\n        idx = i;\n      }\n    }\n    for (j = 0, i = 0; i < 3; i++) {\n      if (i !== idx) {\n        indices[j++] = i;\n      }\n    }\n    for (i = 0; i < 2; i++) {\n      rhs[i] = cp[indices[i]] - pt3[indices[i]];\n      c1[i] = pt1[indices[i]] - pt3[indices[i]];\n      c2[i] = pt2[indices[i]] - pt3[indices[i]];\n    }\n    det = determinant2x2(c1, c2);\n    if (det === 0.0) {\n      pcoords[0] = 0.0;\n      pcoords[1] = 0.0;\n      outObj.evaluation = -1;\n      return outObj;\n    }\n    pcoords[0] = determinant2x2(rhs, c2) / det;\n    pcoords[1] = determinant2x2(c1, rhs) / det; // Okay, now find closest point to element\n\n    weights[0] = 1 - (pcoords[0] + pcoords[1]);\n    weights[1] = pcoords[0];\n    weights[2] = pcoords[1];\n    if (weights[0] >= 0.0 && weights[0] <= 1.0 && weights[1] >= 0.0 && weights[1] <= 1.0 && weights[2] >= 0.0 && weights[2] <= 1.0) {\n      // projection distance\n      if (closestPoint) {\n        outObj.dist2 = distance2BetweenPoints(cp, x);\n        closestPoint[0] = cp[0];\n        closestPoint[1] = cp[1];\n        closestPoint[2] = cp[2];\n      }\n      outObj.evaluation = 1;\n    } else {\n      var t;\n      if (closestPoint) {\n        if (weights[1] < 0.0 && weights[2] < 0.0) {\n          dist2Point = distance2BetweenPoints(x, pt3);\n          dist2Line1 = vtkLine.distanceToLine(x, pt1, pt3, t, closestPoint1);\n          dist2Line2 = vtkLine.distanceToLine(x, pt3, pt2, t, closestPoint2);\n          if (dist2Point < dist2Line1) {\n            outObj.dist2 = dist2Point;\n            closest = pt3;\n          } else {\n            outObj.dist2 = dist2Line1;\n            closest = closestPoint1;\n          }\n          if (dist2Line2 < outObj.dist2) {\n            outObj.dist2 = dist2Line2;\n            closest = closestPoint2;\n          }\n          for (i = 0; i < 3; i++) {\n            closestPoint[i] = closest[i];\n          }\n        } else if (weights[2] < 0.0 && weights[0] < 0.0) {\n          dist2Point = distance2BetweenPoints(x, pt1);\n          dist2Line1 = vtkLine.distanceToLine(x, pt1, pt3, t, closestPoint1);\n          dist2Line2 = vtkLine.distanceToLine(x, pt1, pt2, t, closestPoint2);\n          if (dist2Point < dist2Line1) {\n            outObj.dist2 = dist2Point;\n            closest = pt1;\n          } else {\n            outObj.dist2 = dist2Line1;\n            closest = closestPoint1;\n          }\n          if (dist2Line2 < outObj.dist2) {\n            outObj.dist2 = dist2Line2;\n            closest = closestPoint2;\n          }\n          for (i = 0; i < 3; i++) {\n            closestPoint[i] = closest[i];\n          }\n        } else if (weights[1] < 0.0 && weights[0] < 0.0) {\n          dist2Point = distance2BetweenPoints(x, pt2);\n          dist2Line1 = vtkLine.distanceToLine(x, pt2, pt3, t, closestPoint1);\n          dist2Line2 = vtkLine.distanceToLine(x, pt1, pt2, t, closestPoint2);\n          if (dist2Point < dist2Line1) {\n            outObj.dist2 = dist2Point;\n            closest = pt2;\n          } else {\n            outObj.dist2 = dist2Line1;\n            closest = closestPoint1;\n          }\n          if (dist2Line2 < outObj.dist2) {\n            outObj.dist2 = dist2Line2;\n            closest = closestPoint2;\n          }\n          for (i = 0; i < 3; i++) {\n            closestPoint[i] = closest[i];\n          }\n        } else if (weights[0] < 0.0) {\n          var lineDistance = vtkLine.distanceToLine(x, pt1, pt2, closestPoint);\n          outObj.dist2 = lineDistance.distance;\n        } else if (weights[1] < 0.0) {\n          var _lineDistance = vtkLine.distanceToLine(x, pt2, pt3, closestPoint);\n          outObj.dist2 = _lineDistance.distance;\n        } else if (weights[2] < 0.0) {\n          var _lineDistance2 = vtkLine.distanceToLine(x, pt1, pt3, closestPoint);\n          outObj.dist2 = _lineDistance2.distance;\n        }\n      }\n      outObj.evaluation = 0;\n    }\n    return outObj;\n  };\n  publicAPI.evaluateLocation = function (pcoords, x, weights) {\n    var p0 = [];\n    var p1 = [];\n    var p2 = [];\n    model.points.getPoint(0, p0);\n    model.points.getPoint(1, p1);\n    model.points.getPoint(2, p2);\n    var u3 = 1.0 - pcoords[0] - pcoords[1];\n    for (var i = 0; i < 3; i++) {\n      x[i] = p0[i] * u3 + p1[i] * pcoords[0] + p2[i] * pcoords[1];\n    }\n    weights[0] = u3;\n    weights[1] = pcoords[0];\n    weights[2] = pcoords[1];\n  };\n  publicAPI.getParametricDistance = function (pcoords) {\n    var pDist;\n    var pDistMax = 0.0;\n    var pc = [];\n    pc[0] = pcoords[0];\n    pc[1] = pcoords[1];\n    pc[2] = 1.0 - pcoords[0] - pcoords[1];\n    for (var i = 0; i < 3; i++) {\n      if (pc[i] < 0.0) {\n        pDist = -pc[i];\n      } else if (pc[i] > 1.0) {\n        pDist = pc[i] - 1.0;\n      } else {\n        // inside the cell in the parametric direction\n        pDist = 0.0;\n      }\n      if (pDist > pDistMax) {\n        pDistMax = pDist;\n      }\n    }\n    return pDistMax;\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nvar DEFAULT_VALUES = {}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n  vtkCell.extend(publicAPI, model, initialValues);\n  vtkTriangle(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = macro.newInstance(extend, 'vtkTriangle'); // ----------------------------------------------------------------------------\n\nvar vtkTriangle$1 = _objectSpread({\n  newInstance: newInstance,\n  extend: extend\n}, STATIC);\nexport { STATIC, vtkTriangle$1 as default, extend, newInstance };","map":{"version":3,"names":["_defineProperty","macro","vtkCell","d","dot","j","cross","l","normalize","m","multiplyAccumulate","e","distance2BetweenPoints","o","determinant2x2","vtkLine","vtkPlane","ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","getOwnPropertyDescriptors","defineProperties","defineProperty","computeNormalDirection","v1","v2","v3","n","ax","ay","az","bx","by","bz","computeNormal","Math","sqrt","intersectWithTriangle","p1","q1","r1","p2","q2","r2","tolerance","undefined","coplanar","pt1","pt2","surfaceId","n1","n2","s1","s2","dist1","intersect","dist2","abs","pts1","pts2","n1n2","a","b","p","v","index1","index2","t1","t2","ts1","ts2","id1","id2","val1","intersectWithLine","intersection","t","x","val2","t12","t22","Number","isNaN","t11","t21","tt1","tt2","STATIC","vtkTriangle","publicAPI","model","classHierarchy","getCellDimension","tol","pcoords","outObj","subId","MAX_VALUE","betweenPoints","closestPoint","tol2","pt3","points","getPoint","weights","plane","inside","evaluatePosition","evaluation","dist2Pt1Pt2","dist2Pt2Pt3","dist2Pt3Pt1","line","newInstance","getPoints","setPoint","intersectLine","pt3Pt1","pt3Pt2","pt3X","fabsn","rhs","c1","c2","det","idx","indices","dist2Point","dist2Line1","dist2Line2","closest","closestPoint1","closestPoint2","cp","generalizedProjectPoint","maxComponent","distanceToLine","lineDistance","distance","_lineDistance","_lineDistance2","evaluateLocation","p0","u3","getParametricDistance","pDist","pDistMax","pc","DEFAULT_VALUES","extend","initialValues","assign","vtkTriangle$1","default"],"sources":["/home/rakshith/Documents/RemoteRendering/vtk-js-react-app/node_modules/@kitware/vtk.js/Common/DataModel/Triangle.js"],"sourcesContent":["import _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport macro from '../../macros.js';\nimport vtkCell from './Cell.js';\nimport { d as dot, j as cross, l as normalize, m as multiplyAccumulate, e as distance2BetweenPoints, o as determinant2x2 } from '../Core/Math/index.js';\nimport vtkLine from './Line.js';\nimport vtkPlane from './Plane.js';\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n// Global methods\n// ----------------------------------------------------------------------------\n\nfunction computeNormalDirection(v1, v2, v3, n) {\n  // order is important!!! maintain consistency with triangle vertex order\n  var ax = v3[0] - v2[0];\n  var ay = v3[1] - v2[1];\n  var az = v3[2] - v2[2];\n  var bx = v1[0] - v2[0];\n  var by = v1[1] - v2[1];\n  var bz = v1[2] - v2[2];\n  n[0] = ay * bz - az * by;\n  n[1] = az * bx - ax * bz;\n  n[2] = ax * by - ay * bx;\n}\n\nfunction computeNormal(v1, v2, v3, n) {\n  computeNormalDirection(v1, v2, v3, n);\n  var length = Math.sqrt(n[0] * n[0] + n[1] * n[1] + n[2] * n[2]);\n\n  if (length !== 0.0) {\n    n[0] /= length;\n    n[1] /= length;\n    n[2] /= length;\n  }\n}\n\nfunction intersectWithTriangle(p1, q1, r1, p2, q2, r2) {\n  var tolerance = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 1e-6;\n  var coplanar = false;\n  var pt1 = [];\n  var pt2 = [];\n  var surfaceId = [];\n  var n1 = [];\n  var n2 = []; // Compute supporting plane normals.\n\n  computeNormal(p1, q1, r1, n1);\n  computeNormal(p2, q2, r2, n2);\n  var s1 = -dot(n1, p1);\n  var s2 = -dot(n2, p2); // Compute signed distances of points p1, q1, r1 from supporting\n  // plane of second triangle.\n\n  var dist1 = [dot(n2, p1) + s2, dot(n2, q1) + s2, dot(n2, r1) + s2]; // If signs of all points are the same, all the points lie on the\n  // same side of the supporting plane, and we can exit early.\n\n  if (dist1[0] * dist1[1] > tolerance && dist1[0] * dist1[2] > tolerance) {\n    // vtkDebugMacro(<<\"Same side supporting plane 1!\");\n    return {\n      intersect: false,\n      coplanar: coplanar,\n      pt1: pt1,\n      pt2: pt2,\n      surfaceId: surfaceId\n    };\n  } // Do the same for p2, q2, r2 and supporting plane of first\n  // triangle.\n\n\n  var dist2 = [dot(n1, p2) + s1, dot(n1, q2) + s1, dot(n1, r2) + s1]; // If signs of all points are the same, all the points lie on the\n  // same side of the supporting plane, and we can exit early.\n\n  if (dist2[0] * dist2[1] > tolerance && dist2[0] * dist2[2] > tolerance) {\n    // vtkDebugMacro(<<\"Same side supporting plane 2!\");\n    return {\n      intersect: false,\n      coplanar: coplanar,\n      pt1: pt1,\n      pt2: pt2,\n      surfaceId: surfaceId\n    };\n  } // Check for coplanarity of the supporting planes.\n\n\n  if (Math.abs(n1[0] - n2[0]) < 1e-9 && Math.abs(n1[1] - n2[1]) < 1e-9 && Math.abs(n1[2] - n2[2]) < 1e-9 && Math.abs(s1 - s2) < 1e-9) {\n    coplanar = true; // vtkDebugMacro(<<\"Coplanar!\");\n\n    return {\n      intersect: false,\n      coplanar: coplanar,\n      pt1: pt1,\n      pt2: pt2,\n      surfaceId: surfaceId\n    };\n  } // There are more efficient ways to find the intersection line (if\n  // it exists), but this is clear enough.\n\n\n  var pts1 = [p1, q1, r1];\n  var pts2 = [p2, q2, r2]; // Find line of intersection (L = p + t*v) between two planes.\n\n  var n1n2 = dot(n1, n2);\n  var a = (s1 - s2 * n1n2) / (n1n2 * n1n2 - 1.0);\n  var b = (s2 - s1 * n1n2) / (n1n2 * n1n2 - 1.0);\n  var p = [a * n1[0] + b * n2[0], a * n1[1] + b * n2[1], a * n1[2] + b * n2[2]];\n  var v = cross(n1, n2, []);\n  normalize(v);\n  var index1 = 0;\n  var index2 = 0;\n  var t1 = [];\n  var t2 = [];\n  var ts1 = 50;\n  var ts2 = 50;\n\n  for (var i = 0; i < 3; i++) {\n    var id1 = i;\n    var id2 = (i + 1) % 3; // Find t coordinate on line of intersection between two planes.\n\n    var val1 = vtkPlane.intersectWithLine(pts1[id1], pts1[id2], p2, n2);\n\n    if (val1.intersection && val1.t > 0 - tolerance && val1.t < 1 + tolerance) {\n      if (val1.t < 1 + tolerance && val1.t > 1 - tolerance) {\n        ts1 = index1;\n      }\n\n      t1[index1++] = dot(val1.x, v) - dot(p, v);\n    }\n\n    var val2 = vtkPlane.intersectWithLine(pts2[id1], pts2[id2], p1, n1);\n\n    if (val2.intersection && val2.t > 0 - tolerance && val2.t < 1 + tolerance) {\n      if (val2.t < 1 + tolerance && val2.t > 1 - tolerance) {\n        ts2 = index2;\n      }\n\n      t2[index2++] = dot(val2.x, v) - dot(p, v);\n    }\n  } // If the value of the index is greater than 2, the intersecting point\n  // actually is intersected by all three edges. In this case, set the two\n  // edges to the two edges where the intersecting point is not the end point\n\n\n  if (index1 > 2) {\n    index1--; // swap\n\n    var t12 = t1[2];\n    t1[2] = t1[ts1];\n    t1[ts1] = t12;\n  }\n\n  if (index2 > 2) {\n    index2--;\n    var t22 = t2[2];\n    t2[2] = t2[ts2];\n    t2[ts2] = t22;\n  } // Check if only one edge or all edges intersect the supporting\n  // planes intersection.\n\n\n  if (index1 !== 2 || index2 !== 2) {\n    // vtkDebugMacro(<<\"Only one edge intersecting!\");\n    return {\n      intersect: false,\n      coplanar: coplanar,\n      pt1: pt1,\n      pt2: pt2,\n      surfaceId: surfaceId\n    };\n  } // Check for NaNs\n\n\n  if (Number.isNaN(t1[0]) || Number.isNaN(t1[1]) || Number.isNaN(t2[0]) || Number.isNaN(t2[1])) {\n    // vtkWarningMacro(<<\"NaNs!\");\n    return {\n      intersect: false,\n      coplanar: coplanar,\n      pt1: pt1,\n      pt2: pt2,\n      surfaceId: surfaceId\n    };\n  }\n\n  if (t1[0] > t1[1]) {\n    // swap\n    var t11 = t1[1];\n    t1[1] = t1[0];\n    t1[0] = t11;\n  }\n\n  if (t2[0] > t2[1]) {\n    // swap\n    var t21 = t2[1];\n    t2[1] = t2[0];\n    t2[0] = t21;\n  } // Handle the different interval configuration cases.\n\n\n  var tt1;\n  var tt2;\n\n  if (t1[1] < t2[0] || t2[1] < t1[0]) {\n    // vtkDebugMacro(<<\"No Overlap!\");\n    return {\n      intersect: false,\n      coplanar: coplanar,\n      pt1: pt1,\n      pt2: pt2,\n      surfaceId: surfaceId\n    }; // No overlap\n  }\n\n  if (t1[0] < t2[0]) {\n    if (t1[1] < t2[1]) {\n      // First point on surface 2, second point on surface 1\n      surfaceId[0] = 2;\n      surfaceId[1] = 1;\n      tt1 = t2[0];\n      tt2 = t1[1];\n    } else {\n      // Both points belong to lines on surface 2\n      surfaceId[0] = 2;\n      surfaceId[1] = 2;\n      tt1 = t2[0];\n      tt2 = t2[1];\n    }\n  } // t1[0] >= t2[0]\n  else if (t1[1] < t2[1]) {\n    // Both points belong to lines on surface 1\n    surfaceId[0] = 1;\n    surfaceId[1] = 1;\n    tt1 = t1[0];\n    tt2 = t1[1];\n  } else {\n    // First point on surface 1, second point on surface 2\n    surfaceId[0] = 1;\n    surfaceId[1] = 2;\n    tt1 = t1[0];\n    tt2 = t2[1];\n  } // Create actual intersection points.\n\n\n  multiplyAccumulate(p, v, tt1, pt1);\n  multiplyAccumulate(p, v, tt2, pt2);\n  return {\n    intersect: true,\n    coplanar: coplanar,\n    pt1: pt1,\n    pt2: pt2,\n    surfaceId: surfaceId\n  };\n} // ----------------------------------------------------------------------------\n// Static API\n// ----------------------------------------------------------------------------\n\n\nvar STATIC = {\n  computeNormalDirection: computeNormalDirection,\n  computeNormal: computeNormal,\n  intersectWithTriangle: intersectWithTriangle\n}; // ----------------------------------------------------------------------------\n// vtkTriangle methods\n// ----------------------------------------------------------------------------\n\nfunction vtkTriangle(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkTriangle');\n\n  publicAPI.getCellDimension = function () {\n    return 2;\n  };\n\n  publicAPI.intersectWithLine = function (p1, p2, tol, x, pcoords) {\n    var outObj = {\n      subId: 0,\n      t: Number.MAX_VALUE,\n      intersect: 0,\n      betweenPoints: false\n    };\n    pcoords[2] = 0.0;\n    var closestPoint = [];\n    var tol2 = tol * tol; // Get normal for triangle\n\n    var pt1 = [];\n    var pt2 = [];\n    var pt3 = [];\n    model.points.getPoint(0, pt1);\n    model.points.getPoint(1, pt2);\n    model.points.getPoint(2, pt3);\n    var n = [];\n    var weights = [];\n    computeNormal(pt1, pt2, pt3, n);\n\n    if (n[0] !== 0 || n[1] !== 0 || n[2] !== 0) {\n      // Intersect plane of triangle with line\n      var plane = vtkPlane.intersectWithLine(p1, p2, pt1, n);\n      outObj.betweenPoints = plane.betweenPoints;\n      outObj.t = plane.t;\n      x[0] = plane.x[0];\n      x[1] = plane.x[1];\n      x[2] = plane.x[2];\n\n      if (!plane.intersection) {\n        pcoords[0] = 0.0;\n        pcoords[1] = 0.0;\n        outObj.intersect = 0;\n        return outObj;\n      } // Evaluate position\n\n\n      var inside = publicAPI.evaluatePosition(x, closestPoint, pcoords, weights);\n\n      if (inside.evaluation >= 0) {\n        if (inside.dist2 <= tol2) {\n          outObj.intersect = 1;\n          return outObj;\n        }\n\n        outObj.intersect = inside.evaluation;\n        return outObj;\n      }\n    } // Normals are null, so the triangle is degenerated and\n    // we still need to check intersection between line and\n    // the longest edge.\n\n\n    var dist2Pt1Pt2 = distance2BetweenPoints(pt1, pt2);\n    var dist2Pt2Pt3 = distance2BetweenPoints(pt2, pt3);\n    var dist2Pt3Pt1 = distance2BetweenPoints(pt3, pt1);\n\n    if (!model.line) {\n      model.line = vtkLine.newInstance();\n    }\n\n    if (dist2Pt1Pt2 > dist2Pt2Pt3 && dist2Pt1Pt2 > dist2Pt3Pt1) {\n      model.line.getPoints().setPoint(0, pt1);\n      model.line.getPoints().setPoint(1, pt2);\n    } else if (dist2Pt2Pt3 > dist2Pt3Pt1 && dist2Pt2Pt3 > dist2Pt1Pt2) {\n      model.line.getPoints().setPoint(0, pt2);\n      model.line.getPoints().setPoint(1, pt3);\n    } else {\n      model.line.getPoints().setPoint(0, pt3);\n      model.line.getPoints().setPoint(1, pt1);\n    }\n\n    var intersectLine = model.line.intersectWithLine(p1, p2, tol, x, pcoords);\n    outObj.betweenPoints = intersectLine.betweenPoints;\n    outObj.t = intersectLine.t;\n\n    if (intersectLine.intersect) {\n      var pt3Pt1 = [];\n      var pt3Pt2 = [];\n      var pt3X = []; // Compute r and s manually, using dot and norm.\n\n      for (var i = 0; i < 3; i++) {\n        pt3Pt1[i] = pt1[i] - pt3[i];\n        pt3Pt2[i] = pt2[i] - pt3[i];\n        pt3X[i] = x[i] - pt3[i];\n      }\n\n      pcoords[0] = dot(pt3X, pt3Pt1) / dist2Pt3Pt1;\n      pcoords[1] = dot(pt3X, pt3Pt2) / dist2Pt2Pt3;\n      outObj.intersect = 1;\n      return outObj;\n    }\n\n    pcoords[0] = 0.0;\n    pcoords[1] = 0.0;\n    outObj.intersect = 0;\n    return outObj;\n  };\n\n  publicAPI.evaluatePosition = function (x, closestPoint, pcoords, weights) {\n    // will return obj\n    var outObj = {\n      subId: 0,\n      dist2: 0,\n      evaluation: -1\n    };\n    var i;\n    var j;\n    var pt1 = [];\n    var pt2 = [];\n    var pt3 = [];\n    var n = [];\n    var fabsn;\n    var rhs = [];\n    var c1 = [];\n    var c2 = [];\n    var det = 0;\n    var idx = 0;\n    var indices = [];\n    var dist2Point;\n    var dist2Line1;\n    var dist2Line2;\n    var closest = [];\n    var closestPoint1 = [];\n    var closestPoint2 = [];\n    var cp = [];\n    outObj.subId = 0;\n    pcoords[2] = 0.0; // Get normal for triangle, only the normal direction is needed, i.e. the\n    // normal need not be normalized (unit length)\n    //\n\n    model.points.getPoint(1, pt1);\n    model.points.getPoint(2, pt2);\n    model.points.getPoint(0, pt3);\n    computeNormalDirection(pt1, pt2, pt3, n); // Project point to plane\n\n    vtkPlane.generalizedProjectPoint(x, pt1, n, cp); // Construct matrices.  Since we have over determined system, need to find\n    // which 2 out of 3 equations to use to develop equations. (Any 2 should\n    // work since we've projected point to plane.)\n\n    var maxComponent = 0.0;\n\n    for (i = 0; i < 3; i++) {\n      // trying to avoid an expensive call to fabs()\n      if (n[i] < 0) {\n        fabsn = -n[i];\n      } else {\n        fabsn = n[i];\n      }\n\n      if (fabsn > maxComponent) {\n        maxComponent = fabsn;\n        idx = i;\n      }\n    }\n\n    for (j = 0, i = 0; i < 3; i++) {\n      if (i !== idx) {\n        indices[j++] = i;\n      }\n    }\n\n    for (i = 0; i < 2; i++) {\n      rhs[i] = cp[indices[i]] - pt3[indices[i]];\n      c1[i] = pt1[indices[i]] - pt3[indices[i]];\n      c2[i] = pt2[indices[i]] - pt3[indices[i]];\n    }\n\n    det = determinant2x2(c1, c2);\n\n    if (det === 0.0) {\n      pcoords[0] = 0.0;\n      pcoords[1] = 0.0;\n      outObj.evaluation = -1;\n      return outObj;\n    }\n\n    pcoords[0] = determinant2x2(rhs, c2) / det;\n    pcoords[1] = determinant2x2(c1, rhs) / det; // Okay, now find closest point to element\n\n    weights[0] = 1 - (pcoords[0] + pcoords[1]);\n    weights[1] = pcoords[0];\n    weights[2] = pcoords[1];\n\n    if (weights[0] >= 0.0 && weights[0] <= 1.0 && weights[1] >= 0.0 && weights[1] <= 1.0 && weights[2] >= 0.0 && weights[2] <= 1.0) {\n      // projection distance\n      if (closestPoint) {\n        outObj.dist2 = distance2BetweenPoints(cp, x);\n        closestPoint[0] = cp[0];\n        closestPoint[1] = cp[1];\n        closestPoint[2] = cp[2];\n      }\n\n      outObj.evaluation = 1;\n    } else {\n      var t;\n\n      if (closestPoint) {\n        if (weights[1] < 0.0 && weights[2] < 0.0) {\n          dist2Point = distance2BetweenPoints(x, pt3);\n          dist2Line1 = vtkLine.distanceToLine(x, pt1, pt3, t, closestPoint1);\n          dist2Line2 = vtkLine.distanceToLine(x, pt3, pt2, t, closestPoint2);\n\n          if (dist2Point < dist2Line1) {\n            outObj.dist2 = dist2Point;\n            closest = pt3;\n          } else {\n            outObj.dist2 = dist2Line1;\n            closest = closestPoint1;\n          }\n\n          if (dist2Line2 < outObj.dist2) {\n            outObj.dist2 = dist2Line2;\n            closest = closestPoint2;\n          }\n\n          for (i = 0; i < 3; i++) {\n            closestPoint[i] = closest[i];\n          }\n        } else if (weights[2] < 0.0 && weights[0] < 0.0) {\n          dist2Point = distance2BetweenPoints(x, pt1);\n          dist2Line1 = vtkLine.distanceToLine(x, pt1, pt3, t, closestPoint1);\n          dist2Line2 = vtkLine.distanceToLine(x, pt1, pt2, t, closestPoint2);\n\n          if (dist2Point < dist2Line1) {\n            outObj.dist2 = dist2Point;\n            closest = pt1;\n          } else {\n            outObj.dist2 = dist2Line1;\n            closest = closestPoint1;\n          }\n\n          if (dist2Line2 < outObj.dist2) {\n            outObj.dist2 = dist2Line2;\n            closest = closestPoint2;\n          }\n\n          for (i = 0; i < 3; i++) {\n            closestPoint[i] = closest[i];\n          }\n        } else if (weights[1] < 0.0 && weights[0] < 0.0) {\n          dist2Point = distance2BetweenPoints(x, pt2);\n          dist2Line1 = vtkLine.distanceToLine(x, pt2, pt3, t, closestPoint1);\n          dist2Line2 = vtkLine.distanceToLine(x, pt1, pt2, t, closestPoint2);\n\n          if (dist2Point < dist2Line1) {\n            outObj.dist2 = dist2Point;\n            closest = pt2;\n          } else {\n            outObj.dist2 = dist2Line1;\n            closest = closestPoint1;\n          }\n\n          if (dist2Line2 < outObj.dist2) {\n            outObj.dist2 = dist2Line2;\n            closest = closestPoint2;\n          }\n\n          for (i = 0; i < 3; i++) {\n            closestPoint[i] = closest[i];\n          }\n        } else if (weights[0] < 0.0) {\n          var lineDistance = vtkLine.distanceToLine(x, pt1, pt2, closestPoint);\n          outObj.dist2 = lineDistance.distance;\n        } else if (weights[1] < 0.0) {\n          var _lineDistance = vtkLine.distanceToLine(x, pt2, pt3, closestPoint);\n\n          outObj.dist2 = _lineDistance.distance;\n        } else if (weights[2] < 0.0) {\n          var _lineDistance2 = vtkLine.distanceToLine(x, pt1, pt3, closestPoint);\n\n          outObj.dist2 = _lineDistance2.distance;\n        }\n      }\n\n      outObj.evaluation = 0;\n    }\n\n    return outObj;\n  };\n\n  publicAPI.evaluateLocation = function (pcoords, x, weights) {\n    var p0 = [];\n    var p1 = [];\n    var p2 = [];\n    model.points.getPoint(0, p0);\n    model.points.getPoint(1, p1);\n    model.points.getPoint(2, p2);\n    var u3 = 1.0 - pcoords[0] - pcoords[1];\n\n    for (var i = 0; i < 3; i++) {\n      x[i] = p0[i] * u3 + p1[i] * pcoords[0] + p2[i] * pcoords[1];\n    }\n\n    weights[0] = u3;\n    weights[1] = pcoords[0];\n    weights[2] = pcoords[1];\n  };\n\n  publicAPI.getParametricDistance = function (pcoords) {\n    var pDist;\n    var pDistMax = 0.0;\n    var pc = [];\n    pc[0] = pcoords[0];\n    pc[1] = pcoords[1];\n    pc[2] = 1.0 - pcoords[0] - pcoords[1];\n\n    for (var i = 0; i < 3; i++) {\n      if (pc[i] < 0.0) {\n        pDist = -pc[i];\n      } else if (pc[i] > 1.0) {\n        pDist = pc[i] - 1.0;\n      } else {\n        // inside the cell in the parametric direction\n        pDist = 0.0;\n      }\n\n      if (pDist > pDistMax) {\n        pDistMax = pDist;\n      }\n    }\n\n    return pDistMax;\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\n\nvar DEFAULT_VALUES = {}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n  vtkCell.extend(publicAPI, model, initialValues);\n  vtkTriangle(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = macro.newInstance(extend, 'vtkTriangle'); // ----------------------------------------------------------------------------\n\nvar vtkTriangle$1 = _objectSpread({\n  newInstance: newInstance,\n  extend: extend\n}, STATIC);\n\nexport { STATIC, vtkTriangle$1 as default, extend, newInstance };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}