{"ast":null,"code":"import { mat4 } from 'gl-matrix';\nimport Constants from '../Core/ImageMapper/Constants.js';\nimport { newInstance as newInstance$1, setGet, obj, vtkErrorMacro as vtkErrorMacro$1 } from '../../macros.js';\nimport vtkDataArray from '../../Common/Core/DataArray.js';\nimport { VtkDataTypes } from '../../Common/Core/DataArray/Constants.js';\nimport vtkHelper from './Helper.js';\nimport { u as uninitializeBounds } from '../../Common/Core/Math/index.js';\nimport vtkOpenGLTexture from './Texture.js';\nimport vtkShaderProgram from './ShaderProgram.js';\nimport vtkViewNode from '../SceneGraph/ViewNode.js';\nimport { Representation } from '../Core/Property/Constants.js';\nimport { Filter, Wrap } from './Texture/Constants.js';\nimport { InterpolationType } from '../Core/ImageProperty/Constants.js';\nimport { v as vtkPolyDataVS } from './glsl/vtkPolyDataVS.glsl.js';\nimport { v as vtkPolyDataFS } from './glsl/vtkPolyDataFS.glsl.js';\nimport vtkReplacementShaderMapper from './ReplacementShaderMapper.js';\nimport { registerOverride } from './ViewNodeFactory.js';\nvar vtkErrorMacro = vtkErrorMacro$1;\nvar SlicingMode = Constants.SlicingMode; // ----------------------------------------------------------------------------\n// helper methods\n// ----------------------------------------------------------------------------\n\nfunction computeFnToString(property, fn, numberOfComponents) {\n  var pwfun = fn.apply(property);\n  if (pwfun) {\n    var iComps = property.getIndependentComponents();\n    return \"\".concat(property.getMTime(), \"-\").concat(iComps, \"-\").concat(numberOfComponents);\n  }\n  return '0';\n} // ----------------------------------------------------------------------------\n// vtkOpenGLImageMapper methods\n// ----------------------------------------------------------------------------\n\nfunction vtkOpenGLImageMapper(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkOpenGLImageMapper');\n  publicAPI.buildPass = function (prepass) {\n    if (prepass) {\n      model.currentRenderPass = null;\n      model.openGLImageSlice = publicAPI.getFirstAncestorOfType('vtkOpenGLImageSlice');\n      model._openGLRenderer = publicAPI.getFirstAncestorOfType('vtkOpenGLRenderer');\n      model._openGLRenderWindow = model._openGLRenderer.getParent();\n      model.context = model._openGLRenderWindow.getContext();\n      model.tris.setOpenGLRenderWindow(model._openGLRenderWindow);\n      model.openGLTexture.setOpenGLRenderWindow(model._openGLRenderWindow);\n      model.colorTexture.setOpenGLRenderWindow(model._openGLRenderWindow);\n      model.pwfTexture.setOpenGLRenderWindow(model._openGLRenderWindow);\n      var ren = model._openGLRenderer.getRenderable();\n      model.openGLCamera = model._openGLRenderer.getViewNodeFor(ren.getActiveCamera()); // is slice set by the camera\n\n      if (model.renderable.isA('vtkImageMapper') && model.renderable.getSliceAtFocalPoint()) {\n        model.renderable.setSliceFromCamera(ren.getActiveCamera());\n      }\n    }\n  };\n  publicAPI.translucentPass = function (prepass, renderPass) {\n    if (prepass) {\n      model.currentRenderPass = renderPass;\n      publicAPI.render();\n    }\n  };\n  publicAPI.zBufferPass = function (prepass) {\n    if (prepass) {\n      model.haveSeenDepthRequest = true;\n      model.renderDepth = true;\n      publicAPI.render();\n      model.renderDepth = false;\n    }\n  };\n  publicAPI.opaqueZBufferPass = function (prepass) {\n    return publicAPI.zBufferPass(prepass);\n  };\n  publicAPI.opaquePass = function (prepass) {\n    if (prepass) {\n      publicAPI.render();\n    }\n  };\n  publicAPI.getCoincidentParameters = function (ren, actor) {\n    if (model.renderable.getResolveCoincidentTopology()) {\n      return model.renderable.getCoincidentTopologyPolygonOffsetParameters();\n    }\n    return null;\n  }; // Renders myself\n\n  publicAPI.render = function () {\n    var actor = model.openGLImageSlice.getRenderable();\n    var ren = model._openGLRenderer.getRenderable();\n    publicAPI.renderPiece(ren, actor);\n  };\n  publicAPI.getShaderTemplate = function (shaders, ren, actor) {\n    shaders.Vertex = vtkPolyDataVS;\n    shaders.Fragment = vtkPolyDataFS;\n    shaders.Geometry = '';\n  };\n  publicAPI.replaceShaderValues = function (shaders, ren, actor) {\n    var VSSource = shaders.Vertex;\n    var FSSource = shaders.Fragment;\n    VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::Camera::Dec', ['uniform mat4 MCPCMatrix;']).result;\n    VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::PositionVC::Impl', ['  gl_Position = MCPCMatrix * vertexMC;']).result;\n    VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::TCoord::Impl', 'tcoordVCVSOutput = tcoordMC;').result;\n    VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::TCoord::Dec', 'attribute vec2 tcoordMC; varying vec2 tcoordVCVSOutput;').result;\n    var tNumComp = model.openGLTexture.getComponents();\n    var iComps = actor.getProperty().getIndependentComponents();\n    var tcoordDec = ['varying vec2 tcoordVCVSOutput;',\n    // color shift and scale\n    'uniform float cshift0;', 'uniform float cscale0;',\n    // pwf shift and scale\n    'uniform float pwfshift0;', 'uniform float pwfscale0;', 'uniform sampler2D texture1;', 'uniform sampler2D colorTexture1;', 'uniform sampler2D pwfTexture1;', 'uniform float opacity;'];\n    if (iComps) {\n      for (var comp = 1; comp < tNumComp; comp++) {\n        tcoordDec = tcoordDec.concat([\n        // color shift and scale\n        \"uniform float cshift\".concat(comp, \";\"), \"uniform float cscale\".concat(comp, \";\"),\n        // weighting shift and scale\n        \"uniform float pwfshift\".concat(comp, \";\"), \"uniform float pwfscale\".concat(comp, \";\")]);\n      } // the heights defined below are the locations\n      // for the up to four components of the tfuns\n      // the tfuns have a height of 2XnumComps pixels so the\n      // values are computed to hit the middle of the two rows\n      // for that component\n\n      switch (tNumComp) {\n        case 1:\n          tcoordDec = tcoordDec.concat(['uniform float mix0;', '#define height0 0.5']);\n          break;\n        case 2:\n          tcoordDec = tcoordDec.concat(['uniform float mix0;', 'uniform float mix1;', '#define height0 0.25', '#define height1 0.75']);\n          break;\n        case 3:\n          tcoordDec = tcoordDec.concat(['uniform float mix0;', 'uniform float mix1;', 'uniform float mix2;', '#define height0 0.17', '#define height1 0.5', '#define height2 0.83']);\n          break;\n        case 4:\n          tcoordDec = tcoordDec.concat(['uniform float mix0;', 'uniform float mix1;', 'uniform float mix2;', 'uniform float mix3;', '#define height0 0.125', '#define height1 0.375', '#define height2 0.625', '#define height3 0.875']);\n          break;\n        default:\n          vtkErrorMacro('Unsupported number of independent coordinates.');\n      }\n    }\n    FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::TCoord::Dec', tcoordDec).result;\n    if (iComps) {\n      var rgba = ['r', 'g', 'b', 'a'];\n      var tcoordImpl = ['vec4 tvalue = texture2D(texture1, tcoordVCVSOutput);'];\n      for (var _comp = 0; _comp < tNumComp; _comp++) {\n        tcoordImpl = tcoordImpl.concat([\"vec3 tcolor\".concat(_comp, \" = mix\").concat(_comp, \" * texture2D(colorTexture1, vec2(tvalue.\").concat(rgba[_comp], \" * cscale\").concat(_comp, \" + cshift\").concat(_comp, \", height\").concat(_comp, \")).rgb;\"), \"float compWeight\".concat(_comp, \" = mix\").concat(_comp, \" * texture2D(pwfTexture1, vec2(tvalue.\").concat(rgba[_comp], \" * pwfscale\").concat(_comp, \" + pwfshift\").concat(_comp, \", height\").concat(_comp, \")).r;\")]);\n      }\n      switch (tNumComp) {\n        case 1:\n          tcoordImpl = tcoordImpl.concat(['gl_FragData[0] = vec4(tcolor0.rgb, opacity);']);\n          break;\n        case 2:\n          tcoordImpl = tcoordImpl.concat(['float weightSum = compWeight0 + compWeight1;', 'gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum))), opacity);']);\n          break;\n        case 3:\n          tcoordImpl = tcoordImpl.concat(['float weightSum = compWeight0 + compWeight1 + compWeight2;', 'gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum))), opacity);']);\n          break;\n        case 4:\n          tcoordImpl = tcoordImpl.concat(['float weightSum = compWeight0 + compWeight1 + compWeight2 + compWeight3;', 'gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum)) + (tcolor3.rgb * (compWeight3 / weightSum))), opacity);']);\n          break;\n        default:\n          vtkErrorMacro('Unsupported number of independent coordinates.');\n      }\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::TCoord::Impl', tcoordImpl).result;\n    } else {\n      // dependent components\n      switch (tNumComp) {\n        case 1:\n          FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::TCoord::Impl', ['float intensity = texture2D(texture1, tcoordVCVSOutput).r;', 'vec3 tcolor = texture2D(colorTexture1, vec2(intensity * cscale0 + cshift0, 0.5)).rgb;', 'float scalarOpacity = texture2D(pwfTexture1, vec2(intensity * pwfscale0 + pwfshift0, 0.5)).r;', 'gl_FragData[0] = vec4(tcolor, scalarOpacity * opacity);']).result;\n          break;\n        case 2:\n          FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::TCoord::Impl', ['vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);', 'float intensity = tcolor.r*cscale0 + cshift0;', 'gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(intensity, 0.5)).rgb, pwfscale0*tcolor.g + pwfshift0);']).result;\n          break;\n        case 3:\n          FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::TCoord::Impl', ['vec4 tcolor = cscale0*texture2D(texture1, tcoordVCVSOutput.st) + cshift0;', 'gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,', '  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,', '  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, opacity);']).result;\n          break;\n        default:\n          FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::TCoord::Impl', ['vec4 tcolor = cscale0*texture2D(texture1, tcoordVCVSOutput.st) + cshift0;', 'gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,', '  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,', '  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, tcolor.a);']).result;\n      }\n    }\n    if (model.haveSeenDepthRequest) {\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::ZBuffer::Dec', 'uniform int depthRequest;').result;\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::ZBuffer::Impl', ['if (depthRequest == 1) {', 'float iz = floor(gl_FragCoord.z*65535.0 + 0.1);', 'float rf = floor(iz/256.0)/255.0;', 'float gf = mod(iz,256.0)/255.0;', 'gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }']).result;\n    }\n    shaders.Vertex = VSSource;\n    shaders.Fragment = FSSource;\n    publicAPI.replaceShaderClip(shaders, ren, actor);\n    publicAPI.replaceShaderCoincidentOffset(shaders, ren, actor);\n  };\n  publicAPI.replaceShaderClip = function (shaders, ren, actor) {\n    var VSSource = shaders.Vertex;\n    var FSSource = shaders.Fragment;\n    if (model.renderable.getNumberOfClippingPlanes()) {\n      var numClipPlanes = model.renderable.getNumberOfClippingPlanes();\n      if (numClipPlanes > 6) {\n        vtkErrorMacro$1('OpenGL has a limit of 6 clipping planes');\n        numClipPlanes = 6;\n      }\n      VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::Clip::Dec', ['uniform int numClipPlanes;', 'uniform vec4 clipPlanes[6];', 'varying float clipDistancesVSOutput[6];']).result;\n      VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::Clip::Impl', ['for (int planeNum = 0; planeNum < 6; planeNum++)', '    {', '    if (planeNum >= numClipPlanes)', '        {', '        break;', '        }', '    clipDistancesVSOutput[planeNum] = dot(clipPlanes[planeNum], vertexMC);', '    }']).result;\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Clip::Dec', ['uniform int numClipPlanes;', 'varying float clipDistancesVSOutput[6];']).result;\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Clip::Impl', ['for (int planeNum = 0; planeNum < 6; planeNum++)', '    {', '    if (planeNum >= numClipPlanes)', '        {', '        break;', '        }', '    if (clipDistancesVSOutput[planeNum] < 0.0) discard;', '    }']).result;\n    }\n    shaders.Vertex = VSSource;\n    shaders.Fragment = FSSource;\n  };\n  publicAPI.getNeedToRebuildShaders = function (cellBO, ren, actor) {\n    // has something changed that would require us to recreate the shader?\n    // candidates are\n    // property modified (representation interpolation and lighting)\n    // input modified\n    // light complexity changed\n    // render pass shader replacement changed\n    var tNumComp = model.openGLTexture.getComponents();\n    var iComp = actor.getProperty().getIndependentComponents(); // has the render pass shader replacement changed? Two options\n\n    var needRebuild = false;\n    if (!model.currentRenderPass && model.lastRenderPassShaderReplacement || model.currentRenderPass && model.currentRenderPass.getShaderReplacement() !== model.lastRenderPassShaderReplacement) {\n      needRebuild = true;\n    }\n    if (needRebuild || model.lastHaveSeenDepthRequest !== model.haveSeenDepthRequest || cellBO.getProgram() === 0 || model.lastTextureComponents !== tNumComp || model.lastIndependentComponents !== iComp) {\n      model.lastHaveSeenDepthRequest = model.haveSeenDepthRequest;\n      model.lastTextureComponents = tNumComp;\n      model.lastIndependentComponents = iComp;\n      return true;\n    }\n    return false;\n  };\n  publicAPI.updateShaders = function (cellBO, ren, actor) {\n    model.lastBoundBO = cellBO; // has something changed that would require us to recreate the shader?\n\n    if (publicAPI.getNeedToRebuildShaders(cellBO, ren, actor)) {\n      var shaders = {\n        Vertex: null,\n        Fragment: null,\n        Geometry: null\n      };\n      publicAPI.buildShaders(shaders, ren, actor); // compile and bind the program if needed\n\n      var newShader = model._openGLRenderWindow.getShaderCache().readyShaderProgramArray(shaders.Vertex, shaders.Fragment, shaders.Geometry); // if the shader changed reinitialize the VAO\n\n      if (newShader !== cellBO.getProgram()) {\n        cellBO.setProgram(newShader); // reset the VAO as the shader has changed\n\n        cellBO.getVAO().releaseGraphicsResources();\n      }\n      cellBO.getShaderSourceTime().modified();\n    } else {\n      model._openGLRenderWindow.getShaderCache().readyShaderProgram(cellBO.getProgram());\n    }\n    cellBO.getVAO().bind();\n    publicAPI.setMapperShaderParameters(cellBO, ren, actor);\n    publicAPI.setCameraShaderParameters(cellBO, ren, actor);\n    publicAPI.setPropertyShaderParameters(cellBO, ren, actor);\n  };\n  publicAPI.setMapperShaderParameters = function (cellBO, ren, actor) {\n    // Now to update the VAO too, if necessary.\n    if (cellBO.getCABO().getElementCount() && (model.VBOBuildTime > cellBO.getAttributeUpdateTime().getMTime() || cellBO.getShaderSourceTime().getMTime() > cellBO.getAttributeUpdateTime().getMTime())) {\n      if (cellBO.getProgram().isAttributeUsed('vertexMC')) {\n        if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO(), 'vertexMC', cellBO.getCABO().getVertexOffset(), cellBO.getCABO().getStride(), model.context.FLOAT, 3, model.context.FALSE)) {\n          vtkErrorMacro('Error setting vertexMC in shader VAO.');\n        }\n      }\n      if (cellBO.getProgram().isAttributeUsed('tcoordMC') && cellBO.getCABO().getTCoordOffset()) {\n        if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO(), 'tcoordMC', cellBO.getCABO().getTCoordOffset(), cellBO.getCABO().getStride(), model.context.FLOAT, cellBO.getCABO().getTCoordComponents(), model.context.FALSE)) {\n          vtkErrorMacro('Error setting tcoordMC in shader VAO.');\n        }\n      }\n      cellBO.getAttributeUpdateTime().modified();\n    }\n    var texUnit = model.openGLTexture.getTextureUnit();\n    cellBO.getProgram().setUniformi('texture1', texUnit);\n    var numComp = model.openGLTexture.getComponents();\n    var iComps = actor.getProperty().getIndependentComponents();\n    if (iComps) {\n      for (var i = 0; i < numComp; i++) {\n        cellBO.getProgram().setUniformf(\"mix\".concat(i), actor.getProperty().getComponentWeight(i));\n      }\n    }\n    var oglShiftScale = model.openGLTexture.getShiftAndScale(); // three levels of shift scale combined into one\n    // for performance in the fragment shader\n\n    for (var _i = 0; _i < numComp; _i++) {\n      var cw = actor.getProperty().getColorWindow();\n      var cl = actor.getProperty().getColorLevel();\n      var target = iComps ? _i : 0;\n      var cfun = actor.getProperty().getRGBTransferFunction(target);\n      if (cfun && actor.getProperty().getUseLookupTableScalarRange()) {\n        var cRange = cfun.getRange();\n        cw = cRange[1] - cRange[0];\n        cl = 0.5 * (cRange[1] + cRange[0]);\n      }\n      var scale = oglShiftScale.scale / cw;\n      var shift = (oglShiftScale.shift - cl) / cw + 0.5;\n      cellBO.getProgram().setUniformf(\"cshift\".concat(_i), shift);\n      cellBO.getProgram().setUniformf(\"cscale\".concat(_i), scale);\n    } // pwf shift/scale\n\n    for (var _i2 = 0; _i2 < numComp; _i2++) {\n      var pwfScale = 1.0;\n      var pwfShift = 0.0;\n      var _target = iComps ? _i2 : 0;\n      var pwfun = actor.getProperty().getPiecewiseFunction(_target);\n      if (pwfun) {\n        var pwfRange = pwfun.getRange();\n        var length = pwfRange[1] - pwfRange[0];\n        var mid = 0.5 * (pwfRange[0] + pwfRange[1]);\n        pwfScale = oglShiftScale.scale / length;\n        pwfShift = (oglShiftScale.shift - mid) / length + 0.5;\n      }\n      cellBO.getProgram().setUniformf(\"pwfshift\".concat(_i2), pwfShift);\n      cellBO.getProgram().setUniformf(\"pwfscale\".concat(_i2), pwfScale);\n    }\n    if (model.haveSeenDepthRequest) {\n      cellBO.getProgram().setUniformi('depthRequest', model.renderDepth ? 1 : 0);\n    } // handle coincident\n\n    if (cellBO.getProgram().isUniformUsed('coffset')) {\n      var cp = publicAPI.getCoincidentParameters(ren, actor);\n      cellBO.getProgram().setUniformf('coffset', cp.offset); // cfactor isn't always used when coffset is.\n\n      if (cellBO.getProgram().isUniformUsed('cfactor')) {\n        cellBO.getProgram().setUniformf('cfactor', cp.factor);\n      }\n    }\n    var texColorUnit = model.colorTexture.getTextureUnit();\n    cellBO.getProgram().setUniformi('colorTexture1', texColorUnit);\n    var texOpacityUnit = model.pwfTexture.getTextureUnit();\n    cellBO.getProgram().setUniformi('pwfTexture1', texOpacityUnit);\n    if (model.renderable.getNumberOfClippingPlanes()) {\n      // add all the clipping planes\n      var numClipPlanes = model.renderable.getNumberOfClippingPlanes();\n      if (numClipPlanes > 6) {\n        vtkErrorMacro$1('OpenGL has a limit of 6 clipping planes');\n        numClipPlanes = 6;\n      }\n      var shiftScaleEnabled = cellBO.getCABO().getCoordShiftAndScaleEnabled();\n      var inverseShiftScaleMatrix = shiftScaleEnabled ? cellBO.getCABO().getInverseShiftAndScaleMatrix() : null;\n      var mat = inverseShiftScaleMatrix ? mat4.copy(model.imagematinv, actor.getMatrix()) : actor.getMatrix();\n      if (inverseShiftScaleMatrix) {\n        mat4.transpose(mat, mat);\n        mat4.multiply(mat, mat, inverseShiftScaleMatrix);\n        mat4.transpose(mat, mat);\n      } // transform crop plane normal with transpose(inverse(worldToIndex))\n\n      mat4.transpose(model.imagemat, model.currentInput.getIndexToWorld());\n      mat4.multiply(model.imagematinv, mat, model.imagemat);\n      var planeEquations = [];\n      for (var _i3 = 0; _i3 < numClipPlanes; _i3++) {\n        var planeEquation = [];\n        model.renderable.getClippingPlaneInDataCoords(model.imagematinv, _i3, planeEquation);\n        for (var j = 0; j < 4; j++) {\n          planeEquations.push(planeEquation[j]);\n        }\n      }\n      cellBO.getProgram().setUniformi('numClipPlanes', numClipPlanes);\n      cellBO.getProgram().setUniform4fv('clipPlanes', planeEquations);\n    }\n  };\n  publicAPI.setCameraShaderParameters = function (cellBO, ren, actor) {\n    var program = cellBO.getProgram();\n    var actMats = model.openGLImageSlice.getKeyMatrices();\n    var image = model.currentInput;\n    var i2wmat4 = image.getIndexToWorld();\n    mat4.multiply(model.imagemat, actMats.mcwc, i2wmat4);\n    var keyMats = model.openGLCamera.getKeyMatrices(ren);\n    mat4.multiply(model.imagemat, keyMats.wcpc, model.imagemat);\n    if (cellBO.getCABO().getCoordShiftAndScaleEnabled()) {\n      var inverseShiftScaleMat = cellBO.getCABO().getInverseShiftAndScaleMatrix();\n      mat4.multiply(model.imagemat, model.imagemat, inverseShiftScaleMat);\n    }\n    program.setUniformMatrix('MCPCMatrix', model.imagemat);\n  };\n  publicAPI.setPropertyShaderParameters = function (cellBO, ren, actor) {\n    var program = cellBO.getProgram();\n    var ppty = actor.getProperty();\n    var opacity = ppty.getOpacity();\n    program.setUniformf('opacity', opacity);\n  };\n  publicAPI.renderPieceStart = function (ren, actor) {\n    // make sure the BOs are up to date\n    publicAPI.updateBufferObjects(ren, actor); // Bind the OpenGL, this is shared between the different primitive/cell types.\n\n    model.lastBoundBO = null;\n  };\n  publicAPI.renderPieceDraw = function (ren, actor) {\n    var gl = model.context; // activate the texture\n\n    model.openGLTexture.activate();\n    model.colorTexture.activate();\n    model.pwfTexture.activate(); // draw polygons\n\n    if (model.tris.getCABO().getElementCount()) {\n      // First we do the triangles, update the shader, set uniforms, etc.\n      publicAPI.updateShaders(model.tris, ren, actor);\n      gl.drawArrays(gl.TRIANGLES, 0, model.tris.getCABO().getElementCount());\n      model.tris.getVAO().release();\n    }\n    model.openGLTexture.deactivate();\n    model.colorTexture.deactivate();\n    model.pwfTexture.deactivate();\n  };\n  publicAPI.renderPieceFinish = function (ren, actor) {};\n  publicAPI.renderPiece = function (ren, actor) {\n    // Make sure that we have been properly initialized.\n    // if (ren.getRenderWindow().checkAbortStatus()) {\n    //   return;\n    // }\n    publicAPI.invokeEvent({\n      type: 'StartEvent'\n    });\n    model.renderable.update();\n    model.currentInput = model.renderable.getCurrentImage();\n    publicAPI.invokeEvent({\n      type: 'EndEvent'\n    });\n    if (!model.currentInput) {\n      vtkErrorMacro('No input!');\n      return;\n    }\n    publicAPI.renderPieceStart(ren, actor);\n    publicAPI.renderPieceDraw(ren, actor);\n    publicAPI.renderPieceFinish(ren, actor);\n  };\n  publicAPI.computeBounds = function (ren, actor) {\n    if (!publicAPI.getInput()) {\n      uninitializeBounds(model.bounds);\n      return;\n    }\n    model.bounds = publicAPI.getInput().getBounds();\n  };\n  publicAPI.updateBufferObjects = function (ren, actor) {\n    // Rebuild buffers if needed\n    if (publicAPI.getNeedToRebuildBufferObjects(ren, actor)) {\n      publicAPI.buildBufferObjects(ren, actor);\n    }\n  };\n  publicAPI.getNeedToRebuildBufferObjects = function (ren, actor) {\n    // first do a coarse check\n    if (model.VBOBuildTime.getMTime() < publicAPI.getMTime() || model.VBOBuildTime.getMTime() < actor.getMTime() || model.VBOBuildTime.getMTime() < model.renderable.getMTime() || model.VBOBuildTime.getMTime() < actor.getProperty().getMTime() || model.VBOBuildTime.getMTime() < model.currentInput.getMTime()) {\n      return true;\n    }\n    return false;\n  };\n  publicAPI.buildBufferObjects = function (ren, actor) {\n    var image = model.currentInput;\n    if (!image) {\n      return;\n    }\n    var imgScalars = image.getPointData() && image.getPointData().getScalars();\n    if (!imgScalars) {\n      return;\n    }\n    var dataType = imgScalars.getDataType();\n    var numComp = imgScalars.getNumberOfComponents();\n    var actorProperty = actor.getProperty(); // set interpolation on the texture based on property setting\n\n    var iType = actorProperty.getInterpolationType();\n    if (iType === InterpolationType.NEAREST) {\n      model.colorTexture.setMinificationFilter(Filter.NEAREST);\n      model.colorTexture.setMagnificationFilter(Filter.NEAREST);\n      model.pwfTexture.setMinificationFilter(Filter.NEAREST);\n      model.pwfTexture.setMagnificationFilter(Filter.NEAREST);\n    } else {\n      model.colorTexture.setMinificationFilter(Filter.LINEAR);\n      model.colorTexture.setMagnificationFilter(Filter.LINEAR);\n      model.pwfTexture.setMinificationFilter(Filter.LINEAR);\n      model.pwfTexture.setMagnificationFilter(Filter.LINEAR);\n    }\n    var iComps = actorProperty.getIndependentComponents();\n    var numIComps = iComps ? numComp : 1;\n    var textureHeight = iComps ? 2 * numIComps : 1;\n    var cfunToString = computeFnToString(actorProperty, actorProperty.getRGBTransferFunction, numIComps);\n    if (model.colorTextureString !== cfunToString) {\n      var cWidth = 1024;\n      var cSize = cWidth * textureHeight * 3;\n      var cTable = new Uint8Array(cSize);\n      var cfun = actorProperty.getRGBTransferFunction();\n      if (cfun) {\n        var tmpTable = new Float32Array(cWidth * 3);\n        for (var c = 0; c < numIComps; c++) {\n          cfun = actorProperty.getRGBTransferFunction(c);\n          var cRange = cfun.getRange();\n          cfun.getTable(cRange[0], cRange[1], cWidth, tmpTable, 1);\n          if (iComps) {\n            for (var i = 0; i < cWidth * 3; i++) {\n              cTable[c * cWidth * 6 + i] = 255.0 * tmpTable[i];\n              cTable[c * cWidth * 6 + i + cWidth * 3] = 255.0 * tmpTable[i];\n            }\n          } else {\n            for (var _i4 = 0; _i4 < cWidth * 3; _i4++) {\n              cTable[c * cWidth * 6 + _i4] = 255.0 * tmpTable[_i4];\n            }\n          }\n        }\n        model.colorTexture.create2DFromRaw(cWidth, textureHeight, 3, VtkDataTypes.UNSIGNED_CHAR, cTable);\n      } else {\n        for (var _i5 = 0; _i5 < cWidth * 3; ++_i5) {\n          cTable[_i5] = 255.0 * _i5 / ((cWidth - 1) * 3);\n          cTable[_i5 + 1] = 255.0 * _i5 / ((cWidth - 1) * 3);\n          cTable[_i5 + 2] = 255.0 * _i5 / ((cWidth - 1) * 3);\n        }\n        model.colorTexture.create2DFromRaw(cWidth, 1, 3, VtkDataTypes.UNSIGNED_CHAR, cTable);\n      }\n      model.colorTextureString = cfunToString;\n    } // Build piecewise function buffer.  This buffer is used either\n    // for component weighting or opacity, depending on whether we're\n    // rendering components independently or not.\n\n    var pwfunToString = computeFnToString(actorProperty, actorProperty.getPiecewiseFunction, numIComps);\n    if (model.pwfTextureString !== pwfunToString) {\n      var pwfWidth = 1024;\n      var pwfSize = pwfWidth * textureHeight;\n      var pwfTable = new Uint8Array(pwfSize);\n      var pwfun = actorProperty.getPiecewiseFunction(); // support case where pwfun is added/removed\n\n      model.pwfTexture.resetFormatAndType();\n      if (pwfun) {\n        var pwfFloatTable = new Float32Array(pwfSize);\n        var _tmpTable = new Float32Array(pwfWidth);\n        for (var _c = 0; _c < numIComps; ++_c) {\n          pwfun = actorProperty.getPiecewiseFunction(_c);\n          if (pwfun === null) {\n            // Piecewise constant max if no function supplied for this component\n            pwfFloatTable.fill(1.0);\n          } else {\n            var pwfRange = pwfun.getRange();\n            pwfun.getTable(pwfRange[0], pwfRange[1], pwfWidth, _tmpTable, 1); // adjust for sample distance etc\n\n            if (iComps) {\n              for (var _i6 = 0; _i6 < pwfWidth; _i6++) {\n                pwfFloatTable[_c * pwfWidth * 2 + _i6] = _tmpTable[_i6];\n                pwfFloatTable[_c * pwfWidth * 2 + _i6 + pwfWidth] = _tmpTable[_i6];\n              }\n            } else {\n              for (var _i7 = 0; _i7 < pwfWidth; _i7++) {\n                pwfFloatTable[_c * pwfWidth * 2 + _i7] = _tmpTable[_i7];\n              }\n            }\n          }\n        }\n        model.pwfTexture.create2DFromRaw(pwfWidth, textureHeight, 1, VtkDataTypes.FLOAT, pwfFloatTable);\n      } else {\n        // default is opaque\n        pwfTable.fill(255.0);\n        model.pwfTexture.create2DFromRaw(pwfWidth, 1, 1, VtkDataTypes.UNSIGNED_CHAR, pwfTable);\n      }\n      model.pwfTextureString = pwfunToString;\n    } // Find what IJK axis and what direction to slice along\n\n    var _model$renderable$get = model.renderable.getClosestIJKAxis(),\n      ijkMode = _model$renderable$get.ijkMode; // Find the IJK slice\n\n    var slice = model.renderable.getSlice();\n    if (ijkMode !== model.renderable.getSlicingMode()) {\n      // If not IJK slicing, get the IJK slice from the XYZ position/slice\n      slice = model.renderable.getSliceAtPosition(slice);\n    } // Use sub-Slice number/offset if mapper being used is vtkImageArrayMapper,\n    // since this mapper uses a collection of vtkImageData (and not just a single vtkImageData).\n\n    var nSlice = model.renderable.isA('vtkImageArrayMapper') ? model.renderable.getSubSlice() // get subSlice of the current (possibly multi-frame) image\n    : Math.round(slice); // Find sliceOffset\n\n    var ext = image.getExtent();\n    var sliceOffset;\n    if (ijkMode === SlicingMode.I) {\n      sliceOffset = nSlice - ext[0];\n    }\n    if (ijkMode === SlicingMode.J) {\n      sliceOffset = nSlice - ext[2];\n    }\n    if (ijkMode === SlicingMode.K || ijkMode === SlicingMode.NONE) {\n      sliceOffset = nSlice - ext[4];\n    } // rebuild the VBO if the data has changed\n\n    var toString = \"\".concat(slice, \"A\").concat(image.getMTime(), \"A\").concat(imgScalars.getMTime(), \"B\").concat(publicAPI.getMTime(), \"C\").concat(model.renderable.getSlicingMode(), \"D\").concat(actor.getProperty().getInterpolationType());\n    if (model.VBOBuildString !== toString) {\n      var _model$renderable$get2, _model$renderable;\n\n      // Build the VBOs\n      var dims = image.getDimensions();\n      if (iType === InterpolationType.NEAREST) {\n        if (new Set([1, 3, 4]).has(numComp) && dataType === VtkDataTypes.UNSIGNED_CHAR && !iComps) {\n          model.openGLTexture.setGenerateMipmap(true);\n          model.openGLTexture.setMinificationFilter(Filter.NEAREST);\n        } else {\n          model.openGLTexture.setMinificationFilter(Filter.NEAREST);\n        }\n        model.openGLTexture.setMagnificationFilter(Filter.NEAREST);\n      } else {\n        if (numComp === 4 && dataType === VtkDataTypes.UNSIGNED_CHAR && !iComps) {\n          model.openGLTexture.setGenerateMipmap(true);\n          model.openGLTexture.setMinificationFilter(Filter.LINEAR_MIPMAP_LINEAR);\n        } else {\n          model.openGLTexture.setMinificationFilter(Filter.LINEAR);\n        }\n        model.openGLTexture.setMagnificationFilter(Filter.LINEAR);\n      }\n      model.openGLTexture.setWrapS(Wrap.CLAMP_TO_EDGE);\n      model.openGLTexture.setWrapT(Wrap.CLAMP_TO_EDGE);\n      var sliceSize = dims[0] * dims[1] * numComp;\n      var ptsArray = new Float32Array(12);\n      var tcoordArray = new Float32Array(8);\n      for (var _i8 = 0; _i8 < 4; _i8++) {\n        tcoordArray[_i8 * 2] = _i8 % 2 ? 1.0 : 0.0;\n        tcoordArray[_i8 * 2 + 1] = _i8 > 1 ? 1.0 : 0.0;\n      } // Determine depth position of the slicing plane in the scene.\n      // Slicing modes X, Y, and Z use a continuous axis position, whereas\n      // slicing modes I, J, and K should use discrete positions.\n\n      var sliceDepth = [SlicingMode.X, SlicingMode.Y, SlicingMode.Z].includes(model.renderable.getSlicingMode()) ? slice : nSlice;\n      var spatialExt = image.getSpatialExtent();\n      var basicScalars = imgScalars.getData();\n      var scalars = null; // Get right scalars according to slicing mode\n\n      if (ijkMode === SlicingMode.I) {\n        scalars = new basicScalars.constructor(dims[2] * dims[1] * numComp);\n        var id = 0;\n        for (var k = 0; k < dims[2]; k++) {\n          for (var j = 0; j < dims[1]; j++) {\n            var bsIdx = (sliceOffset + j * dims[0] + k * dims[0] * dims[1]) * numComp;\n            id = (k * dims[1] + j) * numComp;\n            var end = bsIdx + numComp;\n            while (bsIdx < end) {\n              scalars[id++] = basicScalars[bsIdx++];\n            }\n          }\n        }\n        dims[0] = dims[1];\n        dims[1] = dims[2];\n        ptsArray[0] = sliceDepth;\n        ptsArray[1] = spatialExt[2];\n        ptsArray[2] = spatialExt[4];\n        ptsArray[3] = sliceDepth;\n        ptsArray[4] = spatialExt[3];\n        ptsArray[5] = spatialExt[4];\n        ptsArray[6] = sliceDepth;\n        ptsArray[7] = spatialExt[2];\n        ptsArray[8] = spatialExt[5];\n        ptsArray[9] = sliceDepth;\n        ptsArray[10] = spatialExt[3];\n        ptsArray[11] = spatialExt[5];\n      } else if (ijkMode === SlicingMode.J) {\n        scalars = new basicScalars.constructor(dims[2] * dims[0] * numComp);\n        var _id = 0;\n        for (var _k = 0; _k < dims[2]; _k++) {\n          for (var _i9 = 0; _i9 < dims[0]; _i9++) {\n            var _bsIdx = (_i9 + sliceOffset * dims[0] + _k * dims[0] * dims[1]) * numComp;\n            _id = (_k * dims[0] + _i9) * numComp;\n            var _end = _bsIdx + numComp;\n            while (_bsIdx < _end) {\n              scalars[_id++] = basicScalars[_bsIdx++];\n            }\n          }\n        }\n        dims[1] = dims[2];\n        ptsArray[0] = spatialExt[0];\n        ptsArray[1] = sliceDepth;\n        ptsArray[2] = spatialExt[4];\n        ptsArray[3] = spatialExt[1];\n        ptsArray[4] = sliceDepth;\n        ptsArray[5] = spatialExt[4];\n        ptsArray[6] = spatialExt[0];\n        ptsArray[7] = sliceDepth;\n        ptsArray[8] = spatialExt[5];\n        ptsArray[9] = spatialExt[1];\n        ptsArray[10] = sliceDepth;\n        ptsArray[11] = spatialExt[5];\n      } else if (ijkMode === SlicingMode.K || ijkMode === SlicingMode.NONE) {\n        scalars = basicScalars.subarray(sliceOffset * sliceSize, (sliceOffset + 1) * sliceSize);\n        ptsArray[0] = spatialExt[0];\n        ptsArray[1] = spatialExt[2];\n        ptsArray[2] = sliceDepth;\n        ptsArray[3] = spatialExt[1];\n        ptsArray[4] = spatialExt[2];\n        ptsArray[5] = sliceDepth;\n        ptsArray[6] = spatialExt[0];\n        ptsArray[7] = spatialExt[3];\n        ptsArray[8] = sliceDepth;\n        ptsArray[9] = spatialExt[1];\n        ptsArray[10] = spatialExt[3];\n        ptsArray[11] = sliceDepth;\n      } else {\n        vtkErrorMacro('Reformat slicing not yet supported.');\n      }\n      model.openGLTexture.create2DFilterableFromRaw(dims[0], dims[1], numComp, imgScalars.getDataType(), scalars, (_model$renderable$get2 = (_model$renderable = model.renderable).getPreferSizeOverAccuracy) === null || _model$renderable$get2 === void 0 ? void 0 : _model$renderable$get2.call(_model$renderable));\n      model.openGLTexture.activate();\n      model.openGLTexture.sendParameters();\n      model.openGLTexture.deactivate();\n      var points = vtkDataArray.newInstance({\n        numberOfComponents: 3,\n        values: ptsArray\n      });\n      points.setName('points');\n      var tcoords = vtkDataArray.newInstance({\n        numberOfComponents: 2,\n        values: tcoordArray\n      });\n      tcoords.setName('tcoords');\n      var cellArray = new Uint16Array(8);\n      cellArray[0] = 3;\n      cellArray[1] = 0;\n      cellArray[2] = 1;\n      cellArray[3] = 3;\n      cellArray[4] = 3;\n      cellArray[5] = 0;\n      cellArray[6] = 3;\n      cellArray[7] = 2;\n      var cells = vtkDataArray.newInstance({\n        numberOfComponents: 1,\n        values: cellArray\n      });\n      model.tris.getCABO().createVBO(cells, 'polys', Representation.SURFACE, {\n        points: points,\n        tcoords: tcoords,\n        cellOffset: 0\n      });\n      model.VBOBuildTime.modified();\n      model.VBOBuildString = toString;\n    }\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nvar DEFAULT_VALUES = {\n  VBOBuildTime: 0,\n  VBOBuildString: null,\n  openGLTexture: null,\n  tris: null,\n  imagemat: null,\n  imagematinv: null,\n  colorTexture: null,\n  pwfTexture: null,\n  lastHaveSeenDepthRequest: false,\n  haveSeenDepthRequest: false,\n  lastTextureComponents: 0\n}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Inheritance\n\n  vtkViewNode.extend(publicAPI, model, initialValues);\n  vtkReplacementShaderMapper.implementReplaceShaderCoincidentOffset(publicAPI, model, initialValues);\n  vtkReplacementShaderMapper.implementBuildShadersWithReplacements(publicAPI, model, initialValues);\n  model.tris = vtkHelper.newInstance();\n  model.openGLTexture = vtkOpenGLTexture.newInstance({\n    resizable: true\n  });\n  model.colorTexture = vtkOpenGLTexture.newInstance({\n    resizable: true\n  });\n  model.pwfTexture = vtkOpenGLTexture.newInstance({\n    resizable: true\n  });\n  model.imagemat = mat4.identity(new Float64Array(16));\n  model.imagematinv = mat4.identity(new Float64Array(16)); // Build VTK API\n\n  setGet(publicAPI, model, []);\n  model.VBOBuildTime = {};\n  obj(model.VBOBuildTime); // Object methods\n\n  vtkOpenGLImageMapper(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = newInstance$1(extend, 'vtkOpenGLImageMapper'); // ----------------------------------------------------------------------------\n\nvar vtkImageMapper = {\n  newInstance: newInstance,\n  extend: extend\n}; // Register ourself to OpenGL backend if imported\n\nregisterOverride('vtkAbstractImageMapper', newInstance);\nexport { vtkImageMapper as default, extend, newInstance };","map":{"version":3,"names":["mat4","Constants","newInstance","newInstance$1","setGet","obj","vtkErrorMacro","vtkErrorMacro$1","vtkDataArray","VtkDataTypes","vtkHelper","u","uninitializeBounds","vtkOpenGLTexture","vtkShaderProgram","vtkViewNode","Representation","Filter","Wrap","InterpolationType","v","vtkPolyDataVS","vtkPolyDataFS","vtkReplacementShaderMapper","registerOverride","SlicingMode","computeFnToString","property","fn","numberOfComponents","pwfun","apply","iComps","getIndependentComponents","concat","getMTime","vtkOpenGLImageMapper","publicAPI","model","classHierarchy","push","buildPass","prepass","currentRenderPass","openGLImageSlice","getFirstAncestorOfType","_openGLRenderer","_openGLRenderWindow","getParent","context","getContext","tris","setOpenGLRenderWindow","openGLTexture","colorTexture","pwfTexture","ren","getRenderable","openGLCamera","getViewNodeFor","getActiveCamera","renderable","isA","getSliceAtFocalPoint","setSliceFromCamera","translucentPass","renderPass","render","zBufferPass","haveSeenDepthRequest","renderDepth","opaqueZBufferPass","opaquePass","getCoincidentParameters","actor","getResolveCoincidentTopology","getCoincidentTopologyPolygonOffsetParameters","renderPiece","getShaderTemplate","shaders","Vertex","Fragment","Geometry","replaceShaderValues","VSSource","FSSource","substitute","result","tNumComp","getComponents","getProperty","tcoordDec","comp","rgba","tcoordImpl","_comp","replaceShaderClip","replaceShaderCoincidentOffset","getNumberOfClippingPlanes","numClipPlanes","getNeedToRebuildShaders","cellBO","iComp","needRebuild","lastRenderPassShaderReplacement","getShaderReplacement","lastHaveSeenDepthRequest","getProgram","lastTextureComponents","lastIndependentComponents","updateShaders","lastBoundBO","buildShaders","newShader","getShaderCache","readyShaderProgramArray","setProgram","getVAO","releaseGraphicsResources","getShaderSourceTime","modified","readyShaderProgram","bind","setMapperShaderParameters","setCameraShaderParameters","setPropertyShaderParameters","getCABO","getElementCount","VBOBuildTime","getAttributeUpdateTime","isAttributeUsed","addAttributeArray","getVertexOffset","getStride","FLOAT","FALSE","getTCoordOffset","getTCoordComponents","texUnit","getTextureUnit","setUniformi","numComp","i","setUniformf","getComponentWeight","oglShiftScale","getShiftAndScale","_i","cw","getColorWindow","cl","getColorLevel","target","cfun","getRGBTransferFunction","getUseLookupTableScalarRange","cRange","getRange","scale","shift","_i2","pwfScale","pwfShift","_target","getPiecewiseFunction","pwfRange","length","mid","isUniformUsed","cp","offset","factor","texColorUnit","texOpacityUnit","shiftScaleEnabled","getCoordShiftAndScaleEnabled","inverseShiftScaleMatrix","getInverseShiftAndScaleMatrix","mat","copy","imagematinv","getMatrix","transpose","multiply","imagemat","currentInput","getIndexToWorld","planeEquations","_i3","planeEquation","getClippingPlaneInDataCoords","j","setUniform4fv","program","actMats","getKeyMatrices","image","i2wmat4","mcwc","keyMats","wcpc","inverseShiftScaleMat","setUniformMatrix","ppty","opacity","getOpacity","renderPieceStart","updateBufferObjects","renderPieceDraw","gl","activate","drawArrays","TRIANGLES","release","deactivate","renderPieceFinish","invokeEvent","type","update","getCurrentImage","computeBounds","getInput","bounds","getBounds","getNeedToRebuildBufferObjects","buildBufferObjects","imgScalars","getPointData","getScalars","dataType","getDataType","getNumberOfComponents","actorProperty","iType","getInterpolationType","NEAREST","setMinificationFilter","setMagnificationFilter","LINEAR","numIComps","textureHeight","cfunToString","colorTextureString","cWidth","cSize","cTable","Uint8Array","tmpTable","Float32Array","c","getTable","_i4","create2DFromRaw","UNSIGNED_CHAR","_i5","pwfunToString","pwfTextureString","pwfWidth","pwfSize","pwfTable","resetFormatAndType","pwfFloatTable","_tmpTable","_c","fill","_i6","_i7","_model$renderable$get","getClosestIJKAxis","ijkMode","slice","getSlice","getSlicingMode","getSliceAtPosition","nSlice","getSubSlice","Math","round","ext","getExtent","sliceOffset","I","J","K","NONE","toString","VBOBuildString","_model$renderable$get2","_model$renderable","dims","getDimensions","Set","has","setGenerateMipmap","LINEAR_MIPMAP_LINEAR","setWrapS","CLAMP_TO_EDGE","setWrapT","sliceSize","ptsArray","tcoordArray","_i8","sliceDepth","X","Y","Z","includes","spatialExt","getSpatialExtent","basicScalars","getData","scalars","constructor","id","k","bsIdx","end","_id","_k","_i9","_bsIdx","_end","subarray","create2DFilterableFromRaw","getPreferSizeOverAccuracy","call","sendParameters","points","values","setName","tcoords","cellArray","Uint16Array","cells","createVBO","SURFACE","cellOffset","DEFAULT_VALUES","extend","initialValues","arguments","undefined","Object","assign","implementReplaceShaderCoincidentOffset","implementBuildShadersWithReplacements","resizable","identity","Float64Array","vtkImageMapper","default"],"sources":["/home/rakshith/Documents/RemoteRendering/vtk-js-react-app/node_modules/@kitware/vtk.js/Rendering/OpenGL/ImageMapper.js"],"sourcesContent":["import { mat4 } from 'gl-matrix';\nimport Constants from '../Core/ImageMapper/Constants.js';\nimport { newInstance as newInstance$1, setGet, obj, vtkErrorMacro as vtkErrorMacro$1 } from '../../macros.js';\nimport vtkDataArray from '../../Common/Core/DataArray.js';\nimport { VtkDataTypes } from '../../Common/Core/DataArray/Constants.js';\nimport vtkHelper from './Helper.js';\nimport { u as uninitializeBounds } from '../../Common/Core/Math/index.js';\nimport vtkOpenGLTexture from './Texture.js';\nimport vtkShaderProgram from './ShaderProgram.js';\nimport vtkViewNode from '../SceneGraph/ViewNode.js';\nimport { Representation } from '../Core/Property/Constants.js';\nimport { Filter, Wrap } from './Texture/Constants.js';\nimport { InterpolationType } from '../Core/ImageProperty/Constants.js';\nimport { v as vtkPolyDataVS } from './glsl/vtkPolyDataVS.glsl.js';\nimport { v as vtkPolyDataFS } from './glsl/vtkPolyDataFS.glsl.js';\nimport vtkReplacementShaderMapper from './ReplacementShaderMapper.js';\nimport { registerOverride } from './ViewNodeFactory.js';\n\nvar vtkErrorMacro = vtkErrorMacro$1;\nvar SlicingMode = Constants.SlicingMode; // ----------------------------------------------------------------------------\n// helper methods\n// ----------------------------------------------------------------------------\n\nfunction computeFnToString(property, fn, numberOfComponents) {\n  var pwfun = fn.apply(property);\n\n  if (pwfun) {\n    var iComps = property.getIndependentComponents();\n    return \"\".concat(property.getMTime(), \"-\").concat(iComps, \"-\").concat(numberOfComponents);\n  }\n\n  return '0';\n} // ----------------------------------------------------------------------------\n// vtkOpenGLImageMapper methods\n// ----------------------------------------------------------------------------\n\n\nfunction vtkOpenGLImageMapper(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkOpenGLImageMapper');\n\n  publicAPI.buildPass = function (prepass) {\n    if (prepass) {\n      model.currentRenderPass = null;\n      model.openGLImageSlice = publicAPI.getFirstAncestorOfType('vtkOpenGLImageSlice');\n      model._openGLRenderer = publicAPI.getFirstAncestorOfType('vtkOpenGLRenderer');\n      model._openGLRenderWindow = model._openGLRenderer.getParent();\n      model.context = model._openGLRenderWindow.getContext();\n      model.tris.setOpenGLRenderWindow(model._openGLRenderWindow);\n      model.openGLTexture.setOpenGLRenderWindow(model._openGLRenderWindow);\n      model.colorTexture.setOpenGLRenderWindow(model._openGLRenderWindow);\n      model.pwfTexture.setOpenGLRenderWindow(model._openGLRenderWindow);\n\n      var ren = model._openGLRenderer.getRenderable();\n\n      model.openGLCamera = model._openGLRenderer.getViewNodeFor(ren.getActiveCamera()); // is slice set by the camera\n\n      if (model.renderable.isA('vtkImageMapper') && model.renderable.getSliceAtFocalPoint()) {\n        model.renderable.setSliceFromCamera(ren.getActiveCamera());\n      }\n    }\n  };\n\n  publicAPI.translucentPass = function (prepass, renderPass) {\n    if (prepass) {\n      model.currentRenderPass = renderPass;\n      publicAPI.render();\n    }\n  };\n\n  publicAPI.zBufferPass = function (prepass) {\n    if (prepass) {\n      model.haveSeenDepthRequest = true;\n      model.renderDepth = true;\n      publicAPI.render();\n      model.renderDepth = false;\n    }\n  };\n\n  publicAPI.opaqueZBufferPass = function (prepass) {\n    return publicAPI.zBufferPass(prepass);\n  };\n\n  publicAPI.opaquePass = function (prepass) {\n    if (prepass) {\n      publicAPI.render();\n    }\n  };\n\n  publicAPI.getCoincidentParameters = function (ren, actor) {\n    if (model.renderable.getResolveCoincidentTopology()) {\n      return model.renderable.getCoincidentTopologyPolygonOffsetParameters();\n    }\n\n    return null;\n  }; // Renders myself\n\n\n  publicAPI.render = function () {\n    var actor = model.openGLImageSlice.getRenderable();\n\n    var ren = model._openGLRenderer.getRenderable();\n\n    publicAPI.renderPiece(ren, actor);\n  };\n\n  publicAPI.getShaderTemplate = function (shaders, ren, actor) {\n    shaders.Vertex = vtkPolyDataVS;\n    shaders.Fragment = vtkPolyDataFS;\n    shaders.Geometry = '';\n  };\n\n  publicAPI.replaceShaderValues = function (shaders, ren, actor) {\n    var VSSource = shaders.Vertex;\n    var FSSource = shaders.Fragment;\n    VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::Camera::Dec', ['uniform mat4 MCPCMatrix;']).result;\n    VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::PositionVC::Impl', ['  gl_Position = MCPCMatrix * vertexMC;']).result;\n    VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::TCoord::Impl', 'tcoordVCVSOutput = tcoordMC;').result;\n    VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::TCoord::Dec', 'attribute vec2 tcoordMC; varying vec2 tcoordVCVSOutput;').result;\n    var tNumComp = model.openGLTexture.getComponents();\n    var iComps = actor.getProperty().getIndependentComponents();\n    var tcoordDec = ['varying vec2 tcoordVCVSOutput;', // color shift and scale\n    'uniform float cshift0;', 'uniform float cscale0;', // pwf shift and scale\n    'uniform float pwfshift0;', 'uniform float pwfscale0;', 'uniform sampler2D texture1;', 'uniform sampler2D colorTexture1;', 'uniform sampler2D pwfTexture1;', 'uniform float opacity;'];\n\n    if (iComps) {\n      for (var comp = 1; comp < tNumComp; comp++) {\n        tcoordDec = tcoordDec.concat([// color shift and scale\n        \"uniform float cshift\".concat(comp, \";\"), \"uniform float cscale\".concat(comp, \";\"), // weighting shift and scale\n        \"uniform float pwfshift\".concat(comp, \";\"), \"uniform float pwfscale\".concat(comp, \";\")]);\n      } // the heights defined below are the locations\n      // for the up to four components of the tfuns\n      // the tfuns have a height of 2XnumComps pixels so the\n      // values are computed to hit the middle of the two rows\n      // for that component\n\n\n      switch (tNumComp) {\n        case 1:\n          tcoordDec = tcoordDec.concat(['uniform float mix0;', '#define height0 0.5']);\n          break;\n\n        case 2:\n          tcoordDec = tcoordDec.concat(['uniform float mix0;', 'uniform float mix1;', '#define height0 0.25', '#define height1 0.75']);\n          break;\n\n        case 3:\n          tcoordDec = tcoordDec.concat(['uniform float mix0;', 'uniform float mix1;', 'uniform float mix2;', '#define height0 0.17', '#define height1 0.5', '#define height2 0.83']);\n          break;\n\n        case 4:\n          tcoordDec = tcoordDec.concat(['uniform float mix0;', 'uniform float mix1;', 'uniform float mix2;', 'uniform float mix3;', '#define height0 0.125', '#define height1 0.375', '#define height2 0.625', '#define height3 0.875']);\n          break;\n\n        default:\n          vtkErrorMacro('Unsupported number of independent coordinates.');\n      }\n    }\n\n    FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::TCoord::Dec', tcoordDec).result;\n\n    if (iComps) {\n      var rgba = ['r', 'g', 'b', 'a'];\n      var tcoordImpl = ['vec4 tvalue = texture2D(texture1, tcoordVCVSOutput);'];\n\n      for (var _comp = 0; _comp < tNumComp; _comp++) {\n        tcoordImpl = tcoordImpl.concat([\"vec3 tcolor\".concat(_comp, \" = mix\").concat(_comp, \" * texture2D(colorTexture1, vec2(tvalue.\").concat(rgba[_comp], \" * cscale\").concat(_comp, \" + cshift\").concat(_comp, \", height\").concat(_comp, \")).rgb;\"), \"float compWeight\".concat(_comp, \" = mix\").concat(_comp, \" * texture2D(pwfTexture1, vec2(tvalue.\").concat(rgba[_comp], \" * pwfscale\").concat(_comp, \" + pwfshift\").concat(_comp, \", height\").concat(_comp, \")).r;\")]);\n      }\n\n      switch (tNumComp) {\n        case 1:\n          tcoordImpl = tcoordImpl.concat(['gl_FragData[0] = vec4(tcolor0.rgb, opacity);']);\n          break;\n\n        case 2:\n          tcoordImpl = tcoordImpl.concat(['float weightSum = compWeight0 + compWeight1;', 'gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum))), opacity);']);\n          break;\n\n        case 3:\n          tcoordImpl = tcoordImpl.concat(['float weightSum = compWeight0 + compWeight1 + compWeight2;', 'gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum))), opacity);']);\n          break;\n\n        case 4:\n          tcoordImpl = tcoordImpl.concat(['float weightSum = compWeight0 + compWeight1 + compWeight2 + compWeight3;', 'gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum)) + (tcolor3.rgb * (compWeight3 / weightSum))), opacity);']);\n          break;\n\n        default:\n          vtkErrorMacro('Unsupported number of independent coordinates.');\n      }\n\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::TCoord::Impl', tcoordImpl).result;\n    } else {\n      // dependent components\n      switch (tNumComp) {\n        case 1:\n          FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::TCoord::Impl', ['float intensity = texture2D(texture1, tcoordVCVSOutput).r;', 'vec3 tcolor = texture2D(colorTexture1, vec2(intensity * cscale0 + cshift0, 0.5)).rgb;', 'float scalarOpacity = texture2D(pwfTexture1, vec2(intensity * pwfscale0 + pwfshift0, 0.5)).r;', 'gl_FragData[0] = vec4(tcolor, scalarOpacity * opacity);']).result;\n          break;\n\n        case 2:\n          FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::TCoord::Impl', ['vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);', 'float intensity = tcolor.r*cscale0 + cshift0;', 'gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(intensity, 0.5)).rgb, pwfscale0*tcolor.g + pwfshift0);']).result;\n          break;\n\n        case 3:\n          FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::TCoord::Impl', ['vec4 tcolor = cscale0*texture2D(texture1, tcoordVCVSOutput.st) + cshift0;', 'gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,', '  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,', '  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, opacity);']).result;\n          break;\n\n        default:\n          FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::TCoord::Impl', ['vec4 tcolor = cscale0*texture2D(texture1, tcoordVCVSOutput.st) + cshift0;', 'gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,', '  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,', '  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, tcolor.a);']).result;\n      }\n    }\n\n    if (model.haveSeenDepthRequest) {\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::ZBuffer::Dec', 'uniform int depthRequest;').result;\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::ZBuffer::Impl', ['if (depthRequest == 1) {', 'float iz = floor(gl_FragCoord.z*65535.0 + 0.1);', 'float rf = floor(iz/256.0)/255.0;', 'float gf = mod(iz,256.0)/255.0;', 'gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }']).result;\n    }\n\n    shaders.Vertex = VSSource;\n    shaders.Fragment = FSSource;\n    publicAPI.replaceShaderClip(shaders, ren, actor);\n    publicAPI.replaceShaderCoincidentOffset(shaders, ren, actor);\n  };\n\n  publicAPI.replaceShaderClip = function (shaders, ren, actor) {\n    var VSSource = shaders.Vertex;\n    var FSSource = shaders.Fragment;\n\n    if (model.renderable.getNumberOfClippingPlanes()) {\n      var numClipPlanes = model.renderable.getNumberOfClippingPlanes();\n\n      if (numClipPlanes > 6) {\n        vtkErrorMacro$1('OpenGL has a limit of 6 clipping planes');\n        numClipPlanes = 6;\n      }\n\n      VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::Clip::Dec', ['uniform int numClipPlanes;', 'uniform vec4 clipPlanes[6];', 'varying float clipDistancesVSOutput[6];']).result;\n      VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::Clip::Impl', ['for (int planeNum = 0; planeNum < 6; planeNum++)', '    {', '    if (planeNum >= numClipPlanes)', '        {', '        break;', '        }', '    clipDistancesVSOutput[planeNum] = dot(clipPlanes[planeNum], vertexMC);', '    }']).result;\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Clip::Dec', ['uniform int numClipPlanes;', 'varying float clipDistancesVSOutput[6];']).result;\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Clip::Impl', ['for (int planeNum = 0; planeNum < 6; planeNum++)', '    {', '    if (planeNum >= numClipPlanes)', '        {', '        break;', '        }', '    if (clipDistancesVSOutput[planeNum] < 0.0) discard;', '    }']).result;\n    }\n\n    shaders.Vertex = VSSource;\n    shaders.Fragment = FSSource;\n  };\n\n  publicAPI.getNeedToRebuildShaders = function (cellBO, ren, actor) {\n    // has something changed that would require us to recreate the shader?\n    // candidates are\n    // property modified (representation interpolation and lighting)\n    // input modified\n    // light complexity changed\n    // render pass shader replacement changed\n    var tNumComp = model.openGLTexture.getComponents();\n    var iComp = actor.getProperty().getIndependentComponents(); // has the render pass shader replacement changed? Two options\n\n    var needRebuild = false;\n\n    if (!model.currentRenderPass && model.lastRenderPassShaderReplacement || model.currentRenderPass && model.currentRenderPass.getShaderReplacement() !== model.lastRenderPassShaderReplacement) {\n      needRebuild = true;\n    }\n\n    if (needRebuild || model.lastHaveSeenDepthRequest !== model.haveSeenDepthRequest || cellBO.getProgram() === 0 || model.lastTextureComponents !== tNumComp || model.lastIndependentComponents !== iComp) {\n      model.lastHaveSeenDepthRequest = model.haveSeenDepthRequest;\n      model.lastTextureComponents = tNumComp;\n      model.lastIndependentComponents = iComp;\n      return true;\n    }\n\n    return false;\n  };\n\n  publicAPI.updateShaders = function (cellBO, ren, actor) {\n    model.lastBoundBO = cellBO; // has something changed that would require us to recreate the shader?\n\n    if (publicAPI.getNeedToRebuildShaders(cellBO, ren, actor)) {\n      var shaders = {\n        Vertex: null,\n        Fragment: null,\n        Geometry: null\n      };\n      publicAPI.buildShaders(shaders, ren, actor); // compile and bind the program if needed\n\n      var newShader = model._openGLRenderWindow.getShaderCache().readyShaderProgramArray(shaders.Vertex, shaders.Fragment, shaders.Geometry); // if the shader changed reinitialize the VAO\n\n\n      if (newShader !== cellBO.getProgram()) {\n        cellBO.setProgram(newShader); // reset the VAO as the shader has changed\n\n        cellBO.getVAO().releaseGraphicsResources();\n      }\n\n      cellBO.getShaderSourceTime().modified();\n    } else {\n      model._openGLRenderWindow.getShaderCache().readyShaderProgram(cellBO.getProgram());\n    }\n\n    cellBO.getVAO().bind();\n    publicAPI.setMapperShaderParameters(cellBO, ren, actor);\n    publicAPI.setCameraShaderParameters(cellBO, ren, actor);\n    publicAPI.setPropertyShaderParameters(cellBO, ren, actor);\n  };\n\n  publicAPI.setMapperShaderParameters = function (cellBO, ren, actor) {\n    // Now to update the VAO too, if necessary.\n    if (cellBO.getCABO().getElementCount() && (model.VBOBuildTime > cellBO.getAttributeUpdateTime().getMTime() || cellBO.getShaderSourceTime().getMTime() > cellBO.getAttributeUpdateTime().getMTime())) {\n      if (cellBO.getProgram().isAttributeUsed('vertexMC')) {\n        if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO(), 'vertexMC', cellBO.getCABO().getVertexOffset(), cellBO.getCABO().getStride(), model.context.FLOAT, 3, model.context.FALSE)) {\n          vtkErrorMacro('Error setting vertexMC in shader VAO.');\n        }\n      }\n\n      if (cellBO.getProgram().isAttributeUsed('tcoordMC') && cellBO.getCABO().getTCoordOffset()) {\n        if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO(), 'tcoordMC', cellBO.getCABO().getTCoordOffset(), cellBO.getCABO().getStride(), model.context.FLOAT, cellBO.getCABO().getTCoordComponents(), model.context.FALSE)) {\n          vtkErrorMacro('Error setting tcoordMC in shader VAO.');\n        }\n      }\n\n      cellBO.getAttributeUpdateTime().modified();\n    }\n\n    var texUnit = model.openGLTexture.getTextureUnit();\n    cellBO.getProgram().setUniformi('texture1', texUnit);\n    var numComp = model.openGLTexture.getComponents();\n    var iComps = actor.getProperty().getIndependentComponents();\n\n    if (iComps) {\n      for (var i = 0; i < numComp; i++) {\n        cellBO.getProgram().setUniformf(\"mix\".concat(i), actor.getProperty().getComponentWeight(i));\n      }\n    }\n\n    var oglShiftScale = model.openGLTexture.getShiftAndScale(); // three levels of shift scale combined into one\n    // for performance in the fragment shader\n\n    for (var _i = 0; _i < numComp; _i++) {\n      var cw = actor.getProperty().getColorWindow();\n      var cl = actor.getProperty().getColorLevel();\n      var target = iComps ? _i : 0;\n      var cfun = actor.getProperty().getRGBTransferFunction(target);\n\n      if (cfun && actor.getProperty().getUseLookupTableScalarRange()) {\n        var cRange = cfun.getRange();\n        cw = cRange[1] - cRange[0];\n        cl = 0.5 * (cRange[1] + cRange[0]);\n      }\n\n      var scale = oglShiftScale.scale / cw;\n      var shift = (oglShiftScale.shift - cl) / cw + 0.5;\n      cellBO.getProgram().setUniformf(\"cshift\".concat(_i), shift);\n      cellBO.getProgram().setUniformf(\"cscale\".concat(_i), scale);\n    } // pwf shift/scale\n\n\n    for (var _i2 = 0; _i2 < numComp; _i2++) {\n      var pwfScale = 1.0;\n      var pwfShift = 0.0;\n\n      var _target = iComps ? _i2 : 0;\n\n      var pwfun = actor.getProperty().getPiecewiseFunction(_target);\n\n      if (pwfun) {\n        var pwfRange = pwfun.getRange();\n        var length = pwfRange[1] - pwfRange[0];\n        var mid = 0.5 * (pwfRange[0] + pwfRange[1]);\n        pwfScale = oglShiftScale.scale / length;\n        pwfShift = (oglShiftScale.shift - mid) / length + 0.5;\n      }\n\n      cellBO.getProgram().setUniformf(\"pwfshift\".concat(_i2), pwfShift);\n      cellBO.getProgram().setUniformf(\"pwfscale\".concat(_i2), pwfScale);\n    }\n\n    if (model.haveSeenDepthRequest) {\n      cellBO.getProgram().setUniformi('depthRequest', model.renderDepth ? 1 : 0);\n    } // handle coincident\n\n\n    if (cellBO.getProgram().isUniformUsed('coffset')) {\n      var cp = publicAPI.getCoincidentParameters(ren, actor);\n      cellBO.getProgram().setUniformf('coffset', cp.offset); // cfactor isn't always used when coffset is.\n\n      if (cellBO.getProgram().isUniformUsed('cfactor')) {\n        cellBO.getProgram().setUniformf('cfactor', cp.factor);\n      }\n    }\n\n    var texColorUnit = model.colorTexture.getTextureUnit();\n    cellBO.getProgram().setUniformi('colorTexture1', texColorUnit);\n    var texOpacityUnit = model.pwfTexture.getTextureUnit();\n    cellBO.getProgram().setUniformi('pwfTexture1', texOpacityUnit);\n\n    if (model.renderable.getNumberOfClippingPlanes()) {\n      // add all the clipping planes\n      var numClipPlanes = model.renderable.getNumberOfClippingPlanes();\n\n      if (numClipPlanes > 6) {\n        vtkErrorMacro$1('OpenGL has a limit of 6 clipping planes');\n        numClipPlanes = 6;\n      }\n\n      var shiftScaleEnabled = cellBO.getCABO().getCoordShiftAndScaleEnabled();\n      var inverseShiftScaleMatrix = shiftScaleEnabled ? cellBO.getCABO().getInverseShiftAndScaleMatrix() : null;\n      var mat = inverseShiftScaleMatrix ? mat4.copy(model.imagematinv, actor.getMatrix()) : actor.getMatrix();\n\n      if (inverseShiftScaleMatrix) {\n        mat4.transpose(mat, mat);\n        mat4.multiply(mat, mat, inverseShiftScaleMatrix);\n        mat4.transpose(mat, mat);\n      } // transform crop plane normal with transpose(inverse(worldToIndex))\n\n\n      mat4.transpose(model.imagemat, model.currentInput.getIndexToWorld());\n      mat4.multiply(model.imagematinv, mat, model.imagemat);\n      var planeEquations = [];\n\n      for (var _i3 = 0; _i3 < numClipPlanes; _i3++) {\n        var planeEquation = [];\n        model.renderable.getClippingPlaneInDataCoords(model.imagematinv, _i3, planeEquation);\n\n        for (var j = 0; j < 4; j++) {\n          planeEquations.push(planeEquation[j]);\n        }\n      }\n\n      cellBO.getProgram().setUniformi('numClipPlanes', numClipPlanes);\n      cellBO.getProgram().setUniform4fv('clipPlanes', planeEquations);\n    }\n  };\n\n  publicAPI.setCameraShaderParameters = function (cellBO, ren, actor) {\n    var program = cellBO.getProgram();\n    var actMats = model.openGLImageSlice.getKeyMatrices();\n    var image = model.currentInput;\n    var i2wmat4 = image.getIndexToWorld();\n    mat4.multiply(model.imagemat, actMats.mcwc, i2wmat4);\n    var keyMats = model.openGLCamera.getKeyMatrices(ren);\n    mat4.multiply(model.imagemat, keyMats.wcpc, model.imagemat);\n\n    if (cellBO.getCABO().getCoordShiftAndScaleEnabled()) {\n      var inverseShiftScaleMat = cellBO.getCABO().getInverseShiftAndScaleMatrix();\n      mat4.multiply(model.imagemat, model.imagemat, inverseShiftScaleMat);\n    }\n\n    program.setUniformMatrix('MCPCMatrix', model.imagemat);\n  };\n\n  publicAPI.setPropertyShaderParameters = function (cellBO, ren, actor) {\n    var program = cellBO.getProgram();\n    var ppty = actor.getProperty();\n    var opacity = ppty.getOpacity();\n    program.setUniformf('opacity', opacity);\n  };\n\n  publicAPI.renderPieceStart = function (ren, actor) {\n    // make sure the BOs are up to date\n    publicAPI.updateBufferObjects(ren, actor); // Bind the OpenGL, this is shared between the different primitive/cell types.\n\n    model.lastBoundBO = null;\n  };\n\n  publicAPI.renderPieceDraw = function (ren, actor) {\n    var gl = model.context; // activate the texture\n\n    model.openGLTexture.activate();\n    model.colorTexture.activate();\n    model.pwfTexture.activate(); // draw polygons\n\n    if (model.tris.getCABO().getElementCount()) {\n      // First we do the triangles, update the shader, set uniforms, etc.\n      publicAPI.updateShaders(model.tris, ren, actor);\n      gl.drawArrays(gl.TRIANGLES, 0, model.tris.getCABO().getElementCount());\n      model.tris.getVAO().release();\n    }\n\n    model.openGLTexture.deactivate();\n    model.colorTexture.deactivate();\n    model.pwfTexture.deactivate();\n  };\n\n  publicAPI.renderPieceFinish = function (ren, actor) {};\n\n  publicAPI.renderPiece = function (ren, actor) {\n    // Make sure that we have been properly initialized.\n    // if (ren.getRenderWindow().checkAbortStatus()) {\n    //   return;\n    // }\n    publicAPI.invokeEvent({\n      type: 'StartEvent'\n    });\n    model.renderable.update();\n    model.currentInput = model.renderable.getCurrentImage();\n    publicAPI.invokeEvent({\n      type: 'EndEvent'\n    });\n\n    if (!model.currentInput) {\n      vtkErrorMacro('No input!');\n      return;\n    }\n\n    publicAPI.renderPieceStart(ren, actor);\n    publicAPI.renderPieceDraw(ren, actor);\n    publicAPI.renderPieceFinish(ren, actor);\n  };\n\n  publicAPI.computeBounds = function (ren, actor) {\n    if (!publicAPI.getInput()) {\n      uninitializeBounds(model.bounds);\n      return;\n    }\n\n    model.bounds = publicAPI.getInput().getBounds();\n  };\n\n  publicAPI.updateBufferObjects = function (ren, actor) {\n    // Rebuild buffers if needed\n    if (publicAPI.getNeedToRebuildBufferObjects(ren, actor)) {\n      publicAPI.buildBufferObjects(ren, actor);\n    }\n  };\n\n  publicAPI.getNeedToRebuildBufferObjects = function (ren, actor) {\n    // first do a coarse check\n    if (model.VBOBuildTime.getMTime() < publicAPI.getMTime() || model.VBOBuildTime.getMTime() < actor.getMTime() || model.VBOBuildTime.getMTime() < model.renderable.getMTime() || model.VBOBuildTime.getMTime() < actor.getProperty().getMTime() || model.VBOBuildTime.getMTime() < model.currentInput.getMTime()) {\n      return true;\n    }\n\n    return false;\n  };\n\n  publicAPI.buildBufferObjects = function (ren, actor) {\n    var image = model.currentInput;\n\n    if (!image) {\n      return;\n    }\n\n    var imgScalars = image.getPointData() && image.getPointData().getScalars();\n\n    if (!imgScalars) {\n      return;\n    }\n\n    var dataType = imgScalars.getDataType();\n    var numComp = imgScalars.getNumberOfComponents();\n    var actorProperty = actor.getProperty(); // set interpolation on the texture based on property setting\n\n    var iType = actorProperty.getInterpolationType();\n\n    if (iType === InterpolationType.NEAREST) {\n      model.colorTexture.setMinificationFilter(Filter.NEAREST);\n      model.colorTexture.setMagnificationFilter(Filter.NEAREST);\n      model.pwfTexture.setMinificationFilter(Filter.NEAREST);\n      model.pwfTexture.setMagnificationFilter(Filter.NEAREST);\n    } else {\n      model.colorTexture.setMinificationFilter(Filter.LINEAR);\n      model.colorTexture.setMagnificationFilter(Filter.LINEAR);\n      model.pwfTexture.setMinificationFilter(Filter.LINEAR);\n      model.pwfTexture.setMagnificationFilter(Filter.LINEAR);\n    }\n\n    var iComps = actorProperty.getIndependentComponents();\n    var numIComps = iComps ? numComp : 1;\n    var textureHeight = iComps ? 2 * numIComps : 1;\n    var cfunToString = computeFnToString(actorProperty, actorProperty.getRGBTransferFunction, numIComps);\n\n    if (model.colorTextureString !== cfunToString) {\n      var cWidth = 1024;\n      var cSize = cWidth * textureHeight * 3;\n      var cTable = new Uint8Array(cSize);\n      var cfun = actorProperty.getRGBTransferFunction();\n\n      if (cfun) {\n        var tmpTable = new Float32Array(cWidth * 3);\n\n        for (var c = 0; c < numIComps; c++) {\n          cfun = actorProperty.getRGBTransferFunction(c);\n          var cRange = cfun.getRange();\n          cfun.getTable(cRange[0], cRange[1], cWidth, tmpTable, 1);\n\n          if (iComps) {\n            for (var i = 0; i < cWidth * 3; i++) {\n              cTable[c * cWidth * 6 + i] = 255.0 * tmpTable[i];\n              cTable[c * cWidth * 6 + i + cWidth * 3] = 255.0 * tmpTable[i];\n            }\n          } else {\n            for (var _i4 = 0; _i4 < cWidth * 3; _i4++) {\n              cTable[c * cWidth * 6 + _i4] = 255.0 * tmpTable[_i4];\n            }\n          }\n        }\n\n        model.colorTexture.create2DFromRaw(cWidth, textureHeight, 3, VtkDataTypes.UNSIGNED_CHAR, cTable);\n      } else {\n        for (var _i5 = 0; _i5 < cWidth * 3; ++_i5) {\n          cTable[_i5] = 255.0 * _i5 / ((cWidth - 1) * 3);\n          cTable[_i5 + 1] = 255.0 * _i5 / ((cWidth - 1) * 3);\n          cTable[_i5 + 2] = 255.0 * _i5 / ((cWidth - 1) * 3);\n        }\n\n        model.colorTexture.create2DFromRaw(cWidth, 1, 3, VtkDataTypes.UNSIGNED_CHAR, cTable);\n      }\n\n      model.colorTextureString = cfunToString;\n    } // Build piecewise function buffer.  This buffer is used either\n    // for component weighting or opacity, depending on whether we're\n    // rendering components independently or not.\n\n\n    var pwfunToString = computeFnToString(actorProperty, actorProperty.getPiecewiseFunction, numIComps);\n\n    if (model.pwfTextureString !== pwfunToString) {\n      var pwfWidth = 1024;\n      var pwfSize = pwfWidth * textureHeight;\n      var pwfTable = new Uint8Array(pwfSize);\n      var pwfun = actorProperty.getPiecewiseFunction(); // support case where pwfun is added/removed\n\n      model.pwfTexture.resetFormatAndType();\n\n      if (pwfun) {\n        var pwfFloatTable = new Float32Array(pwfSize);\n\n        var _tmpTable = new Float32Array(pwfWidth);\n\n        for (var _c = 0; _c < numIComps; ++_c) {\n          pwfun = actorProperty.getPiecewiseFunction(_c);\n\n          if (pwfun === null) {\n            // Piecewise constant max if no function supplied for this component\n            pwfFloatTable.fill(1.0);\n          } else {\n            var pwfRange = pwfun.getRange();\n            pwfun.getTable(pwfRange[0], pwfRange[1], pwfWidth, _tmpTable, 1); // adjust for sample distance etc\n\n            if (iComps) {\n              for (var _i6 = 0; _i6 < pwfWidth; _i6++) {\n                pwfFloatTable[_c * pwfWidth * 2 + _i6] = _tmpTable[_i6];\n                pwfFloatTable[_c * pwfWidth * 2 + _i6 + pwfWidth] = _tmpTable[_i6];\n              }\n            } else {\n              for (var _i7 = 0; _i7 < pwfWidth; _i7++) {\n                pwfFloatTable[_c * pwfWidth * 2 + _i7] = _tmpTable[_i7];\n              }\n            }\n          }\n        }\n\n        model.pwfTexture.create2DFromRaw(pwfWidth, textureHeight, 1, VtkDataTypes.FLOAT, pwfFloatTable);\n      } else {\n        // default is opaque\n        pwfTable.fill(255.0);\n        model.pwfTexture.create2DFromRaw(pwfWidth, 1, 1, VtkDataTypes.UNSIGNED_CHAR, pwfTable);\n      }\n\n      model.pwfTextureString = pwfunToString;\n    } // Find what IJK axis and what direction to slice along\n\n\n    var _model$renderable$get = model.renderable.getClosestIJKAxis(),\n        ijkMode = _model$renderable$get.ijkMode; // Find the IJK slice\n\n\n    var slice = model.renderable.getSlice();\n\n    if (ijkMode !== model.renderable.getSlicingMode()) {\n      // If not IJK slicing, get the IJK slice from the XYZ position/slice\n      slice = model.renderable.getSliceAtPosition(slice);\n    } // Use sub-Slice number/offset if mapper being used is vtkImageArrayMapper,\n    // since this mapper uses a collection of vtkImageData (and not just a single vtkImageData).\n\n\n    var nSlice = model.renderable.isA('vtkImageArrayMapper') ? model.renderable.getSubSlice() // get subSlice of the current (possibly multi-frame) image\n    : Math.round(slice); // Find sliceOffset\n\n    var ext = image.getExtent();\n    var sliceOffset;\n\n    if (ijkMode === SlicingMode.I) {\n      sliceOffset = nSlice - ext[0];\n    }\n\n    if (ijkMode === SlicingMode.J) {\n      sliceOffset = nSlice - ext[2];\n    }\n\n    if (ijkMode === SlicingMode.K || ijkMode === SlicingMode.NONE) {\n      sliceOffset = nSlice - ext[4];\n    } // rebuild the VBO if the data has changed\n\n\n    var toString = \"\".concat(slice, \"A\").concat(image.getMTime(), \"A\").concat(imgScalars.getMTime(), \"B\").concat(publicAPI.getMTime(), \"C\").concat(model.renderable.getSlicingMode(), \"D\").concat(actor.getProperty().getInterpolationType());\n\n    if (model.VBOBuildString !== toString) {\n      var _model$renderable$get2, _model$renderable;\n\n      // Build the VBOs\n      var dims = image.getDimensions();\n\n      if (iType === InterpolationType.NEAREST) {\n        if (new Set([1, 3, 4]).has(numComp) && dataType === VtkDataTypes.UNSIGNED_CHAR && !iComps) {\n          model.openGLTexture.setGenerateMipmap(true);\n          model.openGLTexture.setMinificationFilter(Filter.NEAREST);\n        } else {\n          model.openGLTexture.setMinificationFilter(Filter.NEAREST);\n        }\n\n        model.openGLTexture.setMagnificationFilter(Filter.NEAREST);\n      } else {\n        if (numComp === 4 && dataType === VtkDataTypes.UNSIGNED_CHAR && !iComps) {\n          model.openGLTexture.setGenerateMipmap(true);\n          model.openGLTexture.setMinificationFilter(Filter.LINEAR_MIPMAP_LINEAR);\n        } else {\n          model.openGLTexture.setMinificationFilter(Filter.LINEAR);\n        }\n\n        model.openGLTexture.setMagnificationFilter(Filter.LINEAR);\n      }\n\n      model.openGLTexture.setWrapS(Wrap.CLAMP_TO_EDGE);\n      model.openGLTexture.setWrapT(Wrap.CLAMP_TO_EDGE);\n      var sliceSize = dims[0] * dims[1] * numComp;\n      var ptsArray = new Float32Array(12);\n      var tcoordArray = new Float32Array(8);\n\n      for (var _i8 = 0; _i8 < 4; _i8++) {\n        tcoordArray[_i8 * 2] = _i8 % 2 ? 1.0 : 0.0;\n        tcoordArray[_i8 * 2 + 1] = _i8 > 1 ? 1.0 : 0.0;\n      } // Determine depth position of the slicing plane in the scene.\n      // Slicing modes X, Y, and Z use a continuous axis position, whereas\n      // slicing modes I, J, and K should use discrete positions.\n\n\n      var sliceDepth = [SlicingMode.X, SlicingMode.Y, SlicingMode.Z].includes(model.renderable.getSlicingMode()) ? slice : nSlice;\n      var spatialExt = image.getSpatialExtent();\n      var basicScalars = imgScalars.getData();\n      var scalars = null; // Get right scalars according to slicing mode\n\n      if (ijkMode === SlicingMode.I) {\n        scalars = new basicScalars.constructor(dims[2] * dims[1] * numComp);\n        var id = 0;\n\n        for (var k = 0; k < dims[2]; k++) {\n          for (var j = 0; j < dims[1]; j++) {\n            var bsIdx = (sliceOffset + j * dims[0] + k * dims[0] * dims[1]) * numComp;\n            id = (k * dims[1] + j) * numComp;\n            var end = bsIdx + numComp;\n\n            while (bsIdx < end) {\n              scalars[id++] = basicScalars[bsIdx++];\n            }\n          }\n        }\n\n        dims[0] = dims[1];\n        dims[1] = dims[2];\n        ptsArray[0] = sliceDepth;\n        ptsArray[1] = spatialExt[2];\n        ptsArray[2] = spatialExt[4];\n        ptsArray[3] = sliceDepth;\n        ptsArray[4] = spatialExt[3];\n        ptsArray[5] = spatialExt[4];\n        ptsArray[6] = sliceDepth;\n        ptsArray[7] = spatialExt[2];\n        ptsArray[8] = spatialExt[5];\n        ptsArray[9] = sliceDepth;\n        ptsArray[10] = spatialExt[3];\n        ptsArray[11] = spatialExt[5];\n      } else if (ijkMode === SlicingMode.J) {\n        scalars = new basicScalars.constructor(dims[2] * dims[0] * numComp);\n        var _id = 0;\n\n        for (var _k = 0; _k < dims[2]; _k++) {\n          for (var _i9 = 0; _i9 < dims[0]; _i9++) {\n            var _bsIdx = (_i9 + sliceOffset * dims[0] + _k * dims[0] * dims[1]) * numComp;\n\n            _id = (_k * dims[0] + _i9) * numComp;\n\n            var _end = _bsIdx + numComp;\n\n            while (_bsIdx < _end) {\n              scalars[_id++] = basicScalars[_bsIdx++];\n            }\n          }\n        }\n\n        dims[1] = dims[2];\n        ptsArray[0] = spatialExt[0];\n        ptsArray[1] = sliceDepth;\n        ptsArray[2] = spatialExt[4];\n        ptsArray[3] = spatialExt[1];\n        ptsArray[4] = sliceDepth;\n        ptsArray[5] = spatialExt[4];\n        ptsArray[6] = spatialExt[0];\n        ptsArray[7] = sliceDepth;\n        ptsArray[8] = spatialExt[5];\n        ptsArray[9] = spatialExt[1];\n        ptsArray[10] = sliceDepth;\n        ptsArray[11] = spatialExt[5];\n      } else if (ijkMode === SlicingMode.K || ijkMode === SlicingMode.NONE) {\n        scalars = basicScalars.subarray(sliceOffset * sliceSize, (sliceOffset + 1) * sliceSize);\n        ptsArray[0] = spatialExt[0];\n        ptsArray[1] = spatialExt[2];\n        ptsArray[2] = sliceDepth;\n        ptsArray[3] = spatialExt[1];\n        ptsArray[4] = spatialExt[2];\n        ptsArray[5] = sliceDepth;\n        ptsArray[6] = spatialExt[0];\n        ptsArray[7] = spatialExt[3];\n        ptsArray[8] = sliceDepth;\n        ptsArray[9] = spatialExt[1];\n        ptsArray[10] = spatialExt[3];\n        ptsArray[11] = sliceDepth;\n      } else {\n        vtkErrorMacro('Reformat slicing not yet supported.');\n      }\n\n      model.openGLTexture.create2DFilterableFromRaw(dims[0], dims[1], numComp, imgScalars.getDataType(), scalars, (_model$renderable$get2 = (_model$renderable = model.renderable).getPreferSizeOverAccuracy) === null || _model$renderable$get2 === void 0 ? void 0 : _model$renderable$get2.call(_model$renderable));\n      model.openGLTexture.activate();\n      model.openGLTexture.sendParameters();\n      model.openGLTexture.deactivate();\n      var points = vtkDataArray.newInstance({\n        numberOfComponents: 3,\n        values: ptsArray\n      });\n      points.setName('points');\n      var tcoords = vtkDataArray.newInstance({\n        numberOfComponents: 2,\n        values: tcoordArray\n      });\n      tcoords.setName('tcoords');\n      var cellArray = new Uint16Array(8);\n      cellArray[0] = 3;\n      cellArray[1] = 0;\n      cellArray[2] = 1;\n      cellArray[3] = 3;\n      cellArray[4] = 3;\n      cellArray[5] = 0;\n      cellArray[6] = 3;\n      cellArray[7] = 2;\n      var cells = vtkDataArray.newInstance({\n        numberOfComponents: 1,\n        values: cellArray\n      });\n      model.tris.getCABO().createVBO(cells, 'polys', Representation.SURFACE, {\n        points: points,\n        tcoords: tcoords,\n        cellOffset: 0\n      });\n      model.VBOBuildTime.modified();\n      model.VBOBuildString = toString;\n    }\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\n\nvar DEFAULT_VALUES = {\n  VBOBuildTime: 0,\n  VBOBuildString: null,\n  openGLTexture: null,\n  tris: null,\n  imagemat: null,\n  imagematinv: null,\n  colorTexture: null,\n  pwfTexture: null,\n  lastHaveSeenDepthRequest: false,\n  haveSeenDepthRequest: false,\n  lastTextureComponents: 0\n}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Inheritance\n\n  vtkViewNode.extend(publicAPI, model, initialValues);\n  vtkReplacementShaderMapper.implementReplaceShaderCoincidentOffset(publicAPI, model, initialValues);\n  vtkReplacementShaderMapper.implementBuildShadersWithReplacements(publicAPI, model, initialValues);\n  model.tris = vtkHelper.newInstance();\n  model.openGLTexture = vtkOpenGLTexture.newInstance({\n    resizable: true\n  });\n  model.colorTexture = vtkOpenGLTexture.newInstance({\n    resizable: true\n  });\n  model.pwfTexture = vtkOpenGLTexture.newInstance({\n    resizable: true\n  });\n  model.imagemat = mat4.identity(new Float64Array(16));\n  model.imagematinv = mat4.identity(new Float64Array(16)); // Build VTK API\n\n  setGet(publicAPI, model, []);\n  model.VBOBuildTime = {};\n  obj(model.VBOBuildTime); // Object methods\n\n  vtkOpenGLImageMapper(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = newInstance$1(extend, 'vtkOpenGLImageMapper'); // ----------------------------------------------------------------------------\n\nvar vtkImageMapper = {\n  newInstance: newInstance,\n  extend: extend\n}; // Register ourself to OpenGL backend if imported\n\nregisterOverride('vtkAbstractImageMapper', newInstance);\n\nexport { vtkImageMapper as default, extend, newInstance };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}