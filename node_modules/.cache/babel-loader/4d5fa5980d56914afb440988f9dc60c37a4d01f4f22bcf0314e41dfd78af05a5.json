{"ast":null,"code":"import { mat3, mat4 } from 'gl-matrix';\nimport { newInstance as newInstance$1, obj, setGet, get, vtkErrorMacro as vtkErrorMacro$1 } from '../../macros.js';\nimport vtkDataArray from '../../Common/Core/DataArray.js';\nimport vtkHelper from './Helper.js';\nimport vtkViewNode from '../SceneGraph/ViewNode.js';\nimport vtkOpenGLTexture from './Texture.js';\nimport { Representation } from '../Core/Property/Constants.js';\nimport { registerOverride } from './ViewNodeFactory.js';\nvar vtkErrorMacro = vtkErrorMacro$1; // ----------------------------------------------------------------------------\n// vtkOpenGLSkybox methods\n// ----------------------------------------------------------------------------\n\nfunction vtkOpenGLSkybox(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkOpenGLSkybox'); // Builds myself.\n\n  publicAPI.buildPass = function (prepass) {\n    if (prepass) {\n      model._openGLRenderer = publicAPI.getFirstAncestorOfType('vtkOpenGLRenderer');\n      model._openGLRenderWindow = model._openGLRenderer.getParent();\n      model.context = model._openGLRenderWindow.getContext();\n      model.tris.setOpenGLRenderWindow(model._openGLRenderWindow);\n      model.openGLTexture.setOpenGLRenderWindow(model._openGLRenderWindow);\n      var ren = model._openGLRenderer.getRenderable();\n      model.openGLCamera = model._openGLRenderer.getViewNodeFor(ren.getActiveCamera());\n    }\n  };\n  publicAPI.queryPass = function (prepass, renderPass) {\n    if (prepass) {\n      if (!model.renderable || !model.renderable.getVisibility()) {\n        return;\n      }\n      renderPass.incrementOpaqueActorCount();\n    }\n  };\n  publicAPI.opaquePass = function (prepass, renderPass) {\n    if (prepass && !model._openGLRenderer.getSelector()) {\n      publicAPI.updateBufferObjects();\n      model.context.depthMask(true);\n      model._openGLRenderWindow.getShaderCache().readyShaderProgram(model.tris.getProgram());\n      model.openGLTexture.render(model._openGLRenderWindow);\n      var texUnit = model.openGLTexture.getTextureUnit();\n      model.tris.getProgram().setUniformi('sbtexture', texUnit);\n      var ren = model._openGLRenderer.getRenderable();\n      var keyMats = model.openGLCamera.getKeyMatrices(ren);\n      var imat = new Float64Array(16);\n      mat4.invert(imat, keyMats.wcpc);\n      model.tris.getProgram().setUniformMatrix('IMCPCMatrix', imat);\n      if (model.lastFormat === 'box') {\n        var camPos = ren.getActiveCamera().getPosition();\n        model.tris.getProgram().setUniform3f('camPos', camPos[0], camPos[1], camPos[2]);\n      }\n      model.tris.getVAO().bind(); // draw polygons\n\n      model.context.drawArrays(model.context.TRIANGLES, 0, model.tris.getCABO().getElementCount());\n      model.tris.getVAO().release();\n      model.openGLTexture.deactivate();\n    }\n  };\n  publicAPI.updateBufferObjects = function () {\n    // build the VBO if needed, only happens once\n    if (!model.tris.getCABO().getElementCount()) {\n      var ptsArray = new Float32Array(12);\n      for (var i = 0; i < 4; i++) {\n        ptsArray[i * 3] = i % 2 * 2 - 1.0;\n        ptsArray[i * 3 + 1] = i > 1 ? 1.0 : -1.0;\n        ptsArray[i * 3 + 2] = 1.0;\n      }\n      var points = vtkDataArray.newInstance({\n        numberOfComponents: 3,\n        values: ptsArray\n      });\n      points.setName('points');\n      var cellArray = new Uint16Array(8);\n      cellArray[0] = 3;\n      cellArray[1] = 0;\n      cellArray[2] = 1;\n      cellArray[3] = 3;\n      cellArray[4] = 3;\n      cellArray[5] = 0;\n      cellArray[6] = 3;\n      cellArray[7] = 2;\n      var cells = vtkDataArray.newInstance({\n        numberOfComponents: 1,\n        values: cellArray\n      });\n      model.tris.getCABO().createVBO(cells, 'polys', Representation.SURFACE, {\n        points: points,\n        cellOffset: 0\n      });\n    } // update the program?\n\n    if (model.renderable.getFormat() !== model.lastFormat) {\n      model.lastFormat = model.renderable.getFormat();\n      if (model.lastFormat === 'box') {\n        // we invert Y below because opengl is messed up!\n        // Cube Maps have been specified to follow the RenderMan\n        // specification (for whatever reason), and RenderMan\n        // assumes the images' origin being in the upper left,\n        // contrary to the usual OpenGL behaviour of having the\n        // image origin in the lower left. That's why things get\n        // swapped in the Y direction. It totally breaks with the usual\n        // OpenGL semantics and doesn't make sense at all.\n        // But now we're stuck with it.  From\n        // https://stackoverflow.com/questions/11685608/convention-of-faces-in-opengl-cubemapping\n        //\n        model.tris.setProgram(model._openGLRenderWindow.getShaderCache().readyShaderProgramArray(\"//VTK::System::Dec\\n             attribute vec3 vertexMC;\\n             uniform mat4 IMCPCMatrix;\\n             varying vec3 TexCoords;\\n             void main () {\\n              gl_Position = vec4(vertexMC.xyz, 1.0);\\n              vec4 wpos = IMCPCMatrix * gl_Position;\\n              TexCoords = wpos.xyz/wpos.w;\\n             }\", \"//VTK::System::Dec\\n             //VTK::Output::Dec\\n             varying vec3 TexCoords;\\n             uniform samplerCube sbtexture;\\n             uniform vec3 camPos;\\n             void main () {\\n               // skybox looks from inside out\\n               // which means we have to adjust\\n               // our tcoords. Otherwise text would\\n               // be flipped\\n               vec3 tc = normalize(TexCoords - camPos);\\n               if (abs(tc.z) < max(abs(tc.x),abs(tc.y)))\\n               {\\n                 tc = vec3(1.0, 1.0, -1.0) * tc;\\n               }\\n               else\\n               {\\n                 tc = vec3(-1.0, 1.0, 1.0) * tc;\\n               }\\n               gl_FragData[0] = textureCube(sbtexture, tc);\\n             }\", ''));\n      }\n      if (model.lastFormat === 'background') {\n        // maps the texture to the window\n        model.tris.setProgram(model._openGLRenderWindow.getShaderCache().readyShaderProgramArray(\"//VTK::System::Dec\\n             attribute vec3 vertexMC;\\n             uniform mat4 IMCPCMatrix;\\n             varying vec2 TexCoords;\\n             void main () {\\n              gl_Position = vec4(vertexMC.xyz, 1.0);\\n              vec4 wpos = IMCPCMatrix * gl_Position;\\n              TexCoords = vec2(vertexMC.x, vertexMC.y)*0.5 + 0.5;\\n             }\", \"//VTK::System::Dec\\n             //VTK::Output::Dec\\n             varying vec2 TexCoords;\\n             uniform sampler2D sbtexture;\\n             void main () {\\n               gl_FragData[0] = texture2D(sbtexture, TexCoords);\\n             }\", ''));\n      }\n      model.tris.getShaderSourceTime().modified();\n      model.tris.getVAO().bind();\n      if (!model.tris.getVAO().addAttributeArray(model.tris.getProgram(), model.tris.getCABO(), 'vertexMC', model.tris.getCABO().getVertexOffset(), model.tris.getCABO().getStride(), model.context.FLOAT, 3, model.context.FALSE)) {\n        vtkErrorMacro('Error setting vertexMC in shader VAO.');\n      }\n    } // set/update the texture map if needed\n\n    var tmaps = model.renderable.getTextures();\n    if (!tmaps.length) {\n      vtkErrorMacro('vtkSkybox requires a texture map');\n    }\n    if (model.openGLTexture.getRenderable() !== tmaps[0]) {\n      model.openGLTexture.releaseGraphicsResources(model._openGLRenderWindow);\n      model.openGLTexture.setRenderable(tmaps[0]);\n    }\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nvar DEFAULT_VALUES = {\n  context: null\n}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Inheritance\n\n  vtkViewNode.extend(publicAPI, model, initialValues);\n  model.openGLTexture = vtkOpenGLTexture.newInstance();\n  model.tris = vtkHelper.newInstance();\n  model.keyMatrixTime = {};\n  obj(model.keyMatrixTime, {\n    mtime: 0\n  });\n  model.keyMatrices = {\n    normalMatrix: mat3.identity(new Float64Array(9)),\n    mcwc: mat4.identity(new Float64Array(16))\n  }; // Build VTK API\n\n  setGet(publicAPI, model, ['context']);\n  get(publicAPI, model, ['activeTextures']); // Object methods\n\n  vtkOpenGLSkybox(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = newInstance$1(extend); // ----------------------------------------------------------------------------\n\nvar vtkSkybox = {\n  newInstance: newInstance,\n  extend: extend\n}; // Register ourself to OpenGL backend if imported\n\nregisterOverride('vtkSkybox', newInstance);\nexport { vtkSkybox as default, extend, newInstance };","map":{"version":3,"names":["mat3","mat4","newInstance","newInstance$1","obj","setGet","get","vtkErrorMacro","vtkErrorMacro$1","vtkDataArray","vtkHelper","vtkViewNode","vtkOpenGLTexture","Representation","registerOverride","vtkOpenGLSkybox","publicAPI","model","classHierarchy","push","buildPass","prepass","_openGLRenderer","getFirstAncestorOfType","_openGLRenderWindow","getParent","context","getContext","tris","setOpenGLRenderWindow","openGLTexture","ren","getRenderable","openGLCamera","getViewNodeFor","getActiveCamera","queryPass","renderPass","renderable","getVisibility","incrementOpaqueActorCount","opaquePass","getSelector","updateBufferObjects","depthMask","getShaderCache","readyShaderProgram","getProgram","render","texUnit","getTextureUnit","setUniformi","keyMats","getKeyMatrices","imat","Float64Array","invert","wcpc","setUniformMatrix","lastFormat","camPos","getPosition","setUniform3f","getVAO","bind","drawArrays","TRIANGLES","getCABO","getElementCount","release","deactivate","ptsArray","Float32Array","i","points","numberOfComponents","values","setName","cellArray","Uint16Array","cells","createVBO","SURFACE","cellOffset","getFormat","setProgram","readyShaderProgramArray","getShaderSourceTime","modified","addAttributeArray","getVertexOffset","getStride","FLOAT","FALSE","tmaps","getTextures","length","releaseGraphicsResources","setRenderable","DEFAULT_VALUES","extend","initialValues","arguments","undefined","Object","assign","keyMatrixTime","mtime","keyMatrices","normalMatrix","identity","mcwc","vtkSkybox","default"],"sources":["/home/rakshith/Documents/RemoteRendering/vtk-js-react-app/node_modules/@kitware/vtk.js/Rendering/OpenGL/Skybox.js"],"sourcesContent":["import { mat3, mat4 } from 'gl-matrix';\nimport { newInstance as newInstance$1, obj, setGet, get, vtkErrorMacro as vtkErrorMacro$1 } from '../../macros.js';\nimport vtkDataArray from '../../Common/Core/DataArray.js';\nimport vtkHelper from './Helper.js';\nimport vtkViewNode from '../SceneGraph/ViewNode.js';\nimport vtkOpenGLTexture from './Texture.js';\nimport { Representation } from '../Core/Property/Constants.js';\nimport { registerOverride } from './ViewNodeFactory.js';\n\nvar vtkErrorMacro = vtkErrorMacro$1; // ----------------------------------------------------------------------------\n// vtkOpenGLSkybox methods\n// ----------------------------------------------------------------------------\n\nfunction vtkOpenGLSkybox(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkOpenGLSkybox'); // Builds myself.\n\n  publicAPI.buildPass = function (prepass) {\n    if (prepass) {\n      model._openGLRenderer = publicAPI.getFirstAncestorOfType('vtkOpenGLRenderer');\n      model._openGLRenderWindow = model._openGLRenderer.getParent();\n      model.context = model._openGLRenderWindow.getContext();\n      model.tris.setOpenGLRenderWindow(model._openGLRenderWindow);\n      model.openGLTexture.setOpenGLRenderWindow(model._openGLRenderWindow);\n\n      var ren = model._openGLRenderer.getRenderable();\n\n      model.openGLCamera = model._openGLRenderer.getViewNodeFor(ren.getActiveCamera());\n    }\n  };\n\n  publicAPI.queryPass = function (prepass, renderPass) {\n    if (prepass) {\n      if (!model.renderable || !model.renderable.getVisibility()) {\n        return;\n      }\n\n      renderPass.incrementOpaqueActorCount();\n    }\n  };\n\n  publicAPI.opaquePass = function (prepass, renderPass) {\n    if (prepass && !model._openGLRenderer.getSelector()) {\n      publicAPI.updateBufferObjects();\n      model.context.depthMask(true);\n\n      model._openGLRenderWindow.getShaderCache().readyShaderProgram(model.tris.getProgram());\n\n      model.openGLTexture.render(model._openGLRenderWindow);\n      var texUnit = model.openGLTexture.getTextureUnit();\n      model.tris.getProgram().setUniformi('sbtexture', texUnit);\n\n      var ren = model._openGLRenderer.getRenderable();\n\n      var keyMats = model.openGLCamera.getKeyMatrices(ren);\n      var imat = new Float64Array(16);\n      mat4.invert(imat, keyMats.wcpc);\n      model.tris.getProgram().setUniformMatrix('IMCPCMatrix', imat);\n\n      if (model.lastFormat === 'box') {\n        var camPos = ren.getActiveCamera().getPosition();\n        model.tris.getProgram().setUniform3f('camPos', camPos[0], camPos[1], camPos[2]);\n      }\n\n      model.tris.getVAO().bind(); // draw polygons\n\n      model.context.drawArrays(model.context.TRIANGLES, 0, model.tris.getCABO().getElementCount());\n      model.tris.getVAO().release();\n      model.openGLTexture.deactivate();\n    }\n  };\n\n  publicAPI.updateBufferObjects = function () {\n    // build the VBO if needed, only happens once\n    if (!model.tris.getCABO().getElementCount()) {\n      var ptsArray = new Float32Array(12);\n\n      for (var i = 0; i < 4; i++) {\n        ptsArray[i * 3] = i % 2 * 2 - 1.0;\n        ptsArray[i * 3 + 1] = i > 1 ? 1.0 : -1.0;\n        ptsArray[i * 3 + 2] = 1.0;\n      }\n\n      var points = vtkDataArray.newInstance({\n        numberOfComponents: 3,\n        values: ptsArray\n      });\n      points.setName('points');\n      var cellArray = new Uint16Array(8);\n      cellArray[0] = 3;\n      cellArray[1] = 0;\n      cellArray[2] = 1;\n      cellArray[3] = 3;\n      cellArray[4] = 3;\n      cellArray[5] = 0;\n      cellArray[6] = 3;\n      cellArray[7] = 2;\n      var cells = vtkDataArray.newInstance({\n        numberOfComponents: 1,\n        values: cellArray\n      });\n      model.tris.getCABO().createVBO(cells, 'polys', Representation.SURFACE, {\n        points: points,\n        cellOffset: 0\n      });\n    } // update the program?\n\n\n    if (model.renderable.getFormat() !== model.lastFormat) {\n      model.lastFormat = model.renderable.getFormat();\n\n      if (model.lastFormat === 'box') {\n        // we invert Y below because opengl is messed up!\n        // Cube Maps have been specified to follow the RenderMan\n        // specification (for whatever reason), and RenderMan\n        // assumes the images' origin being in the upper left,\n        // contrary to the usual OpenGL behaviour of having the\n        // image origin in the lower left. That's why things get\n        // swapped in the Y direction. It totally breaks with the usual\n        // OpenGL semantics and doesn't make sense at all.\n        // But now we're stuck with it.  From\n        // https://stackoverflow.com/questions/11685608/convention-of-faces-in-opengl-cubemapping\n        //\n        model.tris.setProgram(model._openGLRenderWindow.getShaderCache().readyShaderProgramArray(\"//VTK::System::Dec\\n             attribute vec3 vertexMC;\\n             uniform mat4 IMCPCMatrix;\\n             varying vec3 TexCoords;\\n             void main () {\\n              gl_Position = vec4(vertexMC.xyz, 1.0);\\n              vec4 wpos = IMCPCMatrix * gl_Position;\\n              TexCoords = wpos.xyz/wpos.w;\\n             }\", \"//VTK::System::Dec\\n             //VTK::Output::Dec\\n             varying vec3 TexCoords;\\n             uniform samplerCube sbtexture;\\n             uniform vec3 camPos;\\n             void main () {\\n               // skybox looks from inside out\\n               // which means we have to adjust\\n               // our tcoords. Otherwise text would\\n               // be flipped\\n               vec3 tc = normalize(TexCoords - camPos);\\n               if (abs(tc.z) < max(abs(tc.x),abs(tc.y)))\\n               {\\n                 tc = vec3(1.0, 1.0, -1.0) * tc;\\n               }\\n               else\\n               {\\n                 tc = vec3(-1.0, 1.0, 1.0) * tc;\\n               }\\n               gl_FragData[0] = textureCube(sbtexture, tc);\\n             }\", ''));\n      }\n\n      if (model.lastFormat === 'background') {\n        // maps the texture to the window\n        model.tris.setProgram(model._openGLRenderWindow.getShaderCache().readyShaderProgramArray(\"//VTK::System::Dec\\n             attribute vec3 vertexMC;\\n             uniform mat4 IMCPCMatrix;\\n             varying vec2 TexCoords;\\n             void main () {\\n              gl_Position = vec4(vertexMC.xyz, 1.0);\\n              vec4 wpos = IMCPCMatrix * gl_Position;\\n              TexCoords = vec2(vertexMC.x, vertexMC.y)*0.5 + 0.5;\\n             }\", \"//VTK::System::Dec\\n             //VTK::Output::Dec\\n             varying vec2 TexCoords;\\n             uniform sampler2D sbtexture;\\n             void main () {\\n               gl_FragData[0] = texture2D(sbtexture, TexCoords);\\n             }\", ''));\n      }\n\n      model.tris.getShaderSourceTime().modified();\n      model.tris.getVAO().bind();\n\n      if (!model.tris.getVAO().addAttributeArray(model.tris.getProgram(), model.tris.getCABO(), 'vertexMC', model.tris.getCABO().getVertexOffset(), model.tris.getCABO().getStride(), model.context.FLOAT, 3, model.context.FALSE)) {\n        vtkErrorMacro('Error setting vertexMC in shader VAO.');\n      }\n    } // set/update the texture map if needed\n\n\n    var tmaps = model.renderable.getTextures();\n\n    if (!tmaps.length) {\n      vtkErrorMacro('vtkSkybox requires a texture map');\n    }\n\n    if (model.openGLTexture.getRenderable() !== tmaps[0]) {\n      model.openGLTexture.releaseGraphicsResources(model._openGLRenderWindow);\n      model.openGLTexture.setRenderable(tmaps[0]);\n    }\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\n\nvar DEFAULT_VALUES = {\n  context: null\n}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Inheritance\n\n  vtkViewNode.extend(publicAPI, model, initialValues);\n  model.openGLTexture = vtkOpenGLTexture.newInstance();\n  model.tris = vtkHelper.newInstance();\n  model.keyMatrixTime = {};\n  obj(model.keyMatrixTime, {\n    mtime: 0\n  });\n  model.keyMatrices = {\n    normalMatrix: mat3.identity(new Float64Array(9)),\n    mcwc: mat4.identity(new Float64Array(16))\n  }; // Build VTK API\n\n  setGet(publicAPI, model, ['context']);\n  get(publicAPI, model, ['activeTextures']); // Object methods\n\n  vtkOpenGLSkybox(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = newInstance$1(extend); // ----------------------------------------------------------------------------\n\nvar vtkSkybox = {\n  newInstance: newInstance,\n  extend: extend\n}; // Register ourself to OpenGL backend if imported\n\nregisterOverride('vtkSkybox', newInstance);\n\nexport { vtkSkybox as default, extend, newInstance };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}