import _defineProperty from '@babel/runtime/helpers/defineProperty';
import { vec3, mat4, quat } from 'gl-matrix';
import CoincidentTopologyHelper from './Mapper/CoincidentTopologyHelper.js';
import vtkAbstractImageMapper from './AbstractImageMapper.js';
import macro from '../../macros.js';
import vtkPoints from '../../Common/Core/Points.js';
import vtkPolyLine from '../../Common/DataModel/PolyLine.js';

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
var vtkErrorMacro = macro.vtkErrorMacro;
var staticOffsetAPI = CoincidentTopologyHelper.staticOffsetAPI,
    otherStaticMethods = CoincidentTopologyHelper.otherStaticMethods; // ----------------------------------------------------------------------------
// vtkImageCPRMapper methods
// ----------------------------------------------------------------------------

function vtkImageCPRMapper(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkImageCPRMapper');

  var superClass = _objectSpread({}, publicAPI);
  /**
   * Public methods
   */


  publicAPI.getBounds = function () {
    var imageWidth = publicAPI.getWidth();
    var imageHeight = publicAPI.getHeight();
    return [0, imageWidth, 0, imageHeight, 0, 0];
  };

  publicAPI.getOrientationDataArray = function () {
    var _publicAPI$getInputDa;

    var pointData = (_publicAPI$getInputDa = publicAPI.getInputData(1)) === null || _publicAPI$getInputDa === void 0 ? void 0 : _publicAPI$getInputDa.getPointData();

    if (!pointData) {
      return null;
    }

    if (model.orientationArrayName !== null) {
      return pointData.getArrayByName(model.orientationArrayName) || null;
    }

    return pointData.getArrayByName('Orientation') || pointData.getArrayByName('Direction') || pointData.getVectors() || pointData.getTensors() || pointData.getNormals() || null;
  };

  publicAPI.getOrientedCenterline = function () {
    var inputPolydata = publicAPI.getInputData(1);

    if (!inputPolydata) {
      // No polydata: return previous centerline
      // Don't reset centerline as it could have been set using setOrientedCenterline
      return model._orientedCenterline;
    } // Get dependencies of centerline


    var orientationDataArray = publicAPI.getOrientationDataArray();
    var linesDataArray = inputPolydata.getLines();
    var pointsDataArray = inputPolydata.getPoints();

    if (!model.useUniformOrientation && !orientationDataArray) {
      vtkErrorMacro('Failed to create oriented centerline from polydata: no orientation');

      publicAPI._resetOrientedCenterline();

      return model._orientedCenterline;
    } // If centerline didn't change, don't recompute


    var centerlineTime = model._orientedCenterline.getMTime();

    if (centerlineTime >= publicAPI.getMTime() && centerlineTime > linesDataArray.getMTime() && centerlineTime > pointsDataArray.getMTime() && (model.useUniformOrientation || centerlineTime > orientationDataArray.getMTime())) {
      return model._orientedCenterline;
    } // Get points of the centerline


    var linesData = linesDataArray.getData();

    if (linesData.length <= 0) {
      // No polyline
      publicAPI._resetOrientedCenterline();

      return model._orientedCenterline;
    }

    var nPoints = linesData[0];

    if (nPoints <= 1) {
      // Empty centerline
      publicAPI._resetOrientedCenterline();

      return model._orientedCenterline;
    }

    var pointIndices = linesData.subarray(1, 1 + nPoints); // Get orientations of the centerline

    var orientations = new Array(nPoints); // Function to convert from mat4, mat3, quat or vec3 to quaternion

    var convert = function convert() {
      return null;
    };

    var numComps = model.useUniformOrientation ? model.uniformOrientation.length : orientationDataArray.getNumberOfComponents();

    switch (numComps) {
      case 16:
        convert = mat4.getRotation;
        break;

      case 9:
        convert = function convert(outQuat, inMat) {
          quat.fromMat3(outQuat, inMat);
          quat.normalize(outQuat, outQuat);
        };

        break;

      case 4:
        convert = quat.copy;
        break;

      case 3:
        convert = function convert(a, b) {
          return quat.rotationTo(a, model.tangentDirection, b);
        };

        break;

      default:
        vtkErrorMacro('Orientation doesnt match mat4, mat3, quat or vec3');

        publicAPI._resetOrientedCenterline();

        return model._orientedCenterline;
    } // Function to get orientation from point index


    var getOrientation = function getOrientation() {
      return null;
    };

    if (model.useUniformOrientation) {
      var outQuat = new Float64Array(4);
      convert(outQuat, model.uniformOrientation);

      getOrientation = function getOrientation() {
        return outQuat;
      };
    } else {
      var temp = new Float64Array(16);

      getOrientation = function getOrientation(i) {
        var outQuat = new Float64Array(4);
        orientationDataArray.getTuple(i, temp);
        convert(outQuat, temp);
        return outQuat;
      };
    } // Fill the orientation array


    for (var i = 0; i < nPoints; ++i) {
      var pointIdx = pointIndices[i];
      orientations[i] = getOrientation(pointIdx);
    } // Done recomputing


    model._orientedCenterline.initialize(pointsDataArray, pointIndices);

    model._orientedCenterline.setOrientations(orientations);

    return model._orientedCenterline;
  };

  publicAPI.setOrientedCenterline = function (centerline) {
    if (model._orientedCenterline !== centerline) {
      model._orientedCenterline = centerline;
      return true;
    }

    return false;
  };

  publicAPI._resetOrientedCenterline = function () {
    model._orientedCenterline.initialize(vtkPoints.newInstance());

    model._orientedCenterline.setOrientations([]);
  };

  publicAPI.getMTime = function () {
    var mTime = superClass.getMTime();

    if (!model._orientedCenterline) {
      return mTime;
    }

    mTime = Math.max(mTime, model._orientedCenterline.getMTime());
    return mTime;
  };

  publicAPI.getHeight = function () {
    var accHeights = publicAPI.getOrientedCenterline().getDistancesToFirstPoint();

    if (accHeights.length === 0) {
      return 0;
    }

    return accHeights[accHeights.length - 1];
  };

  publicAPI.getCenterlinePositionAndOrientation = function (distance) {
    var centerline = publicAPI.getOrientedCenterline();
    var subId = centerline.findPointIdAtDistanceFromFirstPoint(distance);

    if (subId < 0) {
      return {};
    }

    var distances = centerline.getDistancesToFirstPoint();
    var pcoords = [(distance - distances[subId]) / (distances[subId + 1] - distances[subId])];
    var weights = new Array(2);
    var position = new Array(3);
    centerline.evaluateLocation(subId, pcoords, position, weights);
    var orientation = new Array(4);

    if (!centerline.evaluateOrientation(subId, pcoords, orientation, weights)) {
      // No orientation
      return {
        position: position
      };
    }

    return {
      position: position,
      orientation: orientation
    };
  };

  publicAPI.getCenterlineTangentDirections = function () {
    var centerline = publicAPI.getOrientedCenterline();

    var directionsTime = model._centerlineTangentDirectionsTime.getMTime();

    if (directionsTime < centerline.getMTime()) {
      var orientations = centerline.getOrientations();
      model._centerlineTangentDirections = new Float32Array(3 * orientations.length);
      var localDirection = new Array(3);

      for (var i = 0; i < orientations.length; ++i) {
        vec3.transformQuat(localDirection, model.tangentDirection, orientations[i]);

        model._centerlineTangentDirections.set(localDirection, 3 * i);
      }

      model._centerlineTangentDirectionsTime.modified();
    }

    return model._centerlineTangentDirections;
  };

  publicAPI.getUniformDirection = function () {
    return vec3.transformQuat(new Array(3), model.tangentDirection, model.uniformOrientation);
  };

  publicAPI.getDirectionMatrix = function () {
    var tangent = model.tangentDirection;
    var bitangent = model.bitangentDirection;
    var normal = model.normalDirection;
    return new Float64Array([tangent[0], tangent[1], tangent[2], bitangent[0], bitangent[1], bitangent[2], normal[0], normal[1], normal[2]]);
  };

  publicAPI.setDirectionMatrix = function (mat) {
    if (mat4.equals(mat, publicAPI.getDirectionMatrix())) {
      return false;
    }

    model.tangentDirection = [mat[0], mat[1], mat[2]];
    model.bitangentDirection = [mat[3], mat[4], mat[5]];
    model.normalDirection = [mat[6], mat[7], mat[8]];
    publicAPI.modified();
    return true;
  }; // Check if the rendering can occur


  publicAPI.preRenderCheck = function () {
    if (!publicAPI.getInputData(0)) {
      vtkErrorMacro('No image data input');
      return false;
    }

    return true;
  };

  publicAPI.useStraightenedMode = function () {
    publicAPI.setCenterPoint(null);
    publicAPI.setUseUniformOrientation(false);
    publicAPI.getOrientedCenterline().setDistanceFunction(vec3.dist);
  };

  publicAPI.useStretchedMode = function (centerPoint) {
    var centerline = publicAPI.getOrientedCenterline(); // Set center point

    if (!centerPoint) {
      // Get the first point of the centerline if there is one
      var centerlinePoints = centerline.getPoints();
      var newCenterPoint = centerlinePoints.getNumberOfTuples() > 0 ? centerlinePoints.getPoint(0) : [0, 0, 0];
      publicAPI.setCenterPoint(newCenterPoint);
    } else {
      publicAPI.setCenterPoint(centerPoint);
    } // Enable uniform orientation


    publicAPI.setUseUniformOrientation(true); // Change distance function

    centerline.setDistanceFunction(function (a, b) {
      var direction = publicAPI.getUniformDirection();
      var vec = vec3.subtract([], a, b);
      var d2 = vec3.squaredLength(vec);
      var x = vec3.dot(direction, vec);
      return Math.sqrt(d2 - x * x);
    });
  };

  publicAPI.setCenterlineData = function (centerlineData) {
    return publicAPI.setInputData(centerlineData, 1);
  };

  publicAPI.setCenterlineConnection = function (centerlineConnection) {
    return publicAPI.setInputConnection(centerlineConnection, 1);
  };

  publicAPI.setImageData = function (imageData) {
    return publicAPI.setInputData(imageData, 0);
  };

  publicAPI.setImageConnection = function (imageData) {
    return publicAPI.setInputConnection(imageData, 0);
  };

  publicAPI.getIsOpaque = function () {
    return true;
  }; // One can also call setOrientedCenterline and not provide a polydata centerline to input 1


  model._orientedCenterline = vtkPolyLine.newInstance();

  publicAPI._resetOrientedCenterline();
} // ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------


var DEFAULT_VALUES = {
  width: 10,
  uniformOrientation: [0, 0, 0, 1],
  useUniformOrientation: false,
  centerPoint: null,
  preferSizeOverAccuracy: false,
  orientationArrayName: null,
  tangentDirection: [1, 0, 0],
  bitangentDirection: [0, 1, 0],
  normalDirection: [0, 0, 1]
}; // ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues); // Inheritance

  vtkAbstractImageMapper.extend(publicAPI, model, initialValues); // Two inputs: one for the ImageData and one for the PolyData (centerline)

  macro.algo(publicAPI, model, 2, 0);
  model._centerlineTangentDirectionsTime = {};
  macro.obj(model._centerlineTangentDirectionsTime, {
    mtime: 0
  }); // Setters and getters

  macro.setGet(publicAPI, model, ['width', 'uniformOrientation', 'useUniformOrientation', 'centerPoint', 'preferSizeOverAccuracy', 'orientationArrayName', 'tangentDirection', 'bitangentDirection', 'normalDirection']);
  CoincidentTopologyHelper.implementCoincidentTopologyMethods(publicAPI, model); // Object methods

  vtkImageCPRMapper(publicAPI, model);
} // ----------------------------------------------------------------------------

var newInstance = macro.newInstance(extend, 'vtkImageCPRMapper'); // ----------------------------------------------------------------------------

var index = _objectSpread(_objectSpread({
  newInstance: newInstance,
  extend: extend
}, staticOffsetAPI), otherStaticMethods);

export { index as default, extend, newInstance };
