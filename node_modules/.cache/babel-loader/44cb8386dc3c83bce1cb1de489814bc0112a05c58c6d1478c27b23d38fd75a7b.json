{"ast":null,"code":"import macro from '../../macros.js';\nimport vtkPolyData from '../../Common/DataModel/PolyData.js';\nvar vtkErrorMacro = macro.vtkErrorMacro; // ----------------------------------------------------------------------------\n// vtkImageStreamline methods\n// ----------------------------------------------------------------------------\n\nfunction vtkImageStreamline(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkImageStreamline');\n  var indices = new Int32Array(3);\n  var paramCoords = new Float32Array(3);\n  var weights = new Float32Array(8);\n  var voxelIndices = new Uint32Array(8);\n  var dimensions = new Uint32Array(3);\n  var velAt = new Float32Array(3);\n  var xtmp = new Float32Array(3);\n  publicAPI.interpolationFunctions = function (pcoords, sf) {\n    var r = pcoords[0];\n    var s = pcoords[1];\n    var t = pcoords[2];\n    var rm = 1.0 - r;\n    var sm = 1.0 - s;\n    var tm = 1.0 - t;\n    sf[0] = rm * sm * tm;\n    sf[1] = r * sm * tm;\n    sf[2] = rm * s * tm;\n    sf[3] = r * s * tm;\n    sf[4] = rm * sm * t;\n    sf[5] = r * sm * t;\n    sf[6] = rm * s * t;\n    sf[7] = r * s * t;\n  };\n  publicAPI.computeStructuredCoordinates = function (x, ijk, pcoords, extent, spacing, origin, bounds) {\n    // tolerance is needed for 2D data (this is squared tolerance)\n    var tol2 = 1e-12; //\n    //  Compute the ijk location\n    //\n\n    var isInBounds = true;\n    for (var i = 0; i < 3; i++) {\n      var d = x[i] - origin[i];\n      var doubleLoc = d / spacing[i]; // Floor for negative indexes.\n\n      ijk[i] = Math.floor(doubleLoc);\n      pcoords[i] = doubleLoc - ijk[i];\n      var tmpInBounds = false;\n      var minExt = extent[i * 2];\n      var maxExt = extent[i * 2 + 1]; // check if data is one pixel thick\n\n      if (minExt === maxExt) {\n        var dist = x[i] - bounds[2 * i];\n        if (dist * dist <= spacing[i] * spacing[i] * tol2) {\n          pcoords[i] = 0.0;\n          ijk[i] = minExt;\n          tmpInBounds = true;\n        }\n      } else if (ijk[i] < minExt) {\n        if (spacing[i] >= 0 && x[i] >= bounds[i * 2] || spacing[i] < 0 && x[i] <= bounds[i * 2 + 1]) {\n          pcoords[i] = 0.0;\n          ijk[i] = minExt;\n          tmpInBounds = true;\n        }\n      } else if (ijk[i] >= maxExt) {\n        if (spacing[i] >= 0 && x[i] <= bounds[i * 2 + 1] || spacing[i] < 0 && x[i] >= bounds[i * 2]) {\n          // make sure index is within the allowed cell index range\n          pcoords[i] = 1.0;\n          ijk[i] = maxExt - 1;\n          tmpInBounds = true;\n        }\n      } else {\n        tmpInBounds = true;\n      } // clear isInBounds if out of bounds for this dimension\n\n      isInBounds = isInBounds && tmpInBounds;\n    }\n    return isInBounds;\n  };\n  publicAPI.getVoxelIndices = function (ijk, dims, ids) {\n    ids[0] = ijk[2] * dims[0] * dims[1] + ijk[1] * dims[0] + ijk[0];\n    ids[1] = ids[0] + 1; // i+1, j, k\n\n    ids[2] = ids[0] + dims[0]; // i, j+1, k\n\n    ids[3] = ids[2] + 1; // i+1, j+1, k\n\n    ids[4] = ids[0] + dims[0] * dims[1]; // i, j, k+1\n\n    ids[5] = ids[4] + 1; // i+1, j, k+1\n\n    ids[6] = ids[4] + dims[0]; // i, j+1, k+1\n\n    ids[7] = ids[6] + 1; // i+1, j+1, k+1\n  };\n\n  publicAPI.vectorAt = function (xyz, velArray, image, velAtArg) {\n    if (!publicAPI.computeStructuredCoordinates(xyz, indices, paramCoords, image.getExtent(), image.getSpacing(), image.getOrigin(), image.getBounds())) {\n      return false;\n    }\n    publicAPI.interpolationFunctions(paramCoords, weights);\n    var extent = image.getExtent();\n    dimensions[0] = extent[1] - extent[0] + 1;\n    dimensions[1] = extent[3] - extent[2] + 1;\n    dimensions[2] = extent[5] - extent[4] + 1;\n    publicAPI.getVoxelIndices(indices, dimensions, voxelIndices);\n    velAtArg[0] = 0.0;\n    velAtArg[1] = 0.0;\n    velAtArg[2] = 0.0;\n    var vel = new Array(3);\n    for (var i = 0; i < 8; i++) {\n      velArray.getTuple(voxelIndices[i], vel);\n      for (var j = 0; j < 3; j++) {\n        velAtArg[j] += weights[i] * vel[j];\n      }\n    }\n    return true;\n  };\n  publicAPI.computeNextStep = function (velArray, image, delT, xyz) {\n    // This does Runge-Kutta 2\n    // Start with evaluating velocity @ initial point\n    if (!publicAPI.vectorAt(xyz, velArray, image, velAt)) {\n      return false;\n    } // Now find the mid point\n\n    for (var i = 0; i < 3; i++) {\n      xtmp[i] = xyz[i] + delT / 2.0 * velAt[i];\n    } // Use the velocity @ that point to project\n\n    if (!publicAPI.vectorAt(xtmp, velArray, image, velAt)) {\n      return false;\n    }\n    for (var _i = 0; _i < 3; _i++) {\n      xyz[_i] += delT * velAt[_i];\n    }\n    if (!publicAPI.vectorAt(xyz, velArray, image, velAt)) {\n      return false;\n    }\n    return true;\n  };\n  publicAPI.streamIntegrate = function (velArray, image, seed, offset) {\n    var retVal = [];\n    var maxSteps = model.maximumNumberOfSteps;\n    var delT = model.integrationStep;\n    var xyz = new Float32Array(3);\n    xyz[0] = seed[0];\n    xyz[1] = seed[1];\n    xyz[2] = seed[2];\n    var pointsBuffer = [];\n    var step = 0;\n    for (step = 0; step < maxSteps; step++) {\n      if (!publicAPI.computeNextStep(velArray, image, delT, xyz)) {\n        break;\n      }\n      for (var i = 0; i < 3; i++) {\n        pointsBuffer[3 * step + i] = xyz[i];\n      }\n    }\n    var pd = vtkPolyData.newInstance();\n    var points = new Float32Array(pointsBuffer);\n    retVal[0] = points;\n    pd.getPoints().setData(points, 3);\n    var npts = points.length / 3;\n    var line = new Uint32Array(npts + 1);\n    line[0] = npts;\n    for (var _i2 = 0; _i2 < npts; _i2++) {\n      line[_i2 + 1] = _i2 + offset;\n    }\n    retVal[1] = line;\n    pd.getLines().setData(line);\n    return retVal;\n  };\n  publicAPI.requestData = function (inData, outData) {\n    // implement requestData\n    var input = inData[0];\n    var seeds = inData[1];\n    if (!input) {\n      vtkErrorMacro('Invalid or missing input');\n      return;\n    }\n    if (!seeds) {\n      vtkErrorMacro('Invalid or missing seeds');\n      return;\n    }\n    var seedPts = seeds.getPoints();\n    var nSeeds = seedPts.getNumberOfPoints();\n    var offset = 0;\n    var datas = [];\n    var vectors = input.getPointData().getVectors();\n    var point = [];\n    for (var i = 0; i < nSeeds; i++) {\n      seedPts.getTuple(i, point);\n      var retVal = publicAPI.streamIntegrate(vectors, input, point, offset);\n      offset += retVal[0].length / 3;\n      datas.push(retVal);\n    }\n    var cellArrayLength = 0;\n    var pointArrayLength = 0;\n    datas.forEach(function (data) {\n      cellArrayLength += data[1].length;\n      pointArrayLength += data[0].length;\n    });\n    offset = 0;\n    var offset2 = 0;\n    var cellArray = new Uint32Array(cellArrayLength);\n    var pointArray = new Float32Array(pointArrayLength);\n    datas.forEach(function (data) {\n      cellArray.set(data[1], offset);\n      offset += data[1].length;\n      pointArray.set(data[0], offset2);\n      offset2 += data[0].length;\n    });\n    var output = vtkPolyData.newInstance();\n    output.getPoints().setData(pointArray, 3);\n    output.getLines().setData(cellArray);\n    outData[0] = output;\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nvar DEFAULT_VALUES = {\n  integrationStep: 1,\n  maximumNumberOfSteps: 1000\n}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Make this a VTK object\n\n  macro.obj(publicAPI, model); // Also make it an algorithm with one input and one output\n\n  macro.algo(publicAPI, model, 2, 1); // Generate macros for properties\n\n  macro.setGet(publicAPI, model, ['integrationStep', 'maximumNumberOfSteps']); // Object specific methods\n\n  vtkImageStreamline(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = macro.newInstance(extend, 'vtkImageStreamline'); // ----------------------------------------------------------------------------\n\nvar vtkImageStreamline$1 = {\n  newInstance: newInstance,\n  extend: extend\n};\nexport { vtkImageStreamline$1 as default, extend, newInstance };","map":{"version":3,"names":["macro","vtkPolyData","vtkErrorMacro","vtkImageStreamline","publicAPI","model","classHierarchy","push","indices","Int32Array","paramCoords","Float32Array","weights","voxelIndices","Uint32Array","dimensions","velAt","xtmp","interpolationFunctions","pcoords","sf","r","s","t","rm","sm","tm","computeStructuredCoordinates","x","ijk","extent","spacing","origin","bounds","tol2","isInBounds","i","d","doubleLoc","Math","floor","tmpInBounds","minExt","maxExt","dist","getVoxelIndices","dims","ids","vectorAt","xyz","velArray","image","velAtArg","getExtent","getSpacing","getOrigin","getBounds","vel","Array","getTuple","j","computeNextStep","delT","_i","streamIntegrate","seed","offset","retVal","maxSteps","maximumNumberOfSteps","integrationStep","pointsBuffer","step","pd","newInstance","points","getPoints","setData","npts","length","line","_i2","getLines","requestData","inData","outData","input","seeds","seedPts","nSeeds","getNumberOfPoints","datas","vectors","getPointData","getVectors","point","cellArrayLength","pointArrayLength","forEach","data","offset2","cellArray","pointArray","set","output","DEFAULT_VALUES","extend","initialValues","arguments","undefined","Object","assign","obj","algo","setGet","vtkImageStreamline$1","default"],"sources":["/home/rakshith/Documents/RemoteRendering/vtk-js-react-app/node_modules/@kitware/vtk.js/Filters/General/ImageStreamline.js"],"sourcesContent":["import macro from '../../macros.js';\nimport vtkPolyData from '../../Common/DataModel/PolyData.js';\n\nvar vtkErrorMacro = macro.vtkErrorMacro; // ----------------------------------------------------------------------------\n// vtkImageStreamline methods\n// ----------------------------------------------------------------------------\n\nfunction vtkImageStreamline(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkImageStreamline');\n  var indices = new Int32Array(3);\n  var paramCoords = new Float32Array(3);\n  var weights = new Float32Array(8);\n  var voxelIndices = new Uint32Array(8);\n  var dimensions = new Uint32Array(3);\n  var velAt = new Float32Array(3);\n  var xtmp = new Float32Array(3);\n\n  publicAPI.interpolationFunctions = function (pcoords, sf) {\n    var r = pcoords[0];\n    var s = pcoords[1];\n    var t = pcoords[2];\n    var rm = 1.0 - r;\n    var sm = 1.0 - s;\n    var tm = 1.0 - t;\n    sf[0] = rm * sm * tm;\n    sf[1] = r * sm * tm;\n    sf[2] = rm * s * tm;\n    sf[3] = r * s * tm;\n    sf[4] = rm * sm * t;\n    sf[5] = r * sm * t;\n    sf[6] = rm * s * t;\n    sf[7] = r * s * t;\n  };\n\n  publicAPI.computeStructuredCoordinates = function (x, ijk, pcoords, extent, spacing, origin, bounds) {\n    // tolerance is needed for 2D data (this is squared tolerance)\n    var tol2 = 1e-12; //\n    //  Compute the ijk location\n    //\n\n    var isInBounds = true;\n\n    for (var i = 0; i < 3; i++) {\n      var d = x[i] - origin[i];\n      var doubleLoc = d / spacing[i]; // Floor for negative indexes.\n\n      ijk[i] = Math.floor(doubleLoc);\n      pcoords[i] = doubleLoc - ijk[i];\n      var tmpInBounds = false;\n      var minExt = extent[i * 2];\n      var maxExt = extent[i * 2 + 1]; // check if data is one pixel thick\n\n      if (minExt === maxExt) {\n        var dist = x[i] - bounds[2 * i];\n\n        if (dist * dist <= spacing[i] * spacing[i] * tol2) {\n          pcoords[i] = 0.0;\n          ijk[i] = minExt;\n          tmpInBounds = true;\n        }\n      } else if (ijk[i] < minExt) {\n        if (spacing[i] >= 0 && x[i] >= bounds[i * 2] || spacing[i] < 0 && x[i] <= bounds[i * 2 + 1]) {\n          pcoords[i] = 0.0;\n          ijk[i] = minExt;\n          tmpInBounds = true;\n        }\n      } else if (ijk[i] >= maxExt) {\n        if (spacing[i] >= 0 && x[i] <= bounds[i * 2 + 1] || spacing[i] < 0 && x[i] >= bounds[i * 2]) {\n          // make sure index is within the allowed cell index range\n          pcoords[i] = 1.0;\n          ijk[i] = maxExt - 1;\n          tmpInBounds = true;\n        }\n      } else {\n        tmpInBounds = true;\n      } // clear isInBounds if out of bounds for this dimension\n\n\n      isInBounds = isInBounds && tmpInBounds;\n    }\n\n    return isInBounds;\n  };\n\n  publicAPI.getVoxelIndices = function (ijk, dims, ids) {\n    ids[0] = ijk[2] * dims[0] * dims[1] + ijk[1] * dims[0] + ijk[0];\n    ids[1] = ids[0] + 1; // i+1, j, k\n\n    ids[2] = ids[0] + dims[0]; // i, j+1, k\n\n    ids[3] = ids[2] + 1; // i+1, j+1, k\n\n    ids[4] = ids[0] + dims[0] * dims[1]; // i, j, k+1\n\n    ids[5] = ids[4] + 1; // i+1, j, k+1\n\n    ids[6] = ids[4] + dims[0]; // i, j+1, k+1\n\n    ids[7] = ids[6] + 1; // i+1, j+1, k+1\n  };\n\n  publicAPI.vectorAt = function (xyz, velArray, image, velAtArg) {\n    if (!publicAPI.computeStructuredCoordinates(xyz, indices, paramCoords, image.getExtent(), image.getSpacing(), image.getOrigin(), image.getBounds())) {\n      return false;\n    }\n\n    publicAPI.interpolationFunctions(paramCoords, weights);\n    var extent = image.getExtent();\n    dimensions[0] = extent[1] - extent[0] + 1;\n    dimensions[1] = extent[3] - extent[2] + 1;\n    dimensions[2] = extent[5] - extent[4] + 1;\n    publicAPI.getVoxelIndices(indices, dimensions, voxelIndices);\n    velAtArg[0] = 0.0;\n    velAtArg[1] = 0.0;\n    velAtArg[2] = 0.0;\n    var vel = new Array(3);\n\n    for (var i = 0; i < 8; i++) {\n      velArray.getTuple(voxelIndices[i], vel);\n\n      for (var j = 0; j < 3; j++) {\n        velAtArg[j] += weights[i] * vel[j];\n      }\n    }\n\n    return true;\n  };\n\n  publicAPI.computeNextStep = function (velArray, image, delT, xyz) {\n    // This does Runge-Kutta 2\n    // Start with evaluating velocity @ initial point\n    if (!publicAPI.vectorAt(xyz, velArray, image, velAt)) {\n      return false;\n    } // Now find the mid point\n\n\n    for (var i = 0; i < 3; i++) {\n      xtmp[i] = xyz[i] + delT / 2.0 * velAt[i];\n    } // Use the velocity @ that point to project\n\n\n    if (!publicAPI.vectorAt(xtmp, velArray, image, velAt)) {\n      return false;\n    }\n\n    for (var _i = 0; _i < 3; _i++) {\n      xyz[_i] += delT * velAt[_i];\n    }\n\n    if (!publicAPI.vectorAt(xyz, velArray, image, velAt)) {\n      return false;\n    }\n\n    return true;\n  };\n\n  publicAPI.streamIntegrate = function (velArray, image, seed, offset) {\n    var retVal = [];\n    var maxSteps = model.maximumNumberOfSteps;\n    var delT = model.integrationStep;\n    var xyz = new Float32Array(3);\n    xyz[0] = seed[0];\n    xyz[1] = seed[1];\n    xyz[2] = seed[2];\n    var pointsBuffer = [];\n    var step = 0;\n\n    for (step = 0; step < maxSteps; step++) {\n      if (!publicAPI.computeNextStep(velArray, image, delT, xyz)) {\n        break;\n      }\n\n      for (var i = 0; i < 3; i++) {\n        pointsBuffer[3 * step + i] = xyz[i];\n      }\n    }\n\n    var pd = vtkPolyData.newInstance();\n    var points = new Float32Array(pointsBuffer);\n    retVal[0] = points;\n    pd.getPoints().setData(points, 3);\n    var npts = points.length / 3;\n    var line = new Uint32Array(npts + 1);\n    line[0] = npts;\n\n    for (var _i2 = 0; _i2 < npts; _i2++) {\n      line[_i2 + 1] = _i2 + offset;\n    }\n\n    retVal[1] = line;\n    pd.getLines().setData(line);\n    return retVal;\n  };\n\n  publicAPI.requestData = function (inData, outData) {\n    // implement requestData\n    var input = inData[0];\n    var seeds = inData[1];\n\n    if (!input) {\n      vtkErrorMacro('Invalid or missing input');\n      return;\n    }\n\n    if (!seeds) {\n      vtkErrorMacro('Invalid or missing seeds');\n      return;\n    }\n\n    var seedPts = seeds.getPoints();\n    var nSeeds = seedPts.getNumberOfPoints();\n    var offset = 0;\n    var datas = [];\n    var vectors = input.getPointData().getVectors();\n    var point = [];\n\n    for (var i = 0; i < nSeeds; i++) {\n      seedPts.getTuple(i, point);\n      var retVal = publicAPI.streamIntegrate(vectors, input, point, offset);\n      offset += retVal[0].length / 3;\n      datas.push(retVal);\n    }\n\n    var cellArrayLength = 0;\n    var pointArrayLength = 0;\n    datas.forEach(function (data) {\n      cellArrayLength += data[1].length;\n      pointArrayLength += data[0].length;\n    });\n    offset = 0;\n    var offset2 = 0;\n    var cellArray = new Uint32Array(cellArrayLength);\n    var pointArray = new Float32Array(pointArrayLength);\n    datas.forEach(function (data) {\n      cellArray.set(data[1], offset);\n      offset += data[1].length;\n      pointArray.set(data[0], offset2);\n      offset2 += data[0].length;\n    });\n    var output = vtkPolyData.newInstance();\n    output.getPoints().setData(pointArray, 3);\n    output.getLines().setData(cellArray);\n    outData[0] = output;\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\n\nvar DEFAULT_VALUES = {\n  integrationStep: 1,\n  maximumNumberOfSteps: 1000\n}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Make this a VTK object\n\n  macro.obj(publicAPI, model); // Also make it an algorithm with one input and one output\n\n  macro.algo(publicAPI, model, 2, 1); // Generate macros for properties\n\n  macro.setGet(publicAPI, model, ['integrationStep', 'maximumNumberOfSteps']); // Object specific methods\n\n  vtkImageStreamline(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = macro.newInstance(extend, 'vtkImageStreamline'); // ----------------------------------------------------------------------------\n\nvar vtkImageStreamline$1 = {\n  newInstance: newInstance,\n  extend: extend\n};\n\nexport { vtkImageStreamline$1 as default, extend, newInstance };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}