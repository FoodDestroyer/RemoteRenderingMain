{"ast":null,"code":"import _toConsumableArray from '@babel/runtime/helpers/toConsumableArray';\nimport macro from '../../../macros.js';\nimport vtkPoints from '../../../Common/Core/Points.js';\nimport { s as subtract, j as cross, d as dot, n as norm, e as distance2BetweenPoints, k as add, l as normalize } from '../../../Common/Core/Math/index.js';\nimport vtkLine from '../../../Common/DataModel/Line.js';\nimport vtkPolygon from '../../../Common/DataModel/Polygon.js';\nimport vtkIncrementalOctreePointLocator from '../../../Common/DataModel/IncrementalOctreePointLocator.js';\nimport { VtkDataTypes } from '../../../Common/Core/DataArray/Constants.js';\nimport { CCS_POLYGON_TOLERANCE } from './Constants.js';\nimport { PolygonWithPointIntersectionState } from '../../../Common/DataModel/Polygon/Constants.js';\nvar vtkErrorMacro = macro.vtkErrorMacro;\n/**\n * Reverse the elements between the indices firstIdx and lastIdx of the given array arr.\n *\n * @param {Array|TypedArray} arr\n * @param {Number} firstIdx\n * @param {Number} lastIdx\n */\n\nfunction reverseElements(arr) {\n  var firstIdx = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n  var lastIdx = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\n  var first = firstIdx !== null && firstIdx !== void 0 ? firstIdx : 0;\n  var last = lastIdx !== null && lastIdx !== void 0 ? lastIdx : arr.length - 1;\n  var mid = first + Math.floor((last - first) / 2);\n  for (var i = first; i <= mid; ++i) {\n    var _ref = [arr[last - (i - first)], arr[i]];\n    arr[i] = _ref[0];\n    arr[last - (i - first)] = _ref[1];\n  }\n} // ---------------------------------------------------\n\n/**\n * Compute the quality of a triangle.\n *\n * @param {Vector3} p0\n * @param {Vector3} p1\n * @param {Vector3} p2\n * @param {Vector3} normal\n * @returns {Number}\n */\n\nfunction vtkCCSTriangleQuality(p0, p1, p2, normal) {\n  var u = [];\n  var v = [];\n  var w = [];\n  subtract(p1, p0, u);\n  subtract(p2, p1, v);\n  subtract(p0, p2, w);\n  var area2 = (u[1] * v[2] - u[2] * v[1]) * normal[0] + (u[2] * v[0] - u[0] * v[2]) * normal[1] + (u[0] * v[1] - u[1] * v[0]) * normal[2];\n  var perim = Math.sqrt(u[0] * u[0] + u[1] * u[1] + u[2] * u[2]) + Math.sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]) + Math.sqrt(w[0] * w[0] + w[1] * w[1] + w[2] * w[2]);\n  perim *= perim; // square the perimeter\n\n  perim = perim !== 0 ? perim : 1.0; // use a normalization factor so equilateral quality is 1.0\n\n  return area2 / perim * 10.392304845413264;\n} // ---------------------------------------------------\n\n/**\n * Insert a triangle, and subdivide that triangle if one of\n * its edges originally had more than two points before\n * vtkCCSFindTrueEdges was called. Is called by vtkCCSTriangulate.\n *\n * @param {vtkCellArray} polys\n * @param {Array|TypedArray} poly\n * @param {Vector3} trids\n * @param {Array|TypedArray} polyEdges\n * @param {Array|TypedArray} originalEdges\n */\n\nfunction vtkCCSInsertTriangle(polys, poly, trids, polyEdges, originalEdges) {\n  var nextVert = [1, 2, 0]; // To store how many of originalEdges match\n\n  var edgeCount = 0;\n  var edgeLocs = [-1, -1, -1]; // Check for original edge matches\n\n  for (var vert = 0; vert < 3; vert++) {\n    var currId = trids[vert];\n    var edgeLoc = polyEdges[currId];\n    if (edgeLoc >= 0) {\n      var nextId = currId + 1;\n      if (nextId === poly.length) {\n        nextId = 0;\n      } // Is the triangle edge a polygon edge?\n\n      if (nextId === trids[nextVert[vert]]) {\n        edgeLocs[vert] = edgeLoc;\n        edgeCount++;\n      }\n    }\n  }\n  if (edgeCount === 0) {\n    // No special edge handling, so just do one triangle\n    polys.insertNextCell([poly[trids[0]], poly[trids[1]], poly[trids[2]]]);\n  } else {\n    // Make triangle fans for edges with extra points\n    var edgePts = [[poly[trids[0]], poly[trids[1]]], [poly[trids[1]], poly[trids[2]]], [poly[trids[2]], poly[trids[0]]]]; // Find out which edge has the most extra points\n\n    var maxPoints = 0;\n    var currSide = 0;\n    for (var i = 0; i < 3; i++) {\n      if (edgeLocs[i] >= 0) {\n        var _edgeLoc = edgeLocs[i];\n        var npts = originalEdges[_edgeLoc];\n        var pts = originalEdges.slice(_edgeLoc + 1, _edgeLoc + 1 + npts);\n        if (!(edgePts[i][0] === pts[0] || edgePts[i][1] === pts[npts - 1])) {\n          vtkErrorMacro('assertion error in vtkCCSInsertTriangle');\n        }\n        if (npts > maxPoints) {\n          maxPoints = npts;\n          currSide = i;\n        }\n        edgePts[i] = pts;\n      }\n    } // Find the edges before/after the edge with most points\n\n    var prevSide = (currSide + 2) % 3;\n    var nextSide = (currSide + 1) % 3; // If other edges have only 2 points, nothing to do with them\n\n    var prevNeeded = edgePts[prevSide].length > 2;\n    var nextNeeded = edgePts[nextSide].length > 2; // The tail is the common point in the triangle fan\n\n    var tailPtIds = [];\n    tailPtIds[prevSide] = edgePts[currSide][1];\n    tailPtIds[currSide] = edgePts[prevSide][0];\n    tailPtIds[nextSide] = edgePts[currSide][edgePts[currSide].length - 2]; // Go through the sides and make the fans\n\n    for (var side = 0; side < 3; side++) {\n      if ((side !== prevSide || prevNeeded) && (side !== nextSide || nextNeeded)) {\n        var m = 0;\n        var n = edgePts[side].length - 1;\n        if (side === currSide) {\n          m += prevNeeded;\n          n -= nextNeeded;\n        }\n        for (var k = m; k < n; k++) {\n          polys.insertNextCell([edgePts[side][k], edgePts[side][k + 1], tailPtIds[side]]);\n        }\n      }\n    }\n  }\n} // ---------------------------------------------------\n\n/**\n * Triangulate a polygon that has been simplified by FindTrueEdges.\n * This will re-insert the original edges.  The output triangles are\n * appended to \"polys\" and, for each stored triangle, \"color\" will\n * be added to \"scalars\".  The final two arguments (polygon and\n * triangles) are only for temporary storage.\n * The return value is true if triangulation was successful.\n *\n * @param {Array} poly\n * @param {vtkPoints} points\n * @param {Array} polyEdges\n * @param {Array} originalEdges\n * @param {vtkCellArray} polys\n * @param {Vector3} normal\n * @returns {boolean}\n */\n\nfunction vtkCCSTriangulate(poly, points, polyEdges, originalEdges, polys, normal) {\n  var n = poly.length; // If the poly is a line, then skip it\n\n  if (n < 3) {\n    return true;\n  } // If the poly is a triangle, then pass it\n\n  if (n === 3) {\n    var trids = [0, 1, 2];\n    vtkCCSInsertTriangle(polys, poly, trids, polyEdges, originalEdges);\n    return true;\n  } // If the poly has 4 or more points, triangulate it\n\n  var triangulationFailure = false;\n  var ppoint = [];\n  var point = [];\n  var npoint = [];\n  var i = 0;\n  var j = 0;\n  var k = 0;\n  var verts = [];\n  verts.length = n;\n  for (i = 0; i < n; i++) {\n    verts[i] = [i, 0];\n  } // compute the triangle quality for each vert\n\n  k = n - 2;\n  points.getPoint(poly[verts[k][0]], point);\n  i = n - 1;\n  points.getPoint(poly[verts[i][0]], npoint);\n  var concave = 0;\n  var maxq = 0;\n  var maxi = 0;\n  for (j = 0; j < n; j++) {\n    var _ref2 = [point, npoint, ppoint];\n    ppoint = _ref2[0];\n    point = _ref2[1];\n    npoint = _ref2[2];\n    points.getPoint(poly[verts[j][0]], npoint);\n    var q = vtkCCSTriangleQuality(ppoint, point, npoint, normal);\n    if (q > maxq) {\n      maxi = i;\n      maxq = q;\n    }\n    concave += q < 0;\n    verts[i][1] = q;\n    i = j;\n  }\n  var foundEar; // perform the ear-cut triangulation\n\n  for (;;) {\n    // if no potential ears were found, then fail\n    if (maxq <= Number.MIN_VALUE) {\n      triangulationFailure = true;\n      break;\n    }\n    i = maxi;\n    j = i + 1 !== n ? i + 1 : 0;\n    k = i !== 0 ? i - 1 : n - 1;\n    if (verts[i][1] > 0) {\n      foundEar = true;\n      points.getPoint(poly[verts[j][0]], npoint);\n      points.getPoint(poly[verts[k][0]], ppoint); // only do ear check if there are concave vertices\n\n      if (concave) {\n        // get the normal of the split plane\n        var v = [];\n        var u = [];\n        subtract(npoint, ppoint, v);\n        cross(v, normal, u);\n        var d = dot(ppoint, u);\n        var jj = j + 1 !== n ? j + 1 : 0;\n        var x = [];\n        points.getPoint(poly[verts[jj][0]], x);\n        var side = dot(x, u) < d;\n        var foundNegative = side; // check for crossings of the split plane\n\n        jj = jj + 1 !== n ? jj + 1 : 0;\n        var y = [];\n        var s = [];\n        var t = [];\n        for (; foundEar && jj !== k; jj = jj + 1 !== n ? jj + 1 : 0) {\n          var _ref3 = [y, x];\n          x = _ref3[0];\n          y = _ref3[1];\n          points.getPoint(poly[verts[jj][0]], x);\n          var sside = dot(x, u) < d; // XOR\n\n          if (side ? !sside : sside) {\n            side = !side;\n            foundNegative = true;\n            foundEar = vtkLine.intersection(ppoint, npoint, x, y, s, t) === vtkLine.IntersectionState.NO_INTERSECTION;\n          }\n        }\n        foundEar && (foundEar = foundNegative);\n      }\n      if (!foundEar) {\n        // don't try again until it is split\n        verts[i][1] = Number.MIN_VALUE;\n      } else {\n        // create a triangle from vertex and neighbors\n        var _trids = [verts[i][0], verts[j][0], verts[k][0]];\n        vtkCCSInsertTriangle(polys, poly, _trids, polyEdges, originalEdges); // remove the vertex i\n\n        verts.splice(i, 1);\n        k -= i === 0;\n        j -= j !== 0; // break if this was final triangle\n\n        if (--n < 3) {\n          break;\n        } // re-compute quality of previous point\n\n        var kk = k !== 0 ? k - 1 : n - 1;\n        points.getPoint(poly[verts[kk][0]], point);\n        var kq = vtkCCSTriangleQuality(point, ppoint, npoint, normal);\n        concave -= verts[k][1] < 0 && kq >= 0;\n        verts[k][1] = kq; // re-compute quality of next point\n\n        var _jj = j + 1 !== n ? j + 1 : 0;\n        points.getPoint(poly[verts[_jj][0]], point);\n        var jq = vtkCCSTriangleQuality(ppoint, npoint, point, normal);\n        concave -= verts[j][1] < 0 && jq >= 0;\n        verts[j][1] = jq;\n      }\n    } // find the highest-quality ear candidate\n\n    maxi = 0;\n    maxq = verts[0][1];\n    for (i = 1; i < n; i++) {\n      var _q = verts[i][1];\n      if (_q > maxq) {\n        maxi = i;\n        maxq = _q;\n      }\n    }\n  }\n  return !triangulationFailure;\n} // ---------------------------------------------------\n\n/**\n * Create polygons from line segments.\n *\n * @param {vtkPolyData} polyData\n * @param {Number} firstLine\n * @param {Number} endLine\n * @param {Boolean} oriented\n * @param {Array} newPolys\n * @param {Array} incompletePolys\n */\n\nfunction vtkCCSMakePolysFromLines(polyData, firstLine, endLine, oriented, newPolys, incompletePolys) {\n  var npts = 0;\n  var pts = []; // Bitfield for marking lines as used\n\n  var usedLines = new Uint8Array(endLine - firstLine); // defaults to 0\n  // Require cell links to get lines from pointIds\n\n  polyData.buildLinks(polyData.getPoints().getNumberOfPoints());\n  var numNewPolys = 0;\n  var remainingLines = endLine - firstLine;\n  while (remainingLines > 0) {\n    // Create a new poly\n    var polyId = numNewPolys++;\n    var poly = [];\n    newPolys.push(poly);\n    var lineId = 0;\n    var completePoly = false; // start the poly\n\n    for (lineId = firstLine; lineId < endLine; lineId++) {\n      if (!usedLines[lineId - firstLine]) {\n        pts = polyData.getCellPoints(lineId).cellPointIds;\n        npts = pts.length;\n        var n = npts;\n        if (npts > 2 && pts[0] === pts[npts - 1]) {\n          n = npts - 1;\n          completePoly = true;\n        }\n        poly.length = n;\n        for (var i = 0; i < n; i++) {\n          poly[i] = pts[i];\n        }\n        break;\n      }\n    }\n    usedLines[lineId - firstLine] = 1;\n    remainingLines--;\n    var noLinesMatch = remainingLines === 0 && !completePoly;\n    while (!completePoly && !noLinesMatch && remainingLines > 0) {\n      // This is cleared if a match is found\n      noLinesMatch = true; // Number of points in the poly\n\n      var npoly = poly.length;\n      var lineEndPts = [];\n      var endPts = [poly[npoly - 1], poly[0]]; // For both open ends of the polygon\n\n      for (var endIdx = 0; endIdx < 2; endIdx++) {\n        var matches = [];\n        var cells = polyData.getPointCells(endPts[endIdx]); // Go through all lines that contain this endpoint\n\n        for (var icell = 0; icell < cells.length; icell++) {\n          lineId = cells[icell];\n          if (lineId >= firstLine && lineId < endLine && !usedLines[lineId - firstLine]) {\n            pts = polyData.getCellPoints(lineId).cellPointIds;\n            npts = pts.length;\n            lineEndPts[0] = pts[0];\n            lineEndPts[1] = pts[npts - 1]; // Check that poly end matches line end\n\n            if (endPts[endIdx] === lineEndPts[endIdx] || !oriented && endPts[endIdx] === lineEndPts[1 - endIdx]) {\n              matches.push(lineId);\n            }\n          }\n        }\n        if (matches.length > 0) {\n          // Multiple matches mean we need to decide which path to take\n          if (matches.length > 1) {\n            // Remove double-backs\n            var k = matches.length;\n            do {\n              lineId = matches[--k];\n              pts = polyData.getCellPoints(lineId).cellPointIds;\n              npts = pts.length;\n              lineEndPts[0] = pts[0];\n              lineEndPts[1] = pts[npts - 1]; // check if line is reversed\n\n              var r = endPts[endIdx] !== lineEndPts[endIdx];\n              if (!r && (endIdx === 0 && poly[npoly - 2] === pts[1] || endIdx === 1 && poly[1] === pts[npts - 2]) || r && (endIdx === 0 && poly[npoly - 2] === pts[npts - 2] || endIdx === 1 && poly[1] === pts[1])) {\n                matches.splice(k, 1);\n              }\n            } while (k > 0 && matches.length > 1); // If there are multiple matches due to intersections,\n            // they should be dealt with here.\n          }\n\n          lineId = matches[0];\n          pts = polyData.getCellPoints(lineId).cellPointIds;\n          npts = pts.length;\n          lineEndPts[0] = pts[0];\n          lineEndPts[1] = pts[npts - 1]; // Do both ends match?\n\n          if (endPts[endIdx] === lineEndPts[endIdx]) {\n            completePoly = endPts[1 - endIdx] === lineEndPts[1 - endIdx];\n          } else {\n            completePoly = endPts[1 - endIdx] === lineEndPts[endIdx];\n          }\n          if (endIdx === 0) {\n            for (var _i = 1; _i < npts - (completePoly ? 1 : 0); _i++) {\n              poly.push(pts[_i]);\n            }\n          } else {\n            for (var _i2 = completePoly ? 1 : 0; _i2 < npts - 1; _i2++) {\n              poly.unshift(pts[_i2]);\n            }\n          }\n          if (endPts[endIdx] !== lineEndPts[endIdx]) {\n            // reverse the ids in the added line\n            var pit = poly.length;\n            var ptsIt = completePoly ? 1 : 0;\n            var ptsEnd = npts - 1;\n            if (endIdx === 1) {\n              pit = npts - 1 - (completePoly ? 1 : 0);\n              ptsIt = pts + 1;\n              ptsEnd = pts + npts - (completePoly ? 1 : 0);\n            }\n            while (ptsIt !== ptsEnd) {\n              poly[--pit] = poly[ptsIt++];\n            }\n          }\n          usedLines[lineId - firstLine] = 1;\n          remainingLines--;\n          noLinesMatch = false;\n        }\n      }\n    } // Check for incomplete polygons\n\n    if (noLinesMatch) {\n      incompletePolys.push(polyId);\n    }\n  }\n} // ---------------------------------------------------\n\n/**\n * Join polys that have loose ends, as indicated by incompletePolys.\n * Any polys created will have a normal opposite to the supplied normal,\n * and any new edges that are created will be on the hull of the point set.\n * Shorter edges will be preferred over long edges.\n *\n * @param {Array[]} polys\n * @param {Array} incompletePolys\n * @param {vtkPoints} points\n * @param {Vector3} normal\n */\n\nfunction vtkCCSJoinLooseEnds(polys, incompletePolys, points, normal) {\n  // Relative tolerance for checking whether an edge is on the hull\n  var tol = CCS_POLYGON_TOLERANCE; // A list of polys to remove when everything is done\n\n  var removePolys = [];\n  var p1 = [];\n  var p2 = [];\n  var poly1;\n  var poly2;\n  var pt1;\n  var pt2;\n  var dMin;\n  var iMin;\n  var v;\n  var d;\n  var n = incompletePolys.length;\n  while (n !== 0) {\n    poly1 = polys[incompletePolys[n - 1]];\n    pt1 = poly1[poly1.length - 1];\n    points.getPoint(pt1, p1);\n    dMin = Number.MAX_VALUE;\n    iMin = 0;\n    for (var _i3 = 0; _i3 < n; _i3++) {\n      poly2 = polys[incompletePolys[_i3]];\n      pt2 = poly2[0];\n      points.getPoint(pt2, p2); // The next few steps verify that edge [p1, p2] is on the hull\n\n      v = [p2[0] - p1[0], p2[1] - p1[1], p2[2] - p1[2]];\n      d = norm(v);\n      if (d !== 0) {\n        v[0] /= d;\n        v[1] /= d;\n        v[2] /= d;\n      } // Compute the midpoint of the edge\n\n      var pm = [0.5 * (p1[0] + p2[0]), 0.5 * (p1[1] + p2[1]), 0.5 * (p1[2] + p2[2])]; // Create a plane equation\n\n      var pc = [];\n      cross(normal, v, pc);\n      pc[3] = -dot(pc, pm); // Check that all points are inside the plane.  If they aren't, then\n      // the edge is not on the hull of the pointset.\n\n      var badPoint = false;\n      var m = polys.length;\n      var p = [];\n      for (var j = 0; j < m && !badPoint; j++) {\n        var poly = polys[j];\n        var npts = poly.length;\n        for (var k = 0; k < npts; k++) {\n          var ptId = poly[k];\n          if (ptId !== pt1 && ptId !== pt2) {\n            points.getPoint(ptId, p);\n            var val = p[0] * pc[0] + p[1] * pc[1] + p[2] * pc[2] + pc[3];\n            var r2 = distance2BetweenPoints(p, pm); // Check distance from plane against the tolerance\n\n            if (val < 0 && val * val > tol * tol * r2) {\n              badPoint = true;\n              break;\n            }\n          }\n        } // If no bad points, then this edge is a candidate\n\n        if (!badPoint && d < dMin) {\n          dMin = d;\n          iMin = _i3;\n        }\n      }\n    } // If a match was found, append the polys\n\n    if (dMin < Number.MAX_VALUE) {\n      // Did the poly match with itself?\n      if (iMin === n - 1) {\n        // Mark the poly as closed\n        incompletePolys.pop();\n      } else {\n        var _poly;\n        var id2 = incompletePolys[iMin]; // Combine the polys\n        // for (let i = 1; i < polys[id2].length; i++) {\n        //   poly1.push(polys[id2][i]);\n        // }\n\n        (_poly = poly1).push.apply(_poly, _toConsumableArray(polys[id2])); // Erase the second poly\n\n        removePolys.push(id2);\n        incompletePolys.splice(iMin, 1);\n      }\n    } else {\n      // If no match, erase this poly from consideration\n      removePolys.push(incompletePolys[n - 1]);\n      incompletePolys.pop();\n    }\n    n = incompletePolys.length;\n  } // Remove polys that couldn't be completed\n\n  removePolys.sort(function (a, b) {\n    return a - b;\n  });\n  var i = removePolys.length;\n  while (i > 0) {\n    // Remove items in reverse order\n    polys.splice(removePolys[--i], 1);\n  } // Clear the incompletePolys vector, it's indices are no longer valid\n\n  incompletePolys.length = 0;\n} // ---------------------------------------------------\n\n/**\n * Given three vectors p.p1, p.p2, and p.p3, this routine\n * checks to see if progressing from p1 to p2 to p3 is a clockwise\n * or counterclockwise progression with respect to the normal.\n * The return value is -1 for clockwise, +1 for counterclockwise,\n * and 0 if any two of the vectors are coincident.\n *\n * @param {Vector3} p\n * @param {Vector3} p1\n * @param {Vector3} p2\n * @param {Vector3} p3\n * @param {Vector3} normal\n * @returns {Number}\n */\n\nfunction vtkCCSVectorProgression(p, p1, p2, p3, normal) {\n  var v1 = [p1[0] - p[0], p1[1] - p[1], p1[2] - p[2]];\n  var v2 = [p2[0] - p[0], p2[1] - p[1], p2[2] - p[2]];\n  var v3 = [p3[0] - p[0], p3[1] - p[1], p3[2] - p[2]];\n  var w1 = [];\n  var w2 = [];\n  cross(v2, v1, w1);\n  cross(v2, v3, w2);\n  var s1 = dot(w1, normal);\n  var s2 = dot(w2, normal);\n  if (s1 !== 0 && s2 !== 0) {\n    var sb1 = s1 < 0;\n    var sb2 = s2 < 0; // if sines have different signs\n    // XOR\n\n    if (sb1 ? !sb2 : sb2) {\n      // return -1 if s2 is -ve\n      return 1 - 2 * sb2;\n    }\n    var c1 = dot(v2, v1);\n    var l1 = norm(v1);\n    var c2 = dot(v2, v3);\n    var l2 = norm(v3); // ck is the difference of the cosines, flipped in sign if sines are +ve\n\n    var ck = (c2 * l2 - c1 * l1) * (1 - sb1 * 2);\n    if (ck !== 0) {\n      // return the sign of ck\n      return 1 - 2 * (ck < 0);\n    }\n  }\n  return 0;\n} // ---------------------------------------------------\n\n/**\n * Check for self-intersection. Split the figure-eights.\n * This assumes that all intersections occur at existing\n * vertices, i.e. no new vertices will be created. Returns\n * the number of splits made.\n *\n * @param {Array[]} polys\n * @param {vtkPoints} points\n * @param {Array} polyGroups\n * @param {Array} polyEdges\n * @param {Vector3} normal\n * @param {Boolean} oriented\n */\n\nfunction vtkCCSSplitAtPinchPoints(polys, points, polyGroups, polyEdges, normal, oriented) {\n  var tryPoints = vtkPoints.newInstance({\n    dataType: VtkDataTypes.DOUBLE,\n    empty: true\n  });\n  var locator = vtkIncrementalOctreePointLocator.newInstance();\n  var splitCount = 0;\n  var poly;\n  var n;\n  var bounds;\n  var tol;\n  for (var i = 0; i < polys.length; i++) {\n    poly = polys[i];\n    n = poly.length;\n    bounds = [];\n    tol = CCS_POLYGON_TOLERANCE * Math.sqrt(vtkPolygon.getBounds(poly, points, bounds));\n    if (tol === 0) {\n      // eslint-disable-next-line no-continue\n      continue;\n    }\n    tryPoints.initialize();\n    locator.setTolerance(tol);\n    locator.initPointInsertion(tryPoints, bounds);\n    var foundMatch = false;\n    var idx1 = 0;\n    var idx2 = 0;\n    var unique = 0;\n    var point = [];\n    var p1 = [];\n    var p2 = [];\n    var p3 = [];\n    for (idx2 = 0; idx2 < n; idx2++) {\n      points.getPoint(poly[idx2], point);\n      var _locator$insertUnique = locator.insertUniquePoint(point, 0),\n        success = _locator$insertUnique.success,\n        pointIdx = _locator$insertUnique.pointIdx;\n      if (!success) {\n        // Need vertIdx to match poly indices, so force point insertion\n        locator.insertNextPoint(point); // Do the points have different pointIds?\n\n        idx1 = pointIdx;\n        unique = poly[idx2] !== poly[idx1];\n        if (idx2 > idx1 + 2 - unique && n + idx1 > idx2 + 2 - unique) {\n          if (oriented) {\n            // Make sure that splitting this poly won't create a hole poly\n            var prevIdx = n + idx1 - 1;\n            var midIdx = idx1 + 1;\n            var nextIdx = idx2 + 1;\n            if (prevIdx >= n) {\n              prevIdx -= n;\n            }\n            if (midIdx >= n) {\n              midIdx -= n;\n            }\n            if (nextIdx >= n) {\n              nextIdx -= n;\n            }\n            points.getPoint(poly[prevIdx], p1);\n            points.getPoint(poly[midIdx], p2);\n            points.getPoint(poly[nextIdx], p3);\n            if (vtkCCSVectorProgression(point, p1, p2, p3, normal) > 0) {\n              foundMatch = true;\n              break;\n            }\n          } else {\n            foundMatch = true;\n            break;\n          }\n        }\n      }\n    }\n    if (foundMatch) {\n      splitCount++; // Split off a new poly\n\n      var m = idx2 - idx1;\n      var oldPoly = polys[i];\n      var oldEdges = polyEdges[i];\n      var newPoly1 = oldPoly.slice(idx1, idx1 + m + unique);\n      var newEdges1 = oldEdges.slice(idx1, idx1 + m + unique);\n      var newPoly2 = new Array(n - m + unique);\n      var newEdges2 = new Array(n - m + unique);\n      if (unique) {\n        newEdges1[m] = -1;\n      } // The poly that is split off, which might have more intersections\n\n      for (var j = 0; j < idx1 + unique; j++) {\n        newPoly2[j] = oldPoly[j];\n        newEdges2[j] = oldEdges[j];\n      }\n      if (unique) {\n        newEdges2[idx1] = -1;\n      }\n      for (var k = idx2; k < n; k++) {\n        newPoly2[k - m + unique] = oldPoly[k];\n        newEdges2[k - m + unique] = oldEdges[k];\n      }\n      polys[i] = newPoly1;\n      polyEdges[i] = newEdges1;\n      polys.push(newPoly2);\n      polyEdges.push(newEdges2); // Unless polygroup was clear (because poly was reversed),\n      // make a group with one entry for the new poly\n\n      polyGroups.length = polys.length;\n      if (polyGroups[i].length > 0) {\n        polyGroups[polys.length - 1].push(polys.length - 1);\n      }\n    }\n  }\n  return splitCount;\n} // ---------------------------------------------------\n\n/**\n * The polygons might have a lot of extra points, i.e. points\n * in the middle of the edges.  Remove those points, but keep\n * the original edges as polylines in the originalEdges array.\n * Only original edges with more than two points will be kept.\n *\n * @param {Array[]} polys\n * @param {vtkPoints} points\n * @param {Array} polyEdges\n * @param {Array} originalEdges\n */\n\nfunction vtkCCSFindTrueEdges(polys, points, polyEdges, originalEdges) {\n  // Tolerance^2 for angle to see if line segments are parallel\n  var atol2 = CCS_POLYGON_TOLERANCE * CCS_POLYGON_TOLERANCE;\n  var p0 = [];\n  var p1 = [];\n  var p2 = [];\n  var v1 = [];\n  var v2 = [];\n  var l1;\n  var l2;\n  for (var polyId = 0; polyId < polys.length; polyId++) {\n    var oldPoly = polys[polyId];\n    var n = oldPoly.length;\n    var newEdges = [];\n    polyEdges.push(newEdges); // Only useful if poly has more than three sides\n\n    if (n < 4) {\n      newEdges[0] = -1;\n      newEdges[1] = -1;\n      newEdges[2] = -1; // eslint-disable-next-line no-continue\n\n      continue;\n    } // While we remove points, m keeps track of how many points are left\n\n    var m = n; // Compute bounds for tolerance\n\n    var bounds = [];\n    var tol2 = vtkPolygon.getBounds(oldPoly, points, bounds) * atol2; // The new poly\n\n    var newPoly = [];\n    var cornerPointId = 0;\n    var oldOriginalId = -1; // Keep the partial edge from before the first corner is found\n\n    var partialEdge = [];\n    var cellCount = 0;\n    points.getPoint(oldPoly[n - 1], p0);\n    points.getPoint(oldPoly[0], p1);\n    subtract(p1, p0, v1);\n    l1 = dot(v1, v1);\n    for (var j = 0; j < n; j++) {\n      var k = j + 1;\n      if (k >= n) {\n        k -= n;\n      }\n      points.getPoint(oldPoly[k], p2);\n      subtract(p2, p1, v2);\n      l2 = dot(v2, v2); // Dot product is |v1||v2|cos(theta)\n\n      var c = dot(v1, v2); // sin^2(theta) = (1 - cos^2(theta))\n      // and   c*c = l1*l2*cos^2(theta)\n\n      var s2 = l1 * l2 - c * c; // In the small angle approximation, sin(theta) == theta, so\n      // s2/(l1*l2) is the angle that we want to check, but it's not\n      // a valid check if l1 or l2 is very close to zero.\n\n      var pointId = oldPoly[j]; // Keep the point if:\n      // 1) removing it would create a 2-point poly OR\n      // 2) it's more than \"tol\" distance from the prev point AND\n      // 3) the angle is greater than atol:\n\n      if (m <= 3 || l1 > tol2 && (c < 0 || l1 < tol2 || l2 < tol2 || s2 > l1 * l2 * atol2)) {\n        // Complete the previous edge only if the final point count\n        // will be greater than two\n        if (cellCount > 1) {\n          if (pointId !== oldOriginalId) {\n            originalEdges.push(pointId);\n            cellCount++;\n          } // Update the number of segments in the edge\n\n          var countLocation = originalEdges.length - cellCount - 1;\n          originalEdges[countLocation] = cellCount;\n          newEdges.push(countLocation);\n        } else if (cellCount === 0) {\n          partialEdge.push(pointId);\n        } else {\n          newEdges.push(-1);\n        }\n        newPoly.push(pointId); // Start a new edge with cornerPointId as a \"virtual\" point\n\n        cornerPointId = pointId;\n        oldOriginalId = pointId;\n        cellCount = 1; // Rotate to the next point\n\n        p0[0] = p2[0];\n        p0[1] = p2[1];\n        p0[2] = p2[2];\n        p1[0] = p2[0];\n        p1[1] = p2[1];\n        p1[2] = p2[2];\n        v1[0] = v2[0];\n        v1[1] = v2[1];\n        v1[2] = v2[2];\n        l1 = l2;\n      } else {\n        if (cellCount > 0 && pointId !== oldOriginalId) {\n          // First check to see if we have to add cornerPointId\n          if (cellCount === 1) {\n            originalEdges.push(1); // new edge\n\n            originalEdges.push(cornerPointId);\n          } // Then add the new point\n\n          originalEdges.push(pointId);\n          oldOriginalId = pointId;\n          cellCount++;\n        } else {\n          // No corner yet, so save the point\n          partialEdge.push(pointId);\n        } // Reduce the count\n\n        m--; // Join the previous two segments, since the point was removed\n\n        p1[0] = p2[0];\n        p1[1] = p2[1];\n        p1[2] = p2[2];\n        subtract(p2, p0, v1);\n        l1 = dot(v1, v1);\n      }\n    } // Add the partial edge to the end\n\n    for (var ii = 0; ii < partialEdge.length; ii++) {\n      var _pointId = partialEdge[ii];\n      if (_pointId !== oldOriginalId) {\n        if (cellCount === 1) {\n          originalEdges.push(1); // new edge\n\n          originalEdges.push(cornerPointId);\n        }\n        originalEdges.push(_pointId);\n        oldOriginalId = _pointId;\n        cellCount++;\n      }\n    } // Finalize\n\n    if (cellCount > 1) {\n      // Update the number of segments in the edge\n      var _countLocation = originalEdges.length - cellCount - 1;\n      originalEdges[_countLocation] = cellCount;\n      newEdges.push(_countLocation);\n    }\n    polys[polyId] = newPoly;\n  }\n} // ---------------------------------------------------\n\n/**\n * Reverse a cleaned-up polygon along with the info about\n * all of its original vertices.\n *\n * @param {Array} poly\n * @param {Array} edges\n * @param {Array} originalEdges\n */\n\nfunction vtkCCSReversePoly(poly, edges, originalEdges) {\n  reverseElements(poly, 1, poly.length - 1);\n  edges.reverse();\n  for (var i = 0; i < edges.length; i++) {\n    if (edges[i] >= 0) {\n      var firstPtsIdx = edges[i] + 1;\n      var npts = originalEdges[edges[i]];\n      reverseElements(originalEdges, firstPtsIdx, firstPtsIdx + npts - 1);\n    }\n  }\n} // ---------------------------------------------------\n\n/**\n * Check the sense of the polygon against the given normal. Returns\n * zero if the normal is zero.\n *\n * @param {Array} poly\n * @param {vtkPoints} points\n * @param {Vector3} normal\n */\n\nfunction vtkCCSCheckPolygonSense(poly, points, normal) {\n  // Compute the normal\n  var pnormal = [0.0, 0.0, 0.0];\n  var p0 = [];\n  var p1 = [];\n  var p2 = [];\n  var v1 = [];\n  var v2 = [];\n  var v = [];\n  points.getPoint(poly[0], p0);\n  points.getPoint(poly[1], p1);\n  subtract(p1, p0, v1);\n  for (var jj = 2; jj < poly.length; jj++) {\n    points.getPoint(poly[jj], p2);\n    subtract(p2, p0, v2);\n    cross(v1, v2, v);\n    add(pnormal, v, pnormal);\n    p1[0] = p2[0];\n    p1[1] = p2[1];\n    p1[2] = p2[2];\n    v1[0] = v2[0];\n    v1[1] = v2[1];\n    v1[2] = v2[2];\n  } // Check the normal\n\n  var d = dot(pnormal, normal);\n  return {\n    isNormalNotZero: d !== 0,\n    sense: d > 0\n  };\n} // ---------------------------------------------------\n\n/**\n * Check whether innerPoly is inside outerPoly.\n * The normal is needed to verify the polygon orientation.\n * The values of pp, bounds, and tol2 must be precomputed\n * by calling vtkCCSPrepareForPolyInPoly() on outerPoly.\n *\n * @param {Array} outerPoly\n * @param {Array} innerPoly\n * @param {vtkPoints} points\n * @param {Vector3} normal\n * @param {Float64Array} pp\n * @param {Bounds} bounds\n * @param {Number} tol2\n */\n\nfunction vtkCCSPolyInPoly(outerPoly, innerPoly, points, normal, pp, bounds, tol2) {\n  // Find a vertex of poly \"j\" that isn't on the edge of poly \"i\".\n  // This is necessary or the PointInPolygon might return \"true\"\n  // based only on roundoff error.\n  var n = outerPoly.length;\n  var m = innerPoly.length;\n  var p = [];\n  var q1 = [];\n  var q2 = [];\n  for (var jj = 0; jj < m; jj++) {\n    // Semi-randomize the point order\n    // eslint-disable-next-line no-bitwise\n    var kk = (jj >> 1) + (jj & 1) * (m + 1 >> 1);\n    points.getPoint(innerPoly[kk], p);\n    var intersectionState = vtkPolygon.pointInPolygon(p, pp, bounds, normal);\n    if (intersectionState === PolygonWithPointIntersectionState.FAILURE) {\n      vtkErrorMacro('Error finding point in polygon in vtkCCSPolyInPoly');\n    }\n    if (intersectionState !== PolygonWithPointIntersectionState.OUTSIDE) {\n      var pointOnEdge = 0;\n      points.getPoint(outerPoly[n - 1], q1);\n      for (var ii = 0; ii < n; ii++) {\n        points.getPoint(outerPoly[ii], q2); // This method returns distance squared\n\n        var _vtkLine$distanceToLi = vtkLine.distanceToLine(p, q1, q2),\n          distance = _vtkLine$distanceToLi.distance;\n        if (distance < tol2) {\n          pointOnEdge = 1;\n          break;\n        }\n        q1[0] = q2[0];\n        q1[1] = q2[1];\n        q1[2] = q2[2];\n      }\n      if (!pointOnEdge) {\n        // Good result, point is in polygon\n        return true;\n      }\n    }\n  } // No matches found\n\n  return false;\n} // ---------------------------------------------------\n\n/**\n * Precompute values needed for the PolyInPoly check.\n * The values that are returned are as follows:\n * pp: an array of the polygon vertices\n * bounds: the polygon bounds\n * tol2: a tolerance value based on the size of the polygon\n * (note: pp must be pre-allocated to the 3*outerPoly.length)\n *\n * @param {Array} outerPoly\n * @param {vtkPoints} points\n * @param {Float64Array} pp\n * @param {Bounds} bounds\n */\n\nfunction vtkCCSPrepareForPolyInPoly(outerPoly, points, pp, bounds) {\n  var n = outerPoly.length;\n  if (n === 0) {\n    return 0.0; // to avoid false positive warning about uninitialized value\n  } // Pull out the points\n\n  var point = [];\n  var j = 0;\n  for (var i = 0; i < n; i++) {\n    points.getPoint(outerPoly[i], point);\n    pp[j++] = point[0];\n    pp[j++] = point[1];\n    pp[j++] = point[2];\n  } // Find the bounding box and tolerance for the polygon\n\n  return vtkPolygon.getBounds(outerPoly, points, bounds) * (CCS_POLYGON_TOLERANCE * CCS_POLYGON_TOLERANCE);\n} // ---------------------------------------------------\n\n/**\n * Check for polygons within polygons. Group the polygons\n * if they are within each other. Reverse the sense of\n * the interior \"hole\" polygons. A hole within a hole\n * will be reversed twice and will become its own group.\n *\n * @param {Array} newPolys\n * @param {vtkPoints} points\n * @param {Array} polyGroups\n * @param {Array} polyEdges\n * @param {Array} originalEdges\n * @param {Vector3} normal\n * @param {Boolean} oriented\n */\n\nfunction vtkCCSMakeHoleyPolys(newPolys, points, polyGroups, polyEdges, originalEdges, normal, oriented) {\n  var numNewPolys = newPolys.length;\n  if (numNewPolys <= 1) {\n    return;\n  } // Use bit arrays to keep track of inner polys\n\n  var polyReversed = [];\n  var innerPolys = []; // GroupCount is an array only needed for unoriented polys\n\n  var groupCount;\n  if (!oriented) {\n    groupCount = new Int32Array(numNewPolys);\n  } // Find the maximum poly size\n\n  var nmax = 1;\n  for (var kk = 0; kk < numNewPolys; kk++) {\n    nmax = Math.max(nmax, newPolys[kk].length);\n  } // These are some values needed for poly-in-poly checks\n\n  var pp = new Float64Array(3 * nmax);\n  var bounds = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0];\n  var tol2; // Go through all polys\n\n  for (var i = 0; i < numNewPolys; i++) {\n    var n = newPolys[i].length;\n    if (n < 3) {\n      // eslint-disable-next-line no-continue\n      continue;\n    } // Check if poly is reversed\n\n    var _vtkCCSCheckPolygonSe = vtkCCSCheckPolygonSense(newPolys[i], points, normal),\n      isNormalNotZero = _vtkCCSCheckPolygonSe.isNormalNotZero,\n      sense = _vtkCCSCheckPolygonSe.sense;\n    if (isNormalNotZero) {\n      polyReversed[i] = !sense;\n    } // Precompute some values needed for poly-in-poly checks\n\n    tol2 = vtkCCSPrepareForPolyInPoly(newPolys[i], points, pp, bounds); // Look for polygons inside of this one\n\n    for (var j = 0; j < numNewPolys; j++) {\n      if (j !== i && newPolys[j].length >= 3) {\n        // Make sure polygon i is not in polygon j\n        var pg = polyGroups[j];\n        if (!pg.includes(i)) {\n          if (vtkCCSPolyInPoly(newPolys[i], newPolys[j], points, normal, pp.subarray(3 * n), bounds, tol2)) {\n            // Add to group\n            polyGroups[i].push(j);\n            if (groupCount) {\n              groupCount[j] += 1;\n            }\n          }\n        }\n      }\n    }\n  }\n  if (!oriented) {\n    // build a stack of polys that aren't inside other polys=\n    var outerPolyStack = [];\n    for (var ll = 0; ll < numNewPolys; ll++) {\n      if (groupCount[ll] === 0) {\n        outerPolyStack.push(ll);\n      }\n    }\n    var _j;\n    while (outerPolyStack.length > 0) {\n      _j = outerPolyStack.length - 1;\n      outerPolyStack.pop();\n      if (polyReversed[_j]) {\n        vtkCCSReversePoly(newPolys[_j], polyEdges[_j], originalEdges);\n        polyReversed[_j] = false;\n      }\n      if (polyGroups[_j].length > 1) {\n        // Convert the group into a bit array, to make manipulation easier\n        innerPolys.length = 0;\n        for (var k = 1; k < polyGroups[_j].length; k++) {\n          var jj = polyGroups[_j][k];\n          if (groupCount[jj] > 1) {\n            groupCount[jj] -= 2;\n            if (groupCount[jj] === 0) {\n              outerPolyStack.push(jj);\n            }\n          } else {\n            innerPolys[jj] = 1;\n            polyGroups[jj].length = 0;\n            if (!polyReversed[jj]) {\n              vtkCCSReversePoly(newPolys[jj], polyEdges[jj], originalEdges);\n              polyReversed[jj] = false;\n            }\n          }\n        } // Use the bit array to recreate the polyGroup\n\n        polyGroups[_j].length = 0;\n        polyGroups[_j].push(_j);\n        for (var _jj2 = 0; _jj2 < numNewPolys; _jj2++) {\n          if (innerPolys[_jj2]) {\n            polyGroups[_j].push(_jj2);\n          }\n        }\n      }\n    }\n  } else {\n    // oriented\n    for (var _j2 = 0; _j2 < numNewPolys; _j2++) {\n      // Remove the groups for reversed polys\n      if (polyReversed[_j2]) {\n        polyGroups[_j2].length = 0;\n      } // Polys inside the interior polys have their own groups, so remove\n      // them from this group\n      else if (polyGroups[_j2].length > 1) {\n        // Convert the group into a bit array, to make manipulation easier\n        innerPolys.length = 0;\n        for (var _k = 1; _k < polyGroups[_j2].length; _k++) {\n          innerPolys[polyGroups[_j2][_k]] = true;\n        } // Look for non-reversed polys inside this one\n\n        for (var _kk = 1; _kk < polyGroups[_j2].length; _kk++) {\n          // jj is the index of the inner poly\n          var _jj3 = polyGroups[_j2][_kk]; // If inner poly is not reversed then\n\n          if (!polyReversed[_jj3]) {\n            // Remove that poly and all polys inside of it from the group\n            for (var ii = 0; ii < polyGroups[_jj3].length; ii++) {\n              innerPolys[polyGroups[_jj3][ii]] = false;\n            }\n          }\n        } // Use the bit array to recreate the polyGroup\n\n        polyGroups[_j2].length = 0;\n        polyGroups[_j2].push(_j2);\n        for (var _jj4 = 0; _jj4 < numNewPolys; _jj4++) {\n          if (innerPolys[_jj4]) {\n            polyGroups[_j2].push(_jj4);\n          }\n        }\n      }\n    }\n  } // delete[] groupCount;\n} // ---------------------------------------------------\n\n/**\n * Check line segment with point Ids (i, j) to make sure that it\n * doesn't cut through the edges of any polys in the group.\n * Return value of zero means check failed and the cut is not\n * usable.\n *\n * @param {Array[]} polys\n * @param {vtkPoints} points\n * @param {Vector3} normal\n * @param {Array} polyGroup\n * @param {Number} outerPolyId\n * @param {Number} innerPolyId\n * @param {Number} outerIdx\n * @param {Number} innerIdx\n */\n\nfunction vtkCCSCheckCut(polys, points, normal, polyGroup, outerPolyId, innerPolyId, outerIdx, innerIdx) {\n  var ptId1 = polys[outerPolyId][outerIdx];\n  var ptId2 = polys[innerPolyId][innerIdx];\n  var tol = CCS_POLYGON_TOLERANCE;\n  var p1 = [];\n  var p2 = [];\n  points.getPoint(ptId1, p1);\n  points.getPoint(ptId2, p2);\n  var w = [];\n  subtract(p2, p1, w);\n  var l = normalize(w); // Cuts between coincident points are good\n\n  if (l === 0) {\n    return true;\n  } // Define a tolerance with units of distance squared\n\n  var tol2 = l * l * tol * tol; // Check the sense of the cut: it must be pointing \"in\" for both polys.\n\n  var polyId = outerPolyId;\n  var polyIdx = outerIdx;\n  var r = p1;\n  var r1 = [];\n  var r2 = p2;\n  var r3 = [];\n  for (var ii = 0; ii < 2; ii++) {\n    var poly = polys[polyId];\n    var n = poly.length;\n    var prevIdx = n - polyIdx - 1;\n    var nextIdx = polyIdx + 1;\n    if (prevIdx >= n) {\n      prevIdx -= n;\n    }\n    if (nextIdx >= n) {\n      nextIdx -= n;\n    }\n    points.getPoint(poly[prevIdx], r1);\n    points.getPoint(poly[nextIdx], r3);\n    if (vtkCCSVectorProgression(r, r1, r2, r3, normal) > 0) {\n      return false;\n    }\n    polyId = innerPolyId;\n    polyIdx = innerIdx;\n    r = p2;\n    r2 = p1;\n  } // Check for intersections of the cut with polygon edges.\n  // First, create a cut plane that divides space at the cut line.\n\n  var pc = [];\n  cross(normal, w, pc);\n  pc[3] = -dot(pc, p1);\n  for (var i = 0; i < polyGroup.length; i++) {\n    var _poly2 = polys[polyGroup[i]];\n    var _n = _poly2.length;\n    var q1 = [];\n    var q2 = [];\n    var qtId1 = _poly2[_n - 1];\n    points.getPoint(qtId1, q1);\n    var v1 = pc[0] * q1[0] + pc[1] * q1[1] + pc[2] * q1[2] + pc[3];\n    var c1 = v1 > 0;\n    for (var j = 0; j < _n; j++) {\n      var qtId2 = _poly2[j];\n      points.getPoint(qtId2, q2);\n      var v2 = pc[0] * q2[0] + pc[1] * q2[1] + pc[2] * q2[2] + pc[3];\n      var c2 = v2 > 0; // If lines share an endpoint, they can't intersect,\n      // so don't bother with the check.\n\n      if (ptId1 !== qtId1 && ptId1 !== qtId2 && ptId2 !== qtId1 && ptId2 !== qtId2) {\n        // Check for intersection\n        if ((c1 ? !c2 : c2) || v1 * v1 < tol2 || v2 * v2 < tol2) {\n          subtract(q2, q1, w);\n          if (dot(w, w) > 0) {\n            var qc = [];\n            cross(w, normal, qc);\n            qc[3] = -dot(qc, q1);\n            var u1 = qc[0] * p1[0] + qc[1] * p1[1] + qc[2] * p1[2] + qc[3];\n            var u2 = qc[0] * p2[0] + qc[1] * p2[1] + qc[2] * p2[2] + qc[3];\n            var d1 = u1 > 0;\n            var d2 = u2 > 0;\n            if (d1 ? !d2 : d2) {\n              // One final check to make sure endpoints aren't coincident\n              var p = p1;\n              var q = q1;\n              if (v2 * v2 < v1 * v1) {\n                p = p2;\n              }\n              if (u2 * u2 < u1 * u1) {\n                q = q2;\n              }\n              if (distance2BetweenPoints(p, q) > tol2) {\n                return false;\n              }\n            }\n          }\n        }\n      }\n      qtId1 = qtId2;\n      q1[0] = q2[0];\n      q1[1] = q2[1];\n      q1[2] = q2[2];\n      v1 = v2;\n      c1 = c2;\n    }\n  }\n  return true;\n} // ---------------------------------------------------\n\n/**\n * Check the quality of a cut between an outer and inner polygon.\n * An ideal cut is one that forms a 90 degree angle with each\n * line segment that it joins to.  Smaller values indicate a\n * higher quality cut.\n *\n * @param {Array} outerPoly\n * @param {Array} innerPoly\n * @param {Number} i\n * @param {Number} j\n * @param {vtkPoints} points\n */\n\nfunction vtkCCSCutQuality(outerPoly, innerPoly, i, j, points) {\n  var n = outerPoly.length;\n  var m = innerPoly.length;\n  var a = i > 0 ? i - 1 : n - 1;\n  var b = i < n - 1 ? i + 1 : 0;\n  var c = j > 0 ? j - 1 : m - 1;\n  var d = j < m - 1 ? j + 1 : 0;\n  var p0 = [];\n  var p1 = [];\n  var p2 = [];\n  points.getPoint(outerPoly[i], p1);\n  points.getPoint(innerPoly[j], p2);\n  var v1 = [];\n  var v2 = [];\n  subtract(p2, p1, v1);\n  var l1 = dot(v1, v1);\n  var l2;\n  var qmax = 0;\n  var q;\n  points.getPoint(outerPoly[a], p0);\n  subtract(p0, p1, v2);\n  l2 = dot(v2, v2);\n  if (l2 > 0) {\n    q = dot(v1, v2);\n    q *= q / l2;\n    if (q > qmax) {\n      qmax = q;\n    }\n  }\n  points.getPoint(outerPoly[b], p0);\n  subtract(p0, p1, v2);\n  l2 = dot(v2, v2);\n  if (l2 > 0) {\n    q = dot(v1, v2);\n    q *= q / l2;\n    if (q > qmax) {\n      qmax = q;\n    }\n  }\n  points.getPoint(innerPoly[c], p0);\n  subtract(p2, p0, v2);\n  l2 = dot(v2, v2);\n  if (l2 > 0) {\n    q = dot(v1, v2);\n    q *= q / l2;\n    if (q > qmax) {\n      qmax = q;\n    }\n  }\n  points.getPoint(innerPoly[d], p0);\n  subtract(p2, p0, v2);\n  l2 = dot(v2, v2);\n  if (l2 > 0) {\n    q = dot(v1, v2);\n    q *= q / l2;\n    if (q > qmax) {\n      qmax = q;\n    }\n  }\n  if (l1 > 0) {\n    return qmax / l1; // also l1 + qmax, incorporates distance;\n  }\n\n  return Number.MAX_VALUE;\n} // ---------------------------------------------------\n\n/**\n * Find the two sharpest verts on an inner (i.e. inside-out) poly.\n *\n * @param {Array} poly\n * @param {vtkPoints} points\n * @param {Vector3} normal\n * @param {[Number, Number]} verts\n */\n\nfunction vtkCCSFindSharpestVerts(poly, points, normal, verts) {\n  var p1 = [];\n  var p2 = [];\n  var v1 = [];\n  var v2 = [];\n  var v = [];\n  var l1;\n  var l2;\n  var minVal = [0, 0];\n  verts[0] = 0;\n  verts[1] = 0;\n  var n = poly.length;\n  points.getPoint(poly[n - 1], p2);\n  points.getPoint(poly[0], p1);\n  subtract(p1, p2, v1);\n  l1 = Math.sqrt(dot(v1, v1));\n  for (var j = 0; j < n; j++) {\n    var k = j + 1;\n    if (k === n) {\n      k = 0;\n    }\n    points.getPoint(poly[k], p2);\n    subtract(p2, p1, v2);\n    l2 = Math.sqrt(dot(v2, v2));\n    cross(v1, v2, v);\n    var b = dot(v, normal);\n    if (b < 0 && l1 * l2 > 0) {\n      // Dot product is |v1||v2|cos(theta), range [-1, +1]\n      var val = dot(v1, v2) / (l1 * l2);\n      if (val < minVal[0]) {\n        minVal[1] = minVal[0];\n        minVal[0] = val;\n        verts[1] = verts[0];\n        verts[0] = j;\n      }\n    } // Rotate to the next point\n\n    p1[0] = p2[0];\n    p1[1] = p2[1];\n    p1[2] = p2[2];\n    v1[0] = v2[0];\n    v1[1] = v2[1];\n    v1[2] = v2[2];\n    l1 = l2;\n  }\n} // ---------------------------------------------------\n\n/**\n * Find two valid cuts between outerPoly and innerPoly.\n * Used by vtkCCSCutHoleyPolys.\n *\n * @param {Array} polys\n * @param {Array} polyGroup\n * @param {Number} outerPolyId\n * @param {Number} innerPolyId\n * @param {vtkPoints} points\n * @param {Vector3} normal\n * @param {Array[]} cuts\n * @param {Boolean} exhaustive\n */\n\nfunction vtkCCSFindCuts(polys, polyGroup, outerPolyId, innerPolyId, points, normal, cuts, exhaustive) {\n  var outerPoly = polys[outerPolyId];\n  var innerPoly = polys[innerPolyId];\n  var innerSize = innerPoly.length; // Find the two sharpest points on the inner poly\n\n  var verts = [];\n  vtkCCSFindSharpestVerts(innerPoly, points, normal, verts); // A list of cut locations according to quality\n\n  var cutlist = [];\n  cutlist.length = outerPoly.length; // Search for potential cuts (need to find two cuts)\n\n  var cutId = 0;\n  cuts[0][0] = 0;\n  cuts[0][1] = 0;\n  cuts[1][0] = 0;\n  cuts[1][1] = 0;\n  var foundCut = false;\n  for (cutId = 0; cutId < 2; cutId++) {\n    var count = exhaustive ? innerSize : 3;\n    for (var i = 0; i < count && !foundCut; i++) {\n      // Semi-randomize the search order\n      // TODO: Does this do the same as in C++?\n      // eslint-disable-next-line no-bitwise\n      var j = (i >> 1) + (i & 1) * (innerSize + 1 >> 1); // Start at the best first point\n\n      j = (j + verts[cutId]) % innerSize;\n      for (var kk = 0; kk < outerPoly.length; kk++) {\n        var q = vtkCCSCutQuality(outerPoly, innerPoly, kk, j, points);\n        cutlist[kk] = [q, kk];\n      }\n      cutlist.sort(function (a, b) {\n        return a[0] - b[0];\n      });\n      for (var lid = 0; lid < cutlist.length; lid++) {\n        var k = cutlist[lid][1]; // If this is the second cut, do extra checks\n\n        if (cutId > 0) {\n          // Make sure cuts don't share an endpoint\n          if (j === cuts[0][1] || k === cuts[0][0]) {\n            // eslint-disable-next-line no-continue\n            continue;\n          } // Make sure cuts don't intersect\n\n          var p1 = [];\n          var p2 = [];\n          points.getPoint(outerPoly[cuts[0][0]], p1);\n          points.getPoint(innerPoly[cuts[0][1]], p2);\n          var q1 = [];\n          var q2 = [];\n          points.getPoint(outerPoly[k], q1);\n          points.getPoint(innerPoly[j], q2);\n          var u = void 0;\n          var v = void 0;\n          if (vtkLine.intersection(p1, p2, q1, q2, u, v) === vtkLine.IntersectionState.YES_INTERSECTION) {\n            // eslint-disable-next-line no-continue\n            continue;\n          }\n        } // This check is done for both cuts\n\n        if (vtkCCSCheckCut(polys, points, normal, polyGroup, outerPolyId, innerPolyId, k, j)) {\n          cuts[cutId][0] = k;\n          cuts[cutId][1] = j;\n          foundCut = true;\n          break;\n        }\n      }\n    }\n    if (!foundCut) {\n      return false;\n    }\n  }\n  return true;\n} // ---------------------------------------------------\n\n/**\n * Helper for vtkCCSCutHoleyPolys.  Change a polygon and a hole\n * into two separate polygons by making two cuts between them.\n *\n * @param {Array[]} polys\n * @param {Array} polyEdges\n * @param {Number} outerPolyId\n * @param {Number} innerPolyId\n * @param {vtkPoints} points\n * @param {Array[]} cuts\n */\n\nfunction vtkCCSMakeCuts(polys, polyEdges, outerPolyId, innerPolyId, points, cuts) {\n  var q = [];\n  var r = [];\n  for (var bb = 0; bb < 2; bb++) {\n    var ptId1 = polys[outerPolyId][cuts[bb][0]];\n    var ptId2 = polys[innerPolyId][cuts[bb][1]];\n    points.getPoint(ptId1, q);\n    points.getPoint(ptId2, r);\n  }\n  var outerPoly = polys[outerPolyId];\n  var innerPoly = polys[innerPolyId];\n  var outerEdges = polyEdges[outerPolyId];\n  var innerEdges = polyEdges[innerPolyId]; // Generate new polys from the cuts\n\n  var n = outerPoly.length;\n  var m = innerPoly.length;\n  var idx; // Generate poly1\n\n  var n1 = n * (cuts[1][0] < cuts[0][0]) + cuts[1][0] - cuts[0][0] + 1;\n  var n2 = n1 + m * (cuts[0][1] < cuts[1][1]) + cuts[0][1] - cuts[1][1] + 1;\n  var poly1 = [];\n  poly1.length = n2;\n  var edges1 = new Array(n2);\n  idx = cuts[0][0];\n  for (var i1 = 0; i1 < n1; i1++) {\n    var k = idx++;\n    poly1[i1] = outerPoly[k];\n    edges1[i1] = outerEdges[k];\n    idx *= idx !== n;\n  }\n  edges1[n1 - 1] = -1;\n  idx = cuts[1][1];\n  for (var i2 = n1; i2 < n2; i2++) {\n    var _k2 = idx++;\n    poly1[i2] = innerPoly[_k2];\n    edges1[i2] = innerEdges[_k2];\n    idx *= idx !== m;\n  }\n  edges1[n2 - 1] = -1; // Generate poly2\n\n  var m1 = n * (cuts[0][0] < cuts[1][0]) + cuts[0][0] - cuts[1][0] + 1;\n  var m2 = m1 + m * (cuts[1][1] < cuts[0][1]) + cuts[1][1] - cuts[0][1] + 1;\n  var poly2 = [];\n  poly2.length = m2;\n  var edges2 = new Array(m2);\n  idx = cuts[1][0];\n  for (var j1 = 0; j1 < m1; j1++) {\n    var _k3 = idx++;\n    poly2[j1] = outerPoly[_k3];\n    edges2[j1] = outerEdges[_k3];\n    idx *= idx !== n;\n  }\n  edges2[m1 - 1] = -1;\n  idx = cuts[0][1];\n  for (var j2 = m1; j2 < m2; j2++) {\n    var _k4 = idx++;\n    poly2[j2] = innerPoly[_k4];\n    edges2[j2] = innerEdges[_k4];\n    idx *= idx !== m;\n  }\n  edges2[m2 - 1] = -1; // Replace outerPoly and innerPoly with these new polys\n\n  polys[outerPolyId] = poly1;\n  polys[innerPolyId] = poly2;\n  polyEdges[outerPolyId] = edges1;\n  polyEdges[innerPolyId] = edges2;\n} // ---------------------------------------------------\n\n/**\n * After the holes have been identified, make cuts between the\n * outer poly and each hole.  Make two cuts per hole.  The only\n * strict requirement is that the cut must not intersect any\n * edges, but it's best to make sure that no really sharp angles\n * are created.\n *\n * @param {Array[]} polys\n * @param {vtkPoints} points\n * @param {Array[]} polyGroups\n * @param {Array} polyEdges\n * @param {Vector3} normal\n * @returns {boolean}\n */\n\nfunction vtkCCSCutHoleyPolys(polys, points, polyGroups, polyEdges, normal) {\n  var cutFailure = 0; // Go through all groups and cut out the first inner poly that is\n  // found.  Every time an inner poly is cut out, the groupId counter\n  // is reset because cutting a poly creates a new group.\n\n  var groupId = 0;\n  while (groupId < polyGroups.length) {\n    var polyGroup = polyGroups[groupId]; // Only need to make a cut if the group size is greater than 1\n\n    if (polyGroup.length > 1) {\n      // The first member of the group is the outer poly\n      var outerPolyId = polyGroup[0]; // The second member of the group is the first inner poly\n\n      var innerPolyId = polyGroup[1]; // Sort the group by size, do largest holes first\n\n      var innerBySize = new Array(polyGroup.length);\n      for (var i = 1; i < polyGroup.length; i++) {\n        innerBySize[i] = [polys[polyGroup[i]].length, i];\n      }\n      innerBySize = [innerBySize[0]].concat(_toConsumableArray(innerBySize.splice(1).sort(function (a, b) {\n        return a[0] - b[0];\n      })));\n      reverseElements(innerBySize, 1, innerBySize.length - 1); // Need to check all inner polys in sequence, until one succeeds.\n      // Do a quick search first, then do an exhaustive search.\n\n      var madeCut = 0;\n      var inner = 0;\n      for (var exhaustive = 0; exhaustive < 2 && !madeCut; exhaustive++) {\n        for (var j = 1; j < polyGroup.length; j++) {\n          inner = innerBySize[j][1];\n          innerPolyId = polyGroup[inner];\n          var cuts = [];\n          if (vtkCCSFindCuts(polys, polyGroup, outerPolyId, innerPolyId, points, normal, cuts, exhaustive)) {\n            vtkCCSMakeCuts(polys, polyEdges, outerPolyId, innerPolyId, points, cuts);\n            madeCut = 1;\n            break;\n          }\n        }\n      }\n      if (madeCut) {\n        // Move successfully cut innerPolyId into its own group\n        polyGroup.splice(inner, 1); // Only add if innerPolyId hasn't been set already.\n        // Having the same poly occur as both polyGroup and\n        // innerPoly would cause an infinite loop.\n\n        if (polyGroups[innerPolyId].length === 0) {\n          polyGroups[innerPolyId].push(innerPolyId);\n        }\n      } else {\n        // Remove all failed inner polys from the group\n        for (var k = 1; k < polyGroup.length; k++) {\n          innerPolyId = polyGroup[k]; // Only add if innerPolyId hasn't been set already.\n          // Having the same poly occur as both polyGroup and\n          // innerPoly would cause an infinite loop.\n\n          if (polyGroups[innerPolyId].length === 0) {\n            polyGroups[innerPolyId].push(innerPolyId);\n          }\n        }\n        polyGroup.length = 1;\n        cutFailure = 1;\n      } // If there are other interior polys in the group, find out whether\n      // they are in poly1 or poly2\n\n      if (polyGroup.length > 1) {\n        var poly1 = polys[outerPolyId];\n        var pp = new Float64Array(3 * poly1.length);\n        var bounds = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0];\n        var tol2 = vtkCCSPrepareForPolyInPoly(poly1, points, pp, bounds);\n        var nextGroupId = groupId;\n        var ii = 1;\n        while (ii < polyGroup.length) {\n          if (vtkCCSPolyInPoly(poly1, polys[polyGroup[ii]], points, normal, pp, bounds, tol2)) {\n            // Keep this poly in polyGroup\n            ii++;\n          } else {\n            // Move this poly to poly2 group\n            polyGroups[innerPolyId].push(polyGroup[ii]);\n            polyGroup.splice(ii, 1); // Reduce the groupId to ensure that this new group will get cut\n\n            if (innerPolyId < nextGroupId) {\n              nextGroupId = innerPolyId;\n            }\n          }\n        } // Set the groupId for the next iteration\n\n        groupId = nextGroupId; // eslint-disable-next-line no-continue\n\n        continue;\n      }\n    } // Increment to the next group\n\n    groupId++;\n  }\n  return !cutFailure;\n}\nexport { reverseElements, vtkCCSCheckCut, vtkCCSCheckPolygonSense, vtkCCSCutHoleyPolys, vtkCCSCutQuality, vtkCCSFindCuts, vtkCCSFindSharpestVerts, vtkCCSFindTrueEdges, vtkCCSInsertTriangle, vtkCCSJoinLooseEnds, vtkCCSMakeCuts, vtkCCSMakeHoleyPolys, vtkCCSMakePolysFromLines, vtkCCSPolyInPoly, vtkCCSPrepareForPolyInPoly, vtkCCSReversePoly, vtkCCSSplitAtPinchPoints, vtkCCSTriangleQuality, vtkCCSTriangulate, vtkCCSVectorProgression };","map":{"version":3,"names":["_toConsumableArray","macro","vtkPoints","s","subtract","j","cross","d","dot","n","norm","e","distance2BetweenPoints","k","add","l","normalize","vtkLine","vtkPolygon","vtkIncrementalOctreePointLocator","VtkDataTypes","CCS_POLYGON_TOLERANCE","PolygonWithPointIntersectionState","vtkErrorMacro","reverseElements","arr","firstIdx","arguments","length","undefined","lastIdx","first","last","mid","Math","floor","i","_ref","vtkCCSTriangleQuality","p0","p1","p2","normal","u","v","w","area2","perim","sqrt","vtkCCSInsertTriangle","polys","poly","trids","polyEdges","originalEdges","nextVert","edgeCount","edgeLocs","vert","currId","edgeLoc","nextId","insertNextCell","edgePts","maxPoints","currSide","_edgeLoc","npts","pts","slice","prevSide","nextSide","prevNeeded","nextNeeded","tailPtIds","side","m","vtkCCSTriangulate","points","triangulationFailure","ppoint","point","npoint","verts","getPoint","concave","maxq","maxi","_ref2","q","foundEar","Number","MIN_VALUE","jj","x","foundNegative","y","t","_ref3","sside","intersection","IntersectionState","NO_INTERSECTION","_trids","splice","kk","kq","_jj","jq","_q","vtkCCSMakePolysFromLines","polyData","firstLine","endLine","oriented","newPolys","incompletePolys","usedLines","Uint8Array","buildLinks","getPoints","getNumberOfPoints","numNewPolys","remainingLines","polyId","push","lineId","completePoly","getCellPoints","cellPointIds","noLinesMatch","npoly","lineEndPts","endPts","endIdx","matches","cells","getPointCells","icell","r","_i","_i2","unshift","pit","ptsIt","ptsEnd","vtkCCSJoinLooseEnds","tol","removePolys","poly1","poly2","pt1","pt2","dMin","iMin","MAX_VALUE","_i3","pm","pc","badPoint","p","ptId","val","r2","pop","_poly","id2","apply","sort","a","b","vtkCCSVectorProgression","p3","v1","v2","v3","w1","w2","s1","s2","sb1","sb2","c1","l1","c2","l2","ck","vtkCCSSplitAtPinchPoints","polyGroups","tryPoints","newInstance","dataType","DOUBLE","empty","locator","splitCount","bounds","getBounds","initialize","setTolerance","initPointInsertion","foundMatch","idx1","idx2","unique","_locator$insertUnique","insertUniquePoint","success","pointIdx","insertNextPoint","prevIdx","midIdx","nextIdx","oldPoly","oldEdges","newPoly1","newEdges1","newPoly2","Array","newEdges2","vtkCCSFindTrueEdges","atol2","newEdges","tol2","newPoly","cornerPointId","oldOriginalId","partialEdge","cellCount","c","pointId","countLocation","ii","_pointId","_countLocation","vtkCCSReversePoly","edges","reverse","firstPtsIdx","vtkCCSCheckPolygonSense","pnormal","isNormalNotZero","sense","vtkCCSPolyInPoly","outerPoly","innerPoly","pp","q1","q2","intersectionState","pointInPolygon","FAILURE","OUTSIDE","pointOnEdge","_vtkLine$distanceToLi","distanceToLine","distance","vtkCCSPrepareForPolyInPoly","vtkCCSMakeHoleyPolys","polyReversed","innerPolys","groupCount","Int32Array","nmax","max","Float64Array","_vtkCCSCheckPolygonSe","pg","includes","subarray","outerPolyStack","ll","_j","_jj2","_j2","_k","_kk","_jj3","_jj4","vtkCCSCheckCut","polyGroup","outerPolyId","innerPolyId","outerIdx","innerIdx","ptId1","ptId2","polyIdx","r1","r3","_poly2","_n","qtId1","qtId2","qc","u1","u2","d1","d2","vtkCCSCutQuality","qmax","vtkCCSFindSharpestVerts","minVal","vtkCCSFindCuts","cuts","exhaustive","innerSize","cutlist","cutId","foundCut","count","lid","YES_INTERSECTION","vtkCCSMakeCuts","bb","outerEdges","innerEdges","idx","n1","n2","edges1","i1","i2","_k2","m1","m2","edges2","j1","_k3","j2","_k4","vtkCCSCutHoleyPolys","cutFailure","groupId","innerBySize","concat","madeCut","inner","nextGroupId"],"sources":["/home/rakshith/Documents/RemoteRendering/vtk-js-react-app/node_modules/@kitware/vtk.js/Filters/General/ContourTriangulator/helper.js"],"sourcesContent":["import _toConsumableArray from '@babel/runtime/helpers/toConsumableArray';\nimport macro from '../../../macros.js';\nimport vtkPoints from '../../../Common/Core/Points.js';\nimport { s as subtract, j as cross, d as dot, n as norm, e as distance2BetweenPoints, k as add, l as normalize } from '../../../Common/Core/Math/index.js';\nimport vtkLine from '../../../Common/DataModel/Line.js';\nimport vtkPolygon from '../../../Common/DataModel/Polygon.js';\nimport vtkIncrementalOctreePointLocator from '../../../Common/DataModel/IncrementalOctreePointLocator.js';\nimport { VtkDataTypes } from '../../../Common/Core/DataArray/Constants.js';\nimport { CCS_POLYGON_TOLERANCE } from './Constants.js';\nimport { PolygonWithPointIntersectionState } from '../../../Common/DataModel/Polygon/Constants.js';\n\nvar vtkErrorMacro = macro.vtkErrorMacro;\n/**\n * Reverse the elements between the indices firstIdx and lastIdx of the given array arr.\n *\n * @param {Array|TypedArray} arr\n * @param {Number} firstIdx\n * @param {Number} lastIdx\n */\n\nfunction reverseElements(arr) {\n  var firstIdx = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n  var lastIdx = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\n  var first = firstIdx !== null && firstIdx !== void 0 ? firstIdx : 0;\n  var last = lastIdx !== null && lastIdx !== void 0 ? lastIdx : arr.length - 1;\n  var mid = first + Math.floor((last - first) / 2);\n\n  for (var i = first; i <= mid; ++i) {\n    var _ref = [arr[last - (i - first)], arr[i]];\n    arr[i] = _ref[0];\n    arr[last - (i - first)] = _ref[1];\n  }\n} // ---------------------------------------------------\n\n/**\n * Compute the quality of a triangle.\n *\n * @param {Vector3} p0\n * @param {Vector3} p1\n * @param {Vector3} p2\n * @param {Vector3} normal\n * @returns {Number}\n */\n\nfunction vtkCCSTriangleQuality(p0, p1, p2, normal) {\n  var u = [];\n  var v = [];\n  var w = [];\n  subtract(p1, p0, u);\n  subtract(p2, p1, v);\n  subtract(p0, p2, w);\n  var area2 = (u[1] * v[2] - u[2] * v[1]) * normal[0] + (u[2] * v[0] - u[0] * v[2]) * normal[1] + (u[0] * v[1] - u[1] * v[0]) * normal[2];\n  var perim = Math.sqrt(u[0] * u[0] + u[1] * u[1] + u[2] * u[2]) + Math.sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]) + Math.sqrt(w[0] * w[0] + w[1] * w[1] + w[2] * w[2]);\n  perim *= perim; // square the perimeter\n\n  perim = perim !== 0 ? perim : 1.0; // use a normalization factor so equilateral quality is 1.0\n\n  return area2 / perim * 10.392304845413264;\n} // ---------------------------------------------------\n\n/**\n * Insert a triangle, and subdivide that triangle if one of\n * its edges originally had more than two points before\n * vtkCCSFindTrueEdges was called. Is called by vtkCCSTriangulate.\n *\n * @param {vtkCellArray} polys\n * @param {Array|TypedArray} poly\n * @param {Vector3} trids\n * @param {Array|TypedArray} polyEdges\n * @param {Array|TypedArray} originalEdges\n */\n\nfunction vtkCCSInsertTriangle(polys, poly, trids, polyEdges, originalEdges) {\n  var nextVert = [1, 2, 0]; // To store how many of originalEdges match\n\n  var edgeCount = 0;\n  var edgeLocs = [-1, -1, -1]; // Check for original edge matches\n\n  for (var vert = 0; vert < 3; vert++) {\n    var currId = trids[vert];\n    var edgeLoc = polyEdges[currId];\n\n    if (edgeLoc >= 0) {\n      var nextId = currId + 1;\n\n      if (nextId === poly.length) {\n        nextId = 0;\n      } // Is the triangle edge a polygon edge?\n\n\n      if (nextId === trids[nextVert[vert]]) {\n        edgeLocs[vert] = edgeLoc;\n        edgeCount++;\n      }\n    }\n  }\n\n  if (edgeCount === 0) {\n    // No special edge handling, so just do one triangle\n    polys.insertNextCell([poly[trids[0]], poly[trids[1]], poly[trids[2]]]);\n  } else {\n    // Make triangle fans for edges with extra points\n    var edgePts = [[poly[trids[0]], poly[trids[1]]], [poly[trids[1]], poly[trids[2]]], [poly[trids[2]], poly[trids[0]]]]; // Find out which edge has the most extra points\n\n    var maxPoints = 0;\n    var currSide = 0;\n\n    for (var i = 0; i < 3; i++) {\n      if (edgeLocs[i] >= 0) {\n        var _edgeLoc = edgeLocs[i];\n        var npts = originalEdges[_edgeLoc];\n        var pts = originalEdges.slice(_edgeLoc + 1, _edgeLoc + 1 + npts);\n\n        if (!(edgePts[i][0] === pts[0] || edgePts[i][1] === pts[npts - 1])) {\n          vtkErrorMacro('assertion error in vtkCCSInsertTriangle');\n        }\n\n        if (npts > maxPoints) {\n          maxPoints = npts;\n          currSide = i;\n        }\n\n        edgePts[i] = pts;\n      }\n    } // Find the edges before/after the edge with most points\n\n\n    var prevSide = (currSide + 2) % 3;\n    var nextSide = (currSide + 1) % 3; // If other edges have only 2 points, nothing to do with them\n\n    var prevNeeded = edgePts[prevSide].length > 2;\n    var nextNeeded = edgePts[nextSide].length > 2; // The tail is the common point in the triangle fan\n\n    var tailPtIds = [];\n    tailPtIds[prevSide] = edgePts[currSide][1];\n    tailPtIds[currSide] = edgePts[prevSide][0];\n    tailPtIds[nextSide] = edgePts[currSide][edgePts[currSide].length - 2]; // Go through the sides and make the fans\n\n    for (var side = 0; side < 3; side++) {\n      if ((side !== prevSide || prevNeeded) && (side !== nextSide || nextNeeded)) {\n        var m = 0;\n        var n = edgePts[side].length - 1;\n\n        if (side === currSide) {\n          m += prevNeeded;\n          n -= nextNeeded;\n        }\n\n        for (var k = m; k < n; k++) {\n          polys.insertNextCell([edgePts[side][k], edgePts[side][k + 1], tailPtIds[side]]);\n        }\n      }\n    }\n  }\n} // ---------------------------------------------------\n\n/**\n * Triangulate a polygon that has been simplified by FindTrueEdges.\n * This will re-insert the original edges.  The output triangles are\n * appended to \"polys\" and, for each stored triangle, \"color\" will\n * be added to \"scalars\".  The final two arguments (polygon and\n * triangles) are only for temporary storage.\n * The return value is true if triangulation was successful.\n *\n * @param {Array} poly\n * @param {vtkPoints} points\n * @param {Array} polyEdges\n * @param {Array} originalEdges\n * @param {vtkCellArray} polys\n * @param {Vector3} normal\n * @returns {boolean}\n */\n\nfunction vtkCCSTriangulate(poly, points, polyEdges, originalEdges, polys, normal) {\n  var n = poly.length; // If the poly is a line, then skip it\n\n  if (n < 3) {\n    return true;\n  } // If the poly is a triangle, then pass it\n\n\n  if (n === 3) {\n    var trids = [0, 1, 2];\n    vtkCCSInsertTriangle(polys, poly, trids, polyEdges, originalEdges);\n    return true;\n  } // If the poly has 4 or more points, triangulate it\n\n\n  var triangulationFailure = false;\n  var ppoint = [];\n  var point = [];\n  var npoint = [];\n  var i = 0;\n  var j = 0;\n  var k = 0;\n  var verts = [];\n  verts.length = n;\n\n  for (i = 0; i < n; i++) {\n    verts[i] = [i, 0];\n  } // compute the triangle quality for each vert\n\n\n  k = n - 2;\n  points.getPoint(poly[verts[k][0]], point);\n  i = n - 1;\n  points.getPoint(poly[verts[i][0]], npoint);\n  var concave = 0;\n  var maxq = 0;\n  var maxi = 0;\n\n  for (j = 0; j < n; j++) {\n    var _ref2 = [point, npoint, ppoint];\n    ppoint = _ref2[0];\n    point = _ref2[1];\n    npoint = _ref2[2];\n    points.getPoint(poly[verts[j][0]], npoint);\n    var q = vtkCCSTriangleQuality(ppoint, point, npoint, normal);\n\n    if (q > maxq) {\n      maxi = i;\n      maxq = q;\n    }\n\n    concave += q < 0;\n    verts[i][1] = q;\n    i = j;\n  }\n\n  var foundEar; // perform the ear-cut triangulation\n\n  for (;;) {\n    // if no potential ears were found, then fail\n    if (maxq <= Number.MIN_VALUE) {\n      triangulationFailure = true;\n      break;\n    }\n\n    i = maxi;\n    j = i + 1 !== n ? i + 1 : 0;\n    k = i !== 0 ? i - 1 : n - 1;\n\n    if (verts[i][1] > 0) {\n      foundEar = true;\n      points.getPoint(poly[verts[j][0]], npoint);\n      points.getPoint(poly[verts[k][0]], ppoint); // only do ear check if there are concave vertices\n\n      if (concave) {\n        // get the normal of the split plane\n        var v = [];\n        var u = [];\n        subtract(npoint, ppoint, v);\n        cross(v, normal, u);\n        var d = dot(ppoint, u);\n        var jj = j + 1 !== n ? j + 1 : 0;\n        var x = [];\n        points.getPoint(poly[verts[jj][0]], x);\n        var side = dot(x, u) < d;\n        var foundNegative = side; // check for crossings of the split plane\n\n        jj = jj + 1 !== n ? jj + 1 : 0;\n        var y = [];\n        var s = [];\n        var t = [];\n\n        for (; foundEar && jj !== k; jj = jj + 1 !== n ? jj + 1 : 0) {\n          var _ref3 = [y, x];\n          x = _ref3[0];\n          y = _ref3[1];\n          points.getPoint(poly[verts[jj][0]], x);\n          var sside = dot(x, u) < d; // XOR\n\n          if (side ? !sside : sside) {\n            side = !side;\n            foundNegative = true;\n            foundEar = vtkLine.intersection(ppoint, npoint, x, y, s, t) === vtkLine.IntersectionState.NO_INTERSECTION;\n          }\n        }\n\n        foundEar && (foundEar = foundNegative);\n      }\n\n      if (!foundEar) {\n        // don't try again until it is split\n        verts[i][1] = Number.MIN_VALUE;\n      } else {\n        // create a triangle from vertex and neighbors\n        var _trids = [verts[i][0], verts[j][0], verts[k][0]];\n        vtkCCSInsertTriangle(polys, poly, _trids, polyEdges, originalEdges); // remove the vertex i\n\n        verts.splice(i, 1);\n        k -= i === 0;\n        j -= j !== 0; // break if this was final triangle\n\n        if (--n < 3) {\n          break;\n        } // re-compute quality of previous point\n\n\n        var kk = k !== 0 ? k - 1 : n - 1;\n        points.getPoint(poly[verts[kk][0]], point);\n        var kq = vtkCCSTriangleQuality(point, ppoint, npoint, normal);\n        concave -= verts[k][1] < 0 && kq >= 0;\n        verts[k][1] = kq; // re-compute quality of next point\n\n        var _jj = j + 1 !== n ? j + 1 : 0;\n\n        points.getPoint(poly[verts[_jj][0]], point);\n        var jq = vtkCCSTriangleQuality(ppoint, npoint, point, normal);\n        concave -= verts[j][1] < 0 && jq >= 0;\n        verts[j][1] = jq;\n      }\n    } // find the highest-quality ear candidate\n\n\n    maxi = 0;\n    maxq = verts[0][1];\n\n    for (i = 1; i < n; i++) {\n      var _q = verts[i][1];\n\n      if (_q > maxq) {\n        maxi = i;\n        maxq = _q;\n      }\n    }\n  }\n\n  return !triangulationFailure;\n} // ---------------------------------------------------\n\n/**\n * Create polygons from line segments.\n *\n * @param {vtkPolyData} polyData\n * @param {Number} firstLine\n * @param {Number} endLine\n * @param {Boolean} oriented\n * @param {Array} newPolys\n * @param {Array} incompletePolys\n */\n\nfunction vtkCCSMakePolysFromLines(polyData, firstLine, endLine, oriented, newPolys, incompletePolys) {\n  var npts = 0;\n  var pts = []; // Bitfield for marking lines as used\n\n  var usedLines = new Uint8Array(endLine - firstLine); // defaults to 0\n  // Require cell links to get lines from pointIds\n\n  polyData.buildLinks(polyData.getPoints().getNumberOfPoints());\n  var numNewPolys = 0;\n  var remainingLines = endLine - firstLine;\n\n  while (remainingLines > 0) {\n    // Create a new poly\n    var polyId = numNewPolys++;\n    var poly = [];\n    newPolys.push(poly);\n    var lineId = 0;\n    var completePoly = false; // start the poly\n\n    for (lineId = firstLine; lineId < endLine; lineId++) {\n      if (!usedLines[lineId - firstLine]) {\n        pts = polyData.getCellPoints(lineId).cellPointIds;\n        npts = pts.length;\n        var n = npts;\n\n        if (npts > 2 && pts[0] === pts[npts - 1]) {\n          n = npts - 1;\n          completePoly = true;\n        }\n\n        poly.length = n;\n\n        for (var i = 0; i < n; i++) {\n          poly[i] = pts[i];\n        }\n\n        break;\n      }\n    }\n\n    usedLines[lineId - firstLine] = 1;\n    remainingLines--;\n    var noLinesMatch = remainingLines === 0 && !completePoly;\n\n    while (!completePoly && !noLinesMatch && remainingLines > 0) {\n      // This is cleared if a match is found\n      noLinesMatch = true; // Number of points in the poly\n\n      var npoly = poly.length;\n      var lineEndPts = [];\n      var endPts = [poly[npoly - 1], poly[0]]; // For both open ends of the polygon\n\n      for (var endIdx = 0; endIdx < 2; endIdx++) {\n        var matches = [];\n        var cells = polyData.getPointCells(endPts[endIdx]); // Go through all lines that contain this endpoint\n\n        for (var icell = 0; icell < cells.length; icell++) {\n          lineId = cells[icell];\n\n          if (lineId >= firstLine && lineId < endLine && !usedLines[lineId - firstLine]) {\n            pts = polyData.getCellPoints(lineId).cellPointIds;\n            npts = pts.length;\n            lineEndPts[0] = pts[0];\n            lineEndPts[1] = pts[npts - 1]; // Check that poly end matches line end\n\n            if (endPts[endIdx] === lineEndPts[endIdx] || !oriented && endPts[endIdx] === lineEndPts[1 - endIdx]) {\n              matches.push(lineId);\n            }\n          }\n        }\n\n        if (matches.length > 0) {\n          // Multiple matches mean we need to decide which path to take\n          if (matches.length > 1) {\n            // Remove double-backs\n            var k = matches.length;\n\n            do {\n              lineId = matches[--k];\n              pts = polyData.getCellPoints(lineId).cellPointIds;\n              npts = pts.length;\n              lineEndPts[0] = pts[0];\n              lineEndPts[1] = pts[npts - 1]; // check if line is reversed\n\n              var r = endPts[endIdx] !== lineEndPts[endIdx];\n\n              if (!r && (endIdx === 0 && poly[npoly - 2] === pts[1] || endIdx === 1 && poly[1] === pts[npts - 2]) || r && (endIdx === 0 && poly[npoly - 2] === pts[npts - 2] || endIdx === 1 && poly[1] === pts[1])) {\n                matches.splice(k, 1);\n              }\n            } while (k > 0 && matches.length > 1); // If there are multiple matches due to intersections,\n            // they should be dealt with here.\n\n          }\n\n          lineId = matches[0];\n          pts = polyData.getCellPoints(lineId).cellPointIds;\n          npts = pts.length;\n          lineEndPts[0] = pts[0];\n          lineEndPts[1] = pts[npts - 1]; // Do both ends match?\n\n          if (endPts[endIdx] === lineEndPts[endIdx]) {\n            completePoly = endPts[1 - endIdx] === lineEndPts[1 - endIdx];\n          } else {\n            completePoly = endPts[1 - endIdx] === lineEndPts[endIdx];\n          }\n\n          if (endIdx === 0) {\n            for (var _i = 1; _i < npts - (completePoly ? 1 : 0); _i++) {\n              poly.push(pts[_i]);\n            }\n          } else {\n            for (var _i2 = completePoly ? 1 : 0; _i2 < npts - 1; _i2++) {\n              poly.unshift(pts[_i2]);\n            }\n          }\n\n          if (endPts[endIdx] !== lineEndPts[endIdx]) {\n            // reverse the ids in the added line\n            var pit = poly.length;\n            var ptsIt = completePoly ? 1 : 0;\n            var ptsEnd = npts - 1;\n\n            if (endIdx === 1) {\n              pit = npts - 1 - (completePoly ? 1 : 0);\n              ptsIt = pts + 1;\n              ptsEnd = pts + npts - (completePoly ? 1 : 0);\n            }\n\n            while (ptsIt !== ptsEnd) {\n              poly[--pit] = poly[ptsIt++];\n            }\n          }\n\n          usedLines[lineId - firstLine] = 1;\n          remainingLines--;\n          noLinesMatch = false;\n        }\n      }\n    } // Check for incomplete polygons\n\n\n    if (noLinesMatch) {\n      incompletePolys.push(polyId);\n    }\n  }\n} // ---------------------------------------------------\n\n/**\n * Join polys that have loose ends, as indicated by incompletePolys.\n * Any polys created will have a normal opposite to the supplied normal,\n * and any new edges that are created will be on the hull of the point set.\n * Shorter edges will be preferred over long edges.\n *\n * @param {Array[]} polys\n * @param {Array} incompletePolys\n * @param {vtkPoints} points\n * @param {Vector3} normal\n */\n\nfunction vtkCCSJoinLooseEnds(polys, incompletePolys, points, normal) {\n  // Relative tolerance for checking whether an edge is on the hull\n  var tol = CCS_POLYGON_TOLERANCE; // A list of polys to remove when everything is done\n\n  var removePolys = [];\n  var p1 = [];\n  var p2 = [];\n  var poly1;\n  var poly2;\n  var pt1;\n  var pt2;\n  var dMin;\n  var iMin;\n  var v;\n  var d;\n  var n = incompletePolys.length;\n\n  while (n !== 0) {\n    poly1 = polys[incompletePolys[n - 1]];\n    pt1 = poly1[poly1.length - 1];\n    points.getPoint(pt1, p1);\n    dMin = Number.MAX_VALUE;\n    iMin = 0;\n\n    for (var _i3 = 0; _i3 < n; _i3++) {\n      poly2 = polys[incompletePolys[_i3]];\n      pt2 = poly2[0];\n      points.getPoint(pt2, p2); // The next few steps verify that edge [p1, p2] is on the hull\n\n      v = [p2[0] - p1[0], p2[1] - p1[1], p2[2] - p1[2]];\n      d = norm(v);\n\n      if (d !== 0) {\n        v[0] /= d;\n        v[1] /= d;\n        v[2] /= d;\n      } // Compute the midpoint of the edge\n\n\n      var pm = [0.5 * (p1[0] + p2[0]), 0.5 * (p1[1] + p2[1]), 0.5 * (p1[2] + p2[2])]; // Create a plane equation\n\n      var pc = [];\n      cross(normal, v, pc);\n      pc[3] = -dot(pc, pm); // Check that all points are inside the plane.  If they aren't, then\n      // the edge is not on the hull of the pointset.\n\n      var badPoint = false;\n      var m = polys.length;\n      var p = [];\n\n      for (var j = 0; j < m && !badPoint; j++) {\n        var poly = polys[j];\n        var npts = poly.length;\n\n        for (var k = 0; k < npts; k++) {\n          var ptId = poly[k];\n\n          if (ptId !== pt1 && ptId !== pt2) {\n            points.getPoint(ptId, p);\n            var val = p[0] * pc[0] + p[1] * pc[1] + p[2] * pc[2] + pc[3];\n            var r2 = distance2BetweenPoints(p, pm); // Check distance from plane against the tolerance\n\n            if (val < 0 && val * val > tol * tol * r2) {\n              badPoint = true;\n              break;\n            }\n          }\n        } // If no bad points, then this edge is a candidate\n\n\n        if (!badPoint && d < dMin) {\n          dMin = d;\n          iMin = _i3;\n        }\n      }\n    } // If a match was found, append the polys\n\n\n    if (dMin < Number.MAX_VALUE) {\n      // Did the poly match with itself?\n      if (iMin === n - 1) {\n        // Mark the poly as closed\n        incompletePolys.pop();\n      } else {\n        var _poly;\n\n        var id2 = incompletePolys[iMin]; // Combine the polys\n        // for (let i = 1; i < polys[id2].length; i++) {\n        //   poly1.push(polys[id2][i]);\n        // }\n\n        (_poly = poly1).push.apply(_poly, _toConsumableArray(polys[id2])); // Erase the second poly\n\n\n        removePolys.push(id2);\n        incompletePolys.splice(iMin, 1);\n      }\n    } else {\n      // If no match, erase this poly from consideration\n      removePolys.push(incompletePolys[n - 1]);\n      incompletePolys.pop();\n    }\n\n    n = incompletePolys.length;\n  } // Remove polys that couldn't be completed\n\n\n  removePolys.sort(function (a, b) {\n    return a - b;\n  });\n  var i = removePolys.length;\n\n  while (i > 0) {\n    // Remove items in reverse order\n    polys.splice(removePolys[--i], 1);\n  } // Clear the incompletePolys vector, it's indices are no longer valid\n\n\n  incompletePolys.length = 0;\n} // ---------------------------------------------------\n\n/**\n * Given three vectors p.p1, p.p2, and p.p3, this routine\n * checks to see if progressing from p1 to p2 to p3 is a clockwise\n * or counterclockwise progression with respect to the normal.\n * The return value is -1 for clockwise, +1 for counterclockwise,\n * and 0 if any two of the vectors are coincident.\n *\n * @param {Vector3} p\n * @param {Vector3} p1\n * @param {Vector3} p2\n * @param {Vector3} p3\n * @param {Vector3} normal\n * @returns {Number}\n */\n\nfunction vtkCCSVectorProgression(p, p1, p2, p3, normal) {\n  var v1 = [p1[0] - p[0], p1[1] - p[1], p1[2] - p[2]];\n  var v2 = [p2[0] - p[0], p2[1] - p[1], p2[2] - p[2]];\n  var v3 = [p3[0] - p[0], p3[1] - p[1], p3[2] - p[2]];\n  var w1 = [];\n  var w2 = [];\n  cross(v2, v1, w1);\n  cross(v2, v3, w2);\n  var s1 = dot(w1, normal);\n  var s2 = dot(w2, normal);\n\n  if (s1 !== 0 && s2 !== 0) {\n    var sb1 = s1 < 0;\n    var sb2 = s2 < 0; // if sines have different signs\n    // XOR\n\n    if (sb1 ? !sb2 : sb2) {\n      // return -1 if s2 is -ve\n      return 1 - 2 * sb2;\n    }\n\n    var c1 = dot(v2, v1);\n    var l1 = norm(v1);\n    var c2 = dot(v2, v3);\n    var l2 = norm(v3); // ck is the difference of the cosines, flipped in sign if sines are +ve\n\n    var ck = (c2 * l2 - c1 * l1) * (1 - sb1 * 2);\n\n    if (ck !== 0) {\n      // return the sign of ck\n      return 1 - 2 * (ck < 0);\n    }\n  }\n\n  return 0;\n} // ---------------------------------------------------\n\n/**\n * Check for self-intersection. Split the figure-eights.\n * This assumes that all intersections occur at existing\n * vertices, i.e. no new vertices will be created. Returns\n * the number of splits made.\n *\n * @param {Array[]} polys\n * @param {vtkPoints} points\n * @param {Array} polyGroups\n * @param {Array} polyEdges\n * @param {Vector3} normal\n * @param {Boolean} oriented\n */\n\nfunction vtkCCSSplitAtPinchPoints(polys, points, polyGroups, polyEdges, normal, oriented) {\n  var tryPoints = vtkPoints.newInstance({\n    dataType: VtkDataTypes.DOUBLE,\n    empty: true\n  });\n  var locator = vtkIncrementalOctreePointLocator.newInstance();\n  var splitCount = 0;\n  var poly;\n  var n;\n  var bounds;\n  var tol;\n\n  for (var i = 0; i < polys.length; i++) {\n    poly = polys[i];\n    n = poly.length;\n    bounds = [];\n    tol = CCS_POLYGON_TOLERANCE * Math.sqrt(vtkPolygon.getBounds(poly, points, bounds));\n\n    if (tol === 0) {\n      // eslint-disable-next-line no-continue\n      continue;\n    }\n\n    tryPoints.initialize();\n    locator.setTolerance(tol);\n    locator.initPointInsertion(tryPoints, bounds);\n    var foundMatch = false;\n    var idx1 = 0;\n    var idx2 = 0;\n    var unique = 0;\n    var point = [];\n    var p1 = [];\n    var p2 = [];\n    var p3 = [];\n\n    for (idx2 = 0; idx2 < n; idx2++) {\n      points.getPoint(poly[idx2], point);\n\n      var _locator$insertUnique = locator.insertUniquePoint(point, 0),\n          success = _locator$insertUnique.success,\n          pointIdx = _locator$insertUnique.pointIdx;\n\n      if (!success) {\n        // Need vertIdx to match poly indices, so force point insertion\n        locator.insertNextPoint(point); // Do the points have different pointIds?\n\n        idx1 = pointIdx;\n        unique = poly[idx2] !== poly[idx1];\n\n        if (idx2 > idx1 + 2 - unique && n + idx1 > idx2 + 2 - unique) {\n          if (oriented) {\n            // Make sure that splitting this poly won't create a hole poly\n            var prevIdx = n + idx1 - 1;\n            var midIdx = idx1 + 1;\n            var nextIdx = idx2 + 1;\n\n            if (prevIdx >= n) {\n              prevIdx -= n;\n            }\n\n            if (midIdx >= n) {\n              midIdx -= n;\n            }\n\n            if (nextIdx >= n) {\n              nextIdx -= n;\n            }\n\n            points.getPoint(poly[prevIdx], p1);\n            points.getPoint(poly[midIdx], p2);\n            points.getPoint(poly[nextIdx], p3);\n\n            if (vtkCCSVectorProgression(point, p1, p2, p3, normal) > 0) {\n              foundMatch = true;\n              break;\n            }\n          } else {\n            foundMatch = true;\n            break;\n          }\n        }\n      }\n    }\n\n    if (foundMatch) {\n      splitCount++; // Split off a new poly\n\n      var m = idx2 - idx1;\n      var oldPoly = polys[i];\n      var oldEdges = polyEdges[i];\n      var newPoly1 = oldPoly.slice(idx1, idx1 + m + unique);\n      var newEdges1 = oldEdges.slice(idx1, idx1 + m + unique);\n      var newPoly2 = new Array(n - m + unique);\n      var newEdges2 = new Array(n - m + unique);\n\n      if (unique) {\n        newEdges1[m] = -1;\n      } // The poly that is split off, which might have more intersections\n\n\n      for (var j = 0; j < idx1 + unique; j++) {\n        newPoly2[j] = oldPoly[j];\n        newEdges2[j] = oldEdges[j];\n      }\n\n      if (unique) {\n        newEdges2[idx1] = -1;\n      }\n\n      for (var k = idx2; k < n; k++) {\n        newPoly2[k - m + unique] = oldPoly[k];\n        newEdges2[k - m + unique] = oldEdges[k];\n      }\n\n      polys[i] = newPoly1;\n      polyEdges[i] = newEdges1;\n      polys.push(newPoly2);\n      polyEdges.push(newEdges2); // Unless polygroup was clear (because poly was reversed),\n      // make a group with one entry for the new poly\n\n      polyGroups.length = polys.length;\n\n      if (polyGroups[i].length > 0) {\n        polyGroups[polys.length - 1].push(polys.length - 1);\n      }\n    }\n  }\n\n  return splitCount;\n} // ---------------------------------------------------\n\n/**\n * The polygons might have a lot of extra points, i.e. points\n * in the middle of the edges.  Remove those points, but keep\n * the original edges as polylines in the originalEdges array.\n * Only original edges with more than two points will be kept.\n *\n * @param {Array[]} polys\n * @param {vtkPoints} points\n * @param {Array} polyEdges\n * @param {Array} originalEdges\n */\n\nfunction vtkCCSFindTrueEdges(polys, points, polyEdges, originalEdges) {\n  // Tolerance^2 for angle to see if line segments are parallel\n  var atol2 = CCS_POLYGON_TOLERANCE * CCS_POLYGON_TOLERANCE;\n  var p0 = [];\n  var p1 = [];\n  var p2 = [];\n  var v1 = [];\n  var v2 = [];\n  var l1;\n  var l2;\n\n  for (var polyId = 0; polyId < polys.length; polyId++) {\n    var oldPoly = polys[polyId];\n    var n = oldPoly.length;\n    var newEdges = [];\n    polyEdges.push(newEdges); // Only useful if poly has more than three sides\n\n    if (n < 4) {\n      newEdges[0] = -1;\n      newEdges[1] = -1;\n      newEdges[2] = -1; // eslint-disable-next-line no-continue\n\n      continue;\n    } // While we remove points, m keeps track of how many points are left\n\n\n    var m = n; // Compute bounds for tolerance\n\n    var bounds = [];\n    var tol2 = vtkPolygon.getBounds(oldPoly, points, bounds) * atol2; // The new poly\n\n    var newPoly = [];\n    var cornerPointId = 0;\n    var oldOriginalId = -1; // Keep the partial edge from before the first corner is found\n\n    var partialEdge = [];\n    var cellCount = 0;\n    points.getPoint(oldPoly[n - 1], p0);\n    points.getPoint(oldPoly[0], p1);\n    subtract(p1, p0, v1);\n    l1 = dot(v1, v1);\n\n    for (var j = 0; j < n; j++) {\n      var k = j + 1;\n\n      if (k >= n) {\n        k -= n;\n      }\n\n      points.getPoint(oldPoly[k], p2);\n      subtract(p2, p1, v2);\n      l2 = dot(v2, v2); // Dot product is |v1||v2|cos(theta)\n\n      var c = dot(v1, v2); // sin^2(theta) = (1 - cos^2(theta))\n      // and   c*c = l1*l2*cos^2(theta)\n\n      var s2 = l1 * l2 - c * c; // In the small angle approximation, sin(theta) == theta, so\n      // s2/(l1*l2) is the angle that we want to check, but it's not\n      // a valid check if l1 or l2 is very close to zero.\n\n      var pointId = oldPoly[j]; // Keep the point if:\n      // 1) removing it would create a 2-point poly OR\n      // 2) it's more than \"tol\" distance from the prev point AND\n      // 3) the angle is greater than atol:\n\n      if (m <= 3 || l1 > tol2 && (c < 0 || l1 < tol2 || l2 < tol2 || s2 > l1 * l2 * atol2)) {\n        // Complete the previous edge only if the final point count\n        // will be greater than two\n        if (cellCount > 1) {\n          if (pointId !== oldOriginalId) {\n            originalEdges.push(pointId);\n            cellCount++;\n          } // Update the number of segments in the edge\n\n\n          var countLocation = originalEdges.length - cellCount - 1;\n          originalEdges[countLocation] = cellCount;\n          newEdges.push(countLocation);\n        } else if (cellCount === 0) {\n          partialEdge.push(pointId);\n        } else {\n          newEdges.push(-1);\n        }\n\n        newPoly.push(pointId); // Start a new edge with cornerPointId as a \"virtual\" point\n\n        cornerPointId = pointId;\n        oldOriginalId = pointId;\n        cellCount = 1; // Rotate to the next point\n\n        p0[0] = p2[0];\n        p0[1] = p2[1];\n        p0[2] = p2[2];\n        p1[0] = p2[0];\n        p1[1] = p2[1];\n        p1[2] = p2[2];\n        v1[0] = v2[0];\n        v1[1] = v2[1];\n        v1[2] = v2[2];\n        l1 = l2;\n      } else {\n        if (cellCount > 0 && pointId !== oldOriginalId) {\n          // First check to see if we have to add cornerPointId\n          if (cellCount === 1) {\n            originalEdges.push(1); // new edge\n\n            originalEdges.push(cornerPointId);\n          } // Then add the new point\n\n\n          originalEdges.push(pointId);\n          oldOriginalId = pointId;\n          cellCount++;\n        } else {\n          // No corner yet, so save the point\n          partialEdge.push(pointId);\n        } // Reduce the count\n\n\n        m--; // Join the previous two segments, since the point was removed\n\n        p1[0] = p2[0];\n        p1[1] = p2[1];\n        p1[2] = p2[2];\n        subtract(p2, p0, v1);\n        l1 = dot(v1, v1);\n      }\n    } // Add the partial edge to the end\n\n\n    for (var ii = 0; ii < partialEdge.length; ii++) {\n      var _pointId = partialEdge[ii];\n\n      if (_pointId !== oldOriginalId) {\n        if (cellCount === 1) {\n          originalEdges.push(1); // new edge\n\n          originalEdges.push(cornerPointId);\n        }\n\n        originalEdges.push(_pointId);\n        oldOriginalId = _pointId;\n        cellCount++;\n      }\n    } // Finalize\n\n\n    if (cellCount > 1) {\n      // Update the number of segments in the edge\n      var _countLocation = originalEdges.length - cellCount - 1;\n\n      originalEdges[_countLocation] = cellCount;\n      newEdges.push(_countLocation);\n    }\n\n    polys[polyId] = newPoly;\n  }\n} // ---------------------------------------------------\n\n/**\n * Reverse a cleaned-up polygon along with the info about\n * all of its original vertices.\n *\n * @param {Array} poly\n * @param {Array} edges\n * @param {Array} originalEdges\n */\n\nfunction vtkCCSReversePoly(poly, edges, originalEdges) {\n  reverseElements(poly, 1, poly.length - 1);\n  edges.reverse();\n\n  for (var i = 0; i < edges.length; i++) {\n    if (edges[i] >= 0) {\n      var firstPtsIdx = edges[i] + 1;\n      var npts = originalEdges[edges[i]];\n      reverseElements(originalEdges, firstPtsIdx, firstPtsIdx + npts - 1);\n    }\n  }\n} // ---------------------------------------------------\n\n/**\n * Check the sense of the polygon against the given normal. Returns\n * zero if the normal is zero.\n *\n * @param {Array} poly\n * @param {vtkPoints} points\n * @param {Vector3} normal\n */\n\nfunction vtkCCSCheckPolygonSense(poly, points, normal) {\n  // Compute the normal\n  var pnormal = [0.0, 0.0, 0.0];\n  var p0 = [];\n  var p1 = [];\n  var p2 = [];\n  var v1 = [];\n  var v2 = [];\n  var v = [];\n  points.getPoint(poly[0], p0);\n  points.getPoint(poly[1], p1);\n  subtract(p1, p0, v1);\n\n  for (var jj = 2; jj < poly.length; jj++) {\n    points.getPoint(poly[jj], p2);\n    subtract(p2, p0, v2);\n    cross(v1, v2, v);\n    add(pnormal, v, pnormal);\n    p1[0] = p2[0];\n    p1[1] = p2[1];\n    p1[2] = p2[2];\n    v1[0] = v2[0];\n    v1[1] = v2[1];\n    v1[2] = v2[2];\n  } // Check the normal\n\n\n  var d = dot(pnormal, normal);\n  return {\n    isNormalNotZero: d !== 0,\n    sense: d > 0\n  };\n} // ---------------------------------------------------\n\n/**\n * Check whether innerPoly is inside outerPoly.\n * The normal is needed to verify the polygon orientation.\n * The values of pp, bounds, and tol2 must be precomputed\n * by calling vtkCCSPrepareForPolyInPoly() on outerPoly.\n *\n * @param {Array} outerPoly\n * @param {Array} innerPoly\n * @param {vtkPoints} points\n * @param {Vector3} normal\n * @param {Float64Array} pp\n * @param {Bounds} bounds\n * @param {Number} tol2\n */\n\nfunction vtkCCSPolyInPoly(outerPoly, innerPoly, points, normal, pp, bounds, tol2) {\n  // Find a vertex of poly \"j\" that isn't on the edge of poly \"i\".\n  // This is necessary or the PointInPolygon might return \"true\"\n  // based only on roundoff error.\n  var n = outerPoly.length;\n  var m = innerPoly.length;\n  var p = [];\n  var q1 = [];\n  var q2 = [];\n\n  for (var jj = 0; jj < m; jj++) {\n    // Semi-randomize the point order\n    // eslint-disable-next-line no-bitwise\n    var kk = (jj >> 1) + (jj & 1) * (m + 1 >> 1);\n    points.getPoint(innerPoly[kk], p);\n    var intersectionState = vtkPolygon.pointInPolygon(p, pp, bounds, normal);\n\n    if (intersectionState === PolygonWithPointIntersectionState.FAILURE) {\n      vtkErrorMacro('Error finding point in polygon in vtkCCSPolyInPoly');\n    }\n\n    if (intersectionState !== PolygonWithPointIntersectionState.OUTSIDE) {\n      var pointOnEdge = 0;\n      points.getPoint(outerPoly[n - 1], q1);\n\n      for (var ii = 0; ii < n; ii++) {\n        points.getPoint(outerPoly[ii], q2); // This method returns distance squared\n\n        var _vtkLine$distanceToLi = vtkLine.distanceToLine(p, q1, q2),\n            distance = _vtkLine$distanceToLi.distance;\n\n        if (distance < tol2) {\n          pointOnEdge = 1;\n          break;\n        }\n\n        q1[0] = q2[0];\n        q1[1] = q2[1];\n        q1[2] = q2[2];\n      }\n\n      if (!pointOnEdge) {\n        // Good result, point is in polygon\n        return true;\n      }\n    }\n  } // No matches found\n\n\n  return false;\n} // ---------------------------------------------------\n\n/**\n * Precompute values needed for the PolyInPoly check.\n * The values that are returned are as follows:\n * pp: an array of the polygon vertices\n * bounds: the polygon bounds\n * tol2: a tolerance value based on the size of the polygon\n * (note: pp must be pre-allocated to the 3*outerPoly.length)\n *\n * @param {Array} outerPoly\n * @param {vtkPoints} points\n * @param {Float64Array} pp\n * @param {Bounds} bounds\n */\n\nfunction vtkCCSPrepareForPolyInPoly(outerPoly, points, pp, bounds) {\n  var n = outerPoly.length;\n\n  if (n === 0) {\n    return 0.0; // to avoid false positive warning about uninitialized value\n  } // Pull out the points\n\n\n  var point = [];\n  var j = 0;\n\n  for (var i = 0; i < n; i++) {\n    points.getPoint(outerPoly[i], point);\n    pp[j++] = point[0];\n    pp[j++] = point[1];\n    pp[j++] = point[2];\n  } // Find the bounding box and tolerance for the polygon\n\n\n  return vtkPolygon.getBounds(outerPoly, points, bounds) * (CCS_POLYGON_TOLERANCE * CCS_POLYGON_TOLERANCE);\n} // ---------------------------------------------------\n\n/**\n * Check for polygons within polygons. Group the polygons\n * if they are within each other. Reverse the sense of\n * the interior \"hole\" polygons. A hole within a hole\n * will be reversed twice and will become its own group.\n *\n * @param {Array} newPolys\n * @param {vtkPoints} points\n * @param {Array} polyGroups\n * @param {Array} polyEdges\n * @param {Array} originalEdges\n * @param {Vector3} normal\n * @param {Boolean} oriented\n */\n\nfunction vtkCCSMakeHoleyPolys(newPolys, points, polyGroups, polyEdges, originalEdges, normal, oriented) {\n  var numNewPolys = newPolys.length;\n\n  if (numNewPolys <= 1) {\n    return;\n  } // Use bit arrays to keep track of inner polys\n\n\n  var polyReversed = [];\n  var innerPolys = []; // GroupCount is an array only needed for unoriented polys\n\n  var groupCount;\n\n  if (!oriented) {\n    groupCount = new Int32Array(numNewPolys);\n  } // Find the maximum poly size\n\n\n  var nmax = 1;\n\n  for (var kk = 0; kk < numNewPolys; kk++) {\n    nmax = Math.max(nmax, newPolys[kk].length);\n  } // These are some values needed for poly-in-poly checks\n\n\n  var pp = new Float64Array(3 * nmax);\n  var bounds = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0];\n  var tol2; // Go through all polys\n\n  for (var i = 0; i < numNewPolys; i++) {\n    var n = newPolys[i].length;\n\n    if (n < 3) {\n      // eslint-disable-next-line no-continue\n      continue;\n    } // Check if poly is reversed\n\n\n    var _vtkCCSCheckPolygonSe = vtkCCSCheckPolygonSense(newPolys[i], points, normal),\n        isNormalNotZero = _vtkCCSCheckPolygonSe.isNormalNotZero,\n        sense = _vtkCCSCheckPolygonSe.sense;\n\n    if (isNormalNotZero) {\n      polyReversed[i] = !sense;\n    } // Precompute some values needed for poly-in-poly checks\n\n\n    tol2 = vtkCCSPrepareForPolyInPoly(newPolys[i], points, pp, bounds); // Look for polygons inside of this one\n\n    for (var j = 0; j < numNewPolys; j++) {\n      if (j !== i && newPolys[j].length >= 3) {\n        // Make sure polygon i is not in polygon j\n        var pg = polyGroups[j];\n\n        if (!pg.includes(i)) {\n          if (vtkCCSPolyInPoly(newPolys[i], newPolys[j], points, normal, pp.subarray(3 * n), bounds, tol2)) {\n            // Add to group\n            polyGroups[i].push(j);\n\n            if (groupCount) {\n              groupCount[j] += 1;\n            }\n          }\n        }\n      }\n    }\n  }\n\n  if (!oriented) {\n    // build a stack of polys that aren't inside other polys=\n    var outerPolyStack = [];\n\n    for (var ll = 0; ll < numNewPolys; ll++) {\n      if (groupCount[ll] === 0) {\n        outerPolyStack.push(ll);\n      }\n    }\n\n    var _j;\n\n    while (outerPolyStack.length > 0) {\n      _j = outerPolyStack.length - 1;\n      outerPolyStack.pop();\n\n      if (polyReversed[_j]) {\n        vtkCCSReversePoly(newPolys[_j], polyEdges[_j], originalEdges);\n        polyReversed[_j] = false;\n      }\n\n      if (polyGroups[_j].length > 1) {\n        // Convert the group into a bit array, to make manipulation easier\n        innerPolys.length = 0;\n\n        for (var k = 1; k < polyGroups[_j].length; k++) {\n          var jj = polyGroups[_j][k];\n\n          if (groupCount[jj] > 1) {\n            groupCount[jj] -= 2;\n\n            if (groupCount[jj] === 0) {\n              outerPolyStack.push(jj);\n            }\n          } else {\n            innerPolys[jj] = 1;\n            polyGroups[jj].length = 0;\n\n            if (!polyReversed[jj]) {\n              vtkCCSReversePoly(newPolys[jj], polyEdges[jj], originalEdges);\n              polyReversed[jj] = false;\n            }\n          }\n        } // Use the bit array to recreate the polyGroup\n\n\n        polyGroups[_j].length = 0;\n\n        polyGroups[_j].push(_j);\n\n        for (var _jj2 = 0; _jj2 < numNewPolys; _jj2++) {\n          if (innerPolys[_jj2]) {\n            polyGroups[_j].push(_jj2);\n          }\n        }\n      }\n    }\n  } else {\n    // oriented\n    for (var _j2 = 0; _j2 < numNewPolys; _j2++) {\n      // Remove the groups for reversed polys\n      if (polyReversed[_j2]) {\n        polyGroups[_j2].length = 0;\n      } // Polys inside the interior polys have their own groups, so remove\n      // them from this group\n      else if (polyGroups[_j2].length > 1) {\n        // Convert the group into a bit array, to make manipulation easier\n        innerPolys.length = 0;\n\n        for (var _k = 1; _k < polyGroups[_j2].length; _k++) {\n          innerPolys[polyGroups[_j2][_k]] = true;\n        } // Look for non-reversed polys inside this one\n\n\n        for (var _kk = 1; _kk < polyGroups[_j2].length; _kk++) {\n          // jj is the index of the inner poly\n          var _jj3 = polyGroups[_j2][_kk]; // If inner poly is not reversed then\n\n          if (!polyReversed[_jj3]) {\n            // Remove that poly and all polys inside of it from the group\n            for (var ii = 0; ii < polyGroups[_jj3].length; ii++) {\n              innerPolys[polyGroups[_jj3][ii]] = false;\n            }\n          }\n        } // Use the bit array to recreate the polyGroup\n\n\n        polyGroups[_j2].length = 0;\n\n        polyGroups[_j2].push(_j2);\n\n        for (var _jj4 = 0; _jj4 < numNewPolys; _jj4++) {\n          if (innerPolys[_jj4]) {\n            polyGroups[_j2].push(_jj4);\n          }\n        }\n      }\n    }\n  } // delete[] groupCount;\n\n} // ---------------------------------------------------\n\n/**\n * Check line segment with point Ids (i, j) to make sure that it\n * doesn't cut through the edges of any polys in the group.\n * Return value of zero means check failed and the cut is not\n * usable.\n *\n * @param {Array[]} polys\n * @param {vtkPoints} points\n * @param {Vector3} normal\n * @param {Array} polyGroup\n * @param {Number} outerPolyId\n * @param {Number} innerPolyId\n * @param {Number} outerIdx\n * @param {Number} innerIdx\n */\n\nfunction vtkCCSCheckCut(polys, points, normal, polyGroup, outerPolyId, innerPolyId, outerIdx, innerIdx) {\n  var ptId1 = polys[outerPolyId][outerIdx];\n  var ptId2 = polys[innerPolyId][innerIdx];\n  var tol = CCS_POLYGON_TOLERANCE;\n  var p1 = [];\n  var p2 = [];\n  points.getPoint(ptId1, p1);\n  points.getPoint(ptId2, p2);\n  var w = [];\n  subtract(p2, p1, w);\n  var l = normalize(w); // Cuts between coincident points are good\n\n  if (l === 0) {\n    return true;\n  } // Define a tolerance with units of distance squared\n\n\n  var tol2 = l * l * tol * tol; // Check the sense of the cut: it must be pointing \"in\" for both polys.\n\n  var polyId = outerPolyId;\n  var polyIdx = outerIdx;\n  var r = p1;\n  var r1 = [];\n  var r2 = p2;\n  var r3 = [];\n\n  for (var ii = 0; ii < 2; ii++) {\n    var poly = polys[polyId];\n    var n = poly.length;\n    var prevIdx = n - polyIdx - 1;\n    var nextIdx = polyIdx + 1;\n\n    if (prevIdx >= n) {\n      prevIdx -= n;\n    }\n\n    if (nextIdx >= n) {\n      nextIdx -= n;\n    }\n\n    points.getPoint(poly[prevIdx], r1);\n    points.getPoint(poly[nextIdx], r3);\n\n    if (vtkCCSVectorProgression(r, r1, r2, r3, normal) > 0) {\n      return false;\n    }\n\n    polyId = innerPolyId;\n    polyIdx = innerIdx;\n    r = p2;\n    r2 = p1;\n  } // Check for intersections of the cut with polygon edges.\n  // First, create a cut plane that divides space at the cut line.\n\n\n  var pc = [];\n  cross(normal, w, pc);\n  pc[3] = -dot(pc, p1);\n\n  for (var i = 0; i < polyGroup.length; i++) {\n    var _poly2 = polys[polyGroup[i]];\n    var _n = _poly2.length;\n    var q1 = [];\n    var q2 = [];\n    var qtId1 = _poly2[_n - 1];\n    points.getPoint(qtId1, q1);\n    var v1 = pc[0] * q1[0] + pc[1] * q1[1] + pc[2] * q1[2] + pc[3];\n    var c1 = v1 > 0;\n\n    for (var j = 0; j < _n; j++) {\n      var qtId2 = _poly2[j];\n      points.getPoint(qtId2, q2);\n      var v2 = pc[0] * q2[0] + pc[1] * q2[1] + pc[2] * q2[2] + pc[3];\n      var c2 = v2 > 0; // If lines share an endpoint, they can't intersect,\n      // so don't bother with the check.\n\n      if (ptId1 !== qtId1 && ptId1 !== qtId2 && ptId2 !== qtId1 && ptId2 !== qtId2) {\n        // Check for intersection\n        if ((c1 ? !c2 : c2) || v1 * v1 < tol2 || v2 * v2 < tol2) {\n          subtract(q2, q1, w);\n\n          if (dot(w, w) > 0) {\n            var qc = [];\n            cross(w, normal, qc);\n            qc[3] = -dot(qc, q1);\n            var u1 = qc[0] * p1[0] + qc[1] * p1[1] + qc[2] * p1[2] + qc[3];\n            var u2 = qc[0] * p2[0] + qc[1] * p2[1] + qc[2] * p2[2] + qc[3];\n            var d1 = u1 > 0;\n            var d2 = u2 > 0;\n\n            if (d1 ? !d2 : d2) {\n              // One final check to make sure endpoints aren't coincident\n              var p = p1;\n              var q = q1;\n\n              if (v2 * v2 < v1 * v1) {\n                p = p2;\n              }\n\n              if (u2 * u2 < u1 * u1) {\n                q = q2;\n              }\n\n              if (distance2BetweenPoints(p, q) > tol2) {\n                return false;\n              }\n            }\n          }\n        }\n      }\n\n      qtId1 = qtId2;\n      q1[0] = q2[0];\n      q1[1] = q2[1];\n      q1[2] = q2[2];\n      v1 = v2;\n      c1 = c2;\n    }\n  }\n\n  return true;\n} // ---------------------------------------------------\n\n/**\n * Check the quality of a cut between an outer and inner polygon.\n * An ideal cut is one that forms a 90 degree angle with each\n * line segment that it joins to.  Smaller values indicate a\n * higher quality cut.\n *\n * @param {Array} outerPoly\n * @param {Array} innerPoly\n * @param {Number} i\n * @param {Number} j\n * @param {vtkPoints} points\n */\n\nfunction vtkCCSCutQuality(outerPoly, innerPoly, i, j, points) {\n  var n = outerPoly.length;\n  var m = innerPoly.length;\n  var a = i > 0 ? i - 1 : n - 1;\n  var b = i < n - 1 ? i + 1 : 0;\n  var c = j > 0 ? j - 1 : m - 1;\n  var d = j < m - 1 ? j + 1 : 0;\n  var p0 = [];\n  var p1 = [];\n  var p2 = [];\n  points.getPoint(outerPoly[i], p1);\n  points.getPoint(innerPoly[j], p2);\n  var v1 = [];\n  var v2 = [];\n  subtract(p2, p1, v1);\n  var l1 = dot(v1, v1);\n  var l2;\n  var qmax = 0;\n  var q;\n  points.getPoint(outerPoly[a], p0);\n  subtract(p0, p1, v2);\n  l2 = dot(v2, v2);\n\n  if (l2 > 0) {\n    q = dot(v1, v2);\n    q *= q / l2;\n\n    if (q > qmax) {\n      qmax = q;\n    }\n  }\n\n  points.getPoint(outerPoly[b], p0);\n  subtract(p0, p1, v2);\n  l2 = dot(v2, v2);\n\n  if (l2 > 0) {\n    q = dot(v1, v2);\n    q *= q / l2;\n\n    if (q > qmax) {\n      qmax = q;\n    }\n  }\n\n  points.getPoint(innerPoly[c], p0);\n  subtract(p2, p0, v2);\n  l2 = dot(v2, v2);\n\n  if (l2 > 0) {\n    q = dot(v1, v2);\n    q *= q / l2;\n\n    if (q > qmax) {\n      qmax = q;\n    }\n  }\n\n  points.getPoint(innerPoly[d], p0);\n  subtract(p2, p0, v2);\n  l2 = dot(v2, v2);\n\n  if (l2 > 0) {\n    q = dot(v1, v2);\n    q *= q / l2;\n\n    if (q > qmax) {\n      qmax = q;\n    }\n  }\n\n  if (l1 > 0) {\n    return qmax / l1; // also l1 + qmax, incorporates distance;\n  }\n\n  return Number.MAX_VALUE;\n} // ---------------------------------------------------\n\n/**\n * Find the two sharpest verts on an inner (i.e. inside-out) poly.\n *\n * @param {Array} poly\n * @param {vtkPoints} points\n * @param {Vector3} normal\n * @param {[Number, Number]} verts\n */\n\nfunction vtkCCSFindSharpestVerts(poly, points, normal, verts) {\n  var p1 = [];\n  var p2 = [];\n  var v1 = [];\n  var v2 = [];\n  var v = [];\n  var l1;\n  var l2;\n  var minVal = [0, 0];\n  verts[0] = 0;\n  verts[1] = 0;\n  var n = poly.length;\n  points.getPoint(poly[n - 1], p2);\n  points.getPoint(poly[0], p1);\n  subtract(p1, p2, v1);\n  l1 = Math.sqrt(dot(v1, v1));\n\n  for (var j = 0; j < n; j++) {\n    var k = j + 1;\n\n    if (k === n) {\n      k = 0;\n    }\n\n    points.getPoint(poly[k], p2);\n    subtract(p2, p1, v2);\n    l2 = Math.sqrt(dot(v2, v2));\n    cross(v1, v2, v);\n    var b = dot(v, normal);\n\n    if (b < 0 && l1 * l2 > 0) {\n      // Dot product is |v1||v2|cos(theta), range [-1, +1]\n      var val = dot(v1, v2) / (l1 * l2);\n\n      if (val < minVal[0]) {\n        minVal[1] = minVal[0];\n        minVal[0] = val;\n        verts[1] = verts[0];\n        verts[0] = j;\n      }\n    } // Rotate to the next point\n\n\n    p1[0] = p2[0];\n    p1[1] = p2[1];\n    p1[2] = p2[2];\n    v1[0] = v2[0];\n    v1[1] = v2[1];\n    v1[2] = v2[2];\n    l1 = l2;\n  }\n} // ---------------------------------------------------\n\n/**\n * Find two valid cuts between outerPoly and innerPoly.\n * Used by vtkCCSCutHoleyPolys.\n *\n * @param {Array} polys\n * @param {Array} polyGroup\n * @param {Number} outerPolyId\n * @param {Number} innerPolyId\n * @param {vtkPoints} points\n * @param {Vector3} normal\n * @param {Array[]} cuts\n * @param {Boolean} exhaustive\n */\n\nfunction vtkCCSFindCuts(polys, polyGroup, outerPolyId, innerPolyId, points, normal, cuts, exhaustive) {\n  var outerPoly = polys[outerPolyId];\n  var innerPoly = polys[innerPolyId];\n  var innerSize = innerPoly.length; // Find the two sharpest points on the inner poly\n\n  var verts = [];\n  vtkCCSFindSharpestVerts(innerPoly, points, normal, verts); // A list of cut locations according to quality\n\n  var cutlist = [];\n  cutlist.length = outerPoly.length; // Search for potential cuts (need to find two cuts)\n\n  var cutId = 0;\n  cuts[0][0] = 0;\n  cuts[0][1] = 0;\n  cuts[1][0] = 0;\n  cuts[1][1] = 0;\n  var foundCut = false;\n\n  for (cutId = 0; cutId < 2; cutId++) {\n    var count = exhaustive ? innerSize : 3;\n\n    for (var i = 0; i < count && !foundCut; i++) {\n      // Semi-randomize the search order\n      // TODO: Does this do the same as in C++?\n      // eslint-disable-next-line no-bitwise\n      var j = (i >> 1) + (i & 1) * (innerSize + 1 >> 1); // Start at the best first point\n\n      j = (j + verts[cutId]) % innerSize;\n\n      for (var kk = 0; kk < outerPoly.length; kk++) {\n        var q = vtkCCSCutQuality(outerPoly, innerPoly, kk, j, points);\n        cutlist[kk] = [q, kk];\n      }\n\n      cutlist.sort(function (a, b) {\n        return a[0] - b[0];\n      });\n\n      for (var lid = 0; lid < cutlist.length; lid++) {\n        var k = cutlist[lid][1]; // If this is the second cut, do extra checks\n\n        if (cutId > 0) {\n          // Make sure cuts don't share an endpoint\n          if (j === cuts[0][1] || k === cuts[0][0]) {\n            // eslint-disable-next-line no-continue\n            continue;\n          } // Make sure cuts don't intersect\n\n\n          var p1 = [];\n          var p2 = [];\n          points.getPoint(outerPoly[cuts[0][0]], p1);\n          points.getPoint(innerPoly[cuts[0][1]], p2);\n          var q1 = [];\n          var q2 = [];\n          points.getPoint(outerPoly[k], q1);\n          points.getPoint(innerPoly[j], q2);\n          var u = void 0;\n          var v = void 0;\n\n          if (vtkLine.intersection(p1, p2, q1, q2, u, v) === vtkLine.IntersectionState.YES_INTERSECTION) {\n            // eslint-disable-next-line no-continue\n            continue;\n          }\n        } // This check is done for both cuts\n\n\n        if (vtkCCSCheckCut(polys, points, normal, polyGroup, outerPolyId, innerPolyId, k, j)) {\n          cuts[cutId][0] = k;\n          cuts[cutId][1] = j;\n          foundCut = true;\n          break;\n        }\n      }\n    }\n\n    if (!foundCut) {\n      return false;\n    }\n  }\n\n  return true;\n} // ---------------------------------------------------\n\n/**\n * Helper for vtkCCSCutHoleyPolys.  Change a polygon and a hole\n * into two separate polygons by making two cuts between them.\n *\n * @param {Array[]} polys\n * @param {Array} polyEdges\n * @param {Number} outerPolyId\n * @param {Number} innerPolyId\n * @param {vtkPoints} points\n * @param {Array[]} cuts\n */\n\nfunction vtkCCSMakeCuts(polys, polyEdges, outerPolyId, innerPolyId, points, cuts) {\n  var q = [];\n  var r = [];\n\n  for (var bb = 0; bb < 2; bb++) {\n    var ptId1 = polys[outerPolyId][cuts[bb][0]];\n    var ptId2 = polys[innerPolyId][cuts[bb][1]];\n    points.getPoint(ptId1, q);\n    points.getPoint(ptId2, r);\n  }\n\n  var outerPoly = polys[outerPolyId];\n  var innerPoly = polys[innerPolyId];\n  var outerEdges = polyEdges[outerPolyId];\n  var innerEdges = polyEdges[innerPolyId]; // Generate new polys from the cuts\n\n  var n = outerPoly.length;\n  var m = innerPoly.length;\n  var idx; // Generate poly1\n\n  var n1 = n * (cuts[1][0] < cuts[0][0]) + cuts[1][0] - cuts[0][0] + 1;\n  var n2 = n1 + m * (cuts[0][1] < cuts[1][1]) + cuts[0][1] - cuts[1][1] + 1;\n  var poly1 = [];\n  poly1.length = n2;\n  var edges1 = new Array(n2);\n  idx = cuts[0][0];\n\n  for (var i1 = 0; i1 < n1; i1++) {\n    var k = idx++;\n    poly1[i1] = outerPoly[k];\n    edges1[i1] = outerEdges[k];\n    idx *= idx !== n;\n  }\n\n  edges1[n1 - 1] = -1;\n  idx = cuts[1][1];\n\n  for (var i2 = n1; i2 < n2; i2++) {\n    var _k2 = idx++;\n\n    poly1[i2] = innerPoly[_k2];\n    edges1[i2] = innerEdges[_k2];\n    idx *= idx !== m;\n  }\n\n  edges1[n2 - 1] = -1; // Generate poly2\n\n  var m1 = n * (cuts[0][0] < cuts[1][0]) + cuts[0][0] - cuts[1][0] + 1;\n  var m2 = m1 + m * (cuts[1][1] < cuts[0][1]) + cuts[1][1] - cuts[0][1] + 1;\n  var poly2 = [];\n  poly2.length = m2;\n  var edges2 = new Array(m2);\n  idx = cuts[1][0];\n\n  for (var j1 = 0; j1 < m1; j1++) {\n    var _k3 = idx++;\n\n    poly2[j1] = outerPoly[_k3];\n    edges2[j1] = outerEdges[_k3];\n    idx *= idx !== n;\n  }\n\n  edges2[m1 - 1] = -1;\n  idx = cuts[0][1];\n\n  for (var j2 = m1; j2 < m2; j2++) {\n    var _k4 = idx++;\n\n    poly2[j2] = innerPoly[_k4];\n    edges2[j2] = innerEdges[_k4];\n    idx *= idx !== m;\n  }\n\n  edges2[m2 - 1] = -1; // Replace outerPoly and innerPoly with these new polys\n\n  polys[outerPolyId] = poly1;\n  polys[innerPolyId] = poly2;\n  polyEdges[outerPolyId] = edges1;\n  polyEdges[innerPolyId] = edges2;\n} // ---------------------------------------------------\n\n/**\n * After the holes have been identified, make cuts between the\n * outer poly and each hole.  Make two cuts per hole.  The only\n * strict requirement is that the cut must not intersect any\n * edges, but it's best to make sure that no really sharp angles\n * are created.\n *\n * @param {Array[]} polys\n * @param {vtkPoints} points\n * @param {Array[]} polyGroups\n * @param {Array} polyEdges\n * @param {Vector3} normal\n * @returns {boolean}\n */\n\nfunction vtkCCSCutHoleyPolys(polys, points, polyGroups, polyEdges, normal) {\n  var cutFailure = 0; // Go through all groups and cut out the first inner poly that is\n  // found.  Every time an inner poly is cut out, the groupId counter\n  // is reset because cutting a poly creates a new group.\n\n  var groupId = 0;\n\n  while (groupId < polyGroups.length) {\n    var polyGroup = polyGroups[groupId]; // Only need to make a cut if the group size is greater than 1\n\n    if (polyGroup.length > 1) {\n      // The first member of the group is the outer poly\n      var outerPolyId = polyGroup[0]; // The second member of the group is the first inner poly\n\n      var innerPolyId = polyGroup[1]; // Sort the group by size, do largest holes first\n\n      var innerBySize = new Array(polyGroup.length);\n\n      for (var i = 1; i < polyGroup.length; i++) {\n        innerBySize[i] = [polys[polyGroup[i]].length, i];\n      }\n\n      innerBySize = [innerBySize[0]].concat(_toConsumableArray(innerBySize.splice(1).sort(function (a, b) {\n        return a[0] - b[0];\n      })));\n      reverseElements(innerBySize, 1, innerBySize.length - 1); // Need to check all inner polys in sequence, until one succeeds.\n      // Do a quick search first, then do an exhaustive search.\n\n      var madeCut = 0;\n      var inner = 0;\n\n      for (var exhaustive = 0; exhaustive < 2 && !madeCut; exhaustive++) {\n        for (var j = 1; j < polyGroup.length; j++) {\n          inner = innerBySize[j][1];\n          innerPolyId = polyGroup[inner];\n          var cuts = [];\n\n          if (vtkCCSFindCuts(polys, polyGroup, outerPolyId, innerPolyId, points, normal, cuts, exhaustive)) {\n            vtkCCSMakeCuts(polys, polyEdges, outerPolyId, innerPolyId, points, cuts);\n            madeCut = 1;\n            break;\n          }\n        }\n      }\n\n      if (madeCut) {\n        // Move successfully cut innerPolyId into its own group\n        polyGroup.splice(inner, 1); // Only add if innerPolyId hasn't been set already.\n        // Having the same poly occur as both polyGroup and\n        // innerPoly would cause an infinite loop.\n\n        if (polyGroups[innerPolyId].length === 0) {\n          polyGroups[innerPolyId].push(innerPolyId);\n        }\n      } else {\n        // Remove all failed inner polys from the group\n        for (var k = 1; k < polyGroup.length; k++) {\n          innerPolyId = polyGroup[k]; // Only add if innerPolyId hasn't been set already.\n          // Having the same poly occur as both polyGroup and\n          // innerPoly would cause an infinite loop.\n\n          if (polyGroups[innerPolyId].length === 0) {\n            polyGroups[innerPolyId].push(innerPolyId);\n          }\n        }\n\n        polyGroup.length = 1;\n        cutFailure = 1;\n      } // If there are other interior polys in the group, find out whether\n      // they are in poly1 or poly2\n\n\n      if (polyGroup.length > 1) {\n        var poly1 = polys[outerPolyId];\n        var pp = new Float64Array(3 * poly1.length);\n        var bounds = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0];\n        var tol2 = vtkCCSPrepareForPolyInPoly(poly1, points, pp, bounds);\n        var nextGroupId = groupId;\n        var ii = 1;\n\n        while (ii < polyGroup.length) {\n          if (vtkCCSPolyInPoly(poly1, polys[polyGroup[ii]], points, normal, pp, bounds, tol2)) {\n            // Keep this poly in polyGroup\n            ii++;\n          } else {\n            // Move this poly to poly2 group\n            polyGroups[innerPolyId].push(polyGroup[ii]);\n            polyGroup.splice(ii, 1); // Reduce the groupId to ensure that this new group will get cut\n\n            if (innerPolyId < nextGroupId) {\n              nextGroupId = innerPolyId;\n            }\n          }\n        } // Set the groupId for the next iteration\n\n\n        groupId = nextGroupId; // eslint-disable-next-line no-continue\n\n        continue;\n      }\n    } // Increment to the next group\n\n\n    groupId++;\n  }\n\n  return !cutFailure;\n}\n\nexport { reverseElements, vtkCCSCheckCut, vtkCCSCheckPolygonSense, vtkCCSCutHoleyPolys, vtkCCSCutQuality, vtkCCSFindCuts, vtkCCSFindSharpestVerts, vtkCCSFindTrueEdges, vtkCCSInsertTriangle, vtkCCSJoinLooseEnds, vtkCCSMakeCuts, vtkCCSMakeHoleyPolys, vtkCCSMakePolysFromLines, vtkCCSPolyInPoly, vtkCCSPrepareForPolyInPoly, vtkCCSReversePoly, vtkCCSSplitAtPinchPoints, vtkCCSTriangleQuality, vtkCCSTriangulate, vtkCCSVectorProgression };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}