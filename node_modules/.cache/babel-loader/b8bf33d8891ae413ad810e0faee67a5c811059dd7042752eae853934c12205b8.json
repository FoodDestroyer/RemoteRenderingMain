{"ast":null,"code":"import _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport macro from '../../macros.js';\nimport vtkAbstractMapper3D from './AbstractMapper3D.js';\nimport vtkDataArray from '../../Common/Core/DataArray.js';\nimport vtkImageData from '../../Common/DataModel/ImageData.js';\nimport vtkLookupTable from '../../Common/Core/LookupTable.js';\nimport { F as createUninitializedBounds, i as isNan } from '../../Common/Core/Math/index.js';\nimport vtkScalarsToColors from '../../Common/Core/ScalarsToColors/Constants.js';\nimport CoincidentTopologyHelper from './Mapper/CoincidentTopologyHelper.js';\nimport Constants from './Mapper/Constants.js';\nimport vtkDataSet from '../../Common/DataModel/DataSet.js';\nimport { PassTypes } from '../OpenGL/HardwareSelector/Constants.js';\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n  return target;\n}\nvar FieldAssociations = vtkDataSet.FieldAssociations;\nvar staticOffsetAPI = CoincidentTopologyHelper.staticOffsetAPI,\n  otherStaticMethods = CoincidentTopologyHelper.otherStaticMethods;\nvar ColorMode = Constants.ColorMode,\n  ScalarMode = Constants.ScalarMode,\n  GetArray = Constants.GetArray;\nvar VectorMode = vtkScalarsToColors.VectorMode;\nvar VtkDataTypes = vtkDataArray.VtkDataTypes; // ----------------------------------------------------------------------------\n\nfunction notImplemented(method) {\n  return function () {\n    return macro.vtkErrorMacro(\"vtkMapper::\".concat(method, \" - NOT IMPLEMENTED\"));\n  };\n} // ----------------------------------------------------------------------------\n// vtkMapper methods\n// ----------------------------------------------------------------------------\n\nfunction vtkMapper(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkMapper');\n  publicAPI.getBounds = function () {\n    var input = publicAPI.getInputData();\n    if (!input) {\n      model.bounds = createUninitializedBounds();\n    } else {\n      if (!model.static) {\n        publicAPI.update();\n      }\n      model.bounds = input.getBounds();\n    }\n    return model.bounds;\n  };\n  publicAPI.setForceCompileOnly = function (v) {\n    model.forceCompileOnly = v; // make sure we do NOT call modified()\n  };\n\n  publicAPI.setSelectionWebGLIdsToVTKIds = function (selectionWebGLIdsToVTKIds) {\n    model.selectionWebGLIdsToVTKIds = selectionWebGLIdsToVTKIds; // make sure we do NOT call modified()\n    // this attribute is only used when processing a selection made with the hardware selector\n    // the mtime of the mapper doesn't need to be changed\n  };\n\n  publicAPI.createDefaultLookupTable = function () {\n    model.lookupTable = vtkLookupTable.newInstance();\n  };\n  publicAPI.getColorModeAsString = function () {\n    return macro.enumToString(ColorMode, model.colorMode);\n  };\n  publicAPI.setColorModeToDefault = function () {\n    return publicAPI.setColorMode(0);\n  };\n  publicAPI.setColorModeToMapScalars = function () {\n    return publicAPI.setColorMode(1);\n  };\n  publicAPI.setColorModeToDirectScalars = function () {\n    return publicAPI.setColorMode(2);\n  };\n  publicAPI.getScalarModeAsString = function () {\n    return macro.enumToString(ScalarMode, model.scalarMode);\n  };\n  publicAPI.setScalarModeToDefault = function () {\n    return publicAPI.setScalarMode(0);\n  };\n  publicAPI.setScalarModeToUsePointData = function () {\n    return publicAPI.setScalarMode(1);\n  };\n  publicAPI.setScalarModeToUseCellData = function () {\n    return publicAPI.setScalarMode(2);\n  };\n  publicAPI.setScalarModeToUsePointFieldData = function () {\n    return publicAPI.setScalarMode(3);\n  };\n  publicAPI.setScalarModeToUseCellFieldData = function () {\n    return publicAPI.setScalarMode(4);\n  };\n  publicAPI.setScalarModeToUseFieldData = function () {\n    return publicAPI.setScalarMode(5);\n  };\n  publicAPI.getAbstractScalars = function (input, scalarMode, arrayAccessMode, arrayId, arrayName) {\n    // make sure we have an input\n    if (!input || !model.scalarVisibility) {\n      return {\n        scalars: null,\n        cellFLag: false\n      };\n    }\n    var scalars = null;\n    var cellFlag = false; // get and scalar data according to scalar mode\n\n    if (scalarMode === ScalarMode.DEFAULT) {\n      scalars = input.getPointData().getScalars();\n      if (!scalars) {\n        scalars = input.getCellData().getScalars();\n        cellFlag = true;\n      }\n    } else if (scalarMode === ScalarMode.USE_POINT_DATA) {\n      scalars = input.getPointData().getScalars();\n    } else if (scalarMode === ScalarMode.USE_CELL_DATA) {\n      scalars = input.getCellData().getScalars();\n      cellFlag = true;\n    } else if (scalarMode === ScalarMode.USE_POINT_FIELD_DATA) {\n      var pd = input.getPointData();\n      if (arrayAccessMode === GetArray.BY_ID) {\n        scalars = pd.getArrayByIndex(arrayId);\n      } else {\n        scalars = pd.getArrayByName(arrayName);\n      }\n    } else if (scalarMode === ScalarMode.USE_CELL_FIELD_DATA) {\n      var cd = input.getCellData();\n      cellFlag = true;\n      if (arrayAccessMode === GetArray.BY_ID) {\n        scalars = cd.getArrayByIndex(arrayId);\n      } else {\n        scalars = cd.getArrayByName(arrayName);\n      }\n    } else if (scalarMode === ScalarMode.USE_FIELD_DATA) {\n      var fd = input.getFieldData();\n      if (arrayAccessMode === GetArray.BY_ID) {\n        scalars = fd.getArrayByIndex(arrayId);\n      } else {\n        scalars = fd.getArrayByName(arrayName);\n      }\n    }\n    return {\n      scalars: scalars,\n      cellFlag: cellFlag\n    };\n  };\n  publicAPI.mapScalars = function (input, alpha) {\n    var scalars = publicAPI.getAbstractScalars(input, model.scalarMode, model.arrayAccessMode, model.arrayId, model.colorByArrayName).scalars;\n    if (!scalars) {\n      model.colorCoordinates = null;\n      model.colorTextureMap = null;\n      model.colorMapColors = null;\n      return;\n    } // we want to only recompute when something has changed\n\n    var toString = \"\".concat(publicAPI.getMTime()).concat(scalars.getMTime()).concat(alpha);\n    if (model.colorBuildString === toString) return;\n    if (!model.useLookupTableScalarRange) {\n      publicAPI.getLookupTable().setRange(model.scalarRange[0], model.scalarRange[1]);\n    } // Decide between texture color or vertex color.\n    // Cell data always uses vertex color.\n    // Only point data can use both texture and vertex coloring.\n\n    if (publicAPI.canUseTextureMapForColoring(input)) {\n      publicAPI.mapScalarsToTexture(scalars, alpha);\n    } else {\n      model.colorCoordinates = null;\n      model.colorTextureMap = null;\n      var lut = publicAPI.getLookupTable();\n      if (lut) {\n        // Ensure that the lookup table is built\n        lut.build();\n        model.colorMapColors = lut.mapScalars(scalars, model.colorMode, model.fieldDataTupleId);\n      }\n    }\n    model.colorBuildString = \"\".concat(publicAPI.getMTime()).concat(scalars.getMTime()).concat(alpha);\n  }; //-----------------------------------------------------------------------------\n\n  publicAPI.scalarToTextureCoordinate = function (scalarValue,\n  // Input scalar\n  rangeMin,\n  // range[0]\n  invRangeWidth) {\n    // 1/(range[1]-range[0])\n    var texCoordS = 0.5; // Scalar value is arbitrary when NaN\n\n    var texCoordT = 1.0; // 1.0 in t coordinate means NaN\n\n    if (!isNan(scalarValue)) {\n      // 0.0 in t coordinate means not NaN.  So why am I setting it to 0.49?\n      // Because when you are mapping scalars and you have a NaN adjacent to\n      // anything else, the interpolation everywhere should be NaN.  Thus, I\n      // want the NaN color everywhere except right on the non-NaN neighbors.\n      // To simulate this, I set the t coord for the real numbers close to\n      // the threshold so that the interpolation almost immediately looks up\n      // the NaN value.\n      texCoordT = 0.49;\n      texCoordS = (scalarValue - rangeMin) * invRangeWidth; // Some implementations apparently don't handle relatively large\n      // numbers (compared to the range [0.0, 1.0]) very well. In fact,\n      // values above 1122.0f appear to cause texture wrap-around on\n      // some systems even when edge clamping is enabled. Why 1122.0f? I\n      // don't know. For safety, we'll clamp at +/- 1000. This will\n      // result in incorrect images when the texture value should be\n      // above or below 1000, but I don't have a better solution.\n\n      if (texCoordS > 1000.0) {\n        texCoordS = 1000.0;\n      } else if (texCoordS < -1000.0) {\n        texCoordS = -1000.0;\n      }\n    }\n    return {\n      texCoordS: texCoordS,\n      texCoordT: texCoordT\n    };\n  }; //-----------------------------------------------------------------------------\n\n  publicAPI.createColorTextureCoordinates = function (input, output, numScalars, numComps, component, range, tableRange, tableNumberOfColors, useLogScale) {\n    // We have to change the range used for computing texture\n    // coordinates slightly to accommodate the special above- and\n    // below-range colors that are the first and last texels,\n    // respectively.\n    var scalarTexelWidth = (range[1] - range[0]) / tableNumberOfColors;\n    var paddedRange = [];\n    paddedRange[0] = range[0] - scalarTexelWidth;\n    paddedRange[1] = range[1] + scalarTexelWidth;\n    var invRangeWidth = 1.0 / (paddedRange[1] - paddedRange[0]);\n    var outputV = output.getData();\n    var inputV = input.getData();\n    var count = 0;\n    var outputCount = 0;\n    if (component < 0 || component >= numComps) {\n      for (var scalarIdx = 0; scalarIdx < numScalars; ++scalarIdx) {\n        var sum = 0;\n        for (var compIdx = 0; compIdx < numComps; ++compIdx) {\n          sum += inputV[count] * inputV[count];\n          count++;\n        }\n        var magnitude = Math.sqrt(sum);\n        if (useLogScale) {\n          magnitude = vtkLookupTable.applyLogScale(magnitude, tableRange, range);\n        }\n        var outputs = publicAPI.scalarToTextureCoordinate(magnitude, paddedRange[0], invRangeWidth);\n        outputV[outputCount] = outputs.texCoordS;\n        outputV[outputCount + 1] = outputs.texCoordT;\n        outputCount += 2;\n      }\n    } else {\n      count += component;\n      for (var _scalarIdx = 0; _scalarIdx < numScalars; ++_scalarIdx) {\n        var inputValue = inputV[count];\n        if (useLogScale) {\n          inputValue = vtkLookupTable.applyLogScale(inputValue, tableRange, range);\n        }\n        var _outputs = publicAPI.scalarToTextureCoordinate(inputValue, paddedRange[0], invRangeWidth);\n        outputV[outputCount] = _outputs.texCoordS;\n        outputV[outputCount + 1] = _outputs.texCoordT;\n        outputCount += 2;\n        count += numComps;\n      }\n    }\n  };\n  publicAPI.mapScalarsToTexture = function (scalars, alpha) {\n    var range = model.lookupTable.getRange();\n    var useLogScale = model.lookupTable.usingLogScale();\n    if (useLogScale) {\n      // convert range to log.\n      vtkLookupTable.getLogRange(range, range);\n    }\n    var origAlpha = model.lookupTable.getAlpha(); // Get rid of vertex color array.  Only texture or vertex coloring\n    // can be active at one time.  The existence of the array is the\n    // signal to use that technique.\n\n    model.colorMapColors = null; // If the lookup table has changed, then recreate the color texture map.\n    // Set a new lookup table changes this->MTime.\n\n    if (model.colorTextureMap == null || publicAPI.getMTime() > model.colorTextureMap.getMTime() || model.lookupTable.getMTime() > model.colorTextureMap.getMTime() || model.lookupTable.getAlpha() !== alpha) {\n      model.lookupTable.setAlpha(alpha);\n      model.colorTextureMap = null; // Get the texture map from the lookup table.\n      // Create a dummy ramp of scalars.\n      // In the future, we could extend vtkScalarsToColors.\n\n      model.lookupTable.build();\n      var numberOfColors = model.lookupTable.getNumberOfAvailableColors();\n      if (numberOfColors > 4094) {\n        numberOfColors = 4094;\n      }\n      if (numberOfColors < 64) {\n        numberOfColors = 64;\n      }\n      numberOfColors += 2;\n      var k = (range[1] - range[0]) / (numberOfColors - 2);\n      var newArray = new Float64Array(numberOfColors * 2);\n      for (var i = 0; i < numberOfColors; ++i) {\n        newArray[i] = range[0] + i * k - k / 2.0; // minus k / 2 to start at below range color\n\n        if (useLogScale) {\n          newArray[i] = Math.pow(10.0, newArray[i]);\n        }\n      } // Dimension on NaN.\n\n      for (var _i = 0; _i < numberOfColors; ++_i) {\n        newArray[_i + numberOfColors] = NaN;\n      }\n      model.colorTextureMap = vtkImageData.newInstance();\n      model.colorTextureMap.setExtent(0, numberOfColors - 1, 0, 1, 0, 0);\n      var tmp = vtkDataArray.newInstance({\n        numberOfComponents: 1,\n        values: newArray\n      });\n      model.colorTextureMap.getPointData().setScalars(model.lookupTable.mapScalars(tmp, model.colorMode, 0));\n      model.lookupTable.setAlpha(origAlpha);\n    } // Create new coordinates if necessary.\n    // Need to compare lookup table in case the range has changed.\n\n    if (!model.colorCoordinates || publicAPI.getMTime() > model.colorCoordinates.getMTime() || publicAPI.getInputData(0).getMTime() > model.colorCoordinates.getMTime() || model.lookupTable.getMTime() > model.colorCoordinates.getMTime()) {\n      // Get rid of old colors\n      model.colorCoordinates = null; // Now create the color texture coordinates.\n\n      var numComps = scalars.getNumberOfComponents();\n      var num = scalars.getNumberOfTuples(); // const fArray = new FloatArray(num * 2);\n\n      model.colorCoordinates = vtkDataArray.newInstance({\n        numberOfComponents: 2,\n        values: new Float32Array(num * 2)\n      });\n      var scalarComponent = model.lookupTable.getVectorComponent(); // Although I like the feature of applying magnitude to single component\n      // scalars, it is not how the old MapScalars for vertex coloring works.\n\n      if (model.lookupTable.getVectorMode() === VectorMode.MAGNITUDE && scalars.getNumberOfComponents() > 1) {\n        scalarComponent = -1;\n      }\n      publicAPI.createColorTextureCoordinates(scalars, model.colorCoordinates, num, numComps, scalarComponent, range, model.lookupTable.getRange(), model.colorTextureMap.getPointData().getScalars().getNumberOfTuples() / 2 - 2, useLogScale);\n    }\n  };\n  publicAPI.getIsOpaque = function () {\n    var input = publicAPI.getInputData();\n    var gasResult = publicAPI.getAbstractScalars(input, model.scalarMode, model.arrayAccessMode, model.arrayId, model.colorByArrayName);\n    var scalars = gasResult.scalars;\n    if (!model.scalarVisibility || scalars == null) {\n      // No scalar colors.\n      return true;\n    }\n    var lut = publicAPI.getLookupTable();\n    if (lut) {\n      // Ensure that the lookup table is built\n      lut.build();\n      return lut.areScalarsOpaque(scalars, model.colorMode, -1);\n    }\n    return true;\n  };\n  publicAPI.canUseTextureMapForColoring = function (input) {\n    if (!model.interpolateScalarsBeforeMapping) {\n      return false; // user doesn't want us to use texture maps at all.\n    } // index color does not use textures\n\n    if (model.lookupTable && model.lookupTable.getIndexedLookup()) {\n      return false;\n    }\n    var gasResult = publicAPI.getAbstractScalars(input, model.scalarMode, model.arrayAccessMode, model.arrayId, model.colorByArrayName);\n    var scalars = gasResult.scalars;\n    if (!scalars) {\n      // no scalars on this dataset, we don't care if texture is used at all.\n      return false;\n    }\n    if (gasResult.cellFlag) {\n      return false; // cell data colors, don't use textures.\n    }\n\n    if (model.colorMode === ColorMode.DEFAULT && scalars.getDataType() === VtkDataTypes.UNSIGNED_CHAR || model.colorMode === ColorMode.DIRECT_SCALARS) {\n      // Don't use texture is direct coloring using RGB unsigned chars is\n      // requested.\n      return false;\n    }\n    return true;\n  };\n  publicAPI.clearColorArrays = function () {\n    model.colorMapColors = null;\n    model.colorCoordinates = null;\n    model.colorTextureMap = null;\n  };\n  publicAPI.getLookupTable = function () {\n    if (!model.lookupTable) {\n      publicAPI.createDefaultLookupTable();\n    }\n    return model.lookupTable;\n  };\n  publicAPI.getMTime = function () {\n    var mt = model.mtime;\n    if (model.lookupTable !== null) {\n      var time = model.lookupTable.getMTime();\n      mt = time > mt ? time : mt;\n    }\n    return mt;\n  };\n  publicAPI.getPrimitiveCount = function () {\n    var input = publicAPI.getInputData();\n    var pcount = {\n      points: input.getPoints().getNumberOfValues() / 3,\n      verts: input.getVerts().getNumberOfValues() - input.getVerts().getNumberOfCells(),\n      lines: input.getLines().getNumberOfValues() - 2 * input.getLines().getNumberOfCells(),\n      triangles: input.getPolys().getNumberOfValues() - 3 * input.getPolys().getNumberOfCells()\n    };\n    return pcount;\n  };\n  publicAPI.acquireInvertibleLookupTable = notImplemented('AcquireInvertibleLookupTable');\n  publicAPI.valueToColor = notImplemented('ValueToColor');\n  publicAPI.colorToValue = notImplemented('ColorToValue');\n  publicAPI.useInvertibleColorFor = notImplemented('UseInvertibleColorFor');\n  publicAPI.clearInvertibleColor = notImplemented('ClearInvertibleColor');\n  publicAPI.processSelectorPixelBuffers = function (selector, pixelOffsets) {\n    /* eslint-disable no-bitwise */\n    if (!selector || !model.selectionWebGLIdsToVTKIds || !model.populateSelectionSettings) {\n      return;\n    }\n    var rawLowData = selector.getRawPixelBuffer(PassTypes.ID_LOW24);\n    var rawHighData = selector.getRawPixelBuffer(PassTypes.ID_HIGH24);\n    var currentPass = selector.getCurrentPass();\n    var fieldAssociation = selector.getFieldAssociation();\n    var idMap = null;\n    if (fieldAssociation === FieldAssociations.FIELD_ASSOCIATION_POINTS) {\n      idMap = model.selectionWebGLIdsToVTKIds.points;\n    } else if (fieldAssociation === FieldAssociations.FIELD_ASSOCIATION_CELLS) {\n      idMap = model.selectionWebGLIdsToVTKIds.cells;\n    }\n    if (!idMap) {\n      return;\n    }\n    pixelOffsets.forEach(function (pos) {\n      if (currentPass === PassTypes.ID_LOW24) {\n        var inValue = 0;\n        if (rawHighData) {\n          inValue += rawHighData[pos];\n          inValue *= 256;\n        }\n        inValue += rawLowData[pos + 2];\n        inValue *= 256;\n        inValue += rawLowData[pos + 1];\n        inValue *= 256;\n        inValue += rawLowData[pos];\n        var outValue = idMap[inValue];\n        var lowData = selector.getPixelBuffer(PassTypes.ID_LOW24);\n        lowData[pos] = outValue & 0xff;\n        lowData[pos + 1] = (outValue & 0xff00) >> 8;\n        lowData[pos + 2] = (outValue & 0xff0000) >> 16;\n      } else if (currentPass === PassTypes.ID_HIGH24 && rawHighData) {\n        var _inValue = 0;\n        _inValue += rawHighData[pos];\n        _inValue *= 256;\n        _inValue += rawLowData[pos];\n        _inValue *= 256;\n        _inValue += rawLowData[pos + 1];\n        _inValue *= 256;\n        _inValue += rawLowData[pos + 2];\n        var _outValue = idMap[_inValue];\n        var highData = selector.getPixelBuffer(PassTypes.ID_HIGH24);\n        highData[pos] = (_outValue & 0xff000000) >> 24;\n      }\n    });\n    /* eslint-enable no-bitwise */\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nvar DEFAULT_VALUES = {\n  colorMapColors: null,\n  // Same as this->Colors\n  static: false,\n  lookupTable: null,\n  scalarVisibility: true,\n  scalarRange: [0, 1],\n  useLookupTableScalarRange: false,\n  colorMode: 0,\n  scalarMode: 0,\n  arrayAccessMode: 1,\n  // By_NAME\n  renderTime: 0,\n  colorByArrayName: null,\n  fieldDataTupleId: -1,\n  populateSelectionSettings: true,\n  selectionWebGLIdsToVTKIds: null,\n  interpolateScalarsBeforeMapping: false,\n  colorCoordinates: null,\n  colorTextureMap: null,\n  forceCompileOnly: 0,\n  useInvertibleColors: false,\n  invertibleScalars: null,\n  customShaderAttributes: []\n}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Inheritance\n\n  vtkAbstractMapper3D.extend(publicAPI, model, initialValues);\n  macro.get(publicAPI, model, ['colorCoordinates', 'colorMapColors', 'colorTextureMap', 'selectionWebGLIdsToVTKIds']);\n  macro.setGet(publicAPI, model, ['colorByArrayName', 'arrayAccessMode', 'colorMode', 'fieldDataTupleId', 'interpolateScalarsBeforeMapping', 'lookupTable', 'populateSelectionSettings', 'renderTime', 'scalarMode', 'scalarVisibility', 'static', 'useLookupTableScalarRange', 'customShaderAttributes' // point data array names that will be transferred to the VBO\n  ]);\n\n  macro.setGetArray(publicAPI, model, ['scalarRange'], 2);\n  CoincidentTopologyHelper.implementCoincidentTopologyMethods(publicAPI, model); // Object methods\n\n  vtkMapper(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = macro.newInstance(extend, 'vtkMapper'); // ----------------------------------------------------------------------------\n\nvar vtkMapper$1 = _objectSpread(_objectSpread(_objectSpread({\n  newInstance: newInstance,\n  extend: extend\n}, staticOffsetAPI), otherStaticMethods), Constants);\nexport { vtkMapper$1 as default, extend, newInstance };","map":{"version":3,"names":["_defineProperty","macro","vtkAbstractMapper3D","vtkDataArray","vtkImageData","vtkLookupTable","F","createUninitializedBounds","i","isNan","vtkScalarsToColors","CoincidentTopologyHelper","Constants","vtkDataSet","PassTypes","ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","arguments","length","source","forEach","key","getOwnPropertyDescriptors","defineProperties","defineProperty","FieldAssociations","staticOffsetAPI","otherStaticMethods","ColorMode","ScalarMode","GetArray","VectorMode","VtkDataTypes","notImplemented","method","vtkErrorMacro","concat","vtkMapper","publicAPI","model","classHierarchy","getBounds","input","getInputData","bounds","static","update","setForceCompileOnly","v","forceCompileOnly","setSelectionWebGLIdsToVTKIds","selectionWebGLIdsToVTKIds","createDefaultLookupTable","lookupTable","newInstance","getColorModeAsString","enumToString","colorMode","setColorModeToDefault","setColorMode","setColorModeToMapScalars","setColorModeToDirectScalars","getScalarModeAsString","scalarMode","setScalarModeToDefault","setScalarMode","setScalarModeToUsePointData","setScalarModeToUseCellData","setScalarModeToUsePointFieldData","setScalarModeToUseCellFieldData","setScalarModeToUseFieldData","getAbstractScalars","arrayAccessMode","arrayId","arrayName","scalarVisibility","scalars","cellFLag","cellFlag","DEFAULT","getPointData","getScalars","getCellData","USE_POINT_DATA","USE_CELL_DATA","USE_POINT_FIELD_DATA","pd","BY_ID","getArrayByIndex","getArrayByName","USE_CELL_FIELD_DATA","cd","USE_FIELD_DATA","fd","getFieldData","mapScalars","alpha","colorByArrayName","colorCoordinates","colorTextureMap","colorMapColors","toString","getMTime","colorBuildString","useLookupTableScalarRange","getLookupTable","setRange","scalarRange","canUseTextureMapForColoring","mapScalarsToTexture","lut","build","fieldDataTupleId","scalarToTextureCoordinate","scalarValue","rangeMin","invRangeWidth","texCoordS","texCoordT","createColorTextureCoordinates","output","numScalars","numComps","component","range","tableRange","tableNumberOfColors","useLogScale","scalarTexelWidth","paddedRange","outputV","getData","inputV","count","outputCount","scalarIdx","sum","compIdx","magnitude","Math","sqrt","applyLogScale","outputs","_scalarIdx","inputValue","_outputs","getRange","usingLogScale","getLogRange","origAlpha","getAlpha","setAlpha","numberOfColors","getNumberOfAvailableColors","k","newArray","Float64Array","pow","_i","NaN","setExtent","tmp","numberOfComponents","values","setScalars","getNumberOfComponents","num","getNumberOfTuples","Float32Array","scalarComponent","getVectorComponent","getVectorMode","MAGNITUDE","getIsOpaque","gasResult","areScalarsOpaque","interpolateScalarsBeforeMapping","getIndexedLookup","getDataType","UNSIGNED_CHAR","DIRECT_SCALARS","clearColorArrays","mt","mtime","time","getPrimitiveCount","pcount","points","getPoints","getNumberOfValues","verts","getVerts","getNumberOfCells","lines","getLines","triangles","getPolys","acquireInvertibleLookupTable","valueToColor","colorToValue","useInvertibleColorFor","clearInvertibleColor","processSelectorPixelBuffers","selector","pixelOffsets","populateSelectionSettings","rawLowData","getRawPixelBuffer","ID_LOW24","rawHighData","ID_HIGH24","currentPass","getCurrentPass","fieldAssociation","getFieldAssociation","idMap","FIELD_ASSOCIATION_POINTS","FIELD_ASSOCIATION_CELLS","cells","pos","inValue","outValue","lowData","getPixelBuffer","_inValue","_outValue","highData","DEFAULT_VALUES","renderTime","useInvertibleColors","invertibleScalars","customShaderAttributes","extend","initialValues","undefined","assign","get","setGet","setGetArray","implementCoincidentTopologyMethods","vtkMapper$1","default"],"sources":["/home/rakshith/Documents/RemoteRendering/vtk-js-react-app/node_modules/@kitware/vtk.js/Rendering/Core/Mapper.js"],"sourcesContent":["import _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport macro from '../../macros.js';\nimport vtkAbstractMapper3D from './AbstractMapper3D.js';\nimport vtkDataArray from '../../Common/Core/DataArray.js';\nimport vtkImageData from '../../Common/DataModel/ImageData.js';\nimport vtkLookupTable from '../../Common/Core/LookupTable.js';\nimport { F as createUninitializedBounds, i as isNan } from '../../Common/Core/Math/index.js';\nimport vtkScalarsToColors from '../../Common/Core/ScalarsToColors/Constants.js';\nimport CoincidentTopologyHelper from './Mapper/CoincidentTopologyHelper.js';\nimport Constants from './Mapper/Constants.js';\nimport vtkDataSet from '../../Common/DataModel/DataSet.js';\nimport { PassTypes } from '../OpenGL/HardwareSelector/Constants.js';\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nvar FieldAssociations = vtkDataSet.FieldAssociations;\nvar staticOffsetAPI = CoincidentTopologyHelper.staticOffsetAPI,\n    otherStaticMethods = CoincidentTopologyHelper.otherStaticMethods;\nvar ColorMode = Constants.ColorMode,\n    ScalarMode = Constants.ScalarMode,\n    GetArray = Constants.GetArray;\nvar VectorMode = vtkScalarsToColors.VectorMode;\nvar VtkDataTypes = vtkDataArray.VtkDataTypes; // ----------------------------------------------------------------------------\n\nfunction notImplemented(method) {\n  return function () {\n    return macro.vtkErrorMacro(\"vtkMapper::\".concat(method, \" - NOT IMPLEMENTED\"));\n  };\n} // ----------------------------------------------------------------------------\n// vtkMapper methods\n// ----------------------------------------------------------------------------\n\n\nfunction vtkMapper(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkMapper');\n\n  publicAPI.getBounds = function () {\n    var input = publicAPI.getInputData();\n\n    if (!input) {\n      model.bounds = createUninitializedBounds();\n    } else {\n      if (!model.static) {\n        publicAPI.update();\n      }\n\n      model.bounds = input.getBounds();\n    }\n\n    return model.bounds;\n  };\n\n  publicAPI.setForceCompileOnly = function (v) {\n    model.forceCompileOnly = v; // make sure we do NOT call modified()\n  };\n\n  publicAPI.setSelectionWebGLIdsToVTKIds = function (selectionWebGLIdsToVTKIds) {\n    model.selectionWebGLIdsToVTKIds = selectionWebGLIdsToVTKIds; // make sure we do NOT call modified()\n    // this attribute is only used when processing a selection made with the hardware selector\n    // the mtime of the mapper doesn't need to be changed\n  };\n\n  publicAPI.createDefaultLookupTable = function () {\n    model.lookupTable = vtkLookupTable.newInstance();\n  };\n\n  publicAPI.getColorModeAsString = function () {\n    return macro.enumToString(ColorMode, model.colorMode);\n  };\n\n  publicAPI.setColorModeToDefault = function () {\n    return publicAPI.setColorMode(0);\n  };\n\n  publicAPI.setColorModeToMapScalars = function () {\n    return publicAPI.setColorMode(1);\n  };\n\n  publicAPI.setColorModeToDirectScalars = function () {\n    return publicAPI.setColorMode(2);\n  };\n\n  publicAPI.getScalarModeAsString = function () {\n    return macro.enumToString(ScalarMode, model.scalarMode);\n  };\n\n  publicAPI.setScalarModeToDefault = function () {\n    return publicAPI.setScalarMode(0);\n  };\n\n  publicAPI.setScalarModeToUsePointData = function () {\n    return publicAPI.setScalarMode(1);\n  };\n\n  publicAPI.setScalarModeToUseCellData = function () {\n    return publicAPI.setScalarMode(2);\n  };\n\n  publicAPI.setScalarModeToUsePointFieldData = function () {\n    return publicAPI.setScalarMode(3);\n  };\n\n  publicAPI.setScalarModeToUseCellFieldData = function () {\n    return publicAPI.setScalarMode(4);\n  };\n\n  publicAPI.setScalarModeToUseFieldData = function () {\n    return publicAPI.setScalarMode(5);\n  };\n\n  publicAPI.getAbstractScalars = function (input, scalarMode, arrayAccessMode, arrayId, arrayName) {\n    // make sure we have an input\n    if (!input || !model.scalarVisibility) {\n      return {\n        scalars: null,\n        cellFLag: false\n      };\n    }\n\n    var scalars = null;\n    var cellFlag = false; // get and scalar data according to scalar mode\n\n    if (scalarMode === ScalarMode.DEFAULT) {\n      scalars = input.getPointData().getScalars();\n\n      if (!scalars) {\n        scalars = input.getCellData().getScalars();\n        cellFlag = true;\n      }\n    } else if (scalarMode === ScalarMode.USE_POINT_DATA) {\n      scalars = input.getPointData().getScalars();\n    } else if (scalarMode === ScalarMode.USE_CELL_DATA) {\n      scalars = input.getCellData().getScalars();\n      cellFlag = true;\n    } else if (scalarMode === ScalarMode.USE_POINT_FIELD_DATA) {\n      var pd = input.getPointData();\n\n      if (arrayAccessMode === GetArray.BY_ID) {\n        scalars = pd.getArrayByIndex(arrayId);\n      } else {\n        scalars = pd.getArrayByName(arrayName);\n      }\n    } else if (scalarMode === ScalarMode.USE_CELL_FIELD_DATA) {\n      var cd = input.getCellData();\n      cellFlag = true;\n\n      if (arrayAccessMode === GetArray.BY_ID) {\n        scalars = cd.getArrayByIndex(arrayId);\n      } else {\n        scalars = cd.getArrayByName(arrayName);\n      }\n    } else if (scalarMode === ScalarMode.USE_FIELD_DATA) {\n      var fd = input.getFieldData();\n\n      if (arrayAccessMode === GetArray.BY_ID) {\n        scalars = fd.getArrayByIndex(arrayId);\n      } else {\n        scalars = fd.getArrayByName(arrayName);\n      }\n    }\n\n    return {\n      scalars: scalars,\n      cellFlag: cellFlag\n    };\n  };\n\n  publicAPI.mapScalars = function (input, alpha) {\n    var scalars = publicAPI.getAbstractScalars(input, model.scalarMode, model.arrayAccessMode, model.arrayId, model.colorByArrayName).scalars;\n\n    if (!scalars) {\n      model.colorCoordinates = null;\n      model.colorTextureMap = null;\n      model.colorMapColors = null;\n      return;\n    } // we want to only recompute when something has changed\n\n\n    var toString = \"\".concat(publicAPI.getMTime()).concat(scalars.getMTime()).concat(alpha);\n    if (model.colorBuildString === toString) return;\n\n    if (!model.useLookupTableScalarRange) {\n      publicAPI.getLookupTable().setRange(model.scalarRange[0], model.scalarRange[1]);\n    } // Decide between texture color or vertex color.\n    // Cell data always uses vertex color.\n    // Only point data can use both texture and vertex coloring.\n\n\n    if (publicAPI.canUseTextureMapForColoring(input)) {\n      publicAPI.mapScalarsToTexture(scalars, alpha);\n    } else {\n      model.colorCoordinates = null;\n      model.colorTextureMap = null;\n      var lut = publicAPI.getLookupTable();\n\n      if (lut) {\n        // Ensure that the lookup table is built\n        lut.build();\n        model.colorMapColors = lut.mapScalars(scalars, model.colorMode, model.fieldDataTupleId);\n      }\n    }\n\n    model.colorBuildString = \"\".concat(publicAPI.getMTime()).concat(scalars.getMTime()).concat(alpha);\n  }; //-----------------------------------------------------------------------------\n\n\n  publicAPI.scalarToTextureCoordinate = function (scalarValue, // Input scalar\n  rangeMin, // range[0]\n  invRangeWidth) {\n    // 1/(range[1]-range[0])\n    var texCoordS = 0.5; // Scalar value is arbitrary when NaN\n\n    var texCoordT = 1.0; // 1.0 in t coordinate means NaN\n\n    if (!isNan(scalarValue)) {\n      // 0.0 in t coordinate means not NaN.  So why am I setting it to 0.49?\n      // Because when you are mapping scalars and you have a NaN adjacent to\n      // anything else, the interpolation everywhere should be NaN.  Thus, I\n      // want the NaN color everywhere except right on the non-NaN neighbors.\n      // To simulate this, I set the t coord for the real numbers close to\n      // the threshold so that the interpolation almost immediately looks up\n      // the NaN value.\n      texCoordT = 0.49;\n      texCoordS = (scalarValue - rangeMin) * invRangeWidth; // Some implementations apparently don't handle relatively large\n      // numbers (compared to the range [0.0, 1.0]) very well. In fact,\n      // values above 1122.0f appear to cause texture wrap-around on\n      // some systems even when edge clamping is enabled. Why 1122.0f? I\n      // don't know. For safety, we'll clamp at +/- 1000. This will\n      // result in incorrect images when the texture value should be\n      // above or below 1000, but I don't have a better solution.\n\n      if (texCoordS > 1000.0) {\n        texCoordS = 1000.0;\n      } else if (texCoordS < -1000.0) {\n        texCoordS = -1000.0;\n      }\n    }\n\n    return {\n      texCoordS: texCoordS,\n      texCoordT: texCoordT\n    };\n  }; //-----------------------------------------------------------------------------\n\n\n  publicAPI.createColorTextureCoordinates = function (input, output, numScalars, numComps, component, range, tableRange, tableNumberOfColors, useLogScale) {\n    // We have to change the range used for computing texture\n    // coordinates slightly to accommodate the special above- and\n    // below-range colors that are the first and last texels,\n    // respectively.\n    var scalarTexelWidth = (range[1] - range[0]) / tableNumberOfColors;\n    var paddedRange = [];\n    paddedRange[0] = range[0] - scalarTexelWidth;\n    paddedRange[1] = range[1] + scalarTexelWidth;\n    var invRangeWidth = 1.0 / (paddedRange[1] - paddedRange[0]);\n    var outputV = output.getData();\n    var inputV = input.getData();\n    var count = 0;\n    var outputCount = 0;\n\n    if (component < 0 || component >= numComps) {\n      for (var scalarIdx = 0; scalarIdx < numScalars; ++scalarIdx) {\n        var sum = 0;\n\n        for (var compIdx = 0; compIdx < numComps; ++compIdx) {\n          sum += inputV[count] * inputV[count];\n          count++;\n        }\n\n        var magnitude = Math.sqrt(sum);\n\n        if (useLogScale) {\n          magnitude = vtkLookupTable.applyLogScale(magnitude, tableRange, range);\n        }\n\n        var outputs = publicAPI.scalarToTextureCoordinate(magnitude, paddedRange[0], invRangeWidth);\n        outputV[outputCount] = outputs.texCoordS;\n        outputV[outputCount + 1] = outputs.texCoordT;\n        outputCount += 2;\n      }\n    } else {\n      count += component;\n\n      for (var _scalarIdx = 0; _scalarIdx < numScalars; ++_scalarIdx) {\n        var inputValue = inputV[count];\n\n        if (useLogScale) {\n          inputValue = vtkLookupTable.applyLogScale(inputValue, tableRange, range);\n        }\n\n        var _outputs = publicAPI.scalarToTextureCoordinate(inputValue, paddedRange[0], invRangeWidth);\n\n        outputV[outputCount] = _outputs.texCoordS;\n        outputV[outputCount + 1] = _outputs.texCoordT;\n        outputCount += 2;\n        count += numComps;\n      }\n    }\n  };\n\n  publicAPI.mapScalarsToTexture = function (scalars, alpha) {\n    var range = model.lookupTable.getRange();\n    var useLogScale = model.lookupTable.usingLogScale();\n\n    if (useLogScale) {\n      // convert range to log.\n      vtkLookupTable.getLogRange(range, range);\n    }\n\n    var origAlpha = model.lookupTable.getAlpha(); // Get rid of vertex color array.  Only texture or vertex coloring\n    // can be active at one time.  The existence of the array is the\n    // signal to use that technique.\n\n    model.colorMapColors = null; // If the lookup table has changed, then recreate the color texture map.\n    // Set a new lookup table changes this->MTime.\n\n    if (model.colorTextureMap == null || publicAPI.getMTime() > model.colorTextureMap.getMTime() || model.lookupTable.getMTime() > model.colorTextureMap.getMTime() || model.lookupTable.getAlpha() !== alpha) {\n      model.lookupTable.setAlpha(alpha);\n      model.colorTextureMap = null; // Get the texture map from the lookup table.\n      // Create a dummy ramp of scalars.\n      // In the future, we could extend vtkScalarsToColors.\n\n      model.lookupTable.build();\n      var numberOfColors = model.lookupTable.getNumberOfAvailableColors();\n\n      if (numberOfColors > 4094) {\n        numberOfColors = 4094;\n      }\n\n      if (numberOfColors < 64) {\n        numberOfColors = 64;\n      }\n\n      numberOfColors += 2;\n      var k = (range[1] - range[0]) / (numberOfColors - 2);\n      var newArray = new Float64Array(numberOfColors * 2);\n\n      for (var i = 0; i < numberOfColors; ++i) {\n        newArray[i] = range[0] + i * k - k / 2.0; // minus k / 2 to start at below range color\n\n        if (useLogScale) {\n          newArray[i] = Math.pow(10.0, newArray[i]);\n        }\n      } // Dimension on NaN.\n\n\n      for (var _i = 0; _i < numberOfColors; ++_i) {\n        newArray[_i + numberOfColors] = NaN;\n      }\n\n      model.colorTextureMap = vtkImageData.newInstance();\n      model.colorTextureMap.setExtent(0, numberOfColors - 1, 0, 1, 0, 0);\n      var tmp = vtkDataArray.newInstance({\n        numberOfComponents: 1,\n        values: newArray\n      });\n      model.colorTextureMap.getPointData().setScalars(model.lookupTable.mapScalars(tmp, model.colorMode, 0));\n      model.lookupTable.setAlpha(origAlpha);\n    } // Create new coordinates if necessary.\n    // Need to compare lookup table in case the range has changed.\n\n\n    if (!model.colorCoordinates || publicAPI.getMTime() > model.colorCoordinates.getMTime() || publicAPI.getInputData(0).getMTime() > model.colorCoordinates.getMTime() || model.lookupTable.getMTime() > model.colorCoordinates.getMTime()) {\n      // Get rid of old colors\n      model.colorCoordinates = null; // Now create the color texture coordinates.\n\n      var numComps = scalars.getNumberOfComponents();\n      var num = scalars.getNumberOfTuples(); // const fArray = new FloatArray(num * 2);\n\n      model.colorCoordinates = vtkDataArray.newInstance({\n        numberOfComponents: 2,\n        values: new Float32Array(num * 2)\n      });\n      var scalarComponent = model.lookupTable.getVectorComponent(); // Although I like the feature of applying magnitude to single component\n      // scalars, it is not how the old MapScalars for vertex coloring works.\n\n      if (model.lookupTable.getVectorMode() === VectorMode.MAGNITUDE && scalars.getNumberOfComponents() > 1) {\n        scalarComponent = -1;\n      }\n\n      publicAPI.createColorTextureCoordinates(scalars, model.colorCoordinates, num, numComps, scalarComponent, range, model.lookupTable.getRange(), model.colorTextureMap.getPointData().getScalars().getNumberOfTuples() / 2 - 2, useLogScale);\n    }\n  };\n\n  publicAPI.getIsOpaque = function () {\n    var input = publicAPI.getInputData();\n    var gasResult = publicAPI.getAbstractScalars(input, model.scalarMode, model.arrayAccessMode, model.arrayId, model.colorByArrayName);\n    var scalars = gasResult.scalars;\n\n    if (!model.scalarVisibility || scalars == null) {\n      // No scalar colors.\n      return true;\n    }\n\n    var lut = publicAPI.getLookupTable();\n\n    if (lut) {\n      // Ensure that the lookup table is built\n      lut.build();\n      return lut.areScalarsOpaque(scalars, model.colorMode, -1);\n    }\n\n    return true;\n  };\n\n  publicAPI.canUseTextureMapForColoring = function (input) {\n    if (!model.interpolateScalarsBeforeMapping) {\n      return false; // user doesn't want us to use texture maps at all.\n    } // index color does not use textures\n\n\n    if (model.lookupTable && model.lookupTable.getIndexedLookup()) {\n      return false;\n    }\n\n    var gasResult = publicAPI.getAbstractScalars(input, model.scalarMode, model.arrayAccessMode, model.arrayId, model.colorByArrayName);\n    var scalars = gasResult.scalars;\n\n    if (!scalars) {\n      // no scalars on this dataset, we don't care if texture is used at all.\n      return false;\n    }\n\n    if (gasResult.cellFlag) {\n      return false; // cell data colors, don't use textures.\n    }\n\n    if (model.colorMode === ColorMode.DEFAULT && scalars.getDataType() === VtkDataTypes.UNSIGNED_CHAR || model.colorMode === ColorMode.DIRECT_SCALARS) {\n      // Don't use texture is direct coloring using RGB unsigned chars is\n      // requested.\n      return false;\n    }\n\n    return true;\n  };\n\n  publicAPI.clearColorArrays = function () {\n    model.colorMapColors = null;\n    model.colorCoordinates = null;\n    model.colorTextureMap = null;\n  };\n\n  publicAPI.getLookupTable = function () {\n    if (!model.lookupTable) {\n      publicAPI.createDefaultLookupTable();\n    }\n\n    return model.lookupTable;\n  };\n\n  publicAPI.getMTime = function () {\n    var mt = model.mtime;\n\n    if (model.lookupTable !== null) {\n      var time = model.lookupTable.getMTime();\n      mt = time > mt ? time : mt;\n    }\n\n    return mt;\n  };\n\n  publicAPI.getPrimitiveCount = function () {\n    var input = publicAPI.getInputData();\n    var pcount = {\n      points: input.getPoints().getNumberOfValues() / 3,\n      verts: input.getVerts().getNumberOfValues() - input.getVerts().getNumberOfCells(),\n      lines: input.getLines().getNumberOfValues() - 2 * input.getLines().getNumberOfCells(),\n      triangles: input.getPolys().getNumberOfValues() - 3 * input.getPolys().getNumberOfCells()\n    };\n    return pcount;\n  };\n\n  publicAPI.acquireInvertibleLookupTable = notImplemented('AcquireInvertibleLookupTable');\n  publicAPI.valueToColor = notImplemented('ValueToColor');\n  publicAPI.colorToValue = notImplemented('ColorToValue');\n  publicAPI.useInvertibleColorFor = notImplemented('UseInvertibleColorFor');\n  publicAPI.clearInvertibleColor = notImplemented('ClearInvertibleColor');\n\n  publicAPI.processSelectorPixelBuffers = function (selector, pixelOffsets) {\n    /* eslint-disable no-bitwise */\n    if (!selector || !model.selectionWebGLIdsToVTKIds || !model.populateSelectionSettings) {\n      return;\n    }\n\n    var rawLowData = selector.getRawPixelBuffer(PassTypes.ID_LOW24);\n    var rawHighData = selector.getRawPixelBuffer(PassTypes.ID_HIGH24);\n    var currentPass = selector.getCurrentPass();\n    var fieldAssociation = selector.getFieldAssociation();\n    var idMap = null;\n\n    if (fieldAssociation === FieldAssociations.FIELD_ASSOCIATION_POINTS) {\n      idMap = model.selectionWebGLIdsToVTKIds.points;\n    } else if (fieldAssociation === FieldAssociations.FIELD_ASSOCIATION_CELLS) {\n      idMap = model.selectionWebGLIdsToVTKIds.cells;\n    }\n\n    if (!idMap) {\n      return;\n    }\n\n    pixelOffsets.forEach(function (pos) {\n      if (currentPass === PassTypes.ID_LOW24) {\n        var inValue = 0;\n\n        if (rawHighData) {\n          inValue += rawHighData[pos];\n          inValue *= 256;\n        }\n\n        inValue += rawLowData[pos + 2];\n        inValue *= 256;\n        inValue += rawLowData[pos + 1];\n        inValue *= 256;\n        inValue += rawLowData[pos];\n        var outValue = idMap[inValue];\n        var lowData = selector.getPixelBuffer(PassTypes.ID_LOW24);\n        lowData[pos] = outValue & 0xff;\n        lowData[pos + 1] = (outValue & 0xff00) >> 8;\n        lowData[pos + 2] = (outValue & 0xff0000) >> 16;\n      } else if (currentPass === PassTypes.ID_HIGH24 && rawHighData) {\n        var _inValue = 0;\n        _inValue += rawHighData[pos];\n        _inValue *= 256;\n        _inValue += rawLowData[pos];\n        _inValue *= 256;\n        _inValue += rawLowData[pos + 1];\n        _inValue *= 256;\n        _inValue += rawLowData[pos + 2];\n        var _outValue = idMap[_inValue];\n        var highData = selector.getPixelBuffer(PassTypes.ID_HIGH24);\n        highData[pos] = (_outValue & 0xff000000) >> 24;\n      }\n    });\n    /* eslint-enable no-bitwise */\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\n\nvar DEFAULT_VALUES = {\n  colorMapColors: null,\n  // Same as this->Colors\n  static: false,\n  lookupTable: null,\n  scalarVisibility: true,\n  scalarRange: [0, 1],\n  useLookupTableScalarRange: false,\n  colorMode: 0,\n  scalarMode: 0,\n  arrayAccessMode: 1,\n  // By_NAME\n  renderTime: 0,\n  colorByArrayName: null,\n  fieldDataTupleId: -1,\n  populateSelectionSettings: true,\n  selectionWebGLIdsToVTKIds: null,\n  interpolateScalarsBeforeMapping: false,\n  colorCoordinates: null,\n  colorTextureMap: null,\n  forceCompileOnly: 0,\n  useInvertibleColors: false,\n  invertibleScalars: null,\n  customShaderAttributes: []\n}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Inheritance\n\n  vtkAbstractMapper3D.extend(publicAPI, model, initialValues);\n  macro.get(publicAPI, model, ['colorCoordinates', 'colorMapColors', 'colorTextureMap', 'selectionWebGLIdsToVTKIds']);\n  macro.setGet(publicAPI, model, ['colorByArrayName', 'arrayAccessMode', 'colorMode', 'fieldDataTupleId', 'interpolateScalarsBeforeMapping', 'lookupTable', 'populateSelectionSettings', 'renderTime', 'scalarMode', 'scalarVisibility', 'static', 'useLookupTableScalarRange', 'customShaderAttributes' // point data array names that will be transferred to the VBO\n  ]);\n  macro.setGetArray(publicAPI, model, ['scalarRange'], 2);\n  CoincidentTopologyHelper.implementCoincidentTopologyMethods(publicAPI, model); // Object methods\n\n  vtkMapper(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = macro.newInstance(extend, 'vtkMapper'); // ----------------------------------------------------------------------------\n\nvar vtkMapper$1 = _objectSpread(_objectSpread(_objectSpread({\n  newInstance: newInstance,\n  extend: extend\n}, staticOffsetAPI), otherStaticMethods), Constants);\n\nexport { vtkMapper$1 as default, extend, newInstance };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}