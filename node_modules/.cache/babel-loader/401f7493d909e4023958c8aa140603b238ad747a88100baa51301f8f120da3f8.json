{"ast":null,"code":"import _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport _toConsumableArray from '@babel/runtime/helpers/toConsumableArray';\nimport macro from '../../macros.js';\nimport { d as dot, s as subtract, j as cross, k as add, l as normalize, e as distance2BetweenPoints, n as norm } from '../Core/Math/index.js';\nimport vtkLine from './Line.js';\nimport vtkPlane from './Plane.js';\nimport vtkPriorityQueue from '../Core/PriorityQueue.js';\nimport vtkBoundingBox from './BoundingBox.js';\nimport { IntersectionState } from './Line/Constants.js';\nimport { PolygonWithPointIntersectionState, FLOAT_EPSILON, TOLERANCE, EPSILON } from './Polygon/Constants.js';\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n  return target;\n}\n// Global methods\n// ----------------------------------------------------------------------------\n// Given the line (p0,p1), determine if the given point is located to the left\n// of, on, or to the right of a line (with the function returning >0, ==0, or\n// <0 respectively). The points are assumed 3D points, but projected into\n// one of x-y-z planes; hence the indices axis0 and axis1 specify which plane\n// the computation is to be performed on.\n\nfunction pointLocation(axis0, axis1, p0, p1, point) {\n  return (p1[axis0] - p0[axis0]) * (point[axis1] - p0[axis1]) - (point[axis0] - p0[axis0]) * (p1[axis1] - p0[axis1]);\n} //------------------------------------------------------------------------------\n\nfunction pointInPolygon(point, vertices, bounds, normal) {\n  // Do a quick bounds check to throw out trivial cases.\n  // winding plane.\n  if (point[0] < bounds[0] || point[0] > bounds[1] || point[1] < bounds[2] || point[1] > bounds[3] || point[2] < bounds[4] || point[2] > bounds[5]) {\n    return PolygonWithPointIntersectionState.OUTSIDE;\n  } //  Check that the normal is non-zero.\n\n  if (normalize(normal) <= FLOAT_EPSILON) {\n    return PolygonWithPointIntersectionState.FAILURE;\n  } // Assess whether the point lies on the boundary of the polygon. Points on\n  // the boundary are considered inside the polygon. Need to define a small\n  // tolerance relative to the bounding box diagonal length of the polygon.\n\n  var tol2 = TOLERANCE * ((bounds[1] - bounds[0]) * (bounds[1] - bounds[0]) + (bounds[3] - bounds[2]) * (bounds[3] - bounds[2]) + (bounds[5] - bounds[4]) * (bounds[5] - bounds[4]));\n  tol2 *= tol2;\n  tol2 = tol2 === 0.0 ? FLOAT_EPSILON : tol2;\n  var p0 = [];\n  var p1 = [];\n  for (var i = 0; i < vertices.length;) {\n    // Check coincidence to polygon vertices\n    p0[0] = vertices[i++];\n    p0[1] = vertices[i++];\n    p0[2] = vertices[i++];\n    if (distance2BetweenPoints(point, p0) <= tol2) {\n      return PolygonWithPointIntersectionState.INSIDE;\n    } // Check coincidence to polygon edges\n\n    var _vtkLine$distanceToLi = vtkLine.distanceToLine(point, p0, p1),\n      distance = _vtkLine$distanceToLi.distance,\n      t = _vtkLine$distanceToLi.t;\n    if (distance <= tol2 && t > 0.0 && t < 1.0) {\n      return PolygonWithPointIntersectionState.INSIDE;\n    }\n  } // If here, begin computation of the winding number. This method works for\n  // points/polygons arbitrarily oriented in 3D space.  Hence a projection\n  // onto one of the x-y-z coordinate planes using the maximum normal\n  // component. The computation will be performed in the (axis0, axis1) plane.\n\n  var axis0;\n  var axis1;\n  if (Math.abs(normal[0]) > Math.abs(normal[1])) {\n    if (Math.abs(normal[0]) > Math.abs(normal[2])) {\n      axis0 = 1;\n      axis1 = 2;\n    } else {\n      axis0 = 0;\n      axis1 = 1;\n    }\n  } else if (Math.abs(normal[1]) > Math.abs(normal[2])) {\n    axis0 = 0;\n    axis1 = 2;\n  } else {\n    axis0 = 0;\n    axis1 = 1;\n  } // Compute the winding number wn. If after processing all polygon edges\n  // wn == 0, then the point is outside.  Otherwise, the point is inside the\n  // polygon. Process all polygon edges determining if there are ascending or\n  // descending crossings of the line axis1=constant.\n\n  var wn = 0;\n  for (var _i = 0; _i < vertices.length;) {\n    p0[0] = vertices[_i++];\n    p0[1] = vertices[_i++];\n    p0[2] = vertices[_i++];\n    if (_i < vertices.length) {\n      p1[0] = vertices[_i];\n      p1[1] = vertices[_i + 1];\n      p1[2] = vertices[_i + 2];\n    } else {\n      p1[0] = vertices[0];\n      p1[1] = vertices[1];\n      p1[2] = vertices[2];\n    }\n    if (p0[axis1] <= point[axis1]) {\n      if (p1[axis1] > point[axis1]) {\n        // if an upward crossing\n        if (pointLocation(axis0, axis1, p0, p1, point) > 0) {\n          // if x left of edge\n          ++wn; // a valid up intersect, increment the winding number\n        }\n      }\n    } else if (p1[axis1] <= point[axis1]) {\n      // if a downward crossing\n      if (pointLocation(axis0, axis1, p0, p1, point) < 0) {\n        // if x right of edge\n        --wn; // a valid down intersect, decrement the winding number\n      }\n    }\n  } // Over all polygon edges\n  // A winding number == 0 is outside the polygon\n\n  return wn === 0 ? PolygonWithPointIntersectionState.OUTSIDE : PolygonWithPointIntersectionState.INSIDE;\n} // ---------------------------------------------------\n\n/**\n * Simple utility method for computing polygon bounds.\n * Returns the sum of the squares of the dimensions.\n * Requires a poly with at least one point.\n *\n * @param {Array<Number>|TypedArray<Number>} poly\n * @param {vtkPoints} points\n * @param {Bound} bounds\n */\n\nfunction getBounds(poly, points, bounds) {\n  var n = poly.length;\n  var p = [];\n  points.getPoint(poly[0], p);\n  bounds[0] = p[0];\n  bounds[1] = p[0];\n  bounds[2] = p[1];\n  bounds[3] = p[1];\n  bounds[4] = p[2];\n  bounds[5] = p[2];\n  for (var j = 1; j < n; j++) {\n    points.getPoint(poly[j], p);\n    vtkBoundingBox.addPoint.apply(vtkBoundingBox, [bounds].concat(p));\n  }\n  var length = vtkBoundingBox.getLengths(bounds);\n  return dot(length, length);\n} // ---------------------------------------------------\n\n/**\n * Compute the normal of a polygon and return its norm.\n *\n * TBD: This does the same thing as vtkPolygon.computeNormal,\n * but in a more generic way. Maybe we can keep the public\n * static method somehow and have the private method use it instead.\n *\n * @param {Array<Number>|TypedArray<Number>} poly\n * @param {vtkPoints} points\n * @param {Vector3} normal\n * @returns {Number}\n */\n\nfunction getNormal(poly, points, normal) {\n  normal.length = 3;\n  normal[0] = 0.0;\n  normal[1] = 0.0;\n  normal[2] = 0.0;\n  var p0 = [];\n  var p1 = [];\n  var p2 = [];\n  var v1 = [];\n  var v2 = [];\n  points.getPoint(poly[0], p0);\n  points.getPoint(poly[1], p1);\n  for (var j = 2; j < poly.length; j++) {\n    points.getPoint(poly[j], p2);\n    subtract(p2, p1, v1);\n    subtract(p0, p1, v2);\n    var n = [0, 0, 0];\n    cross(v1, v2, n);\n    add(normal, n, normal);\n    var _ref = [p2, p1];\n    p1 = _ref[0];\n    p2 = _ref[1];\n  }\n  return normalize(normal);\n} // ----------------------------------------------------------------------------\n// Static API\n// ----------------------------------------------------------------------------\n\nvar STATIC = {\n  PolygonWithPointIntersectionState: PolygonWithPointIntersectionState,\n  pointInPolygon: pointInPolygon,\n  getBounds: getBounds,\n  getNormal: getNormal\n}; // ----------------------------------------------------------------------------\n// vtkPolygon methods\n// ----------------------------------------------------------------------------\n\nfunction vtkPolygon(publicAPI, model) {\n  // Set our classname\n  model.classHierarchy.push('vtkPolygon');\n  function computeNormal() {\n    var v1 = [0, 0, 0];\n    var v2 = [0, 0, 0];\n    model.normal = [0, 0, 0];\n    var anchor = _toConsumableArray(model.firstPoint.point);\n    var point = model.firstPoint;\n    for (var i = 0; i < model.pointCount; i++) {\n      subtract(point.point, anchor, v1);\n      subtract(point.next.point, anchor, v2);\n      var n = [0, 0, 0];\n      cross(v1, v2, n);\n      add(model.normal, n, model.normal);\n      point = point.next;\n    }\n    return normalize(model.normal);\n  }\n  function computeMeasure(point) {\n    var v1 = [0, 0, 0];\n    var v2 = [0, 0, 0];\n    var v3 = [0, 0, 0];\n    var v4 = [0, 0, 0];\n    subtract(point.point, point.previous.point, v1);\n    subtract(point.next.point, point.point, v2);\n    subtract(point.previous.point, point.next.point, v3);\n    cross(v1, v2, v4);\n    var area = dot(v4, model.normal);\n    if (area <= 0) {\n      return -1;\n    }\n    var perimeter = norm(v1) + norm(v2) + norm(v3);\n    return perimeter * perimeter / area;\n  }\n  function canRemoveVertex(point) {\n    if (model.pointCount <= 3) {\n      return true;\n    }\n    var previous = point.previous;\n    var next = point.next;\n    var v = [0, 0, 0];\n    subtract(next.point, previous.point, v);\n    var sN = [0, 0, 0];\n    cross(v, model.normal, sN);\n    normalize(sN);\n    if (norm(sN) === 0) {\n      return false;\n    }\n    var val = vtkPlane.evaluate(sN, previous.point, next.next.point); // eslint-disable-next-line no-nested-ternary\n\n    var currentSign = val > EPSILON ? 1 : val < -EPSILON ? -1 : 0;\n    var oneNegative = currentSign < 0 ? 1 : 0;\n    for (var vertex = next.next.next; vertex.id !== previous.id; vertex = vertex.next) {\n      var previousVertex = vertex.previous;\n      val = vtkPlane.evaluate(sN, previous.point, vertex.point); // eslint-disable-next-line no-nested-ternary\n\n      var sign = val > EPSILON ? 1 : val < -EPSILON ? -1 : 0;\n      if (sign !== currentSign) {\n        if (!oneNegative) {\n          oneNegative = sign <= 0 ? 1 : 0;\n        }\n        if (vtkLine.intersection(previous.point, next.point, vertex.point, previousVertex.point, [0], [0]) === IntersectionState.YES_INTERSECTION) {\n          return false;\n        }\n        currentSign = sign;\n      }\n    }\n    return oneNegative === 1;\n  }\n  function removePoint(point, queue) {\n    model.pointCount -= 1;\n    var previous = point.previous;\n    var next = point.next;\n    model.tris = model.tris.concat(point.point);\n    model.tris = model.tris.concat(next.point);\n    model.tris = model.tris.concat(previous.point);\n    previous.next = next;\n    next.previous = previous;\n    queue.deleteById(previous.id);\n    queue.deleteById(next.id);\n    var previousMeasure = computeMeasure(previous);\n    if (previousMeasure > 0) {\n      queue.push(previousMeasure, previous);\n    }\n    var nextMeasure = computeMeasure(next);\n    if (nextMeasure > 0) {\n      queue.push(nextMeasure, next);\n    }\n    if (point.id === model.firstPoint.id) {\n      model.firstPoint = next;\n    }\n  }\n  function earCutTriangulation() {\n    computeNormal();\n    var vertexQueue = vtkPriorityQueue.newInstance();\n    var point = model.firstPoint;\n    for (var i = 0; i < model.pointCount; i++) {\n      var measure = computeMeasure(point);\n      if (measure > 0) {\n        vertexQueue.push(measure, point);\n      }\n      point = point.next;\n    }\n    while (model.pointCount > 2 && vertexQueue.length() > 0) {\n      if (model.pointCount === vertexQueue.length()) {\n        // convex\n        var pointToRemove = vertexQueue.pop();\n        removePoint(pointToRemove, vertexQueue);\n      } else {\n        // concave\n        var _pointToRemove = vertexQueue.pop();\n        if (canRemoveVertex(_pointToRemove)) {\n          removePoint(_pointToRemove, vertexQueue);\n        }\n      }\n    }\n    return model.pointCount <= 2;\n  }\n  publicAPI.triangulate = function () {\n    if (!model.firstPoint) {\n      return null;\n    }\n    return earCutTriangulation();\n  };\n  publicAPI.setPoints = function (points) {\n    model.pointCount = points.length;\n    model.firstPoint = {\n      id: 0,\n      point: points[0],\n      next: null,\n      previous: null\n    };\n    var currentPoint = model.firstPoint;\n    for (var i = 1; i < model.pointCount; i++) {\n      currentPoint.next = {\n        id: i,\n        point: points[i],\n        next: null,\n        previous: currentPoint\n      };\n      currentPoint = currentPoint.next;\n    }\n    model.firstPoint.previous = currentPoint;\n    currentPoint.next = model.firstPoint;\n  };\n  publicAPI.getPointArray = function () {\n    return model.tris;\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nvar DEFAULT_VALUES = {\n  firstPoint: null,\n  pointCount: 0,\n  tris: []\n}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Build VTK API\n\n  macro.obj(publicAPI, model);\n  vtkPolygon(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = macro.newInstance(extend, 'vtkPolygon'); // ----------------------------------------------------------------------------\n\nvar vtkPolygon$1 = _objectSpread({\n  newInstance: newInstance,\n  extend: extend\n}, STATIC);\nexport { vtkPolygon$1 as default, extend, getBounds, getNormal, newInstance };","map":{"version":3,"names":["_defineProperty","_toConsumableArray","macro","d","dot","s","subtract","j","cross","k","add","l","normalize","e","distance2BetweenPoints","n","norm","vtkLine","vtkPlane","vtkPriorityQueue","vtkBoundingBox","IntersectionState","PolygonWithPointIntersectionState","FLOAT_EPSILON","TOLERANCE","EPSILON","ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","getOwnPropertyDescriptors","defineProperties","defineProperty","pointLocation","axis0","axis1","p0","p1","point","pointInPolygon","vertices","bounds","normal","OUTSIDE","FAILURE","tol2","INSIDE","_vtkLine$distanceToLi","distanceToLine","distance","t","Math","abs","wn","_i","getBounds","poly","points","p","getPoint","addPoint","concat","getLengths","getNormal","p2","v1","v2","_ref","STATIC","vtkPolygon","publicAPI","model","classHierarchy","computeNormal","anchor","firstPoint","pointCount","next","computeMeasure","v3","v4","previous","area","perimeter","canRemoveVertex","v","sN","val","evaluate","currentSign","oneNegative","vertex","id","previousVertex","sign","intersection","YES_INTERSECTION","removePoint","queue","tris","deleteById","previousMeasure","nextMeasure","earCutTriangulation","vertexQueue","newInstance","measure","pointToRemove","pop","_pointToRemove","triangulate","setPoints","currentPoint","getPointArray","DEFAULT_VALUES","extend","initialValues","undefined","assign","obj","vtkPolygon$1","default"],"sources":["/home/rakshith/Documents/RemoteRendering/vtk-js-react-app/node_modules/@kitware/vtk.js/Common/DataModel/Polygon.js"],"sourcesContent":["import _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport _toConsumableArray from '@babel/runtime/helpers/toConsumableArray';\nimport macro from '../../macros.js';\nimport { d as dot, s as subtract, j as cross, k as add, l as normalize, e as distance2BetweenPoints, n as norm } from '../Core/Math/index.js';\nimport vtkLine from './Line.js';\nimport vtkPlane from './Plane.js';\nimport vtkPriorityQueue from '../Core/PriorityQueue.js';\nimport vtkBoundingBox from './BoundingBox.js';\nimport { IntersectionState } from './Line/Constants.js';\nimport { PolygonWithPointIntersectionState, FLOAT_EPSILON, TOLERANCE, EPSILON } from './Polygon/Constants.js';\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n// Global methods\n// ----------------------------------------------------------------------------\n// Given the line (p0,p1), determine if the given point is located to the left\n// of, on, or to the right of a line (with the function returning >0, ==0, or\n// <0 respectively). The points are assumed 3D points, but projected into\n// one of x-y-z planes; hence the indices axis0 and axis1 specify which plane\n// the computation is to be performed on.\n\nfunction pointLocation(axis0, axis1, p0, p1, point) {\n  return (p1[axis0] - p0[axis0]) * (point[axis1] - p0[axis1]) - (point[axis0] - p0[axis0]) * (p1[axis1] - p0[axis1]);\n} //------------------------------------------------------------------------------\n\n\nfunction pointInPolygon(point, vertices, bounds, normal) {\n  // Do a quick bounds check to throw out trivial cases.\n  // winding plane.\n  if (point[0] < bounds[0] || point[0] > bounds[1] || point[1] < bounds[2] || point[1] > bounds[3] || point[2] < bounds[4] || point[2] > bounds[5]) {\n    return PolygonWithPointIntersectionState.OUTSIDE;\n  } //  Check that the normal is non-zero.\n\n\n  if (normalize(normal) <= FLOAT_EPSILON) {\n    return PolygonWithPointIntersectionState.FAILURE;\n  } // Assess whether the point lies on the boundary of the polygon. Points on\n  // the boundary are considered inside the polygon. Need to define a small\n  // tolerance relative to the bounding box diagonal length of the polygon.\n\n\n  var tol2 = TOLERANCE * ((bounds[1] - bounds[0]) * (bounds[1] - bounds[0]) + (bounds[3] - bounds[2]) * (bounds[3] - bounds[2]) + (bounds[5] - bounds[4]) * (bounds[5] - bounds[4]));\n  tol2 *= tol2;\n  tol2 = tol2 === 0.0 ? FLOAT_EPSILON : tol2;\n  var p0 = [];\n  var p1 = [];\n\n  for (var i = 0; i < vertices.length;) {\n    // Check coincidence to polygon vertices\n    p0[0] = vertices[i++];\n    p0[1] = vertices[i++];\n    p0[2] = vertices[i++];\n\n    if (distance2BetweenPoints(point, p0) <= tol2) {\n      return PolygonWithPointIntersectionState.INSIDE;\n    } // Check coincidence to polygon edges\n\n\n    var _vtkLine$distanceToLi = vtkLine.distanceToLine(point, p0, p1),\n        distance = _vtkLine$distanceToLi.distance,\n        t = _vtkLine$distanceToLi.t;\n\n    if (distance <= tol2 && t > 0.0 && t < 1.0) {\n      return PolygonWithPointIntersectionState.INSIDE;\n    }\n  } // If here, begin computation of the winding number. This method works for\n  // points/polygons arbitrarily oriented in 3D space.  Hence a projection\n  // onto one of the x-y-z coordinate planes using the maximum normal\n  // component. The computation will be performed in the (axis0, axis1) plane.\n\n\n  var axis0;\n  var axis1;\n\n  if (Math.abs(normal[0]) > Math.abs(normal[1])) {\n    if (Math.abs(normal[0]) > Math.abs(normal[2])) {\n      axis0 = 1;\n      axis1 = 2;\n    } else {\n      axis0 = 0;\n      axis1 = 1;\n    }\n  } else if (Math.abs(normal[1]) > Math.abs(normal[2])) {\n    axis0 = 0;\n    axis1 = 2;\n  } else {\n    axis0 = 0;\n    axis1 = 1;\n  } // Compute the winding number wn. If after processing all polygon edges\n  // wn == 0, then the point is outside.  Otherwise, the point is inside the\n  // polygon. Process all polygon edges determining if there are ascending or\n  // descending crossings of the line axis1=constant.\n\n\n  var wn = 0;\n\n  for (var _i = 0; _i < vertices.length;) {\n    p0[0] = vertices[_i++];\n    p0[1] = vertices[_i++];\n    p0[2] = vertices[_i++];\n\n    if (_i < vertices.length) {\n      p1[0] = vertices[_i];\n      p1[1] = vertices[_i + 1];\n      p1[2] = vertices[_i + 2];\n    } else {\n      p1[0] = vertices[0];\n      p1[1] = vertices[1];\n      p1[2] = vertices[2];\n    }\n\n    if (p0[axis1] <= point[axis1]) {\n      if (p1[axis1] > point[axis1]) {\n        // if an upward crossing\n        if (pointLocation(axis0, axis1, p0, p1, point) > 0) {\n          // if x left of edge\n          ++wn; // a valid up intersect, increment the winding number\n        }\n      }\n    } else if (p1[axis1] <= point[axis1]) {\n      // if a downward crossing\n      if (pointLocation(axis0, axis1, p0, p1, point) < 0) {\n        // if x right of edge\n        --wn; // a valid down intersect, decrement the winding number\n      }\n    }\n  } // Over all polygon edges\n  // A winding number == 0 is outside the polygon\n\n\n  return wn === 0 ? PolygonWithPointIntersectionState.OUTSIDE : PolygonWithPointIntersectionState.INSIDE;\n} // ---------------------------------------------------\n\n/**\n * Simple utility method for computing polygon bounds.\n * Returns the sum of the squares of the dimensions.\n * Requires a poly with at least one point.\n *\n * @param {Array<Number>|TypedArray<Number>} poly\n * @param {vtkPoints} points\n * @param {Bound} bounds\n */\n\n\nfunction getBounds(poly, points, bounds) {\n  var n = poly.length;\n  var p = [];\n  points.getPoint(poly[0], p);\n  bounds[0] = p[0];\n  bounds[1] = p[0];\n  bounds[2] = p[1];\n  bounds[3] = p[1];\n  bounds[4] = p[2];\n  bounds[5] = p[2];\n\n  for (var j = 1; j < n; j++) {\n    points.getPoint(poly[j], p);\n    vtkBoundingBox.addPoint.apply(vtkBoundingBox, [bounds].concat(p));\n  }\n\n  var length = vtkBoundingBox.getLengths(bounds);\n  return dot(length, length);\n} // ---------------------------------------------------\n\n/**\n * Compute the normal of a polygon and return its norm.\n *\n * TBD: This does the same thing as vtkPolygon.computeNormal,\n * but in a more generic way. Maybe we can keep the public\n * static method somehow and have the private method use it instead.\n *\n * @param {Array<Number>|TypedArray<Number>} poly\n * @param {vtkPoints} points\n * @param {Vector3} normal\n * @returns {Number}\n */\n\nfunction getNormal(poly, points, normal) {\n  normal.length = 3;\n  normal[0] = 0.0;\n  normal[1] = 0.0;\n  normal[2] = 0.0;\n  var p0 = [];\n  var p1 = [];\n  var p2 = [];\n  var v1 = [];\n  var v2 = [];\n  points.getPoint(poly[0], p0);\n  points.getPoint(poly[1], p1);\n\n  for (var j = 2; j < poly.length; j++) {\n    points.getPoint(poly[j], p2);\n    subtract(p2, p1, v1);\n    subtract(p0, p1, v2);\n    var n = [0, 0, 0];\n    cross(v1, v2, n);\n    add(normal, n, normal);\n    var _ref = [p2, p1];\n    p1 = _ref[0];\n    p2 = _ref[1];\n  }\n\n  return normalize(normal);\n} // ----------------------------------------------------------------------------\n// Static API\n// ----------------------------------------------------------------------------\n\nvar STATIC = {\n  PolygonWithPointIntersectionState: PolygonWithPointIntersectionState,\n  pointInPolygon: pointInPolygon,\n  getBounds: getBounds,\n  getNormal: getNormal\n}; // ----------------------------------------------------------------------------\n// vtkPolygon methods\n// ----------------------------------------------------------------------------\n\nfunction vtkPolygon(publicAPI, model) {\n  // Set our classname\n  model.classHierarchy.push('vtkPolygon');\n\n  function computeNormal() {\n    var v1 = [0, 0, 0];\n    var v2 = [0, 0, 0];\n    model.normal = [0, 0, 0];\n\n    var anchor = _toConsumableArray(model.firstPoint.point);\n\n    var point = model.firstPoint;\n\n    for (var i = 0; i < model.pointCount; i++) {\n      subtract(point.point, anchor, v1);\n      subtract(point.next.point, anchor, v2);\n      var n = [0, 0, 0];\n      cross(v1, v2, n);\n      add(model.normal, n, model.normal);\n      point = point.next;\n    }\n\n    return normalize(model.normal);\n  }\n\n  function computeMeasure(point) {\n    var v1 = [0, 0, 0];\n    var v2 = [0, 0, 0];\n    var v3 = [0, 0, 0];\n    var v4 = [0, 0, 0];\n    subtract(point.point, point.previous.point, v1);\n    subtract(point.next.point, point.point, v2);\n    subtract(point.previous.point, point.next.point, v3);\n    cross(v1, v2, v4);\n    var area = dot(v4, model.normal);\n\n    if (area <= 0) {\n      return -1;\n    }\n\n    var perimeter = norm(v1) + norm(v2) + norm(v3);\n    return perimeter * perimeter / area;\n  }\n\n  function canRemoveVertex(point) {\n    if (model.pointCount <= 3) {\n      return true;\n    }\n\n    var previous = point.previous;\n    var next = point.next;\n    var v = [0, 0, 0];\n    subtract(next.point, previous.point, v);\n    var sN = [0, 0, 0];\n    cross(v, model.normal, sN);\n    normalize(sN);\n\n    if (norm(sN) === 0) {\n      return false;\n    }\n\n    var val = vtkPlane.evaluate(sN, previous.point, next.next.point); // eslint-disable-next-line no-nested-ternary\n\n    var currentSign = val > EPSILON ? 1 : val < -EPSILON ? -1 : 0;\n    var oneNegative = currentSign < 0 ? 1 : 0;\n\n    for (var vertex = next.next.next; vertex.id !== previous.id; vertex = vertex.next) {\n      var previousVertex = vertex.previous;\n      val = vtkPlane.evaluate(sN, previous.point, vertex.point); // eslint-disable-next-line no-nested-ternary\n\n      var sign = val > EPSILON ? 1 : val < -EPSILON ? -1 : 0;\n\n      if (sign !== currentSign) {\n        if (!oneNegative) {\n          oneNegative = sign <= 0 ? 1 : 0;\n        }\n\n        if (vtkLine.intersection(previous.point, next.point, vertex.point, previousVertex.point, [0], [0]) === IntersectionState.YES_INTERSECTION) {\n          return false;\n        }\n\n        currentSign = sign;\n      }\n    }\n\n    return oneNegative === 1;\n  }\n\n  function removePoint(point, queue) {\n    model.pointCount -= 1;\n    var previous = point.previous;\n    var next = point.next;\n    model.tris = model.tris.concat(point.point);\n    model.tris = model.tris.concat(next.point);\n    model.tris = model.tris.concat(previous.point);\n    previous.next = next;\n    next.previous = previous;\n    queue.deleteById(previous.id);\n    queue.deleteById(next.id);\n    var previousMeasure = computeMeasure(previous);\n\n    if (previousMeasure > 0) {\n      queue.push(previousMeasure, previous);\n    }\n\n    var nextMeasure = computeMeasure(next);\n\n    if (nextMeasure > 0) {\n      queue.push(nextMeasure, next);\n    }\n\n    if (point.id === model.firstPoint.id) {\n      model.firstPoint = next;\n    }\n  }\n\n  function earCutTriangulation() {\n    computeNormal();\n    var vertexQueue = vtkPriorityQueue.newInstance();\n    var point = model.firstPoint;\n\n    for (var i = 0; i < model.pointCount; i++) {\n      var measure = computeMeasure(point);\n\n      if (measure > 0) {\n        vertexQueue.push(measure, point);\n      }\n\n      point = point.next;\n    }\n\n    while (model.pointCount > 2 && vertexQueue.length() > 0) {\n      if (model.pointCount === vertexQueue.length()) {\n        // convex\n        var pointToRemove = vertexQueue.pop();\n        removePoint(pointToRemove, vertexQueue);\n      } else {\n        // concave\n        var _pointToRemove = vertexQueue.pop();\n\n        if (canRemoveVertex(_pointToRemove)) {\n          removePoint(_pointToRemove, vertexQueue);\n        }\n      }\n    }\n\n    return model.pointCount <= 2;\n  }\n\n  publicAPI.triangulate = function () {\n    if (!model.firstPoint) {\n      return null;\n    }\n\n    return earCutTriangulation();\n  };\n\n  publicAPI.setPoints = function (points) {\n    model.pointCount = points.length;\n    model.firstPoint = {\n      id: 0,\n      point: points[0],\n      next: null,\n      previous: null\n    };\n    var currentPoint = model.firstPoint;\n\n    for (var i = 1; i < model.pointCount; i++) {\n      currentPoint.next = {\n        id: i,\n        point: points[i],\n        next: null,\n        previous: currentPoint\n      };\n      currentPoint = currentPoint.next;\n    }\n\n    model.firstPoint.previous = currentPoint;\n    currentPoint.next = model.firstPoint;\n  };\n\n  publicAPI.getPointArray = function () {\n    return model.tris;\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\n\nvar DEFAULT_VALUES = {\n  firstPoint: null,\n  pointCount: 0,\n  tris: []\n}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Build VTK API\n\n  macro.obj(publicAPI, model);\n  vtkPolygon(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = macro.newInstance(extend, 'vtkPolygon'); // ----------------------------------------------------------------------------\n\nvar vtkPolygon$1 = _objectSpread({\n  newInstance: newInstance,\n  extend: extend\n}, STATIC);\n\nexport { vtkPolygon$1 as default, extend, getBounds, getNormal, newInstance };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}