{"ast":null,"code":"import macro from '../../macros.js';\nimport vtkActor from '../../Rendering/Core/Actor.js';\nimport vtkGlyphRepresentation from './GlyphRepresentation.js';\nimport vtkPixelSpaceCallbackMapper from '../../Rendering/Core/PixelSpaceCallbackMapper.js';\n\n// vtkSphereHandleRepresentation methods\n// ----------------------------------------------------------------------------\n\nfunction vtkSphereHandleRepresentation(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkSphereHandleRepresentation'); // --------------------------------------------------------------------------\n  // Generic rendering pipeline\n  // --------------------------------------------------------------------------\n\n  /*\n   * displayActors and displayMappers are used to render objects in HTML, allowing objects\n   * to be 'rendered' internally in a VTK scene without being visible on the final output\n   */\n\n  model.displayMapper = vtkPixelSpaceCallbackMapper.newInstance();\n  model.displayActor = vtkActor.newInstance({\n    parentProp: publicAPI\n  }); // model.displayActor.getProperty().setOpacity(0); // don't show in 3D\n\n  model.displayActor.setMapper(model.displayMapper);\n  model.displayMapper.setInputConnection(publicAPI.getOutputPort());\n  publicAPI.addActor(model.displayActor);\n  model.alwaysVisibleActors = [model.displayActor]; // --------------------------------------------------------------------------\n\n  publicAPI.getGlyphResolution = function () {\n    return model._pipeline.glyph.getPhiResolution();\n  };\n  publicAPI.setGlyphResolution = function (resolution) {\n    return model._pipeline.glyph.setPhiResolution(resolution) || model._pipeline.glyph.setThetaResolution(resolution);\n  }; // --------------------------------------------------------------------------\n\n  function callbackProxy(coords) {\n    if (model.displayCallback) {\n      var filteredList = [];\n      var states = publicAPI.getRepresentationStates();\n      for (var i = 0; i < states.length; i++) {\n        if (states[i].getActive()) {\n          filteredList.push(coords[i]);\n        }\n      }\n      if (filteredList.length) {\n        model.displayCallback(filteredList);\n        return;\n      }\n    }\n    model.displayCallback();\n  }\n  publicAPI.setDisplayCallback = function (callback) {\n    model.displayCallback = callback;\n    model.displayMapper.setCallback(callback ? callbackProxy : null);\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  vtkGlyphRepresentation.extend(publicAPI, model, initialValues); // Object specific methods\n\n  vtkSphereHandleRepresentation(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = macro.newInstance(extend, 'vtkSphereHandleRepresentation'); // ----------------------------------------------------------------------------\n\nvar vtkSphereHandleRepresentation$1 = {\n  newInstance: newInstance,\n  extend: extend\n};\nexport { vtkSphereHandleRepresentation$1 as default, extend, newInstance };","map":{"version":3,"names":["macro","vtkActor","vtkGlyphRepresentation","vtkPixelSpaceCallbackMapper","vtkSphereHandleRepresentation","publicAPI","model","classHierarchy","push","displayMapper","newInstance","displayActor","parentProp","setMapper","setInputConnection","getOutputPort","addActor","alwaysVisibleActors","getGlyphResolution","_pipeline","glyph","getPhiResolution","setGlyphResolution","resolution","setPhiResolution","setThetaResolution","callbackProxy","coords","displayCallback","filteredList","states","getRepresentationStates","i","length","getActive","setDisplayCallback","callback","setCallback","extend","initialValues","arguments","undefined","vtkSphereHandleRepresentation$1","default"],"sources":["/home/rakshith/Documents/RemoteRendering/vtk-js-react-app/node_modules/@kitware/vtk.js/Widgets/Representations/SphereHandleRepresentation.js"],"sourcesContent":["import macro from '../../macros.js';\nimport vtkActor from '../../Rendering/Core/Actor.js';\nimport vtkGlyphRepresentation from './GlyphRepresentation.js';\nimport vtkPixelSpaceCallbackMapper from '../../Rendering/Core/PixelSpaceCallbackMapper.js';\n\n// vtkSphereHandleRepresentation methods\n// ----------------------------------------------------------------------------\n\nfunction vtkSphereHandleRepresentation(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkSphereHandleRepresentation'); // --------------------------------------------------------------------------\n  // Generic rendering pipeline\n  // --------------------------------------------------------------------------\n\n  /*\n   * displayActors and displayMappers are used to render objects in HTML, allowing objects\n   * to be 'rendered' internally in a VTK scene without being visible on the final output\n   */\n\n  model.displayMapper = vtkPixelSpaceCallbackMapper.newInstance();\n  model.displayActor = vtkActor.newInstance({\n    parentProp: publicAPI\n  }); // model.displayActor.getProperty().setOpacity(0); // don't show in 3D\n\n  model.displayActor.setMapper(model.displayMapper);\n  model.displayMapper.setInputConnection(publicAPI.getOutputPort());\n  publicAPI.addActor(model.displayActor);\n  model.alwaysVisibleActors = [model.displayActor]; // --------------------------------------------------------------------------\n\n  publicAPI.getGlyphResolution = function () {\n    return model._pipeline.glyph.getPhiResolution();\n  };\n\n  publicAPI.setGlyphResolution = function (resolution) {\n    return model._pipeline.glyph.setPhiResolution(resolution) || model._pipeline.glyph.setThetaResolution(resolution);\n  }; // --------------------------------------------------------------------------\n\n\n  function callbackProxy(coords) {\n    if (model.displayCallback) {\n      var filteredList = [];\n      var states = publicAPI.getRepresentationStates();\n\n      for (var i = 0; i < states.length; i++) {\n        if (states[i].getActive()) {\n          filteredList.push(coords[i]);\n        }\n      }\n\n      if (filteredList.length) {\n        model.displayCallback(filteredList);\n        return;\n      }\n    }\n\n    model.displayCallback();\n  }\n\n  publicAPI.setDisplayCallback = function (callback) {\n    model.displayCallback = callback;\n    model.displayMapper.setCallback(callback ? callbackProxy : null);\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n// ----------------------------------------------------------------------------\n\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  vtkGlyphRepresentation.extend(publicAPI, model, initialValues); // Object specific methods\n\n  vtkSphereHandleRepresentation(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = macro.newInstance(extend, 'vtkSphereHandleRepresentation'); // ----------------------------------------------------------------------------\n\nvar vtkSphereHandleRepresentation$1 = {\n  newInstance: newInstance,\n  extend: extend\n};\n\nexport { vtkSphereHandleRepresentation$1 as default, extend, newInstance };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}