{"ast":null,"code":"import _toConsumableArray from '@babel/runtime/helpers/toConsumableArray';\nimport macro from '../../macros.js';\nimport vtkPolygon from '../../Common/DataModel/Polygon.js';\nimport vtkPolyData from '../../Common/DataModel/PolyData.js';\nvar vtkWarningMacro = macro.vtkWarningMacro; // ----------------------------------------------------------------------------\n// vtkTriangleFilter methods\n// ----------------------------------------------------------------------------\n\nfunction vtkTriangleFilter(publicAPI, model) {\n  // Set our classname\n  model.classHierarchy.push('vtkTriangleFilter'); // requestData only supports polys for now.\n\n  publicAPI.requestData = function (inData, outData) {\n    var input = inData[0];\n    var points = input.getPoints().getData();\n    var polys = input.getPolys().getData();\n    var cellsDataType = input.getPolys().getDataType();\n    var pointsDataType = input.getPoints().getDataType(); // Todo: instantiate TypedArray of the final size\n\n    var newCells = [];\n    var newPoints = [];\n    model.errorCount = 0;\n    if (polys) {\n      var npts = 0;\n      var isLastPointDuplicated = false;\n      for (var c = 0; c < polys.length; c += npts + 1) {\n        npts = polys[c]; // If the first point is duplicated at the end of the cell, ignore it\n\n        isLastPointDuplicated = polys[c + 1] === polys[c + npts];\n        if (isLastPointDuplicated) {\n          --npts;\n        } // We can't use cell.map here, it doesn't seems to work properly with Uint32Arrays ...\n\n        var cellPoints = [];\n        cellPoints.length = npts;\n        for (var i = 0; i < npts; i++) {\n          var pointId = polys[c + i + 1];\n          cellPoints[i] = [points[3 * pointId], points[3 * pointId + 1], points[3 * pointId + 2]];\n        }\n        if (npts === 3) {\n          var newIdStart = newPoints.length / 3;\n          newCells.push(3, newIdStart, newIdStart + 1, newIdStart + 2);\n          newPoints.push.apply(newPoints, _toConsumableArray(cellPoints[0]).concat(_toConsumableArray(cellPoints[1]), _toConsumableArray(cellPoints[2])));\n        } else if (npts > 3) {\n          var polygon = vtkPolygon.newInstance();\n          polygon.setPoints(cellPoints);\n          if (!polygon.triangulate()) {\n            vtkWarningMacro(\"Triangulation failed at cellOffset \".concat(c));\n            ++model.errorCount;\n          }\n          var newCellPoints = polygon.getPointArray();\n          var numSimplices = Math.floor(newCellPoints.length / 9);\n          var triPts = [];\n          triPts.length = 9;\n          for (var _i = 0; _i < numSimplices; _i++) {\n            for (var j = 0; j < 9; j++) {\n              triPts[j] = newCellPoints[9 * _i + j];\n            }\n            var _newIdStart = newPoints.length / 3;\n            newCells.push(3, _newIdStart, _newIdStart + 1, _newIdStart + 2);\n            newPoints.push.apply(newPoints, triPts);\n          }\n        }\n        if (isLastPointDuplicated) {\n          ++npts;\n        }\n      }\n    }\n    var dataset = vtkPolyData.newInstance();\n    dataset.getPoints().setData(macro.newTypedArrayFrom(pointsDataType, newPoints));\n    dataset.getPolys().setData(macro.newTypedArrayFrom(cellsDataType, newCells));\n    outData[0] = dataset;\n  };\n} // ----------------------------------------------------------------------------\n\nvar DEFAULT_VALUES = {\n  errorCount: 0\n}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Build VTK API\n\n  macro.setGet(publicAPI, model, []);\n  macro.get(publicAPI, model, ['errorCount']); // Make this a VTK object\n\n  macro.obj(publicAPI, model); // Also make it an algorithm with one input and one output\n\n  macro.algo(publicAPI, model, 1, 1); // Object specific methods\n\n  vtkTriangleFilter(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = macro.newInstance(extend, 'vtkTriangleFilter'); // ----------------------------------------------------------------------------\n\nvar vtkTriangleFilter$1 = {\n  newInstance: newInstance,\n  extend: extend\n};\nexport { vtkTriangleFilter$1 as default, extend, newInstance };","map":{"version":3,"names":["_toConsumableArray","macro","vtkPolygon","vtkPolyData","vtkWarningMacro","vtkTriangleFilter","publicAPI","model","classHierarchy","push","requestData","inData","outData","input","points","getPoints","getData","polys","getPolys","cellsDataType","getDataType","pointsDataType","newCells","newPoints","errorCount","npts","isLastPointDuplicated","c","length","cellPoints","i","pointId","newIdStart","apply","concat","polygon","newInstance","setPoints","triangulate","newCellPoints","getPointArray","numSimplices","Math","floor","triPts","_i","j","_newIdStart","dataset","setData","newTypedArrayFrom","DEFAULT_VALUES","extend","initialValues","arguments","undefined","Object","assign","setGet","get","obj","algo","vtkTriangleFilter$1","default"],"sources":["/home/rakshith/Documents/RemoteRendering/vtk-js-react-app/node_modules/@kitware/vtk.js/Filters/General/TriangleFilter.js"],"sourcesContent":["import _toConsumableArray from '@babel/runtime/helpers/toConsumableArray';\nimport macro from '../../macros.js';\nimport vtkPolygon from '../../Common/DataModel/Polygon.js';\nimport vtkPolyData from '../../Common/DataModel/PolyData.js';\n\nvar vtkWarningMacro = macro.vtkWarningMacro; // ----------------------------------------------------------------------------\n// vtkTriangleFilter methods\n// ----------------------------------------------------------------------------\n\nfunction vtkTriangleFilter(publicAPI, model) {\n  // Set our classname\n  model.classHierarchy.push('vtkTriangleFilter'); // requestData only supports polys for now.\n\n  publicAPI.requestData = function (inData, outData) {\n    var input = inData[0];\n    var points = input.getPoints().getData();\n    var polys = input.getPolys().getData();\n    var cellsDataType = input.getPolys().getDataType();\n    var pointsDataType = input.getPoints().getDataType(); // Todo: instantiate TypedArray of the final size\n\n    var newCells = [];\n    var newPoints = [];\n    model.errorCount = 0;\n\n    if (polys) {\n      var npts = 0;\n      var isLastPointDuplicated = false;\n\n      for (var c = 0; c < polys.length; c += npts + 1) {\n        npts = polys[c]; // If the first point is duplicated at the end of the cell, ignore it\n\n        isLastPointDuplicated = polys[c + 1] === polys[c + npts];\n\n        if (isLastPointDuplicated) {\n          --npts;\n        } // We can't use cell.map here, it doesn't seems to work properly with Uint32Arrays ...\n\n\n        var cellPoints = [];\n        cellPoints.length = npts;\n\n        for (var i = 0; i < npts; i++) {\n          var pointId = polys[c + i + 1];\n          cellPoints[i] = [points[3 * pointId], points[3 * pointId + 1], points[3 * pointId + 2]];\n        }\n\n        if (npts === 3) {\n          var newIdStart = newPoints.length / 3;\n          newCells.push(3, newIdStart, newIdStart + 1, newIdStart + 2);\n          newPoints.push.apply(newPoints, _toConsumableArray(cellPoints[0]).concat(_toConsumableArray(cellPoints[1]), _toConsumableArray(cellPoints[2])));\n        } else if (npts > 3) {\n          var polygon = vtkPolygon.newInstance();\n          polygon.setPoints(cellPoints);\n\n          if (!polygon.triangulate()) {\n            vtkWarningMacro(\"Triangulation failed at cellOffset \".concat(c));\n            ++model.errorCount;\n          }\n\n          var newCellPoints = polygon.getPointArray();\n          var numSimplices = Math.floor(newCellPoints.length / 9);\n          var triPts = [];\n          triPts.length = 9;\n\n          for (var _i = 0; _i < numSimplices; _i++) {\n            for (var j = 0; j < 9; j++) {\n              triPts[j] = newCellPoints[9 * _i + j];\n            }\n\n            var _newIdStart = newPoints.length / 3;\n\n            newCells.push(3, _newIdStart, _newIdStart + 1, _newIdStart + 2);\n            newPoints.push.apply(newPoints, triPts);\n          }\n        }\n\n        if (isLastPointDuplicated) {\n          ++npts;\n        }\n      }\n    }\n\n    var dataset = vtkPolyData.newInstance();\n    dataset.getPoints().setData(macro.newTypedArrayFrom(pointsDataType, newPoints));\n    dataset.getPolys().setData(macro.newTypedArrayFrom(cellsDataType, newCells));\n    outData[0] = dataset;\n  };\n} // ----------------------------------------------------------------------------\n\n\nvar DEFAULT_VALUES = {\n  errorCount: 0\n}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Build VTK API\n\n  macro.setGet(publicAPI, model, []);\n  macro.get(publicAPI, model, ['errorCount']); // Make this a VTK object\n\n  macro.obj(publicAPI, model); // Also make it an algorithm with one input and one output\n\n  macro.algo(publicAPI, model, 1, 1); // Object specific methods\n\n  vtkTriangleFilter(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = macro.newInstance(extend, 'vtkTriangleFilter'); // ----------------------------------------------------------------------------\n\nvar vtkTriangleFilter$1 = {\n  newInstance: newInstance,\n  extend: extend\n};\n\nexport { vtkTriangleFilter$1 as default, extend, newInstance };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}