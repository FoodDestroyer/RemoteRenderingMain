{"ast":null,"code":"import _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport _toConsumableArray from '@babel/runtime/helpers/toConsumableArray';\nimport { mat3, mat4, vec3 } from 'gl-matrix';\nimport { newInstance as newInstance$1, setGet, obj, vtkErrorMacro as vtkErrorMacro$1 } from '../../macros.js';\nimport vtkHelper from './Helper.js';\nimport vtkMapper from '../Core/Mapper.js';\nimport { l as normalize, u as uninitializeBounds } from '../../Common/Core/Math/index.js';\nimport vtkOpenGLTexture from './Texture.js';\nimport vtkProp from '../Core/Prop.js';\nimport vtkProperty from '../Core/Property.js';\nimport vtkShaderProgram from './ShaderProgram.js';\nimport vtkViewNode from '../SceneGraph/ViewNode.js';\nimport { v as vtkPolyDataVS } from './glsl/vtkPolyDataVS.glsl.js';\nimport { v as vtkPolyDataFS } from './glsl/vtkPolyDataFS.glsl.js';\nimport vtkReplacementShaderMapper from './ReplacementShaderMapper.js';\nimport { registerOverride } from './ViewNodeFactory.js';\nimport { PassTypes } from './HardwareSelector/Constants.js';\nimport vtkDataSet from '../../Common/DataModel/DataSet.js';\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n  return target;\n}\nvar FieldAssociations = vtkDataSet.FieldAssociations;\n/* eslint-disable no-lonely-if */\n\nvar primTypes = vtkHelper.primTypes;\nvar Representation = vtkProperty.Representation,\n  Shading = vtkProperty.Shading;\nvar ScalarMode = vtkMapper.ScalarMode;\nvar Filter = vtkOpenGLTexture.Filter,\n  Wrap = vtkOpenGLTexture.Wrap;\nvar vtkErrorMacro = vtkErrorMacro$1;\nvar StartEvent = {\n  type: 'StartEvent'\n};\nvar EndEvent = {\n  type: 'EndEvent'\n};\nvar CoordinateSystem = vtkProp.CoordinateSystem; // ----------------------------------------------------------------------------\n// vtkOpenGLPolyDataMapper methods\n// ----------------------------------------------------------------------------\n\nfunction getPickState(renderer) {\n  var selector = renderer.getSelector();\n  if (selector) {\n    return selector.getCurrentPass();\n  }\n  return PassTypes.MIN_KNOWN_PASS - 1;\n}\nfunction vtkOpenGLPolyDataMapper(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkOpenGLPolyDataMapper');\n  publicAPI.buildPass = function (prepass) {\n    if (prepass) {\n      model.currentRenderPass = null;\n      model.openGLActor = publicAPI.getFirstAncestorOfType('vtkOpenGLActor');\n      model._openGLRenderer = model.openGLActor.getFirstAncestorOfType('vtkOpenGLRenderer');\n      model._openGLRenderWindow = model._openGLRenderer.getParent();\n      model.openGLCamera = model._openGLRenderer.getViewNodeFor(model._openGLRenderer.getRenderable().getActiveCamera());\n    }\n  }; // Renders myself\n\n  publicAPI.translucentPass = function (prepass, renderPass) {\n    if (prepass) {\n      model.currentRenderPass = renderPass;\n      publicAPI.render();\n    }\n  };\n  publicAPI.zBufferPass = function (prepass) {\n    if (prepass) {\n      model.haveSeenDepthRequest = true;\n      model.renderDepth = true;\n      publicAPI.render();\n      model.renderDepth = false;\n    }\n  };\n  publicAPI.opaqueZBufferPass = function (prepass) {\n    return publicAPI.zBufferPass(prepass);\n  };\n  publicAPI.opaquePass = function (prepass) {\n    if (prepass) {\n      publicAPI.render();\n    }\n  };\n  publicAPI.render = function () {\n    var ctx = model._openGLRenderWindow.getContext();\n    if (model.context !== ctx) {\n      model.context = ctx;\n      for (var i = primTypes.Start; i < primTypes.End; i++) {\n        model.primitives[i].setOpenGLRenderWindow(model._openGLRenderWindow);\n      }\n    }\n    var actor = model.openGLActor.getRenderable();\n    var ren = model._openGLRenderer.getRenderable();\n    publicAPI.renderPiece(ren, actor);\n  };\n  publicAPI.getShaderTemplate = function (shaders, ren, actor) {\n    shaders.Vertex = vtkPolyDataVS;\n    shaders.Fragment = vtkPolyDataFS;\n    shaders.Geometry = '';\n  };\n  publicAPI.replaceShaderColor = function (shaders, ren, actor) {\n    var VSSource = shaders.Vertex;\n    var GSSource = shaders.Geometry;\n    var FSSource = shaders.Fragment;\n    var lastLightComplexity = model.lastBoundBO.getReferenceByName('lastLightComplexity'); // create the material/color property declarations, and VS implementation\n    // these are always defined\n\n    var colorDec = ['uniform float ambient;', 'uniform float diffuse;', 'uniform float specular;', 'uniform float opacityUniform; // the fragment opacity', 'uniform vec3 ambientColorUniform;', 'uniform vec3 diffuseColorUniform;']; // add more for specular\n\n    if (lastLightComplexity) {\n      colorDec = colorDec.concat(['uniform vec3 specularColorUniform;', 'uniform float specularPowerUniform;']);\n    } // now handle the more complex fragment shader implementation\n    // the following are always defined variables.  We start\n    // by assigning a default value from the uniform\n\n    var colorImpl = ['vec3 ambientColor;', '  vec3 diffuseColor;', '  float opacity;'];\n    if (lastLightComplexity) {\n      colorImpl = colorImpl.concat(['  vec3 specularColor;', '  float specularPower;']);\n    }\n    colorImpl = colorImpl.concat(['  ambientColor = ambientColorUniform;', '  diffuseColor = diffuseColorUniform;', '  opacity = opacityUniform;']);\n    if (lastLightComplexity) {\n      colorImpl = colorImpl.concat(['  specularColor = specularColorUniform;', '  specularPower = specularPowerUniform;']);\n    } // add scalar vertex coloring\n\n    if (model.lastBoundBO.getCABO().getColorComponents() !== 0 && !model.drawingEdges) {\n      colorDec = colorDec.concat(['varying vec4 vertexColorVSOutput;']);\n      VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::Color::Dec', ['attribute vec4 scalarColor;', 'varying vec4 vertexColorVSOutput;']).result;\n      VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::Color::Impl', ['vertexColorVSOutput =  scalarColor;']).result;\n      GSSource = vtkShaderProgram.substitute(GSSource, '//VTK::Color::Dec', ['in vec4 vertexColorVSOutput[];', 'out vec4 vertexColorGSOutput;']).result;\n      GSSource = vtkShaderProgram.substitute(GSSource, '//VTK::Color::Impl', ['vertexColorGSOutput = vertexColorVSOutput[i];']).result;\n    }\n    if (model.lastBoundBO.getCABO().getColorComponents() !== 0 && !model.drawingEdges) {\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Color::Impl', colorImpl.concat(['  diffuseColor = vertexColorVSOutput.rgb;', '  ambientColor = vertexColorVSOutput.rgb;', '  opacity = opacity*vertexColorVSOutput.a;'])).result;\n    } else {\n      if (model.renderable.getInterpolateScalarsBeforeMapping() && model.renderable.getColorCoordinates() && !model.drawingEdges) {\n        FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Color::Impl', colorImpl.concat(['  vec4 texColor = texture2D(texture1, tcoordVCVSOutput.st);', '  diffuseColor = texColor.rgb;', '  ambientColor = texColor.rgb;', '  opacity = opacity*texColor.a;'])).result;\n      } else {\n        if (actor.getBackfaceProperty() && !model.drawingEdges) {\n          colorDec = colorDec.concat(['uniform float opacityUniformBF; // the fragment opacity', 'uniform float ambientIntensityBF; // the material ambient', 'uniform float diffuseIntensityBF; // the material diffuse', 'uniform vec3 ambientColorUniformBF; // ambient material color', 'uniform vec3 diffuseColorUniformBF; // diffuse material color']);\n          if (lastLightComplexity) {\n            colorDec = colorDec.concat(['uniform float specularIntensityBF; // the material specular intensity', 'uniform vec3 specularColorUniformBF; // intensity weighted color', 'uniform float specularPowerUniformBF;']);\n            colorImpl = colorImpl.concat(['if (gl_FrontFacing == false) {', '  ambientColor = ambientIntensityBF * ambientColorUniformBF;', '  diffuseColor = diffuseIntensityBF * diffuseColorUniformBF;', '  specularColor = specularIntensityBF * specularColorUniformBF;', '  specularPower = specularPowerUniformBF;', '  opacity = opacityUniformBF; }']);\n          } else {\n            colorImpl = colorImpl.concat(['if (gl_FrontFacing == false) {', '  ambientColor = ambientIntensityBF * ambientColorUniformBF;', '  diffuseColor = diffuseIntensityBF * diffuseColorUniformBF;', '  opacity = opacityUniformBF; }']);\n          }\n        }\n        if (model.haveCellScalars && !model.drawingEdges) {\n          colorDec = colorDec.concat(['uniform samplerBuffer texture1;']);\n        }\n        FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Color::Impl', colorImpl).result;\n      }\n    }\n    FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Color::Dec', colorDec).result;\n    shaders.Vertex = VSSource;\n    shaders.Geometry = GSSource;\n    shaders.Fragment = FSSource;\n  };\n  publicAPI.replaceShaderLight = function (shaders, ren, actor) {\n    var FSSource = shaders.Fragment; // check for shadow maps\n\n    var shadowFactor = '';\n    var lastLightComplexity = model.lastBoundBO.getReferenceByName('lastLightComplexity');\n    var lastLightCount = model.lastBoundBO.getReferenceByName('lastLightCount');\n    var sstring = [];\n    switch (lastLightComplexity) {\n      case 0:\n        // no lighting or RENDER_VALUES\n        FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Light::Impl', ['  gl_FragData[0] = vec4(ambientColor * ambient + diffuseColor * diffuse, opacity);', '  //VTK::Light::Impl'], false).result;\n        break;\n      case 1:\n        // headlight\n        FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Light::Impl', ['  float df = max(0.0, normalVCVSOutput.z);', '  float sf = pow(df, specularPower);', '  vec3 diffuseL = df * diffuseColor;', '  vec3 specularL = sf * specularColor;', '  gl_FragData[0] = vec4(ambientColor * ambient + diffuseL * diffuse + specularL * specular, opacity);', '  //VTK::Light::Impl'], false).result;\n        break;\n      case 2:\n        // light kit\n        for (var lc = 0; lc < lastLightCount; ++lc) {\n          sstring = sstring.concat([\"uniform vec3 lightColor\".concat(lc, \";\"), \"uniform vec3 lightDirectionVC\".concat(lc, \"; // normalized\"), \"uniform vec3 lightHalfAngleVC\".concat(lc, \"; // normalized\")]);\n        }\n        FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Light::Dec', sstring).result;\n        sstring = ['vec3 diffuseL = vec3(0,0,0);', '  vec3 specularL = vec3(0,0,0);', '  float df;'];\n        for (var _lc = 0; _lc < lastLightCount; ++_lc) {\n          sstring = sstring.concat([\"  df = max(0.0, dot(normalVCVSOutput, -lightDirectionVC\".concat(_lc, \"));\"), \"  diffuseL += ((df\".concat(shadowFactor, \") * lightColor\").concat(_lc, \");\"), \"  if (dot(normalVCVSOutput, lightDirectionVC\".concat(_lc, \") < 0.0)\"), '    {', \"    float sf = sign(df)*pow(max(1e-5,\\n                                              dot(reflect(lightDirectionVC\".concat(_lc, \",normalVCVSOutput),\\n                                                  normalize(-vertexVC.xyz))),\\n                                         specularPower);\"), \"    specularL += (sf\".concat(shadowFactor, \" * lightColor\").concat(_lc, \");\"), '    }']);\n        }\n        sstring = sstring.concat(['  diffuseL = diffuseL * diffuseColor;', '  specularL = specularL * specularColor;', '  gl_FragData[0] = vec4(ambientColor * ambient + diffuseL * diffuse + specularL * specular, opacity);', '  //VTK::Light::Impl']);\n        FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Light::Impl', sstring, false).result;\n        break;\n      case 3:\n        // positional\n        for (var _lc2 = 0; _lc2 < lastLightCount; ++_lc2) {\n          sstring = sstring.concat([\"uniform vec3 lightColor\".concat(_lc2, \";\"), \"uniform vec3 lightDirectionVC\".concat(_lc2, \"; // normalized\"), \"uniform vec3 lightHalfAngleVC\".concat(_lc2, \"; // normalized\"), \"uniform vec3 lightPositionVC\".concat(_lc2, \";\"), \"uniform vec3 lightAttenuation\".concat(_lc2, \";\"), \"uniform float lightConeAngle\".concat(_lc2, \";\"), \"uniform float lightExponent\".concat(_lc2, \";\"), \"uniform int lightPositional\".concat(_lc2, \";\")]);\n        }\n        FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Light::Dec', sstring).result;\n        sstring = ['vec3 diffuseL = vec3(0,0,0);', '  vec3 specularL = vec3(0,0,0);', '  vec3 vertLightDirectionVC;', '  float attenuation;', '  float df;'];\n        for (var _lc3 = 0; _lc3 < lastLightCount; ++_lc3) {\n          sstring = sstring.concat(['  attenuation = 1.0;', \"  if (lightPositional\".concat(_lc3, \" == 0)\"), '    {', \"      vertLightDirectionVC = lightDirectionVC\".concat(_lc3, \";\"), '    }', '  else', '    {', \"    vertLightDirectionVC = vertexVC.xyz - lightPositionVC\".concat(_lc3, \";\"), '    float distanceVC = length(vertLightDirectionVC);', '    vertLightDirectionVC = normalize(vertLightDirectionVC);', '    attenuation = 1.0 /', \"      (lightAttenuation\".concat(_lc3, \".x\"), \"       + lightAttenuation\".concat(_lc3, \".y * distanceVC\"), \"       + lightAttenuation\".concat(_lc3, \".z * distanceVC * distanceVC);\"), '    // per OpenGL standard cone angle is 90 or less for a spot light', \"    if (lightConeAngle\".concat(_lc3, \" <= 90.0)\"), '      {', \"      float coneDot = dot(vertLightDirectionVC, lightDirectionVC\".concat(_lc3, \");\"), '      // if inside the cone', \"      if (coneDot >= cos(radians(lightConeAngle\".concat(_lc3, \")))\"), '        {', \"        attenuation = attenuation * pow(coneDot, lightExponent\".concat(_lc3, \");\"), '        }', '      else', '        {', '        attenuation = 0.0;', '        }', '      }', '    }', '    df = max(0.0, attenuation*dot(normalVCVSOutput, -vertLightDirectionVC));', \"    diffuseL += ((df\".concat(shadowFactor, \") * lightColor\").concat(_lc3, \");\"), '    if (dot(normalVCVSOutput, vertLightDirectionVC) < 0.0)', '      {', \"      float sf = sign(df)*attenuation*pow(max(1e-5,\\n                                                           dot(reflect(lightDirectionVC\".concat(_lc3, \",\\n                                                                       normalVCVSOutput),\\n                                                               normalize(-vertexVC.xyz))),\\n                                                       specularPower);\"), \"    specularL += ((sf\".concat(shadowFactor, \") * lightColor\").concat(_lc3, \");\"), '    }']);\n        }\n        sstring = sstring.concat(['  diffuseL = diffuseL * diffuseColor;', '  specularL = specularL * specularColor;', '  gl_FragData[0] = vec4(ambientColor * ambient + diffuseL * diffuse + specularL * specular, opacity);', '  //VTK::Light::Impl']);\n        FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Light::Impl', sstring, false).result;\n        break;\n      default:\n        vtkErrorMacro('bad light complexity');\n    }\n    shaders.Fragment = FSSource;\n  };\n  publicAPI.replaceShaderNormal = function (shaders, ren, actor) {\n    var lastLightComplexity = model.lastBoundBO.getReferenceByName('lastLightComplexity');\n    if (lastLightComplexity > 0) {\n      var VSSource = shaders.Vertex;\n      var GSSource = shaders.Geometry;\n      var FSSource = shaders.Fragment;\n      if (model.lastBoundBO.getCABO().getNormalOffset()) {\n        VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::Normal::Dec', ['attribute vec3 normalMC;', 'uniform mat3 normalMatrix;', 'varying vec3 normalVCVSOutput;']).result;\n        VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::Normal::Impl', ['normalVCVSOutput = normalMatrix * normalMC;']).result;\n        GSSource = vtkShaderProgram.substitute(GSSource, '//VTK::Normal::Dec', ['in vec3 normalVCVSOutput[];', 'out vec3 normalVCGSOutput;']).result;\n        GSSource = vtkShaderProgram.substitute(GSSource, '//VTK::Normal::Impl', ['normalVCGSOutput = normalVCVSOutput[i];']).result;\n        FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Normal::Dec', ['varying vec3 normalVCVSOutput;']).result;\n        FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Normal::Impl', ['vec3 normalVCVSOutput = normalize(normalVCVSOutput);',\n        //  if (!gl_FrontFacing) does not work in intel hd4000 mac\n        //  if (int(gl_FrontFacing) == 0) does not work on mesa\n        '  if (gl_FrontFacing == false) { normalVCVSOutput = -normalVCVSOutput; }']).result;\n      } else {\n        if (model.haveCellNormals) {\n          FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Normal::Dec', ['uniform mat3 normalMatrix;', 'uniform samplerBuffer textureN;']).result;\n          FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Normal::Impl', ['vec3 normalVCVSOutput = normalize(normalMatrix *', '    texelFetchBuffer(textureN, gl_PrimitiveID + PrimitiveIDOffset).xyz);', '  if (gl_FrontFacing == false) { normalVCVSOutput = -normalVCVSOutput; }']).result;\n        } else {\n          if (model.lastBoundBO.getOpenGLMode(actor.getProperty().getRepresentation()) === model.context.LINES) {\n            // generate a normal for lines, it will be perpendicular to the line\n            // and maximally aligned with the camera view direction\n            // no clue if this is the best way to do this.\n            // the code below has been optimized a bit so what follows is\n            // an explanation of the basic approach. Compute the gradient of the line\n            // with respect to x and y, the the larger of the two\n            // cross that with the camera view direction. That gives a vector\n            // orthogonal to the camera view and the line. Note that the line and the camera\n            // view are probably not orthogonal. Which is why when we cross result that with\n            // the line gradient again we get a reasonable normal. It will be othogonal to\n            // the line (which is a plane but maximally aligned with the camera view.\n            FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::UniformFlow::Impl', ['  vec3 fdx = dFdx(vertexVC.xyz);', '  vec3 fdy = dFdy(vertexVC.xyz);', '  //VTK::UniformFlow::Impl'] // For further replacements\n            ).result;\n            FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Normal::Impl', ['vec3 normalVCVSOutput;', '  if (abs(fdx.x) > 0.0)', '    { fdx = normalize(fdx); normalVCVSOutput = normalize(cross(vec3(fdx.y, -fdx.x, 0.0), fdx)); }', '  else { fdy = normalize(fdy); normalVCVSOutput = normalize(cross(vec3(fdy.y, -fdy.x, 0.0), fdy));}']).result;\n          } else {\n            FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Normal::Dec', ['uniform int cameraParallel;']).result;\n            FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::UniformFlow::Impl', [\n            // '  vec3 fdx = vec3(dFdx(vertexVC.x),dFdx(vertexVC.y),dFdx(vertexVC.z));',\n            // '  vec3 fdy = vec3(dFdy(vertexVC.x),dFdy(vertexVC.y),dFdy(vertexVC.z));',\n            '  vec3 fdx = dFdx(vertexVC.xyz);', '  vec3 fdy = dFdy(vertexVC.xyz);', '  //VTK::UniformFlow::Impl'] // For further replacements\n            ).result;\n            FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Normal::Impl', ['  fdx = normalize(fdx);', '  fdy = normalize(fdy);', '  vec3 normalVCVSOutput = normalize(cross(fdx,fdy));',\n            // the code below is faster, but does not work on some devices\n            // 'vec3 normalVC = normalize(cross(dFdx(vertexVC.xyz), dFdy(vertexVC.xyz)));',\n            '  if (cameraParallel == 1 && normalVCVSOutput.z < 0.0) { normalVCVSOutput = -1.0*normalVCVSOutput; }', '  if (cameraParallel == 0 && dot(normalVCVSOutput,vertexVC.xyz) > 0.0) { normalVCVSOutput = -1.0*normalVCVSOutput; }']).result;\n          }\n        }\n      }\n      shaders.Vertex = VSSource;\n      shaders.Geometry = GSSource;\n      shaders.Fragment = FSSource;\n    }\n  };\n  publicAPI.replaceShaderPositionVC = function (shaders, ren, actor) {\n    // replace common shader code\n    model.lastBoundBO.replaceShaderPositionVC(shaders, ren, actor);\n    var VSSource = shaders.Vertex;\n    var GSSource = shaders.Geometry;\n    var FSSource = shaders.Fragment; // do we need the vertex in the shader in View Coordinates\n\n    var lastLightComplexity = model.lastBoundBO.getReferenceByName('lastLightComplexity');\n    if (lastLightComplexity > 0) {\n      VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::PositionVC::Dec', ['varying vec4 vertexVCVSOutput;']).result;\n      VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::PositionVC::Impl', ['vertexVCVSOutput = MCVCMatrix * vertexMC;', '  gl_Position = MCPCMatrix * vertexMC;']).result;\n      VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::Camera::Dec', ['uniform mat4 MCPCMatrix;', 'uniform mat4 MCVCMatrix;']).result;\n      GSSource = vtkShaderProgram.substitute(GSSource, '//VTK::PositionVC::Dec', ['in vec4 vertexVCVSOutput[];', 'out vec4 vertexVCGSOutput;']).result;\n      GSSource = vtkShaderProgram.substitute(GSSource, '//VTK::PositionVC::Impl', ['vertexVCGSOutput = vertexVCVSOutput[i];']).result;\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::PositionVC::Dec', ['varying vec4 vertexVCVSOutput;']).result;\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::PositionVC::Impl', ['vec4 vertexVC = vertexVCVSOutput;']).result;\n    } else {\n      VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::Camera::Dec', ['uniform mat4 MCPCMatrix;']).result;\n      VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::PositionVC::Impl', ['  gl_Position = MCPCMatrix * vertexMC;']).result;\n    }\n    shaders.Vertex = VSSource;\n    shaders.Geometry = GSSource;\n    shaders.Fragment = FSSource;\n  };\n  publicAPI.replaceShaderTCoord = function (shaders, ren, actor) {\n    if (model.lastBoundBO.getCABO().getTCoordOffset()) {\n      var VSSource = shaders.Vertex;\n      var GSSource = shaders.Geometry;\n      var FSSource = shaders.Fragment;\n      if (model.drawingEdges) {\n        return;\n      }\n      VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::TCoord::Impl', 'tcoordVCVSOutput = tcoordMC;').result; // we only handle the first texture by default\n      // additional textures are activated and we set the uniform\n      // for the texture unit they are assigned to, but you have to\n      // add in the shader code to do something with them\n\n      var tus = model.openGLActor.getActiveTextures();\n      var tNumComp = 2;\n      var tcdim = 2;\n      if (tus && tus.length > 0) {\n        tNumComp = tus[0].getComponents();\n        if (tus[0].getTarget() === model.context.TEXTURE_CUBE_MAP) {\n          tcdim = 3;\n        }\n      }\n      if (model.renderable.getColorTextureMap()) {\n        tNumComp = model.renderable.getColorTextureMap().getPointData().getScalars().getNumberOfComponents();\n        tcdim = 2;\n      }\n      if (tcdim === 2) {\n        VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::TCoord::Dec', 'attribute vec2 tcoordMC; varying vec2 tcoordVCVSOutput;').result;\n        GSSource = vtkShaderProgram.substitute(GSSource, '//VTK::TCoord::Dec', ['in vec2 tcoordVCVSOutput[];', 'out vec2 tcoordVCGSOutput;']).result;\n        GSSource = vtkShaderProgram.substitute(GSSource, '//VTK::TCoord::Impl', 'tcoordVCGSOutput = tcoordVCVSOutput[i];').result;\n        FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::TCoord::Dec', ['varying vec2 tcoordVCVSOutput;', 'uniform sampler2D texture1;']).result;\n        if (tus && tus.length >= 1) {\n          switch (tNumComp) {\n            case 1:\n              FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::TCoord::Impl', ['  vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);', '  ambientColor = ambientColor*tcolor.r;', '  diffuseColor = diffuseColor*tcolor.r;']).result;\n              break;\n            case 2:\n              FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::TCoord::Impl', ['  vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);', '  ambientColor = ambientColor*tcolor.r;', '  diffuseColor = diffuseColor*tcolor.r;', '  opacity = opacity * tcolor.g;']).result;\n              break;\n            default:\n              FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::TCoord::Impl', ['  vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);', '  ambientColor = ambientColor*tcolor.rgb;', '  diffuseColor = diffuseColor*tcolor.rgb;', '  opacity = opacity * tcolor.a;']).result;\n          }\n        }\n      } else {\n        VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::TCoord::Dec', 'attribute vec3 tcoordMC; varying vec3 tcoordVCVSOutput;').result;\n        GSSource = vtkShaderProgram.substitute(GSSource, '//VTK::TCoord::Dec', ['in vec3 tcoordVCVSOutput[];', 'out vec3 tcoordVCGSOutput;']).result;\n        GSSource = vtkShaderProgram.substitute(GSSource, '//VTK::TCoord::Impl', 'tcoordVCGSOutput = tcoordVCVSOutput[i];').result;\n        FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::TCoord::Dec', ['varying vec3 tcoordVCVSOutput;', 'uniform samplerCube texture1;']).result;\n        switch (tNumComp) {\n          case 1:\n            FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::TCoord::Impl', ['  vec4 tcolor = textureCube(texture1, tcoordVCVSOutput);', '  ambientColor = ambientColor*tcolor.r;', '  diffuseColor = diffuseColor*tcolor.r;']).result;\n            break;\n          case 2:\n            FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::TCoord::Impl', ['  vec4 tcolor = textureCube(texture1, tcoordVCVSOutput);', '  ambientColor = ambientColor*tcolor.r;', '  diffuseColor = diffuseColor*tcolor.r;', '  opacity = opacity * tcolor.g;']).result;\n            break;\n          default:\n            FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::TCoord::Impl', ['  vec4 tcolor = textureCube(texture1, tcoordVCVSOutput);', '  ambientColor = ambientColor*tcolor.rgb;', '  diffuseColor = diffuseColor*tcolor.rgb;', '  opacity = opacity * tcolor.a;']).result;\n        }\n      }\n      shaders.Vertex = VSSource;\n      shaders.Geometry = GSSource;\n      shaders.Fragment = FSSource;\n    }\n  };\n  publicAPI.replaceShaderClip = function (shaders, ren, actor) {\n    var VSSource = shaders.Vertex;\n    var FSSource = shaders.Fragment;\n    if (model.renderable.getNumberOfClippingPlanes()) {\n      var numClipPlanes = model.renderable.getNumberOfClippingPlanes();\n      VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::Clip::Dec', ['uniform int numClipPlanes;', \"uniform vec4 clipPlanes[\".concat(numClipPlanes, \"];\"), \"varying float clipDistancesVSOutput[\".concat(numClipPlanes, \"];\")]).result;\n      VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::Clip::Impl', [\"for (int planeNum = 0; planeNum < \".concat(numClipPlanes, \"; planeNum++)\"), '    {', '    if (planeNum >= numClipPlanes)', '        {', '        break;', '        }', '    clipDistancesVSOutput[planeNum] = dot(clipPlanes[planeNum], vertexMC);', '    }']).result;\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Clip::Dec', ['uniform int numClipPlanes;', \"varying float clipDistancesVSOutput[\".concat(numClipPlanes, \"];\")]).result;\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Clip::Impl', [\"for (int planeNum = 0; planeNum < \".concat(numClipPlanes, \"; planeNum++)\"), '    {', '    if (planeNum >= numClipPlanes)', '        {', '        break;', '        }', '    if (clipDistancesVSOutput[planeNum] < 0.0) discard;', '    }']).result;\n    }\n    shaders.Vertex = VSSource;\n    shaders.Fragment = FSSource;\n  };\n  publicAPI.getCoincidentParameters = function (ren, actor) {\n    // 1. ResolveCoincidentTopology is On and non zero for this primitive\n    // type\n    var cp = {\n      factor: 0.0,\n      offset: 0.0\n    };\n    var prop = actor.getProperty();\n    if (model.renderable.getResolveCoincidentTopology() || prop.getEdgeVisibility() && prop.getRepresentation() === Representation.SURFACE) {\n      var primType = model.lastBoundBO.getPrimitiveType();\n      if (primType === primTypes.Points || prop.getRepresentation() === Representation.POINTS) {\n        cp = model.renderable.getCoincidentTopologyPointOffsetParameter();\n      } else if (primType === primTypes.Lines || prop.getRepresentation() === Representation.WIREFRAME) {\n        cp = model.renderable.getCoincidentTopologyLineOffsetParameters();\n      } else if (primType === primTypes.Tris || primType === primTypes.TriStrips) {\n        cp = model.renderable.getCoincidentTopologyPolygonOffsetParameters();\n      }\n      if (primType === primTypes.TrisEdges || primType === primTypes.TriStripsEdges) {\n        cp = model.renderable.getCoincidentTopologyPolygonOffsetParameters();\n        cp.factor /= 2.0;\n        cp.offset /= 2.0;\n      }\n    } // hardware picking always offset due to saved zbuffer\n    // This gets you above the saved surface depth buffer.\n\n    var selector = model._openGLRenderer.getSelector();\n    if (selector && selector.getFieldAssociation() === FieldAssociations.FIELD_ASSOCIATION_POINTS) {\n      cp.offset -= 2.0;\n    }\n    return cp;\n  };\n  publicAPI.replaceShaderPicking = function (shaders, ren, actor) {\n    var FSSource = shaders.Fragment;\n    var VSSource = shaders.Vertex;\n    FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Picking::Dec', ['uniform int picking;', '//VTK::Picking::Dec']).result;\n    if (!model._openGLRenderer.getSelector()) {\n      return;\n    }\n    if (model.lastSelectionState === PassTypes.ID_LOW24 || model.lastSelectionState === PassTypes.ID_HIGH24) {\n      VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::Picking::Dec', ['flat out int vertexIDVSOutput;\\n', 'uniform int VertexIDOffset;\\n']).result;\n      VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::Picking::Impl', '  vertexIDVSOutput = gl_VertexID + VertexIDOffset;\\n').result;\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Picking::Dec', 'flat in int vertexIDVSOutput;\\n').result;\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Picking::Impl', ['  int idx = vertexIDVSOutput;', '//VTK::Picking::Impl']).result;\n    }\n    switch (model.lastSelectionState) {\n      case PassTypes.ID_LOW24:\n        FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Picking::Impl', '  gl_FragData[0] = vec4(float(idx%256)/255.0, float((idx/256)%256)/255.0, float((idx/65536)%256)/255.0, 1.0);').result;\n        break;\n      case PassTypes.ID_HIGH24:\n        FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Picking::Impl', '  gl_FragData[0] = vec4(float(idx)/255.0, 0.0, 0.0, 1.0);').result;\n        break;\n      default:\n        FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Picking::Dec', 'uniform vec3 mapperIndex;').result;\n        FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Picking::Impl', '  gl_FragData[0] = picking != 0 ? vec4(mapperIndex,1.0) : gl_FragData[0];').result;\n    }\n    shaders.Fragment = FSSource;\n    shaders.Vertex = VSSource;\n  };\n  publicAPI.replaceShaderValues = function (shaders, ren, actor) {\n    publicAPI.replaceShaderColor(shaders, ren, actor);\n    publicAPI.replaceShaderNormal(shaders, ren, actor);\n    publicAPI.replaceShaderLight(shaders, ren, actor);\n    publicAPI.replaceShaderTCoord(shaders, ren, actor);\n    publicAPI.replaceShaderPicking(shaders, ren, actor);\n    publicAPI.replaceShaderClip(shaders, ren, actor);\n    publicAPI.replaceShaderCoincidentOffset(shaders, ren, actor);\n    publicAPI.replaceShaderPositionVC(shaders, ren, actor);\n    if (model.haveSeenDepthRequest) {\n      var FSSource = shaders.Fragment;\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::ZBuffer::Dec', 'uniform int depthRequest;').result;\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::ZBuffer::Impl', ['if (depthRequest == 1) {', 'float iz = floor(gl_FragCoord.z*65535.0 + 0.1);', 'float rf = floor(iz/256.0)/255.0;', 'float gf = mod(iz,256.0)/255.0;', 'gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }']).result;\n      shaders.Fragment = FSSource;\n    }\n  };\n  publicAPI.getNeedToRebuildShaders = function (cellBO, ren, actor) {\n    var lightComplexity = 0;\n    var numberOfLights = 0;\n    var primType = cellBO.getPrimitiveType();\n    var poly = model.currentInput; // different algo from C++ as of 5/2019\n\n    var needLighting = false;\n    var pointNormals = poly.getPointData().getNormals();\n    var cellNormals = poly.getCellData().getNormals();\n    var flat = actor.getProperty().getInterpolation() === Shading.FLAT;\n    var representation = actor.getProperty().getRepresentation();\n    var mode = cellBO.getOpenGLMode(representation, primType); // 1) all surfaces need lighting\n\n    if (mode === model.context.TRIANGLES) {\n      needLighting = true; // 2) all cell normals without point normals need lighting\n    } else if (cellNormals && !pointNormals) {\n      needLighting = true; // 3) Phong + pointNormals need lighting\n    } else if (!flat && pointNormals) {\n      needLighting = true; // 4) Phong Lines need lighting\n    } else if (!flat && mode === model.context.LINES) {\n      needLighting = true;\n    } // 5) everything else is unlit\n    // do we need lighting?\n\n    if (actor.getProperty().getLighting() && needLighting) {\n      // consider the lighting complexity to determine which case applies\n      // simple headlight, Light Kit, the whole feature set of VTK\n      lightComplexity = 0;\n      var lights = ren.getLightsByReference();\n      for (var index = 0; index < lights.length; ++index) {\n        var light = lights[index];\n        var status = light.getSwitch();\n        if (status > 0) {\n          numberOfLights++;\n          if (lightComplexity === 0) {\n            lightComplexity = 1;\n          }\n        }\n        if (lightComplexity === 1 && (numberOfLights > 1 || light.getIntensity() !== 1.0 || !light.lightTypeIsHeadLight())) {\n          lightComplexity = 2;\n        }\n        if (lightComplexity < 3 && light.getPositional()) {\n          lightComplexity = 3;\n        }\n      }\n    }\n    var needRebuild = false;\n    var lastLightComplexity = model.lastBoundBO.getReferenceByName('lastLightComplexity');\n    var lastLightCount = model.lastBoundBO.getReferenceByName('lastLightCount');\n    if (lastLightComplexity !== lightComplexity || lastLightCount !== numberOfLights) {\n      model.lastBoundBO.set({\n        lastLightComplexity: lightComplexity\n      }, true);\n      model.lastBoundBO.set({\n        lastLightCount: numberOfLights\n      }, true);\n      needRebuild = true;\n    } // has the render pass shader replacement changed? Two options\n\n    if (!model.currentRenderPass && model.lastRenderPassShaderReplacement || model.currentRenderPass && model.currentRenderPass.getShaderReplacement() !== model.lastRenderPassShaderReplacement) {\n      needRebuild = true;\n    } // has something changed that would require us to recreate the shader?\n    // candidates are\n    // property modified (representation interpolation and lighting)\n    // input modified\n    // light complexity changed\n    // render pass shader replacement changed\n\n    if (model.lastHaveSeenDepthRequest !== model.haveSeenDepthRequest || cellBO.getShaderSourceTime().getMTime() < model.renderable.getMTime() || cellBO.getShaderSourceTime().getMTime() < model.currentInput.getMTime() || cellBO.getShaderSourceTime().getMTime() < model.selectionStateChanged.getMTime() || needRebuild) {\n      model.lastHaveSeenDepthRequest = model.haveSeenDepthRequest;\n      return true;\n    }\n    return false;\n  };\n  publicAPI.invokeShaderCallbacks = function (cellBO, ren, actor) {\n    var listCallbacks = model.renderable.getViewSpecificProperties().ShadersCallbacks;\n    if (listCallbacks) {\n      listCallbacks.forEach(function (object) {\n        object.callback(object.userData, cellBO, ren, actor);\n      });\n    }\n  };\n  publicAPI.setMapperShaderParameters = function (cellBO, ren, actor) {\n    // Now to update the VAO too, if necessary.\n    if (cellBO.getProgram().isUniformUsed('PrimitiveIDOffset')) {\n      cellBO.getProgram().setUniformi('PrimitiveIDOffset', model.primitiveIDOffset);\n    }\n    if (cellBO.getProgram().isUniformUsed('VertexIDOffset')) {\n      cellBO.getProgram().setUniformi('VertexIDOffset', model.vertexIDOffset);\n    }\n    if (cellBO.getCABO().getElementCount() && (model.VBOBuildTime.getMTime() > cellBO.getAttributeUpdateTime().getMTime() || cellBO.getShaderSourceTime().getMTime() > cellBO.getAttributeUpdateTime().getMTime())) {\n      var lastLightComplexity = model.lastBoundBO.getReferenceByName('lastLightComplexity');\n      if (cellBO.getProgram().isAttributeUsed('vertexMC')) {\n        if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO(), 'vertexMC', cellBO.getCABO().getVertexOffset(), cellBO.getCABO().getStride(), model.context.FLOAT, 3, false)) {\n          vtkErrorMacro('Error setting vertexMC in shader VAO.');\n        }\n      }\n      if (cellBO.getProgram().isAttributeUsed('normalMC') && cellBO.getCABO().getNormalOffset() && lastLightComplexity > 0) {\n        if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO(), 'normalMC', cellBO.getCABO().getNormalOffset(), cellBO.getCABO().getStride(), model.context.FLOAT, 3, false)) {\n          vtkErrorMacro('Error setting normalMC in shader VAO.');\n        }\n      } else {\n        cellBO.getVAO().removeAttributeArray('normalMC');\n      }\n      model.renderable.getCustomShaderAttributes().forEach(function (attrName, idx) {\n        if (cellBO.getProgram().isAttributeUsed(\"\".concat(attrName, \"MC\"))) {\n          if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO(), \"\".concat(attrName, \"MC\"), cellBO.getCABO().getCustomData()[idx].offset, cellBO.getCABO().getStride(), model.context.FLOAT, cellBO.getCABO().getCustomData()[idx].components, false)) {\n            vtkErrorMacro(\"Error setting \".concat(attrName, \"MC in shader VAO.\"));\n          }\n        }\n      });\n      if (cellBO.getProgram().isAttributeUsed('tcoordMC') && cellBO.getCABO().getTCoordOffset()) {\n        if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO(), 'tcoordMC', cellBO.getCABO().getTCoordOffset(), cellBO.getCABO().getStride(), model.context.FLOAT, cellBO.getCABO().getTCoordComponents(), false)) {\n          vtkErrorMacro('Error setting tcoordMC in shader VAO.');\n        }\n      } else {\n        cellBO.getVAO().removeAttributeArray('tcoordMC');\n      }\n      if (cellBO.getProgram().isAttributeUsed('scalarColor') && cellBO.getCABO().getColorComponents()) {\n        if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO().getColorBO(), 'scalarColor', cellBO.getCABO().getColorOffset(), cellBO.getCABO().getColorBOStride(), model.context.UNSIGNED_BYTE, 4, true)) {\n          vtkErrorMacro('Error setting scalarColor in shader VAO.');\n        }\n      } else {\n        cellBO.getVAO().removeAttributeArray('scalarColor');\n      }\n      cellBO.getAttributeUpdateTime().modified();\n    }\n    if (model.renderable.getNumberOfClippingPlanes()) {\n      // add all the clipping planes\n      var numClipPlanes = model.renderable.getNumberOfClippingPlanes();\n      var planeEquations = [];\n      var shiftScaleEnabled = cellBO.getCABO().getCoordShiftAndScaleEnabled();\n      var inverseShiftScaleMatrix = shiftScaleEnabled ? cellBO.getCABO().getInverseShiftAndScaleMatrix() : null;\n      var mat = inverseShiftScaleMatrix ? mat4.copy(model.tmpMat4, actor.getMatrix()) : actor.getMatrix();\n      if (inverseShiftScaleMatrix) {\n        mat4.transpose(mat, mat);\n        mat4.multiply(mat, mat, inverseShiftScaleMatrix);\n        mat4.transpose(mat, mat);\n      }\n      for (var i = 0; i < numClipPlanes; i++) {\n        var planeEquation = [];\n        model.renderable.getClippingPlaneInDataCoords(mat, i, planeEquation);\n        for (var j = 0; j < 4; j++) {\n          planeEquations.push(planeEquation[j]);\n        }\n      }\n      cellBO.getProgram().setUniformi('numClipPlanes', numClipPlanes);\n      cellBO.getProgram().setUniform4fv('clipPlanes', planeEquations);\n    }\n    if (model.internalColorTexture && cellBO.getProgram().isUniformUsed('texture1')) {\n      cellBO.getProgram().setUniformi('texture1', model.internalColorTexture.getTextureUnit());\n    }\n    var tus = model.openGLActor.getActiveTextures();\n    if (tus) {\n      for (var index = 0; index < tus.length; ++index) {\n        var tex = tus[index];\n        var texUnit = tex.getTextureUnit();\n        var tname = \"texture\".concat(texUnit + 1);\n        if (cellBO.getProgram().isUniformUsed(tname)) {\n          cellBO.getProgram().setUniformi(tname, texUnit);\n        }\n      }\n    } // handle depth requests\n\n    if (model.haveSeenDepthRequest) {\n      cellBO.getProgram().setUniformi('depthRequest', model.renderDepth ? 1 : 0);\n    } // handle coincident\n\n    if (cellBO.getProgram().isUniformUsed('coffset')) {\n      var cp = publicAPI.getCoincidentParameters(ren, actor);\n      cellBO.getProgram().setUniformf('coffset', cp.offset); // cfactor isn't always used when coffset is.\n\n      if (cellBO.getProgram().isUniformUsed('cfactor')) {\n        cellBO.getProgram().setUniformf('cfactor', cp.factor);\n      }\n    } // handle wide lines\n\n    cellBO.setMapperShaderParameters(ren, actor, model._openGLRenderer.getTiledSizeAndOrigin());\n    var selector = model._openGLRenderer.getSelector();\n    cellBO.getProgram().setUniform3fArray('mapperIndex', selector ? selector.getPropColorValue() : [0.0, 0.0, 0.0]);\n    cellBO.getProgram().setUniformi('picking', selector ? selector.getCurrentPass() + 1 : 0);\n  };\n  publicAPI.setLightingShaderParameters = function (cellBO, ren, actor) {\n    // for unlit and headlight there are no lighting parameters\n    var lastLightComplexity = model.lastBoundBO.getReferenceByName('lastLightComplexity');\n    if (lastLightComplexity < 2) {\n      return;\n    }\n    var program = cellBO.getProgram(); // bind some light settings\n\n    var numberOfLights = 0;\n    var lights = ren.getLightsByReference();\n    for (var index = 0; index < lights.length; ++index) {\n      var light = lights[index];\n      var status = light.getSwitch();\n      if (status > 0.0) {\n        var dColor = light.getColorByReference();\n        var intensity = light.getIntensity();\n        model.lightColor[0] = dColor[0] * intensity;\n        model.lightColor[1] = dColor[1] * intensity;\n        model.lightColor[2] = dColor[2] * intensity; // get required info from light\n\n        var ld = light.getDirection();\n        var transform = ren.getActiveCamera().getViewMatrix();\n        var newLightDirection = _toConsumableArray(ld);\n        if (light.lightTypeIsSceneLight()) {\n          newLightDirection[0] = transform[0] * ld[0] + transform[1] * ld[1] + transform[2] * ld[2];\n          newLightDirection[1] = transform[4] * ld[0] + transform[5] * ld[1] + transform[6] * ld[2];\n          newLightDirection[2] = transform[8] * ld[0] + transform[9] * ld[1] + transform[10] * ld[2];\n          normalize(newLightDirection);\n        }\n        model.lightDirection[0] = newLightDirection[0];\n        model.lightDirection[1] = newLightDirection[1];\n        model.lightDirection[2] = newLightDirection[2];\n        normalize(model.lightDirection);\n        program.setUniform3fArray(\"lightColor\".concat(numberOfLights), model.lightColor);\n        program.setUniform3fArray(\"lightDirectionVC\".concat(numberOfLights), model.lightDirection);\n        numberOfLights++;\n      }\n    } // we are done unless we have positional lights\n\n    if (lastLightComplexity < 3) {\n      return;\n    } // for lightkit case there are some parameters to set\n\n    var cam = ren.getActiveCamera();\n    var viewTF = cam.getViewMatrix();\n    mat4.transpose(viewTF, viewTF);\n    numberOfLights = 0;\n    for (var _index = 0; _index < lights.length; ++_index) {\n      var _light = lights[_index];\n      var _status = _light.getSwitch();\n      if (_status > 0.0) {\n        var lp = _light.getTransformedPosition();\n        var np = new Float64Array(3);\n        vec3.transformMat4(np, lp, viewTF);\n        program.setUniform3fArray(\"lightAttenuation\".concat(numberOfLights), _light.getAttenuationValuesByReference());\n        program.setUniformi(\"lightPositional\".concat(numberOfLights), _light.getPositional());\n        program.setUniformf(\"lightExponent\".concat(numberOfLights), _light.getExponent());\n        program.setUniformf(\"lightConeAngle\".concat(numberOfLights), _light.getConeAngle());\n        program.setUniform3fArray(\"lightPositionVC\".concat(numberOfLights), [np[0], np[1], np[2]]);\n        numberOfLights++;\n      }\n    }\n  };\n  function safeMatrixMultiply(matrixArray, matrixType, tmpMat) {\n    matrixType.identity(tmpMat);\n    return matrixArray.reduce(function (res, matrix, index) {\n      if (index === 0) {\n        return matrix ? matrixType.copy(res, matrix) : matrixType.identity(res);\n      }\n      return matrix ? matrixType.multiply(res, res, matrix) : res;\n    }, tmpMat);\n  }\n  publicAPI.setCameraShaderParameters = function (cellBO, ren, actor) {\n    var program = cellBO.getProgram(); // [WMVP]C == {world, model, view, projection} coordinates\n    // E.g., WCPC == world to projection coordinate transformation\n\n    var keyMats = model.openGLCamera.getKeyMatrices(ren);\n    var cam = ren.getActiveCamera();\n    var camm = model.openGLCamera.getKeyMatrixTime().getMTime();\n    var progm = program.getLastCameraMTime();\n    var shiftScaleEnabled = cellBO.getCABO().getCoordShiftAndScaleEnabled();\n    var inverseShiftScaleMatrix = shiftScaleEnabled ? cellBO.getCABO().getInverseShiftAndScaleMatrix() : null;\n    var actorIsIdentity = actor.getIsIdentity();\n    var actMats = actorIsIdentity ? {\n      mcwc: null,\n      normalMatrix: null\n    } : model.openGLActor.getKeyMatrices();\n    if (actor.getCoordinateSystem() === CoordinateSystem.DISPLAY) {\n      var size = model._openGLRenderer.getTiledSizeAndOrigin();\n      mat4.identity(model.tmpMat4);\n      model.tmpMat4[0] = 2.0 / size.usize;\n      model.tmpMat4[12] = -1.0;\n      model.tmpMat4[5] = 2.0 / size.vsize;\n      model.tmpMat4[13] = -1.0;\n      mat4.multiply(model.tmpMat4, model.tmpMat4, inverseShiftScaleMatrix);\n      program.setUniformMatrix('MCPCMatrix', model.tmpMat4);\n    } else {\n      program.setUniformMatrix('MCPCMatrix', safeMatrixMultiply([keyMats.wcpc, actMats.mcwc, inverseShiftScaleMatrix], mat4, model.tmpMat4));\n    }\n    if (program.isUniformUsed('MCVCMatrix')) {\n      program.setUniformMatrix('MCVCMatrix', safeMatrixMultiply([keyMats.wcvc, actMats.mcwc, inverseShiftScaleMatrix], mat4, model.tmpMat4));\n    }\n    if (program.isUniformUsed('normalMatrix')) {\n      program.setUniformMatrix3x3('normalMatrix', safeMatrixMultiply([keyMats.normalMatrix, actMats.normalMatrix], mat3, model.tmpMat3));\n    }\n    if (progm !== camm) {\n      if (program.isUniformUsed('cameraParallel')) {\n        program.setUniformi('cameraParallel', cam.getParallelProjection());\n      }\n      program.setLastCameraMTime(camm);\n    }\n    if (!actorIsIdentity) {\n      // reset the cam mtime as actor modified the shader values\n      program.setLastCameraMTime(0);\n    }\n  };\n  publicAPI.setPropertyShaderParameters = function (cellBO, ren, actor) {\n    var program = cellBO.getProgram();\n    var ppty = actor.getProperty();\n    var opacity = ppty.getOpacity();\n    var aColor = model.drawingEdges ? ppty.getEdgeColorByReference() : ppty.getAmbientColorByReference();\n    var dColor = model.drawingEdges ? ppty.getEdgeColorByReference() : ppty.getDiffuseColorByReference();\n    var aIntensity = model.drawingEdges ? 1.0 : ppty.getAmbient();\n    var dIntensity = model.drawingEdges ? 0.0 : ppty.getDiffuse();\n    var sIntensity = model.drawingEdges ? 0.0 : ppty.getSpecular();\n    var specularPower = ppty.getSpecularPower();\n    program.setUniformf('opacityUniform', opacity);\n    program.setUniform3fArray('ambientColorUniform', aColor);\n    program.setUniform3fArray('diffuseColorUniform', dColor);\n    program.setUniformf('ambient', aIntensity);\n    program.setUniformf('diffuse', dIntensity); // we are done unless we have lighting\n\n    var lastLightComplexity = model.lastBoundBO.getReferenceByName('lastLightComplexity');\n    if (lastLightComplexity < 1) {\n      return;\n    }\n    var sColor = ppty.getSpecularColorByReference();\n    program.setUniform3fArray('specularColorUniform', sColor);\n    program.setUniformf('specularPowerUniform', specularPower);\n    program.setUniformf('specular', sIntensity); // now set the backface properties if we have them\n\n    if (program.isUniformUsed('ambientIntensityBF')) {\n      ppty = actor.getBackfaceProperty();\n      opacity = ppty.getOpacity();\n      aColor = ppty.getAmbientColor();\n      aIntensity = ppty.getAmbient();\n      dColor = ppty.getDiffuseColor();\n      dIntensity = ppty.getDiffuse();\n      sColor = ppty.getSpecularColor();\n      sIntensity = ppty.getSpecular();\n      program.setUniformf('ambientIntensityBF', aIntensity);\n      program.setUniformf('diffuseIntensityBF', dIntensity);\n      program.setUniformf('opacityUniformBF', opacity);\n      program.setUniform3fArray('ambientColorUniformBF', aColor);\n      program.setUniform3fArray('diffuseColorUniformBF', dColor); // we are done unless we have lighting\n\n      if (lastLightComplexity < 1) {\n        return;\n      }\n      program.setUniformf('specularIntensityBF', sIntensity);\n      program.setUniform3fArray('specularColorUniformBF', sColor);\n      program.setUniformf('specularPowerUniformBF', specularPower);\n    }\n  };\n  publicAPI.updateMaximumPointCellIds = function (ren, actor) {\n    var _model$selectionWebGL, _model$selectionWebGL2, _model$selectionWebGL3, _model$selectionWebGL4;\n    var selector = model._openGLRenderer.getSelector();\n    if (!selector) {\n      return;\n    }\n    if ((_model$selectionWebGL = model.selectionWebGLIdsToVTKIds) !== null && _model$selectionWebGL !== void 0 && (_model$selectionWebGL2 = _model$selectionWebGL.points) !== null && _model$selectionWebGL2 !== void 0 && _model$selectionWebGL2.length) {\n      var length = model.selectionWebGLIdsToVTKIds.points.length;\n      selector.setMaximumPointId(length - 1);\n    }\n    if ((_model$selectionWebGL3 = model.selectionWebGLIdsToVTKIds) !== null && _model$selectionWebGL3 !== void 0 && (_model$selectionWebGL4 = _model$selectionWebGL3.cells) !== null && _model$selectionWebGL4 !== void 0 && _model$selectionWebGL4.length) {\n      var _length = model.selectionWebGLIdsToVTKIds.cells.length;\n      selector.setMaximumCellId(_length - 1);\n    }\n    var fieldAssociation = selector.getFieldAssociation();\n    if (fieldAssociation === FieldAssociations.FIELD_ASSOCIATION_POINTS) {\n      model.pointPicking = true;\n    }\n  };\n  publicAPI.renderPieceStart = function (ren, actor) {\n    model.primitiveIDOffset = 0;\n    model.vertexIDOffset = 0;\n    var picking = getPickState(model._openGLRenderer);\n    if (model.lastSelectionState !== picking) {\n      model.selectionStateChanged.modified();\n      model.lastSelectionState = picking;\n    }\n    if (model._openGLRenderer.getSelector()) {\n      switch (picking) {\n        default:\n          model._openGLRenderer.getSelector().renderProp(actor);\n      }\n    } // make sure the BOs are up to date\n\n    publicAPI.updateBufferObjects(ren, actor); // If we are coloring by texture, then load the texture map.\n    // Use Map as indicator, because texture hangs around.\n\n    if (model.renderable.getColorTextureMap()) {\n      model.internalColorTexture.activate();\n    } // Bind the OpenGL, this is shared between the different primitive/cell types.\n\n    model.lastBoundBO = null;\n  };\n  publicAPI.renderPieceDraw = function (ren, actor) {\n    var representation = actor.getProperty().getRepresentation();\n    var drawSurfaceWithEdges = actor.getProperty().getEdgeVisibility() && representation === Representation.SURFACE;\n    var selector = model._openGLRenderer.getSelector(); // If we are picking points, we need to tell it to the helper\n\n    var pointPicking = selector && selector.getFieldAssociation() === FieldAssociations.FIELD_ASSOCIATION_POINTS && (model.lastSelectionState === PassTypes.ID_LOW24 || model.lastSelectionState === PassTypes.ID_HIGH24); // for every primitive type\n\n    for (var i = primTypes.Start; i < primTypes.End; i++) {\n      model.primitives[i].setPointPicking(pointPicking);\n      var cabo = model.primitives[i].getCABO();\n      if (cabo.getElementCount()) {\n        // are we drawing edges\n        model.drawingEdges = drawSurfaceWithEdges && (i === primTypes.TrisEdges || i === primTypes.TriStripsEdges); // don't draw edges when rendering depth or rendering for picking\n\n        if (!model.drawingEdges || !(model.renderDepth || model.lastSelectionState >= 0)) {\n          model.lastBoundBO = model.primitives[i];\n          model.primitiveIDOffset += model.primitives[i].drawArrays(ren, actor, representation, publicAPI);\n          model.vertexIDOffset += model.primitives[i].getCABO().getElementCount();\n        }\n      }\n    }\n  };\n  publicAPI.renderPieceFinish = function (ren, actor) {\n    if (model.LastBoundBO) {\n      model.LastBoundBO.getVAO().release();\n    }\n    if (model.renderable.getColorTextureMap()) {\n      model.internalColorTexture.deactivate();\n    }\n  };\n  publicAPI.renderPiece = function (ren, actor) {\n    // Make sure that we have been properly initialized.\n    // if (ren.getRenderWindow().checkAbortStatus()) {\n    //   return;\n    // }\n    publicAPI.invokeEvent(StartEvent);\n    if (!model.renderable.getStatic()) {\n      model.renderable.update();\n    }\n    model.currentInput = model.renderable.getInputData();\n    publicAPI.invokeEvent(EndEvent);\n    if (!model.currentInput) {\n      vtkErrorMacro('No input!');\n      return;\n    } // if there are no points then we are done\n\n    if (!model.currentInput.getPoints || !model.currentInput.getPoints().getNumberOfValues()) {\n      return;\n    } // apply faceCulling\n\n    var gl = model.context;\n    var backfaceCulling = actor.getProperty().getBackfaceCulling();\n    var frontfaceCulling = actor.getProperty().getFrontfaceCulling();\n    if (!backfaceCulling && !frontfaceCulling) {\n      model._openGLRenderWindow.disableCullFace();\n    } else if (frontfaceCulling) {\n      model._openGLRenderWindow.enableCullFace();\n      gl.cullFace(gl.FRONT);\n    } else {\n      model._openGLRenderWindow.enableCullFace();\n      gl.cullFace(gl.BACK);\n    }\n    publicAPI.renderPieceStart(ren, actor);\n    publicAPI.renderPieceDraw(ren, actor);\n    publicAPI.renderPieceFinish(ren, actor);\n  };\n  publicAPI.computeBounds = function (ren, actor) {\n    if (!publicAPI.getInput()) {\n      uninitializeBounds(model.bounds);\n      return;\n    }\n    model.bounds = publicAPI.getInput().getBounds();\n  };\n  publicAPI.updateBufferObjects = function (ren, actor) {\n    // Rebuild buffers if needed\n    if (publicAPI.getNeedToRebuildBufferObjects(ren, actor)) {\n      publicAPI.buildBufferObjects(ren, actor);\n    }\n  };\n  publicAPI.getNeedToRebuildBufferObjects = function (ren, actor) {\n    // first do a coarse check\n    // Note that the actor's mtime includes it's properties mtime\n    var vmtime = model.VBOBuildTime.getMTime();\n    if (vmtime < publicAPI.getMTime() || vmtime < model.renderable.getMTime() || vmtime < actor.getMTime() || vmtime < model.currentInput.getMTime()) {\n      return true;\n    }\n    return false;\n  };\n  publicAPI.buildBufferObjects = function (ren, actor) {\n    var poly = model.currentInput;\n    if (poly === null) {\n      return;\n    }\n    model.renderable.mapScalars(poly, 1.0);\n    var c = model.renderable.getColorMapColors();\n    model.haveCellScalars = false;\n    var scalarMode = model.renderable.getScalarMode();\n    if (model.renderable.getScalarVisibility()) {\n      // We must figure out how the scalars should be mapped to the polydata.\n      if ((scalarMode === ScalarMode.USE_CELL_DATA || scalarMode === ScalarMode.USE_CELL_FIELD_DATA || scalarMode === ScalarMode.USE_FIELD_DATA || !poly.getPointData().getScalars()) && scalarMode !== ScalarMode.USE_POINT_FIELD_DATA && c) {\n        model.haveCellScalars = true;\n      }\n    } // Do we have normals?\n\n    var n = actor.getProperty().getInterpolation() !== Shading.FLAT ? poly.getPointData().getNormals() : null;\n    if (n === null && poly.getCellData().getNormals()) {\n      model.haveCellNormals = true;\n      n = poly.getCellData().getNormals();\n    } // rebuild the VBO if the data has changed we create a string for the VBO what\n    // can change the VBO? points normals tcoords colors so what can change those?\n    // the input data is clearly one as it can change all four items tcoords may\n    // haveTextures or not colors may change based on quite a few mapping\n    // parameters in the mapper\n\n    var representation = actor.getProperty().getRepresentation();\n    var tcoords = poly.getPointData().getTCoords();\n    if (!model.openGLActor.getActiveTextures()) {\n      tcoords = null;\n    } // handle color mapping via texture\n\n    if (model.renderable.getColorCoordinates()) {\n      tcoords = model.renderable.getColorCoordinates();\n      if (!model.internalColorTexture) {\n        model.internalColorTexture = vtkOpenGLTexture.newInstance({\n          resizable: true\n        });\n      }\n      var tex = model.internalColorTexture; // the following 4 lines allow for NPOT textures\n\n      tex.setMinificationFilter(Filter.NEAREST);\n      tex.setMagnificationFilter(Filter.NEAREST);\n      tex.setWrapS(Wrap.CLAMP_TO_EDGE);\n      tex.setWrapT(Wrap.CLAMP_TO_EDGE);\n      tex.setOpenGLRenderWindow(model._openGLRenderWindow);\n      var input = model.renderable.getColorTextureMap();\n      var ext = input.getExtent();\n      var inScalars = input.getPointData().getScalars();\n      tex.create2DFromRaw(ext[1] - ext[0] + 1, ext[3] - ext[2] + 1, inScalars.getNumberOfComponents(), inScalars.getDataType(), inScalars.getData());\n      tex.activate();\n      tex.sendParameters();\n      tex.deactivate();\n    }\n    var toString = \"\".concat(poly.getMTime(), \"A\").concat(representation, \"B\").concat(poly.getMTime()) + \"C\".concat(n ? n.getMTime() : 1, \"D\").concat(c ? c.getMTime() : 1) + \"E\".concat(actor.getProperty().getEdgeVisibility()) + \"F\".concat(tcoords ? tcoords.getMTime() : 1);\n    if (model.VBOBuildString !== toString) {\n      // Build the VBOs\n      var points = poly.getPoints();\n      var options = {\n        points: points,\n        normals: n,\n        tcoords: tcoords,\n        colors: c,\n        cellOffset: 0,\n        vertexOffset: 0,\n        // Used to keep track of vertex ids across primitives for selection\n        haveCellScalars: model.haveCellScalars,\n        haveCellNormals: model.haveCellNormals,\n        customAttributes: model.renderable.getCustomShaderAttributes().map(function (arrayName) {\n          return poly.getPointData().getArrayByName(arrayName);\n        })\n      };\n      if (model.renderable.getPopulateSelectionSettings()) {\n        model.selectionWebGLIdsToVTKIds = {\n          points: null,\n          cells: null\n        };\n      }\n      var primitives = [{\n        inRep: 'verts',\n        cells: poly.getVerts()\n      }, {\n        inRep: 'lines',\n        cells: poly.getLines()\n      }, {\n        inRep: 'polys',\n        cells: poly.getPolys()\n      }, {\n        inRep: 'strips',\n        cells: poly.getStrips()\n      }, {\n        inRep: 'polys',\n        cells: poly.getPolys()\n      }, {\n        inRep: 'strips',\n        cells: poly.getStrips()\n      }];\n      var drawSurfaceWithEdges = actor.getProperty().getEdgeVisibility() && representation === Representation.SURFACE;\n      for (var i = primTypes.Start; i < primTypes.End; i++) {\n        if (i !== primTypes.TrisEdges && i !== primTypes.TriStripsEdges) {\n          options.cellOffset += model.primitives[i].getCABO().createVBO(primitives[i].cells, primitives[i].inRep, representation, options, model.selectionWebGLIdsToVTKIds);\n          options.vertexOffset += model.primitives[i].getCABO().getElementCount();\n        } else {\n          // if we have edge visibility build the edge VBOs\n          if (drawSurfaceWithEdges) {\n            // VBOs for edges in \"surface with edges\" are the last to be built,\n            // they are not used when picking with a hardware selector so they\n            // don't need selectionWebGLIdsToVTKIds and don't update cellOffset and vertexOffset\n            model.primitives[i].getCABO().createVBO(primitives[i].cells, primitives[i].inRep, Representation.WIREFRAME, _objectSpread(_objectSpread({}, options), {}, {\n              tcoords: null,\n              colors: null,\n              haveCellScalars: false,\n              haveCellNormals: false\n            }));\n          } else {\n            // otherwise free them\n            model.primitives[i].releaseGraphicsResources();\n          }\n        }\n      }\n      if (model.renderable.getPopulateSelectionSettings()) {\n        model.renderable.setSelectionWebGLIdsToVTKIds(model.selectionWebGLIdsToVTKIds);\n        publicAPI.updateMaximumPointCellIds();\n      }\n      model.VBOBuildTime.modified();\n      model.VBOBuildString = toString;\n    }\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nvar DEFAULT_VALUES = {\n  context: null,\n  VBOBuildTime: 0,\n  VBOBuildString: null,\n  primitives: null,\n  primTypes: null,\n  shaderRebuildString: null,\n  tmpMat4: null,\n  ambientColor: [],\n  // used internally\n  diffuseColor: [],\n  // used internally\n  specularColor: [],\n  // used internally\n  lightColor: [],\n  // used internally\n  lightDirection: [],\n  // used internally\n  lastHaveSeenDepthRequest: false,\n  haveSeenDepthRequest: false,\n  lastSelectionState: PassTypes.MIN_KNOWN_PASS - 1,\n  selectionStateChanged: null,\n  selectionWebGLIdsToVTKIds: null,\n  pointPicking: false\n}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Inheritance\n\n  vtkViewNode.extend(publicAPI, model, initialValues);\n  vtkReplacementShaderMapper.implementReplaceShaderCoincidentOffset(publicAPI, model, initialValues);\n  vtkReplacementShaderMapper.implementBuildShadersWithReplacements(publicAPI, model, initialValues);\n  model.primitives = [];\n  model.primTypes = primTypes;\n  model.tmpMat3 = mat3.identity(new Float64Array(9));\n  model.tmpMat4 = mat4.identity(new Float64Array(16));\n  for (var i = primTypes.Start; i < primTypes.End; i++) {\n    model.primitives[i] = vtkHelper.newInstance();\n    model.primitives[i].setPrimitiveType(i);\n    model.primitives[i].set({\n      lastLightComplexity: 0,\n      lastLightCount: 0,\n      lastSelectionPass: false\n    }, true);\n  } // Build VTK API\n\n  setGet(publicAPI, model, ['context']);\n  model.VBOBuildTime = {};\n  obj(model.VBOBuildTime, {\n    mtime: 0\n  });\n  model.selectionStateChanged = {};\n  obj(model.selectionStateChanged, {\n    mtime: 0\n  }); // Object methods\n\n  vtkOpenGLPolyDataMapper(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = newInstance$1(extend, 'vtkOpenGLPolyDataMapper'); // ----------------------------------------------------------------------------\n\nvar vtkOpenGLPolyDataMapper$1 = {\n  newInstance: newInstance,\n  extend: extend\n}; // Register ourself to OpenGL backend if imported\n\nregisterOverride('vtkMapper', newInstance);\nexport { vtkOpenGLPolyDataMapper$1 as default, extend, newInstance };","map":{"version":3,"names":["_defineProperty","_toConsumableArray","mat3","mat4","vec3","newInstance","newInstance$1","setGet","obj","vtkErrorMacro","vtkErrorMacro$1","vtkHelper","vtkMapper","l","normalize","u","uninitializeBounds","vtkOpenGLTexture","vtkProp","vtkProperty","vtkShaderProgram","vtkViewNode","v","vtkPolyDataVS","vtkPolyDataFS","vtkReplacementShaderMapper","registerOverride","PassTypes","vtkDataSet","ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","getOwnPropertyDescriptors","defineProperties","defineProperty","FieldAssociations","primTypes","Representation","Shading","ScalarMode","Filter","Wrap","StartEvent","type","EndEvent","CoordinateSystem","getPickState","renderer","selector","getSelector","getCurrentPass","MIN_KNOWN_PASS","vtkOpenGLPolyDataMapper","publicAPI","model","classHierarchy","buildPass","prepass","currentRenderPass","openGLActor","getFirstAncestorOfType","_openGLRenderer","_openGLRenderWindow","getParent","openGLCamera","getViewNodeFor","getRenderable","getActiveCamera","translucentPass","renderPass","render","zBufferPass","haveSeenDepthRequest","renderDepth","opaqueZBufferPass","opaquePass","ctx","getContext","context","Start","End","primitives","setOpenGLRenderWindow","actor","ren","renderPiece","getShaderTemplate","shaders","Vertex","Fragment","Geometry","replaceShaderColor","VSSource","GSSource","FSSource","lastLightComplexity","lastBoundBO","getReferenceByName","colorDec","concat","colorImpl","getCABO","getColorComponents","drawingEdges","substitute","result","renderable","getInterpolateScalarsBeforeMapping","getColorCoordinates","getBackfaceProperty","haveCellScalars","replaceShaderLight","shadowFactor","lastLightCount","sstring","lc","_lc","_lc2","_lc3","replaceShaderNormal","getNormalOffset","haveCellNormals","getOpenGLMode","getProperty","getRepresentation","LINES","replaceShaderPositionVC","replaceShaderTCoord","getTCoordOffset","tus","getActiveTextures","tNumComp","tcdim","getComponents","getTarget","TEXTURE_CUBE_MAP","getColorTextureMap","getPointData","getScalars","getNumberOfComponents","replaceShaderClip","getNumberOfClippingPlanes","numClipPlanes","getCoincidentParameters","cp","factor","offset","prop","getResolveCoincidentTopology","getEdgeVisibility","SURFACE","primType","getPrimitiveType","Points","POINTS","getCoincidentTopologyPointOffsetParameter","Lines","WIREFRAME","getCoincidentTopologyLineOffsetParameters","Tris","TriStrips","getCoincidentTopologyPolygonOffsetParameters","TrisEdges","TriStripsEdges","getFieldAssociation","FIELD_ASSOCIATION_POINTS","replaceShaderPicking","lastSelectionState","ID_LOW24","ID_HIGH24","replaceShaderValues","replaceShaderCoincidentOffset","getNeedToRebuildShaders","cellBO","lightComplexity","numberOfLights","poly","currentInput","needLighting","pointNormals","getNormals","cellNormals","getCellData","flat","getInterpolation","FLAT","representation","mode","TRIANGLES","getLighting","lights","getLightsByReference","index","light","status","getSwitch","getIntensity","lightTypeIsHeadLight","getPositional","needRebuild","set","lastRenderPassShaderReplacement","getShaderReplacement","lastHaveSeenDepthRequest","getShaderSourceTime","getMTime","selectionStateChanged","invokeShaderCallbacks","listCallbacks","getViewSpecificProperties","ShadersCallbacks","callback","userData","setMapperShaderParameters","getProgram","isUniformUsed","setUniformi","primitiveIDOffset","vertexIDOffset","getElementCount","VBOBuildTime","getAttributeUpdateTime","isAttributeUsed","getVAO","addAttributeArray","getVertexOffset","getStride","FLOAT","removeAttributeArray","getCustomShaderAttributes","attrName","idx","getCustomData","components","getTCoordComponents","getColorBO","getColorOffset","getColorBOStride","UNSIGNED_BYTE","modified","planeEquations","shiftScaleEnabled","getCoordShiftAndScaleEnabled","inverseShiftScaleMatrix","getInverseShiftAndScaleMatrix","mat","copy","tmpMat4","getMatrix","transpose","multiply","planeEquation","getClippingPlaneInDataCoords","j","setUniform4fv","internalColorTexture","getTextureUnit","tex","texUnit","tname","setUniformf","getTiledSizeAndOrigin","setUniform3fArray","getPropColorValue","setLightingShaderParameters","program","dColor","getColorByReference","intensity","lightColor","ld","getDirection","transform","getViewMatrix","newLightDirection","lightTypeIsSceneLight","lightDirection","cam","viewTF","_index","_light","_status","lp","getTransformedPosition","np","Float64Array","transformMat4","getAttenuationValuesByReference","getExponent","getConeAngle","safeMatrixMultiply","matrixArray","matrixType","tmpMat","identity","reduce","res","matrix","setCameraShaderParameters","keyMats","getKeyMatrices","camm","getKeyMatrixTime","progm","getLastCameraMTime","actorIsIdentity","getIsIdentity","actMats","mcwc","normalMatrix","getCoordinateSystem","DISPLAY","size","usize","vsize","setUniformMatrix","wcpc","wcvc","setUniformMatrix3x3","tmpMat3","getParallelProjection","setLastCameraMTime","setPropertyShaderParameters","ppty","opacity","getOpacity","aColor","getEdgeColorByReference","getAmbientColorByReference","getDiffuseColorByReference","aIntensity","getAmbient","dIntensity","getDiffuse","sIntensity","getSpecular","specularPower","getSpecularPower","sColor","getSpecularColorByReference","getAmbientColor","getDiffuseColor","getSpecularColor","updateMaximumPointCellIds","_model$selectionWebGL","_model$selectionWebGL2","_model$selectionWebGL3","_model$selectionWebGL4","selectionWebGLIdsToVTKIds","points","setMaximumPointId","cells","_length","setMaximumCellId","fieldAssociation","pointPicking","renderPieceStart","picking","renderProp","updateBufferObjects","activate","renderPieceDraw","drawSurfaceWithEdges","setPointPicking","cabo","drawArrays","renderPieceFinish","LastBoundBO","release","deactivate","invokeEvent","getStatic","update","getInputData","getPoints","getNumberOfValues","gl","backfaceCulling","getBackfaceCulling","frontfaceCulling","getFrontfaceCulling","disableCullFace","enableCullFace","cullFace","FRONT","BACK","computeBounds","getInput","bounds","getBounds","getNeedToRebuildBufferObjects","buildBufferObjects","vmtime","mapScalars","c","getColorMapColors","scalarMode","getScalarMode","getScalarVisibility","USE_CELL_DATA","USE_CELL_FIELD_DATA","USE_FIELD_DATA","USE_POINT_FIELD_DATA","n","tcoords","getTCoords","resizable","setMinificationFilter","NEAREST","setMagnificationFilter","setWrapS","CLAMP_TO_EDGE","setWrapT","input","ext","getExtent","inScalars","create2DFromRaw","getDataType","getData","sendParameters","toString","VBOBuildString","options","normals","colors","cellOffset","vertexOffset","customAttributes","map","arrayName","getArrayByName","getPopulateSelectionSettings","inRep","getVerts","getLines","getPolys","getStrips","createVBO","releaseGraphicsResources","setSelectionWebGLIdsToVTKIds","DEFAULT_VALUES","shaderRebuildString","ambientColor","diffuseColor","specularColor","extend","initialValues","undefined","assign","implementReplaceShaderCoincidentOffset","implementBuildShadersWithReplacements","setPrimitiveType","lastSelectionPass","mtime","vtkOpenGLPolyDataMapper$1","default"],"sources":["/home/rakshith/Documents/RemoteRendering/vtk-js-react-app/node_modules/@kitware/vtk.js/Rendering/OpenGL/PolyDataMapper.js"],"sourcesContent":["import _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport _toConsumableArray from '@babel/runtime/helpers/toConsumableArray';\nimport { mat3, mat4, vec3 } from 'gl-matrix';\nimport { newInstance as newInstance$1, setGet, obj, vtkErrorMacro as vtkErrorMacro$1 } from '../../macros.js';\nimport vtkHelper from './Helper.js';\nimport vtkMapper from '../Core/Mapper.js';\nimport { l as normalize, u as uninitializeBounds } from '../../Common/Core/Math/index.js';\nimport vtkOpenGLTexture from './Texture.js';\nimport vtkProp from '../Core/Prop.js';\nimport vtkProperty from '../Core/Property.js';\nimport vtkShaderProgram from './ShaderProgram.js';\nimport vtkViewNode from '../SceneGraph/ViewNode.js';\nimport { v as vtkPolyDataVS } from './glsl/vtkPolyDataVS.glsl.js';\nimport { v as vtkPolyDataFS } from './glsl/vtkPolyDataFS.glsl.js';\nimport vtkReplacementShaderMapper from './ReplacementShaderMapper.js';\nimport { registerOverride } from './ViewNodeFactory.js';\nimport { PassTypes } from './HardwareSelector/Constants.js';\nimport vtkDataSet from '../../Common/DataModel/DataSet.js';\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nvar FieldAssociations = vtkDataSet.FieldAssociations;\n/* eslint-disable no-lonely-if */\n\nvar primTypes = vtkHelper.primTypes;\nvar Representation = vtkProperty.Representation,\n    Shading = vtkProperty.Shading;\nvar ScalarMode = vtkMapper.ScalarMode;\nvar Filter = vtkOpenGLTexture.Filter,\n    Wrap = vtkOpenGLTexture.Wrap;\nvar vtkErrorMacro = vtkErrorMacro$1;\nvar StartEvent = {\n  type: 'StartEvent'\n};\nvar EndEvent = {\n  type: 'EndEvent'\n};\nvar CoordinateSystem = vtkProp.CoordinateSystem; // ----------------------------------------------------------------------------\n// vtkOpenGLPolyDataMapper methods\n// ----------------------------------------------------------------------------\n\nfunction getPickState(renderer) {\n  var selector = renderer.getSelector();\n\n  if (selector) {\n    return selector.getCurrentPass();\n  }\n\n  return PassTypes.MIN_KNOWN_PASS - 1;\n}\n\nfunction vtkOpenGLPolyDataMapper(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkOpenGLPolyDataMapper');\n\n  publicAPI.buildPass = function (prepass) {\n    if (prepass) {\n      model.currentRenderPass = null;\n      model.openGLActor = publicAPI.getFirstAncestorOfType('vtkOpenGLActor');\n      model._openGLRenderer = model.openGLActor.getFirstAncestorOfType('vtkOpenGLRenderer');\n      model._openGLRenderWindow = model._openGLRenderer.getParent();\n      model.openGLCamera = model._openGLRenderer.getViewNodeFor(model._openGLRenderer.getRenderable().getActiveCamera());\n    }\n  }; // Renders myself\n\n\n  publicAPI.translucentPass = function (prepass, renderPass) {\n    if (prepass) {\n      model.currentRenderPass = renderPass;\n      publicAPI.render();\n    }\n  };\n\n  publicAPI.zBufferPass = function (prepass) {\n    if (prepass) {\n      model.haveSeenDepthRequest = true;\n      model.renderDepth = true;\n      publicAPI.render();\n      model.renderDepth = false;\n    }\n  };\n\n  publicAPI.opaqueZBufferPass = function (prepass) {\n    return publicAPI.zBufferPass(prepass);\n  };\n\n  publicAPI.opaquePass = function (prepass) {\n    if (prepass) {\n      publicAPI.render();\n    }\n  };\n\n  publicAPI.render = function () {\n    var ctx = model._openGLRenderWindow.getContext();\n\n    if (model.context !== ctx) {\n      model.context = ctx;\n\n      for (var i = primTypes.Start; i < primTypes.End; i++) {\n        model.primitives[i].setOpenGLRenderWindow(model._openGLRenderWindow);\n      }\n    }\n\n    var actor = model.openGLActor.getRenderable();\n\n    var ren = model._openGLRenderer.getRenderable();\n\n    publicAPI.renderPiece(ren, actor);\n  };\n\n  publicAPI.getShaderTemplate = function (shaders, ren, actor) {\n    shaders.Vertex = vtkPolyDataVS;\n    shaders.Fragment = vtkPolyDataFS;\n    shaders.Geometry = '';\n  };\n\n  publicAPI.replaceShaderColor = function (shaders, ren, actor) {\n    var VSSource = shaders.Vertex;\n    var GSSource = shaders.Geometry;\n    var FSSource = shaders.Fragment;\n    var lastLightComplexity = model.lastBoundBO.getReferenceByName('lastLightComplexity'); // create the material/color property declarations, and VS implementation\n    // these are always defined\n\n    var colorDec = ['uniform float ambient;', 'uniform float diffuse;', 'uniform float specular;', 'uniform float opacityUniform; // the fragment opacity', 'uniform vec3 ambientColorUniform;', 'uniform vec3 diffuseColorUniform;']; // add more for specular\n\n    if (lastLightComplexity) {\n      colorDec = colorDec.concat(['uniform vec3 specularColorUniform;', 'uniform float specularPowerUniform;']);\n    } // now handle the more complex fragment shader implementation\n    // the following are always defined variables.  We start\n    // by assigning a default value from the uniform\n\n\n    var colorImpl = ['vec3 ambientColor;', '  vec3 diffuseColor;', '  float opacity;'];\n\n    if (lastLightComplexity) {\n      colorImpl = colorImpl.concat(['  vec3 specularColor;', '  float specularPower;']);\n    }\n\n    colorImpl = colorImpl.concat(['  ambientColor = ambientColorUniform;', '  diffuseColor = diffuseColorUniform;', '  opacity = opacityUniform;']);\n\n    if (lastLightComplexity) {\n      colorImpl = colorImpl.concat(['  specularColor = specularColorUniform;', '  specularPower = specularPowerUniform;']);\n    } // add scalar vertex coloring\n\n\n    if (model.lastBoundBO.getCABO().getColorComponents() !== 0 && !model.drawingEdges) {\n      colorDec = colorDec.concat(['varying vec4 vertexColorVSOutput;']);\n      VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::Color::Dec', ['attribute vec4 scalarColor;', 'varying vec4 vertexColorVSOutput;']).result;\n      VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::Color::Impl', ['vertexColorVSOutput =  scalarColor;']).result;\n      GSSource = vtkShaderProgram.substitute(GSSource, '//VTK::Color::Dec', ['in vec4 vertexColorVSOutput[];', 'out vec4 vertexColorGSOutput;']).result;\n      GSSource = vtkShaderProgram.substitute(GSSource, '//VTK::Color::Impl', ['vertexColorGSOutput = vertexColorVSOutput[i];']).result;\n    }\n\n    if (model.lastBoundBO.getCABO().getColorComponents() !== 0 && !model.drawingEdges) {\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Color::Impl', colorImpl.concat(['  diffuseColor = vertexColorVSOutput.rgb;', '  ambientColor = vertexColorVSOutput.rgb;', '  opacity = opacity*vertexColorVSOutput.a;'])).result;\n    } else {\n      if (model.renderable.getInterpolateScalarsBeforeMapping() && model.renderable.getColorCoordinates() && !model.drawingEdges) {\n        FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Color::Impl', colorImpl.concat(['  vec4 texColor = texture2D(texture1, tcoordVCVSOutput.st);', '  diffuseColor = texColor.rgb;', '  ambientColor = texColor.rgb;', '  opacity = opacity*texColor.a;'])).result;\n      } else {\n        if (actor.getBackfaceProperty() && !model.drawingEdges) {\n          colorDec = colorDec.concat(['uniform float opacityUniformBF; // the fragment opacity', 'uniform float ambientIntensityBF; // the material ambient', 'uniform float diffuseIntensityBF; // the material diffuse', 'uniform vec3 ambientColorUniformBF; // ambient material color', 'uniform vec3 diffuseColorUniformBF; // diffuse material color']);\n\n          if (lastLightComplexity) {\n            colorDec = colorDec.concat(['uniform float specularIntensityBF; // the material specular intensity', 'uniform vec3 specularColorUniformBF; // intensity weighted color', 'uniform float specularPowerUniformBF;']);\n            colorImpl = colorImpl.concat(['if (gl_FrontFacing == false) {', '  ambientColor = ambientIntensityBF * ambientColorUniformBF;', '  diffuseColor = diffuseIntensityBF * diffuseColorUniformBF;', '  specularColor = specularIntensityBF * specularColorUniformBF;', '  specularPower = specularPowerUniformBF;', '  opacity = opacityUniformBF; }']);\n          } else {\n            colorImpl = colorImpl.concat(['if (gl_FrontFacing == false) {', '  ambientColor = ambientIntensityBF * ambientColorUniformBF;', '  diffuseColor = diffuseIntensityBF * diffuseColorUniformBF;', '  opacity = opacityUniformBF; }']);\n          }\n        }\n\n        if (model.haveCellScalars && !model.drawingEdges) {\n          colorDec = colorDec.concat(['uniform samplerBuffer texture1;']);\n        }\n\n        FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Color::Impl', colorImpl).result;\n      }\n    }\n\n    FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Color::Dec', colorDec).result;\n    shaders.Vertex = VSSource;\n    shaders.Geometry = GSSource;\n    shaders.Fragment = FSSource;\n  };\n\n  publicAPI.replaceShaderLight = function (shaders, ren, actor) {\n    var FSSource = shaders.Fragment; // check for shadow maps\n\n    var shadowFactor = '';\n    var lastLightComplexity = model.lastBoundBO.getReferenceByName('lastLightComplexity');\n    var lastLightCount = model.lastBoundBO.getReferenceByName('lastLightCount');\n    var sstring = [];\n\n    switch (lastLightComplexity) {\n      case 0:\n        // no lighting or RENDER_VALUES\n        FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Light::Impl', ['  gl_FragData[0] = vec4(ambientColor * ambient + diffuseColor * diffuse, opacity);', '  //VTK::Light::Impl'], false).result;\n        break;\n\n      case 1:\n        // headlight\n        FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Light::Impl', ['  float df = max(0.0, normalVCVSOutput.z);', '  float sf = pow(df, specularPower);', '  vec3 diffuseL = df * diffuseColor;', '  vec3 specularL = sf * specularColor;', '  gl_FragData[0] = vec4(ambientColor * ambient + diffuseL * diffuse + specularL * specular, opacity);', '  //VTK::Light::Impl'], false).result;\n        break;\n\n      case 2:\n        // light kit\n        for (var lc = 0; lc < lastLightCount; ++lc) {\n          sstring = sstring.concat([\"uniform vec3 lightColor\".concat(lc, \";\"), \"uniform vec3 lightDirectionVC\".concat(lc, \"; // normalized\"), \"uniform vec3 lightHalfAngleVC\".concat(lc, \"; // normalized\")]);\n        }\n\n        FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Light::Dec', sstring).result;\n        sstring = ['vec3 diffuseL = vec3(0,0,0);', '  vec3 specularL = vec3(0,0,0);', '  float df;'];\n\n        for (var _lc = 0; _lc < lastLightCount; ++_lc) {\n          sstring = sstring.concat([\"  df = max(0.0, dot(normalVCVSOutput, -lightDirectionVC\".concat(_lc, \"));\"), \"  diffuseL += ((df\".concat(shadowFactor, \") * lightColor\").concat(_lc, \");\"), \"  if (dot(normalVCVSOutput, lightDirectionVC\".concat(_lc, \") < 0.0)\"), '    {', \"    float sf = sign(df)*pow(max(1e-5,\\n                                              dot(reflect(lightDirectionVC\".concat(_lc, \",normalVCVSOutput),\\n                                                  normalize(-vertexVC.xyz))),\\n                                         specularPower);\"), \"    specularL += (sf\".concat(shadowFactor, \" * lightColor\").concat(_lc, \");\"), '    }']);\n        }\n\n        sstring = sstring.concat(['  diffuseL = diffuseL * diffuseColor;', '  specularL = specularL * specularColor;', '  gl_FragData[0] = vec4(ambientColor * ambient + diffuseL * diffuse + specularL * specular, opacity);', '  //VTK::Light::Impl']);\n        FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Light::Impl', sstring, false).result;\n        break;\n\n      case 3:\n        // positional\n        for (var _lc2 = 0; _lc2 < lastLightCount; ++_lc2) {\n          sstring = sstring.concat([\"uniform vec3 lightColor\".concat(_lc2, \";\"), \"uniform vec3 lightDirectionVC\".concat(_lc2, \"; // normalized\"), \"uniform vec3 lightHalfAngleVC\".concat(_lc2, \"; // normalized\"), \"uniform vec3 lightPositionVC\".concat(_lc2, \";\"), \"uniform vec3 lightAttenuation\".concat(_lc2, \";\"), \"uniform float lightConeAngle\".concat(_lc2, \";\"), \"uniform float lightExponent\".concat(_lc2, \";\"), \"uniform int lightPositional\".concat(_lc2, \";\")]);\n        }\n\n        FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Light::Dec', sstring).result;\n        sstring = ['vec3 diffuseL = vec3(0,0,0);', '  vec3 specularL = vec3(0,0,0);', '  vec3 vertLightDirectionVC;', '  float attenuation;', '  float df;'];\n\n        for (var _lc3 = 0; _lc3 < lastLightCount; ++_lc3) {\n          sstring = sstring.concat(['  attenuation = 1.0;', \"  if (lightPositional\".concat(_lc3, \" == 0)\"), '    {', \"      vertLightDirectionVC = lightDirectionVC\".concat(_lc3, \";\"), '    }', '  else', '    {', \"    vertLightDirectionVC = vertexVC.xyz - lightPositionVC\".concat(_lc3, \";\"), '    float distanceVC = length(vertLightDirectionVC);', '    vertLightDirectionVC = normalize(vertLightDirectionVC);', '    attenuation = 1.0 /', \"      (lightAttenuation\".concat(_lc3, \".x\"), \"       + lightAttenuation\".concat(_lc3, \".y * distanceVC\"), \"       + lightAttenuation\".concat(_lc3, \".z * distanceVC * distanceVC);\"), '    // per OpenGL standard cone angle is 90 or less for a spot light', \"    if (lightConeAngle\".concat(_lc3, \" <= 90.0)\"), '      {', \"      float coneDot = dot(vertLightDirectionVC, lightDirectionVC\".concat(_lc3, \");\"), '      // if inside the cone', \"      if (coneDot >= cos(radians(lightConeAngle\".concat(_lc3, \")))\"), '        {', \"        attenuation = attenuation * pow(coneDot, lightExponent\".concat(_lc3, \");\"), '        }', '      else', '        {', '        attenuation = 0.0;', '        }', '      }', '    }', '    df = max(0.0, attenuation*dot(normalVCVSOutput, -vertLightDirectionVC));', \"    diffuseL += ((df\".concat(shadowFactor, \") * lightColor\").concat(_lc3, \");\"), '    if (dot(normalVCVSOutput, vertLightDirectionVC) < 0.0)', '      {', \"      float sf = sign(df)*attenuation*pow(max(1e-5,\\n                                                           dot(reflect(lightDirectionVC\".concat(_lc3, \",\\n                                                                       normalVCVSOutput),\\n                                                               normalize(-vertexVC.xyz))),\\n                                                       specularPower);\"), \"    specularL += ((sf\".concat(shadowFactor, \") * lightColor\").concat(_lc3, \");\"), '    }']);\n        }\n\n        sstring = sstring.concat(['  diffuseL = diffuseL * diffuseColor;', '  specularL = specularL * specularColor;', '  gl_FragData[0] = vec4(ambientColor * ambient + diffuseL * diffuse + specularL * specular, opacity);', '  //VTK::Light::Impl']);\n        FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Light::Impl', sstring, false).result;\n        break;\n\n      default:\n        vtkErrorMacro('bad light complexity');\n    }\n\n    shaders.Fragment = FSSource;\n  };\n\n  publicAPI.replaceShaderNormal = function (shaders, ren, actor) {\n    var lastLightComplexity = model.lastBoundBO.getReferenceByName('lastLightComplexity');\n\n    if (lastLightComplexity > 0) {\n      var VSSource = shaders.Vertex;\n      var GSSource = shaders.Geometry;\n      var FSSource = shaders.Fragment;\n\n      if (model.lastBoundBO.getCABO().getNormalOffset()) {\n        VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::Normal::Dec', ['attribute vec3 normalMC;', 'uniform mat3 normalMatrix;', 'varying vec3 normalVCVSOutput;']).result;\n        VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::Normal::Impl', ['normalVCVSOutput = normalMatrix * normalMC;']).result;\n        GSSource = vtkShaderProgram.substitute(GSSource, '//VTK::Normal::Dec', ['in vec3 normalVCVSOutput[];', 'out vec3 normalVCGSOutput;']).result;\n        GSSource = vtkShaderProgram.substitute(GSSource, '//VTK::Normal::Impl', ['normalVCGSOutput = normalVCVSOutput[i];']).result;\n        FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Normal::Dec', ['varying vec3 normalVCVSOutput;']).result;\n        FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Normal::Impl', ['vec3 normalVCVSOutput = normalize(normalVCVSOutput);', //  if (!gl_FrontFacing) does not work in intel hd4000 mac\n        //  if (int(gl_FrontFacing) == 0) does not work on mesa\n        '  if (gl_FrontFacing == false) { normalVCVSOutput = -normalVCVSOutput; }']).result;\n      } else {\n        if (model.haveCellNormals) {\n          FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Normal::Dec', ['uniform mat3 normalMatrix;', 'uniform samplerBuffer textureN;']).result;\n          FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Normal::Impl', ['vec3 normalVCVSOutput = normalize(normalMatrix *', '    texelFetchBuffer(textureN, gl_PrimitiveID + PrimitiveIDOffset).xyz);', '  if (gl_FrontFacing == false) { normalVCVSOutput = -normalVCVSOutput; }']).result;\n        } else {\n          if (model.lastBoundBO.getOpenGLMode(actor.getProperty().getRepresentation()) === model.context.LINES) {\n            // generate a normal for lines, it will be perpendicular to the line\n            // and maximally aligned with the camera view direction\n            // no clue if this is the best way to do this.\n            // the code below has been optimized a bit so what follows is\n            // an explanation of the basic approach. Compute the gradient of the line\n            // with respect to x and y, the the larger of the two\n            // cross that with the camera view direction. That gives a vector\n            // orthogonal to the camera view and the line. Note that the line and the camera\n            // view are probably not orthogonal. Which is why when we cross result that with\n            // the line gradient again we get a reasonable normal. It will be othogonal to\n            // the line (which is a plane but maximally aligned with the camera view.\n            FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::UniformFlow::Impl', ['  vec3 fdx = dFdx(vertexVC.xyz);', '  vec3 fdy = dFdy(vertexVC.xyz);', '  //VTK::UniformFlow::Impl'] // For further replacements\n            ).result;\n            FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Normal::Impl', ['vec3 normalVCVSOutput;', '  if (abs(fdx.x) > 0.0)', '    { fdx = normalize(fdx); normalVCVSOutput = normalize(cross(vec3(fdx.y, -fdx.x, 0.0), fdx)); }', '  else { fdy = normalize(fdy); normalVCVSOutput = normalize(cross(vec3(fdy.y, -fdy.x, 0.0), fdy));}']).result;\n          } else {\n            FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Normal::Dec', ['uniform int cameraParallel;']).result;\n            FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::UniformFlow::Impl', [// '  vec3 fdx = vec3(dFdx(vertexVC.x),dFdx(vertexVC.y),dFdx(vertexVC.z));',\n            // '  vec3 fdy = vec3(dFdy(vertexVC.x),dFdy(vertexVC.y),dFdy(vertexVC.z));',\n            '  vec3 fdx = dFdx(vertexVC.xyz);', '  vec3 fdy = dFdy(vertexVC.xyz);', '  //VTK::UniformFlow::Impl'] // For further replacements\n            ).result;\n            FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Normal::Impl', ['  fdx = normalize(fdx);', '  fdy = normalize(fdy);', '  vec3 normalVCVSOutput = normalize(cross(fdx,fdy));', // the code below is faster, but does not work on some devices\n            // 'vec3 normalVC = normalize(cross(dFdx(vertexVC.xyz), dFdy(vertexVC.xyz)));',\n            '  if (cameraParallel == 1 && normalVCVSOutput.z < 0.0) { normalVCVSOutput = -1.0*normalVCVSOutput; }', '  if (cameraParallel == 0 && dot(normalVCVSOutput,vertexVC.xyz) > 0.0) { normalVCVSOutput = -1.0*normalVCVSOutput; }']).result;\n          }\n        }\n      }\n\n      shaders.Vertex = VSSource;\n      shaders.Geometry = GSSource;\n      shaders.Fragment = FSSource;\n    }\n  };\n\n  publicAPI.replaceShaderPositionVC = function (shaders, ren, actor) {\n    // replace common shader code\n    model.lastBoundBO.replaceShaderPositionVC(shaders, ren, actor);\n    var VSSource = shaders.Vertex;\n    var GSSource = shaders.Geometry;\n    var FSSource = shaders.Fragment; // do we need the vertex in the shader in View Coordinates\n\n    var lastLightComplexity = model.lastBoundBO.getReferenceByName('lastLightComplexity');\n\n    if (lastLightComplexity > 0) {\n      VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::PositionVC::Dec', ['varying vec4 vertexVCVSOutput;']).result;\n      VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::PositionVC::Impl', ['vertexVCVSOutput = MCVCMatrix * vertexMC;', '  gl_Position = MCPCMatrix * vertexMC;']).result;\n      VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::Camera::Dec', ['uniform mat4 MCPCMatrix;', 'uniform mat4 MCVCMatrix;']).result;\n      GSSource = vtkShaderProgram.substitute(GSSource, '//VTK::PositionVC::Dec', ['in vec4 vertexVCVSOutput[];', 'out vec4 vertexVCGSOutput;']).result;\n      GSSource = vtkShaderProgram.substitute(GSSource, '//VTK::PositionVC::Impl', ['vertexVCGSOutput = vertexVCVSOutput[i];']).result;\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::PositionVC::Dec', ['varying vec4 vertexVCVSOutput;']).result;\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::PositionVC::Impl', ['vec4 vertexVC = vertexVCVSOutput;']).result;\n    } else {\n      VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::Camera::Dec', ['uniform mat4 MCPCMatrix;']).result;\n      VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::PositionVC::Impl', ['  gl_Position = MCPCMatrix * vertexMC;']).result;\n    }\n\n    shaders.Vertex = VSSource;\n    shaders.Geometry = GSSource;\n    shaders.Fragment = FSSource;\n  };\n\n  publicAPI.replaceShaderTCoord = function (shaders, ren, actor) {\n    if (model.lastBoundBO.getCABO().getTCoordOffset()) {\n      var VSSource = shaders.Vertex;\n      var GSSource = shaders.Geometry;\n      var FSSource = shaders.Fragment;\n\n      if (model.drawingEdges) {\n        return;\n      }\n\n      VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::TCoord::Impl', 'tcoordVCVSOutput = tcoordMC;').result; // we only handle the first texture by default\n      // additional textures are activated and we set the uniform\n      // for the texture unit they are assigned to, but you have to\n      // add in the shader code to do something with them\n\n      var tus = model.openGLActor.getActiveTextures();\n      var tNumComp = 2;\n      var tcdim = 2;\n\n      if (tus && tus.length > 0) {\n        tNumComp = tus[0].getComponents();\n\n        if (tus[0].getTarget() === model.context.TEXTURE_CUBE_MAP) {\n          tcdim = 3;\n        }\n      }\n\n      if (model.renderable.getColorTextureMap()) {\n        tNumComp = model.renderable.getColorTextureMap().getPointData().getScalars().getNumberOfComponents();\n        tcdim = 2;\n      }\n\n      if (tcdim === 2) {\n        VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::TCoord::Dec', 'attribute vec2 tcoordMC; varying vec2 tcoordVCVSOutput;').result;\n        GSSource = vtkShaderProgram.substitute(GSSource, '//VTK::TCoord::Dec', ['in vec2 tcoordVCVSOutput[];', 'out vec2 tcoordVCGSOutput;']).result;\n        GSSource = vtkShaderProgram.substitute(GSSource, '//VTK::TCoord::Impl', 'tcoordVCGSOutput = tcoordVCVSOutput[i];').result;\n        FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::TCoord::Dec', ['varying vec2 tcoordVCVSOutput;', 'uniform sampler2D texture1;']).result;\n\n        if (tus && tus.length >= 1) {\n          switch (tNumComp) {\n            case 1:\n              FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::TCoord::Impl', ['  vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);', '  ambientColor = ambientColor*tcolor.r;', '  diffuseColor = diffuseColor*tcolor.r;']).result;\n              break;\n\n            case 2:\n              FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::TCoord::Impl', ['  vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);', '  ambientColor = ambientColor*tcolor.r;', '  diffuseColor = diffuseColor*tcolor.r;', '  opacity = opacity * tcolor.g;']).result;\n              break;\n\n            default:\n              FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::TCoord::Impl', ['  vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);', '  ambientColor = ambientColor*tcolor.rgb;', '  diffuseColor = diffuseColor*tcolor.rgb;', '  opacity = opacity * tcolor.a;']).result;\n          }\n        }\n      } else {\n        VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::TCoord::Dec', 'attribute vec3 tcoordMC; varying vec3 tcoordVCVSOutput;').result;\n        GSSource = vtkShaderProgram.substitute(GSSource, '//VTK::TCoord::Dec', ['in vec3 tcoordVCVSOutput[];', 'out vec3 tcoordVCGSOutput;']).result;\n        GSSource = vtkShaderProgram.substitute(GSSource, '//VTK::TCoord::Impl', 'tcoordVCGSOutput = tcoordVCVSOutput[i];').result;\n        FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::TCoord::Dec', ['varying vec3 tcoordVCVSOutput;', 'uniform samplerCube texture1;']).result;\n\n        switch (tNumComp) {\n          case 1:\n            FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::TCoord::Impl', ['  vec4 tcolor = textureCube(texture1, tcoordVCVSOutput);', '  ambientColor = ambientColor*tcolor.r;', '  diffuseColor = diffuseColor*tcolor.r;']).result;\n            break;\n\n          case 2:\n            FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::TCoord::Impl', ['  vec4 tcolor = textureCube(texture1, tcoordVCVSOutput);', '  ambientColor = ambientColor*tcolor.r;', '  diffuseColor = diffuseColor*tcolor.r;', '  opacity = opacity * tcolor.g;']).result;\n            break;\n\n          default:\n            FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::TCoord::Impl', ['  vec4 tcolor = textureCube(texture1, tcoordVCVSOutput);', '  ambientColor = ambientColor*tcolor.rgb;', '  diffuseColor = diffuseColor*tcolor.rgb;', '  opacity = opacity * tcolor.a;']).result;\n        }\n      }\n\n      shaders.Vertex = VSSource;\n      shaders.Geometry = GSSource;\n      shaders.Fragment = FSSource;\n    }\n  };\n\n  publicAPI.replaceShaderClip = function (shaders, ren, actor) {\n    var VSSource = shaders.Vertex;\n    var FSSource = shaders.Fragment;\n\n    if (model.renderable.getNumberOfClippingPlanes()) {\n      var numClipPlanes = model.renderable.getNumberOfClippingPlanes();\n      VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::Clip::Dec', ['uniform int numClipPlanes;', \"uniform vec4 clipPlanes[\".concat(numClipPlanes, \"];\"), \"varying float clipDistancesVSOutput[\".concat(numClipPlanes, \"];\")]).result;\n      VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::Clip::Impl', [\"for (int planeNum = 0; planeNum < \".concat(numClipPlanes, \"; planeNum++)\"), '    {', '    if (planeNum >= numClipPlanes)', '        {', '        break;', '        }', '    clipDistancesVSOutput[planeNum] = dot(clipPlanes[planeNum], vertexMC);', '    }']).result;\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Clip::Dec', ['uniform int numClipPlanes;', \"varying float clipDistancesVSOutput[\".concat(numClipPlanes, \"];\")]).result;\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Clip::Impl', [\"for (int planeNum = 0; planeNum < \".concat(numClipPlanes, \"; planeNum++)\"), '    {', '    if (planeNum >= numClipPlanes)', '        {', '        break;', '        }', '    if (clipDistancesVSOutput[planeNum] < 0.0) discard;', '    }']).result;\n    }\n\n    shaders.Vertex = VSSource;\n    shaders.Fragment = FSSource;\n  };\n\n  publicAPI.getCoincidentParameters = function (ren, actor) {\n    // 1. ResolveCoincidentTopology is On and non zero for this primitive\n    // type\n    var cp = {\n      factor: 0.0,\n      offset: 0.0\n    };\n    var prop = actor.getProperty();\n\n    if (model.renderable.getResolveCoincidentTopology() || prop.getEdgeVisibility() && prop.getRepresentation() === Representation.SURFACE) {\n      var primType = model.lastBoundBO.getPrimitiveType();\n\n      if (primType === primTypes.Points || prop.getRepresentation() === Representation.POINTS) {\n        cp = model.renderable.getCoincidentTopologyPointOffsetParameter();\n      } else if (primType === primTypes.Lines || prop.getRepresentation() === Representation.WIREFRAME) {\n        cp = model.renderable.getCoincidentTopologyLineOffsetParameters();\n      } else if (primType === primTypes.Tris || primType === primTypes.TriStrips) {\n        cp = model.renderable.getCoincidentTopologyPolygonOffsetParameters();\n      }\n\n      if (primType === primTypes.TrisEdges || primType === primTypes.TriStripsEdges) {\n        cp = model.renderable.getCoincidentTopologyPolygonOffsetParameters();\n        cp.factor /= 2.0;\n        cp.offset /= 2.0;\n      }\n    } // hardware picking always offset due to saved zbuffer\n    // This gets you above the saved surface depth buffer.\n\n\n    var selector = model._openGLRenderer.getSelector();\n\n    if (selector && selector.getFieldAssociation() === FieldAssociations.FIELD_ASSOCIATION_POINTS) {\n      cp.offset -= 2.0;\n    }\n\n    return cp;\n  };\n\n  publicAPI.replaceShaderPicking = function (shaders, ren, actor) {\n    var FSSource = shaders.Fragment;\n    var VSSource = shaders.Vertex;\n    FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Picking::Dec', ['uniform int picking;', '//VTK::Picking::Dec']).result;\n\n    if (!model._openGLRenderer.getSelector()) {\n      return;\n    }\n\n    if (model.lastSelectionState === PassTypes.ID_LOW24 || model.lastSelectionState === PassTypes.ID_HIGH24) {\n      VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::Picking::Dec', ['flat out int vertexIDVSOutput;\\n', 'uniform int VertexIDOffset;\\n']).result;\n      VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::Picking::Impl', '  vertexIDVSOutput = gl_VertexID + VertexIDOffset;\\n').result;\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Picking::Dec', 'flat in int vertexIDVSOutput;\\n').result;\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Picking::Impl', ['  int idx = vertexIDVSOutput;', '//VTK::Picking::Impl']).result;\n    }\n\n    switch (model.lastSelectionState) {\n      case PassTypes.ID_LOW24:\n        FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Picking::Impl', '  gl_FragData[0] = vec4(float(idx%256)/255.0, float((idx/256)%256)/255.0, float((idx/65536)%256)/255.0, 1.0);').result;\n        break;\n\n      case PassTypes.ID_HIGH24:\n        FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Picking::Impl', '  gl_FragData[0] = vec4(float(idx)/255.0, 0.0, 0.0, 1.0);').result;\n        break;\n\n      default:\n        FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Picking::Dec', 'uniform vec3 mapperIndex;').result;\n        FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Picking::Impl', '  gl_FragData[0] = picking != 0 ? vec4(mapperIndex,1.0) : gl_FragData[0];').result;\n    }\n\n    shaders.Fragment = FSSource;\n    shaders.Vertex = VSSource;\n  };\n\n  publicAPI.replaceShaderValues = function (shaders, ren, actor) {\n    publicAPI.replaceShaderColor(shaders, ren, actor);\n    publicAPI.replaceShaderNormal(shaders, ren, actor);\n    publicAPI.replaceShaderLight(shaders, ren, actor);\n    publicAPI.replaceShaderTCoord(shaders, ren, actor);\n    publicAPI.replaceShaderPicking(shaders, ren, actor);\n    publicAPI.replaceShaderClip(shaders, ren, actor);\n    publicAPI.replaceShaderCoincidentOffset(shaders, ren, actor);\n    publicAPI.replaceShaderPositionVC(shaders, ren, actor);\n\n    if (model.haveSeenDepthRequest) {\n      var FSSource = shaders.Fragment;\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::ZBuffer::Dec', 'uniform int depthRequest;').result;\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::ZBuffer::Impl', ['if (depthRequest == 1) {', 'float iz = floor(gl_FragCoord.z*65535.0 + 0.1);', 'float rf = floor(iz/256.0)/255.0;', 'float gf = mod(iz,256.0)/255.0;', 'gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }']).result;\n      shaders.Fragment = FSSource;\n    }\n  };\n\n  publicAPI.getNeedToRebuildShaders = function (cellBO, ren, actor) {\n    var lightComplexity = 0;\n    var numberOfLights = 0;\n    var primType = cellBO.getPrimitiveType();\n    var poly = model.currentInput; // different algo from C++ as of 5/2019\n\n    var needLighting = false;\n    var pointNormals = poly.getPointData().getNormals();\n    var cellNormals = poly.getCellData().getNormals();\n    var flat = actor.getProperty().getInterpolation() === Shading.FLAT;\n    var representation = actor.getProperty().getRepresentation();\n    var mode = cellBO.getOpenGLMode(representation, primType); // 1) all surfaces need lighting\n\n    if (mode === model.context.TRIANGLES) {\n      needLighting = true; // 2) all cell normals without point normals need lighting\n    } else if (cellNormals && !pointNormals) {\n      needLighting = true; // 3) Phong + pointNormals need lighting\n    } else if (!flat && pointNormals) {\n      needLighting = true; // 4) Phong Lines need lighting\n    } else if (!flat && mode === model.context.LINES) {\n      needLighting = true;\n    } // 5) everything else is unlit\n    // do we need lighting?\n\n\n    if (actor.getProperty().getLighting() && needLighting) {\n      // consider the lighting complexity to determine which case applies\n      // simple headlight, Light Kit, the whole feature set of VTK\n      lightComplexity = 0;\n      var lights = ren.getLightsByReference();\n\n      for (var index = 0; index < lights.length; ++index) {\n        var light = lights[index];\n        var status = light.getSwitch();\n\n        if (status > 0) {\n          numberOfLights++;\n\n          if (lightComplexity === 0) {\n            lightComplexity = 1;\n          }\n        }\n\n        if (lightComplexity === 1 && (numberOfLights > 1 || light.getIntensity() !== 1.0 || !light.lightTypeIsHeadLight())) {\n          lightComplexity = 2;\n        }\n\n        if (lightComplexity < 3 && light.getPositional()) {\n          lightComplexity = 3;\n        }\n      }\n    }\n\n    var needRebuild = false;\n    var lastLightComplexity = model.lastBoundBO.getReferenceByName('lastLightComplexity');\n    var lastLightCount = model.lastBoundBO.getReferenceByName('lastLightCount');\n\n    if (lastLightComplexity !== lightComplexity || lastLightCount !== numberOfLights) {\n      model.lastBoundBO.set({\n        lastLightComplexity: lightComplexity\n      }, true);\n      model.lastBoundBO.set({\n        lastLightCount: numberOfLights\n      }, true);\n      needRebuild = true;\n    } // has the render pass shader replacement changed? Two options\n\n\n    if (!model.currentRenderPass && model.lastRenderPassShaderReplacement || model.currentRenderPass && model.currentRenderPass.getShaderReplacement() !== model.lastRenderPassShaderReplacement) {\n      needRebuild = true;\n    } // has something changed that would require us to recreate the shader?\n    // candidates are\n    // property modified (representation interpolation and lighting)\n    // input modified\n    // light complexity changed\n    // render pass shader replacement changed\n\n\n    if (model.lastHaveSeenDepthRequest !== model.haveSeenDepthRequest || cellBO.getShaderSourceTime().getMTime() < model.renderable.getMTime() || cellBO.getShaderSourceTime().getMTime() < model.currentInput.getMTime() || cellBO.getShaderSourceTime().getMTime() < model.selectionStateChanged.getMTime() || needRebuild) {\n      model.lastHaveSeenDepthRequest = model.haveSeenDepthRequest;\n      return true;\n    }\n\n    return false;\n  };\n\n  publicAPI.invokeShaderCallbacks = function (cellBO, ren, actor) {\n    var listCallbacks = model.renderable.getViewSpecificProperties().ShadersCallbacks;\n\n    if (listCallbacks) {\n      listCallbacks.forEach(function (object) {\n        object.callback(object.userData, cellBO, ren, actor);\n      });\n    }\n  };\n\n  publicAPI.setMapperShaderParameters = function (cellBO, ren, actor) {\n    // Now to update the VAO too, if necessary.\n    if (cellBO.getProgram().isUniformUsed('PrimitiveIDOffset')) {\n      cellBO.getProgram().setUniformi('PrimitiveIDOffset', model.primitiveIDOffset);\n    }\n\n    if (cellBO.getProgram().isUniformUsed('VertexIDOffset')) {\n      cellBO.getProgram().setUniformi('VertexIDOffset', model.vertexIDOffset);\n    }\n\n    if (cellBO.getCABO().getElementCount() && (model.VBOBuildTime.getMTime() > cellBO.getAttributeUpdateTime().getMTime() || cellBO.getShaderSourceTime().getMTime() > cellBO.getAttributeUpdateTime().getMTime())) {\n      var lastLightComplexity = model.lastBoundBO.getReferenceByName('lastLightComplexity');\n\n      if (cellBO.getProgram().isAttributeUsed('vertexMC')) {\n        if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO(), 'vertexMC', cellBO.getCABO().getVertexOffset(), cellBO.getCABO().getStride(), model.context.FLOAT, 3, false)) {\n          vtkErrorMacro('Error setting vertexMC in shader VAO.');\n        }\n      }\n\n      if (cellBO.getProgram().isAttributeUsed('normalMC') && cellBO.getCABO().getNormalOffset() && lastLightComplexity > 0) {\n        if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO(), 'normalMC', cellBO.getCABO().getNormalOffset(), cellBO.getCABO().getStride(), model.context.FLOAT, 3, false)) {\n          vtkErrorMacro('Error setting normalMC in shader VAO.');\n        }\n      } else {\n        cellBO.getVAO().removeAttributeArray('normalMC');\n      }\n\n      model.renderable.getCustomShaderAttributes().forEach(function (attrName, idx) {\n        if (cellBO.getProgram().isAttributeUsed(\"\".concat(attrName, \"MC\"))) {\n          if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO(), \"\".concat(attrName, \"MC\"), cellBO.getCABO().getCustomData()[idx].offset, cellBO.getCABO().getStride(), model.context.FLOAT, cellBO.getCABO().getCustomData()[idx].components, false)) {\n            vtkErrorMacro(\"Error setting \".concat(attrName, \"MC in shader VAO.\"));\n          }\n        }\n      });\n\n      if (cellBO.getProgram().isAttributeUsed('tcoordMC') && cellBO.getCABO().getTCoordOffset()) {\n        if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO(), 'tcoordMC', cellBO.getCABO().getTCoordOffset(), cellBO.getCABO().getStride(), model.context.FLOAT, cellBO.getCABO().getTCoordComponents(), false)) {\n          vtkErrorMacro('Error setting tcoordMC in shader VAO.');\n        }\n      } else {\n        cellBO.getVAO().removeAttributeArray('tcoordMC');\n      }\n\n      if (cellBO.getProgram().isAttributeUsed('scalarColor') && cellBO.getCABO().getColorComponents()) {\n        if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO().getColorBO(), 'scalarColor', cellBO.getCABO().getColorOffset(), cellBO.getCABO().getColorBOStride(), model.context.UNSIGNED_BYTE, 4, true)) {\n          vtkErrorMacro('Error setting scalarColor in shader VAO.');\n        }\n      } else {\n        cellBO.getVAO().removeAttributeArray('scalarColor');\n      }\n\n      cellBO.getAttributeUpdateTime().modified();\n    }\n\n    if (model.renderable.getNumberOfClippingPlanes()) {\n      // add all the clipping planes\n      var numClipPlanes = model.renderable.getNumberOfClippingPlanes();\n      var planeEquations = [];\n      var shiftScaleEnabled = cellBO.getCABO().getCoordShiftAndScaleEnabled();\n      var inverseShiftScaleMatrix = shiftScaleEnabled ? cellBO.getCABO().getInverseShiftAndScaleMatrix() : null;\n      var mat = inverseShiftScaleMatrix ? mat4.copy(model.tmpMat4, actor.getMatrix()) : actor.getMatrix();\n\n      if (inverseShiftScaleMatrix) {\n        mat4.transpose(mat, mat);\n        mat4.multiply(mat, mat, inverseShiftScaleMatrix);\n        mat4.transpose(mat, mat);\n      }\n\n      for (var i = 0; i < numClipPlanes; i++) {\n        var planeEquation = [];\n        model.renderable.getClippingPlaneInDataCoords(mat, i, planeEquation);\n\n        for (var j = 0; j < 4; j++) {\n          planeEquations.push(planeEquation[j]);\n        }\n      }\n\n      cellBO.getProgram().setUniformi('numClipPlanes', numClipPlanes);\n      cellBO.getProgram().setUniform4fv('clipPlanes', planeEquations);\n    }\n\n    if (model.internalColorTexture && cellBO.getProgram().isUniformUsed('texture1')) {\n      cellBO.getProgram().setUniformi('texture1', model.internalColorTexture.getTextureUnit());\n    }\n\n    var tus = model.openGLActor.getActiveTextures();\n\n    if (tus) {\n      for (var index = 0; index < tus.length; ++index) {\n        var tex = tus[index];\n        var texUnit = tex.getTextureUnit();\n        var tname = \"texture\".concat(texUnit + 1);\n\n        if (cellBO.getProgram().isUniformUsed(tname)) {\n          cellBO.getProgram().setUniformi(tname, texUnit);\n        }\n      }\n    } // handle depth requests\n\n\n    if (model.haveSeenDepthRequest) {\n      cellBO.getProgram().setUniformi('depthRequest', model.renderDepth ? 1 : 0);\n    } // handle coincident\n\n\n    if (cellBO.getProgram().isUniformUsed('coffset')) {\n      var cp = publicAPI.getCoincidentParameters(ren, actor);\n      cellBO.getProgram().setUniformf('coffset', cp.offset); // cfactor isn't always used when coffset is.\n\n      if (cellBO.getProgram().isUniformUsed('cfactor')) {\n        cellBO.getProgram().setUniformf('cfactor', cp.factor);\n      }\n    } // handle wide lines\n\n\n    cellBO.setMapperShaderParameters(ren, actor, model._openGLRenderer.getTiledSizeAndOrigin());\n\n    var selector = model._openGLRenderer.getSelector();\n\n    cellBO.getProgram().setUniform3fArray('mapperIndex', selector ? selector.getPropColorValue() : [0.0, 0.0, 0.0]);\n    cellBO.getProgram().setUniformi('picking', selector ? selector.getCurrentPass() + 1 : 0);\n  };\n\n  publicAPI.setLightingShaderParameters = function (cellBO, ren, actor) {\n    // for unlit and headlight there are no lighting parameters\n    var lastLightComplexity = model.lastBoundBO.getReferenceByName('lastLightComplexity');\n\n    if (lastLightComplexity < 2) {\n      return;\n    }\n\n    var program = cellBO.getProgram(); // bind some light settings\n\n    var numberOfLights = 0;\n    var lights = ren.getLightsByReference();\n\n    for (var index = 0; index < lights.length; ++index) {\n      var light = lights[index];\n      var status = light.getSwitch();\n\n      if (status > 0.0) {\n        var dColor = light.getColorByReference();\n        var intensity = light.getIntensity();\n        model.lightColor[0] = dColor[0] * intensity;\n        model.lightColor[1] = dColor[1] * intensity;\n        model.lightColor[2] = dColor[2] * intensity; // get required info from light\n\n        var ld = light.getDirection();\n        var transform = ren.getActiveCamera().getViewMatrix();\n\n        var newLightDirection = _toConsumableArray(ld);\n\n        if (light.lightTypeIsSceneLight()) {\n          newLightDirection[0] = transform[0] * ld[0] + transform[1] * ld[1] + transform[2] * ld[2];\n          newLightDirection[1] = transform[4] * ld[0] + transform[5] * ld[1] + transform[6] * ld[2];\n          newLightDirection[2] = transform[8] * ld[0] + transform[9] * ld[1] + transform[10] * ld[2];\n          normalize(newLightDirection);\n        }\n\n        model.lightDirection[0] = newLightDirection[0];\n        model.lightDirection[1] = newLightDirection[1];\n        model.lightDirection[2] = newLightDirection[2];\n        normalize(model.lightDirection);\n        program.setUniform3fArray(\"lightColor\".concat(numberOfLights), model.lightColor);\n        program.setUniform3fArray(\"lightDirectionVC\".concat(numberOfLights), model.lightDirection);\n        numberOfLights++;\n      }\n    } // we are done unless we have positional lights\n\n\n    if (lastLightComplexity < 3) {\n      return;\n    } // for lightkit case there are some parameters to set\n\n\n    var cam = ren.getActiveCamera();\n    var viewTF = cam.getViewMatrix();\n    mat4.transpose(viewTF, viewTF);\n    numberOfLights = 0;\n\n    for (var _index = 0; _index < lights.length; ++_index) {\n      var _light = lights[_index];\n\n      var _status = _light.getSwitch();\n\n      if (_status > 0.0) {\n        var lp = _light.getTransformedPosition();\n\n        var np = new Float64Array(3);\n        vec3.transformMat4(np, lp, viewTF);\n        program.setUniform3fArray(\"lightAttenuation\".concat(numberOfLights), _light.getAttenuationValuesByReference());\n        program.setUniformi(\"lightPositional\".concat(numberOfLights), _light.getPositional());\n        program.setUniformf(\"lightExponent\".concat(numberOfLights), _light.getExponent());\n        program.setUniformf(\"lightConeAngle\".concat(numberOfLights), _light.getConeAngle());\n        program.setUniform3fArray(\"lightPositionVC\".concat(numberOfLights), [np[0], np[1], np[2]]);\n        numberOfLights++;\n      }\n    }\n  };\n\n  function safeMatrixMultiply(matrixArray, matrixType, tmpMat) {\n    matrixType.identity(tmpMat);\n    return matrixArray.reduce(function (res, matrix, index) {\n      if (index === 0) {\n        return matrix ? matrixType.copy(res, matrix) : matrixType.identity(res);\n      }\n\n      return matrix ? matrixType.multiply(res, res, matrix) : res;\n    }, tmpMat);\n  }\n\n  publicAPI.setCameraShaderParameters = function (cellBO, ren, actor) {\n    var program = cellBO.getProgram(); // [WMVP]C == {world, model, view, projection} coordinates\n    // E.g., WCPC == world to projection coordinate transformation\n\n    var keyMats = model.openGLCamera.getKeyMatrices(ren);\n    var cam = ren.getActiveCamera();\n    var camm = model.openGLCamera.getKeyMatrixTime().getMTime();\n    var progm = program.getLastCameraMTime();\n    var shiftScaleEnabled = cellBO.getCABO().getCoordShiftAndScaleEnabled();\n    var inverseShiftScaleMatrix = shiftScaleEnabled ? cellBO.getCABO().getInverseShiftAndScaleMatrix() : null;\n    var actorIsIdentity = actor.getIsIdentity();\n    var actMats = actorIsIdentity ? {\n      mcwc: null,\n      normalMatrix: null\n    } : model.openGLActor.getKeyMatrices();\n\n    if (actor.getCoordinateSystem() === CoordinateSystem.DISPLAY) {\n      var size = model._openGLRenderer.getTiledSizeAndOrigin();\n\n      mat4.identity(model.tmpMat4);\n      model.tmpMat4[0] = 2.0 / size.usize;\n      model.tmpMat4[12] = -1.0;\n      model.tmpMat4[5] = 2.0 / size.vsize;\n      model.tmpMat4[13] = -1.0;\n      mat4.multiply(model.tmpMat4, model.tmpMat4, inverseShiftScaleMatrix);\n      program.setUniformMatrix('MCPCMatrix', model.tmpMat4);\n    } else {\n      program.setUniformMatrix('MCPCMatrix', safeMatrixMultiply([keyMats.wcpc, actMats.mcwc, inverseShiftScaleMatrix], mat4, model.tmpMat4));\n    }\n\n    if (program.isUniformUsed('MCVCMatrix')) {\n      program.setUniformMatrix('MCVCMatrix', safeMatrixMultiply([keyMats.wcvc, actMats.mcwc, inverseShiftScaleMatrix], mat4, model.tmpMat4));\n    }\n\n    if (program.isUniformUsed('normalMatrix')) {\n      program.setUniformMatrix3x3('normalMatrix', safeMatrixMultiply([keyMats.normalMatrix, actMats.normalMatrix], mat3, model.tmpMat3));\n    }\n\n    if (progm !== camm) {\n      if (program.isUniformUsed('cameraParallel')) {\n        program.setUniformi('cameraParallel', cam.getParallelProjection());\n      }\n\n      program.setLastCameraMTime(camm);\n    }\n\n    if (!actorIsIdentity) {\n      // reset the cam mtime as actor modified the shader values\n      program.setLastCameraMTime(0);\n    }\n  };\n\n  publicAPI.setPropertyShaderParameters = function (cellBO, ren, actor) {\n    var program = cellBO.getProgram();\n    var ppty = actor.getProperty();\n    var opacity = ppty.getOpacity();\n    var aColor = model.drawingEdges ? ppty.getEdgeColorByReference() : ppty.getAmbientColorByReference();\n    var dColor = model.drawingEdges ? ppty.getEdgeColorByReference() : ppty.getDiffuseColorByReference();\n    var aIntensity = model.drawingEdges ? 1.0 : ppty.getAmbient();\n    var dIntensity = model.drawingEdges ? 0.0 : ppty.getDiffuse();\n    var sIntensity = model.drawingEdges ? 0.0 : ppty.getSpecular();\n    var specularPower = ppty.getSpecularPower();\n    program.setUniformf('opacityUniform', opacity);\n    program.setUniform3fArray('ambientColorUniform', aColor);\n    program.setUniform3fArray('diffuseColorUniform', dColor);\n    program.setUniformf('ambient', aIntensity);\n    program.setUniformf('diffuse', dIntensity); // we are done unless we have lighting\n\n    var lastLightComplexity = model.lastBoundBO.getReferenceByName('lastLightComplexity');\n\n    if (lastLightComplexity < 1) {\n      return;\n    }\n\n    var sColor = ppty.getSpecularColorByReference();\n    program.setUniform3fArray('specularColorUniform', sColor);\n    program.setUniformf('specularPowerUniform', specularPower);\n    program.setUniformf('specular', sIntensity); // now set the backface properties if we have them\n\n    if (program.isUniformUsed('ambientIntensityBF')) {\n      ppty = actor.getBackfaceProperty();\n      opacity = ppty.getOpacity();\n      aColor = ppty.getAmbientColor();\n      aIntensity = ppty.getAmbient();\n      dColor = ppty.getDiffuseColor();\n      dIntensity = ppty.getDiffuse();\n      sColor = ppty.getSpecularColor();\n      sIntensity = ppty.getSpecular();\n      program.setUniformf('ambientIntensityBF', aIntensity);\n      program.setUniformf('diffuseIntensityBF', dIntensity);\n      program.setUniformf('opacityUniformBF', opacity);\n      program.setUniform3fArray('ambientColorUniformBF', aColor);\n      program.setUniform3fArray('diffuseColorUniformBF', dColor); // we are done unless we have lighting\n\n      if (lastLightComplexity < 1) {\n        return;\n      }\n\n      program.setUniformf('specularIntensityBF', sIntensity);\n      program.setUniform3fArray('specularColorUniformBF', sColor);\n      program.setUniformf('specularPowerUniformBF', specularPower);\n    }\n  };\n\n  publicAPI.updateMaximumPointCellIds = function (ren, actor) {\n    var _model$selectionWebGL, _model$selectionWebGL2, _model$selectionWebGL3, _model$selectionWebGL4;\n\n    var selector = model._openGLRenderer.getSelector();\n\n    if (!selector) {\n      return;\n    }\n\n    if ((_model$selectionWebGL = model.selectionWebGLIdsToVTKIds) !== null && _model$selectionWebGL !== void 0 && (_model$selectionWebGL2 = _model$selectionWebGL.points) !== null && _model$selectionWebGL2 !== void 0 && _model$selectionWebGL2.length) {\n      var length = model.selectionWebGLIdsToVTKIds.points.length;\n      selector.setMaximumPointId(length - 1);\n    }\n\n    if ((_model$selectionWebGL3 = model.selectionWebGLIdsToVTKIds) !== null && _model$selectionWebGL3 !== void 0 && (_model$selectionWebGL4 = _model$selectionWebGL3.cells) !== null && _model$selectionWebGL4 !== void 0 && _model$selectionWebGL4.length) {\n      var _length = model.selectionWebGLIdsToVTKIds.cells.length;\n      selector.setMaximumCellId(_length - 1);\n    }\n\n    var fieldAssociation = selector.getFieldAssociation();\n\n    if (fieldAssociation === FieldAssociations.FIELD_ASSOCIATION_POINTS) {\n      model.pointPicking = true;\n    }\n  };\n\n  publicAPI.renderPieceStart = function (ren, actor) {\n    model.primitiveIDOffset = 0;\n    model.vertexIDOffset = 0;\n    var picking = getPickState(model._openGLRenderer);\n\n    if (model.lastSelectionState !== picking) {\n      model.selectionStateChanged.modified();\n      model.lastSelectionState = picking;\n    }\n\n    if (model._openGLRenderer.getSelector()) {\n      switch (picking) {\n        default:\n          model._openGLRenderer.getSelector().renderProp(actor);\n\n      }\n    } // make sure the BOs are up to date\n\n\n    publicAPI.updateBufferObjects(ren, actor); // If we are coloring by texture, then load the texture map.\n    // Use Map as indicator, because texture hangs around.\n\n    if (model.renderable.getColorTextureMap()) {\n      model.internalColorTexture.activate();\n    } // Bind the OpenGL, this is shared between the different primitive/cell types.\n\n\n    model.lastBoundBO = null;\n  };\n\n  publicAPI.renderPieceDraw = function (ren, actor) {\n    var representation = actor.getProperty().getRepresentation();\n    var drawSurfaceWithEdges = actor.getProperty().getEdgeVisibility() && representation === Representation.SURFACE;\n\n    var selector = model._openGLRenderer.getSelector(); // If we are picking points, we need to tell it to the helper\n\n\n    var pointPicking = selector && selector.getFieldAssociation() === FieldAssociations.FIELD_ASSOCIATION_POINTS && (model.lastSelectionState === PassTypes.ID_LOW24 || model.lastSelectionState === PassTypes.ID_HIGH24); // for every primitive type\n\n    for (var i = primTypes.Start; i < primTypes.End; i++) {\n      model.primitives[i].setPointPicking(pointPicking);\n      var cabo = model.primitives[i].getCABO();\n\n      if (cabo.getElementCount()) {\n        // are we drawing edges\n        model.drawingEdges = drawSurfaceWithEdges && (i === primTypes.TrisEdges || i === primTypes.TriStripsEdges); // don't draw edges when rendering depth or rendering for picking\n\n        if (!model.drawingEdges || !(model.renderDepth || model.lastSelectionState >= 0)) {\n          model.lastBoundBO = model.primitives[i];\n          model.primitiveIDOffset += model.primitives[i].drawArrays(ren, actor, representation, publicAPI);\n          model.vertexIDOffset += model.primitives[i].getCABO().getElementCount();\n        }\n      }\n    }\n  };\n\n  publicAPI.renderPieceFinish = function (ren, actor) {\n    if (model.LastBoundBO) {\n      model.LastBoundBO.getVAO().release();\n    }\n\n    if (model.renderable.getColorTextureMap()) {\n      model.internalColorTexture.deactivate();\n    }\n  };\n\n  publicAPI.renderPiece = function (ren, actor) {\n    // Make sure that we have been properly initialized.\n    // if (ren.getRenderWindow().checkAbortStatus()) {\n    //   return;\n    // }\n    publicAPI.invokeEvent(StartEvent);\n\n    if (!model.renderable.getStatic()) {\n      model.renderable.update();\n    }\n\n    model.currentInput = model.renderable.getInputData();\n    publicAPI.invokeEvent(EndEvent);\n\n    if (!model.currentInput) {\n      vtkErrorMacro('No input!');\n      return;\n    } // if there are no points then we are done\n\n\n    if (!model.currentInput.getPoints || !model.currentInput.getPoints().getNumberOfValues()) {\n      return;\n    } // apply faceCulling\n\n\n    var gl = model.context;\n    var backfaceCulling = actor.getProperty().getBackfaceCulling();\n    var frontfaceCulling = actor.getProperty().getFrontfaceCulling();\n\n    if (!backfaceCulling && !frontfaceCulling) {\n      model._openGLRenderWindow.disableCullFace();\n    } else if (frontfaceCulling) {\n      model._openGLRenderWindow.enableCullFace();\n\n      gl.cullFace(gl.FRONT);\n    } else {\n      model._openGLRenderWindow.enableCullFace();\n\n      gl.cullFace(gl.BACK);\n    }\n\n    publicAPI.renderPieceStart(ren, actor);\n    publicAPI.renderPieceDraw(ren, actor);\n    publicAPI.renderPieceFinish(ren, actor);\n  };\n\n  publicAPI.computeBounds = function (ren, actor) {\n    if (!publicAPI.getInput()) {\n      uninitializeBounds(model.bounds);\n      return;\n    }\n\n    model.bounds = publicAPI.getInput().getBounds();\n  };\n\n  publicAPI.updateBufferObjects = function (ren, actor) {\n    // Rebuild buffers if needed\n    if (publicAPI.getNeedToRebuildBufferObjects(ren, actor)) {\n      publicAPI.buildBufferObjects(ren, actor);\n    }\n  };\n\n  publicAPI.getNeedToRebuildBufferObjects = function (ren, actor) {\n    // first do a coarse check\n    // Note that the actor's mtime includes it's properties mtime\n    var vmtime = model.VBOBuildTime.getMTime();\n\n    if (vmtime < publicAPI.getMTime() || vmtime < model.renderable.getMTime() || vmtime < actor.getMTime() || vmtime < model.currentInput.getMTime()) {\n      return true;\n    }\n\n    return false;\n  };\n\n  publicAPI.buildBufferObjects = function (ren, actor) {\n    var poly = model.currentInput;\n\n    if (poly === null) {\n      return;\n    }\n\n    model.renderable.mapScalars(poly, 1.0);\n    var c = model.renderable.getColorMapColors();\n    model.haveCellScalars = false;\n    var scalarMode = model.renderable.getScalarMode();\n\n    if (model.renderable.getScalarVisibility()) {\n      // We must figure out how the scalars should be mapped to the polydata.\n      if ((scalarMode === ScalarMode.USE_CELL_DATA || scalarMode === ScalarMode.USE_CELL_FIELD_DATA || scalarMode === ScalarMode.USE_FIELD_DATA || !poly.getPointData().getScalars()) && scalarMode !== ScalarMode.USE_POINT_FIELD_DATA && c) {\n        model.haveCellScalars = true;\n      }\n    } // Do we have normals?\n\n\n    var n = actor.getProperty().getInterpolation() !== Shading.FLAT ? poly.getPointData().getNormals() : null;\n\n    if (n === null && poly.getCellData().getNormals()) {\n      model.haveCellNormals = true;\n      n = poly.getCellData().getNormals();\n    } // rebuild the VBO if the data has changed we create a string for the VBO what\n    // can change the VBO? points normals tcoords colors so what can change those?\n    // the input data is clearly one as it can change all four items tcoords may\n    // haveTextures or not colors may change based on quite a few mapping\n    // parameters in the mapper\n\n\n    var representation = actor.getProperty().getRepresentation();\n    var tcoords = poly.getPointData().getTCoords();\n\n    if (!model.openGLActor.getActiveTextures()) {\n      tcoords = null;\n    } // handle color mapping via texture\n\n\n    if (model.renderable.getColorCoordinates()) {\n      tcoords = model.renderable.getColorCoordinates();\n\n      if (!model.internalColorTexture) {\n        model.internalColorTexture = vtkOpenGLTexture.newInstance({\n          resizable: true\n        });\n      }\n\n      var tex = model.internalColorTexture; // the following 4 lines allow for NPOT textures\n\n      tex.setMinificationFilter(Filter.NEAREST);\n      tex.setMagnificationFilter(Filter.NEAREST);\n      tex.setWrapS(Wrap.CLAMP_TO_EDGE);\n      tex.setWrapT(Wrap.CLAMP_TO_EDGE);\n      tex.setOpenGLRenderWindow(model._openGLRenderWindow);\n      var input = model.renderable.getColorTextureMap();\n      var ext = input.getExtent();\n      var inScalars = input.getPointData().getScalars();\n      tex.create2DFromRaw(ext[1] - ext[0] + 1, ext[3] - ext[2] + 1, inScalars.getNumberOfComponents(), inScalars.getDataType(), inScalars.getData());\n      tex.activate();\n      tex.sendParameters();\n      tex.deactivate();\n    }\n\n    var toString = \"\".concat(poly.getMTime(), \"A\").concat(representation, \"B\").concat(poly.getMTime()) + \"C\".concat(n ? n.getMTime() : 1, \"D\").concat(c ? c.getMTime() : 1) + \"E\".concat(actor.getProperty().getEdgeVisibility()) + \"F\".concat(tcoords ? tcoords.getMTime() : 1);\n\n    if (model.VBOBuildString !== toString) {\n      // Build the VBOs\n      var points = poly.getPoints();\n      var options = {\n        points: points,\n        normals: n,\n        tcoords: tcoords,\n        colors: c,\n        cellOffset: 0,\n        vertexOffset: 0,\n        // Used to keep track of vertex ids across primitives for selection\n        haveCellScalars: model.haveCellScalars,\n        haveCellNormals: model.haveCellNormals,\n        customAttributes: model.renderable.getCustomShaderAttributes().map(function (arrayName) {\n          return poly.getPointData().getArrayByName(arrayName);\n        })\n      };\n\n      if (model.renderable.getPopulateSelectionSettings()) {\n        model.selectionWebGLIdsToVTKIds = {\n          points: null,\n          cells: null\n        };\n      }\n\n      var primitives = [{\n        inRep: 'verts',\n        cells: poly.getVerts()\n      }, {\n        inRep: 'lines',\n        cells: poly.getLines()\n      }, {\n        inRep: 'polys',\n        cells: poly.getPolys()\n      }, {\n        inRep: 'strips',\n        cells: poly.getStrips()\n      }, {\n        inRep: 'polys',\n        cells: poly.getPolys()\n      }, {\n        inRep: 'strips',\n        cells: poly.getStrips()\n      }];\n      var drawSurfaceWithEdges = actor.getProperty().getEdgeVisibility() && representation === Representation.SURFACE;\n\n      for (var i = primTypes.Start; i < primTypes.End; i++) {\n        if (i !== primTypes.TrisEdges && i !== primTypes.TriStripsEdges) {\n          options.cellOffset += model.primitives[i].getCABO().createVBO(primitives[i].cells, primitives[i].inRep, representation, options, model.selectionWebGLIdsToVTKIds);\n          options.vertexOffset += model.primitives[i].getCABO().getElementCount();\n        } else {\n          // if we have edge visibility build the edge VBOs\n          if (drawSurfaceWithEdges) {\n            // VBOs for edges in \"surface with edges\" are the last to be built,\n            // they are not used when picking with a hardware selector so they\n            // don't need selectionWebGLIdsToVTKIds and don't update cellOffset and vertexOffset\n            model.primitives[i].getCABO().createVBO(primitives[i].cells, primitives[i].inRep, Representation.WIREFRAME, _objectSpread(_objectSpread({}, options), {}, {\n              tcoords: null,\n              colors: null,\n              haveCellScalars: false,\n              haveCellNormals: false\n            }));\n          } else {\n            // otherwise free them\n            model.primitives[i].releaseGraphicsResources();\n          }\n        }\n      }\n\n      if (model.renderable.getPopulateSelectionSettings()) {\n        model.renderable.setSelectionWebGLIdsToVTKIds(model.selectionWebGLIdsToVTKIds);\n        publicAPI.updateMaximumPointCellIds();\n      }\n\n      model.VBOBuildTime.modified();\n      model.VBOBuildString = toString;\n    }\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\n\nvar DEFAULT_VALUES = {\n  context: null,\n  VBOBuildTime: 0,\n  VBOBuildString: null,\n  primitives: null,\n  primTypes: null,\n  shaderRebuildString: null,\n  tmpMat4: null,\n  ambientColor: [],\n  // used internally\n  diffuseColor: [],\n  // used internally\n  specularColor: [],\n  // used internally\n  lightColor: [],\n  // used internally\n  lightDirection: [],\n  // used internally\n  lastHaveSeenDepthRequest: false,\n  haveSeenDepthRequest: false,\n  lastSelectionState: PassTypes.MIN_KNOWN_PASS - 1,\n  selectionStateChanged: null,\n  selectionWebGLIdsToVTKIds: null,\n  pointPicking: false\n}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Inheritance\n\n  vtkViewNode.extend(publicAPI, model, initialValues);\n  vtkReplacementShaderMapper.implementReplaceShaderCoincidentOffset(publicAPI, model, initialValues);\n  vtkReplacementShaderMapper.implementBuildShadersWithReplacements(publicAPI, model, initialValues);\n  model.primitives = [];\n  model.primTypes = primTypes;\n  model.tmpMat3 = mat3.identity(new Float64Array(9));\n  model.tmpMat4 = mat4.identity(new Float64Array(16));\n\n  for (var i = primTypes.Start; i < primTypes.End; i++) {\n    model.primitives[i] = vtkHelper.newInstance();\n    model.primitives[i].setPrimitiveType(i);\n    model.primitives[i].set({\n      lastLightComplexity: 0,\n      lastLightCount: 0,\n      lastSelectionPass: false\n    }, true);\n  } // Build VTK API\n\n\n  setGet(publicAPI, model, ['context']);\n  model.VBOBuildTime = {};\n  obj(model.VBOBuildTime, {\n    mtime: 0\n  });\n  model.selectionStateChanged = {};\n  obj(model.selectionStateChanged, {\n    mtime: 0\n  }); // Object methods\n\n  vtkOpenGLPolyDataMapper(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = newInstance$1(extend, 'vtkOpenGLPolyDataMapper'); // ----------------------------------------------------------------------------\n\nvar vtkOpenGLPolyDataMapper$1 = {\n  newInstance: newInstance,\n  extend: extend\n}; // Register ourself to OpenGL backend if imported\n\nregisterOverride('vtkMapper', newInstance);\n\nexport { vtkOpenGLPolyDataMapper$1 as default, extend, newInstance };\n"],"mappings":"AAAA,OAAOA,eAAe,MAAM,uCAAuC;AACnE,OAAOC,kBAAkB,MAAM,0CAA0C;AACzE,SAASC,IAAI,EAAEC,IAAI,EAAEC,IAAI,QAAQ,WAAW;AAC5C,SAASC,WAAW,IAAIC,aAAa,EAAEC,MAAM,EAAEC,GAAG,EAAEC,aAAa,IAAIC,eAAe,QAAQ,iBAAiB;AAC7G,OAAOC,SAAS,MAAM,aAAa;AACnC,OAAOC,SAAS,MAAM,mBAAmB;AACzC,SAASC,CAAC,IAAIC,SAAS,EAAEC,CAAC,IAAIC,kBAAkB,QAAQ,iCAAiC;AACzF,OAAOC,gBAAgB,MAAM,cAAc;AAC3C,OAAOC,OAAO,MAAM,iBAAiB;AACrC,OAAOC,WAAW,MAAM,qBAAqB;AAC7C,OAAOC,gBAAgB,MAAM,oBAAoB;AACjD,OAAOC,WAAW,MAAM,2BAA2B;AACnD,SAASC,CAAC,IAAIC,aAAa,QAAQ,8BAA8B;AACjE,SAASD,CAAC,IAAIE,aAAa,QAAQ,8BAA8B;AACjE,OAAOC,0BAA0B,MAAM,8BAA8B;AACrE,SAASC,gBAAgB,QAAQ,sBAAsB;AACvD,SAASC,SAAS,QAAQ,iCAAiC;AAC3D,OAAOC,UAAU,MAAM,mCAAmC;AAE1D,SAASC,OAAOA,CAACC,MAAM,EAAEC,cAAc,EAAE;EAAE,IAAIC,IAAI,GAAGC,MAAM,CAACD,IAAI,CAACF,MAAM,CAAC;EAAE,IAAIG,MAAM,CAACC,qBAAqB,EAAE;IAAE,IAAIC,OAAO,GAAGF,MAAM,CAACC,qBAAqB,CAACJ,MAAM,CAAC;IAAEC,cAAc,KAAKI,OAAO,GAAGA,OAAO,CAACC,MAAM,CAAC,UAAUC,GAAG,EAAE;MAAE,OAAOJ,MAAM,CAACK,wBAAwB,CAACR,MAAM,EAAEO,GAAG,CAAC,CAACE,UAAU;IAAE,CAAC,CAAC,CAAC,EAAEP,IAAI,CAACQ,IAAI,CAACC,KAAK,CAACT,IAAI,EAAEG,OAAO,CAAC;EAAE;EAAE,OAAOH,IAAI;AAAE;AAEpV,SAASU,aAAaA,CAACC,MAAM,EAAE;EAAE,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGC,SAAS,CAACC,MAAM,EAAEF,CAAC,EAAE,EAAE;IAAE,IAAIG,MAAM,GAAG,IAAI,IAAIF,SAAS,CAACD,CAAC,CAAC,GAAGC,SAAS,CAACD,CAAC,CAAC,GAAG,CAAC,CAAC;IAAEA,CAAC,GAAG,CAAC,GAAGf,OAAO,CAACI,MAAM,CAACc,MAAM,CAAC,EAAE,CAAC,CAAC,CAAC,CAACC,OAAO,CAAC,UAAUC,GAAG,EAAE;MAAEjD,eAAe,CAAC2C,MAAM,EAAEM,GAAG,EAAEF,MAAM,CAACE,GAAG,CAAC,CAAC;IAAE,CAAC,CAAC,GAAGhB,MAAM,CAACiB,yBAAyB,GAAGjB,MAAM,CAACkB,gBAAgB,CAACR,MAAM,EAAEV,MAAM,CAACiB,yBAAyB,CAACH,MAAM,CAAC,CAAC,GAAGlB,OAAO,CAACI,MAAM,CAACc,MAAM,CAAC,CAAC,CAACC,OAAO,CAAC,UAAUC,GAAG,EAAE;MAAEhB,MAAM,CAACmB,cAAc,CAACT,MAAM,EAAEM,GAAG,EAAEhB,MAAM,CAACK,wBAAwB,CAACS,MAAM,EAAEE,GAAG,CAAC,CAAC;IAAE,CAAC,CAAC;EAAE;EAAE,OAAON,MAAM;AAAE;AACzf,IAAIU,iBAAiB,GAAGzB,UAAU,CAACyB,iBAAiB;AACpD;;AAEA,IAAIC,SAAS,GAAG3C,SAAS,CAAC2C,SAAS;AACnC,IAAIC,cAAc,GAAGpC,WAAW,CAACoC,cAAc;EAC3CC,OAAO,GAAGrC,WAAW,CAACqC,OAAO;AACjC,IAAIC,UAAU,GAAG7C,SAAS,CAAC6C,UAAU;AACrC,IAAIC,MAAM,GAAGzC,gBAAgB,CAACyC,MAAM;EAChCC,IAAI,GAAG1C,gBAAgB,CAAC0C,IAAI;AAChC,IAAIlD,aAAa,GAAGC,eAAe;AACnC,IAAIkD,UAAU,GAAG;EACfC,IAAI,EAAE;AACR,CAAC;AACD,IAAIC,QAAQ,GAAG;EACbD,IAAI,EAAE;AACR,CAAC;AACD,IAAIE,gBAAgB,GAAG7C,OAAO,CAAC6C,gBAAgB,CAAC,CAAC;AACjD;AACA;;AAEA,SAASC,YAAYA,CAACC,QAAQ,EAAE;EAC9B,IAAIC,QAAQ,GAAGD,QAAQ,CAACE,WAAW,CAAC,CAAC;EAErC,IAAID,QAAQ,EAAE;IACZ,OAAOA,QAAQ,CAACE,cAAc,CAAC,CAAC;EAClC;EAEA,OAAOzC,SAAS,CAAC0C,cAAc,GAAG,CAAC;AACrC;AAEA,SAASC,uBAAuBA,CAACC,SAAS,EAAEC,KAAK,EAAE;EACjD;EACAA,KAAK,CAACC,cAAc,CAACjC,IAAI,CAAC,yBAAyB,CAAC;EAEpD+B,SAAS,CAACG,SAAS,GAAG,UAAUC,OAAO,EAAE;IACvC,IAAIA,OAAO,EAAE;MACXH,KAAK,CAACI,iBAAiB,GAAG,IAAI;MAC9BJ,KAAK,CAACK,WAAW,GAAGN,SAAS,CAACO,sBAAsB,CAAC,gBAAgB,CAAC;MACtEN,KAAK,CAACO,eAAe,GAAGP,KAAK,CAACK,WAAW,CAACC,sBAAsB,CAAC,mBAAmB,CAAC;MACrFN,KAAK,CAACQ,mBAAmB,GAAGR,KAAK,CAACO,eAAe,CAACE,SAAS,CAAC,CAAC;MAC7DT,KAAK,CAACU,YAAY,GAAGV,KAAK,CAACO,eAAe,CAACI,cAAc,CAACX,KAAK,CAACO,eAAe,CAACK,aAAa,CAAC,CAAC,CAACC,eAAe,CAAC,CAAC,CAAC;IACpH;EACF,CAAC,CAAC,CAAC;;EAGHd,SAAS,CAACe,eAAe,GAAG,UAAUX,OAAO,EAAEY,UAAU,EAAE;IACzD,IAAIZ,OAAO,EAAE;MACXH,KAAK,CAACI,iBAAiB,GAAGW,UAAU;MACpChB,SAAS,CAACiB,MAAM,CAAC,CAAC;IACpB;EACF,CAAC;EAEDjB,SAAS,CAACkB,WAAW,GAAG,UAAUd,OAAO,EAAE;IACzC,IAAIA,OAAO,EAAE;MACXH,KAAK,CAACkB,oBAAoB,GAAG,IAAI;MACjClB,KAAK,CAACmB,WAAW,GAAG,IAAI;MACxBpB,SAAS,CAACiB,MAAM,CAAC,CAAC;MAClBhB,KAAK,CAACmB,WAAW,GAAG,KAAK;IAC3B;EACF,CAAC;EAEDpB,SAAS,CAACqB,iBAAiB,GAAG,UAAUjB,OAAO,EAAE;IAC/C,OAAOJ,SAAS,CAACkB,WAAW,CAACd,OAAO,CAAC;EACvC,CAAC;EAEDJ,SAAS,CAACsB,UAAU,GAAG,UAAUlB,OAAO,EAAE;IACxC,IAAIA,OAAO,EAAE;MACXJ,SAAS,CAACiB,MAAM,CAAC,CAAC;IACpB;EACF,CAAC;EAEDjB,SAAS,CAACiB,MAAM,GAAG,YAAY;IAC7B,IAAIM,GAAG,GAAGtB,KAAK,CAACQ,mBAAmB,CAACe,UAAU,CAAC,CAAC;IAEhD,IAAIvB,KAAK,CAACwB,OAAO,KAAKF,GAAG,EAAE;MACzBtB,KAAK,CAACwB,OAAO,GAAGF,GAAG;MAEnB,KAAK,IAAIlD,CAAC,GAAGU,SAAS,CAAC2C,KAAK,EAAErD,CAAC,GAAGU,SAAS,CAAC4C,GAAG,EAAEtD,CAAC,EAAE,EAAE;QACpD4B,KAAK,CAAC2B,UAAU,CAACvD,CAAC,CAAC,CAACwD,qBAAqB,CAAC5B,KAAK,CAACQ,mBAAmB,CAAC;MACtE;IACF;IAEA,IAAIqB,KAAK,GAAG7B,KAAK,CAACK,WAAW,CAACO,aAAa,CAAC,CAAC;IAE7C,IAAIkB,GAAG,GAAG9B,KAAK,CAACO,eAAe,CAACK,aAAa,CAAC,CAAC;IAE/Cb,SAAS,CAACgC,WAAW,CAACD,GAAG,EAAED,KAAK,CAAC;EACnC,CAAC;EAED9B,SAAS,CAACiC,iBAAiB,GAAG,UAAUC,OAAO,EAAEH,GAAG,EAAED,KAAK,EAAE;IAC3DI,OAAO,CAACC,MAAM,GAAGnF,aAAa;IAC9BkF,OAAO,CAACE,QAAQ,GAAGnF,aAAa;IAChCiF,OAAO,CAACG,QAAQ,GAAG,EAAE;EACvB,CAAC;EAEDrC,SAAS,CAACsC,kBAAkB,GAAG,UAAUJ,OAAO,EAAEH,GAAG,EAAED,KAAK,EAAE;IAC5D,IAAIS,QAAQ,GAAGL,OAAO,CAACC,MAAM;IAC7B,IAAIK,QAAQ,GAAGN,OAAO,CAACG,QAAQ;IAC/B,IAAII,QAAQ,GAAGP,OAAO,CAACE,QAAQ;IAC/B,IAAIM,mBAAmB,GAAGzC,KAAK,CAAC0C,WAAW,CAACC,kBAAkB,CAAC,qBAAqB,CAAC,CAAC,CAAC;IACvF;;IAEA,IAAIC,QAAQ,GAAG,CAAC,wBAAwB,EAAE,wBAAwB,EAAE,yBAAyB,EAAE,uDAAuD,EAAE,mCAAmC,EAAE,mCAAmC,CAAC,CAAC,CAAC;;IAEnO,IAAIH,mBAAmB,EAAE;MACvBG,QAAQ,GAAGA,QAAQ,CAACC,MAAM,CAAC,CAAC,oCAAoC,EAAE,qCAAqC,CAAC,CAAC;IAC3G,CAAC,CAAC;IACF;IACA;;IAGA,IAAIC,SAAS,GAAG,CAAC,oBAAoB,EAAE,sBAAsB,EAAE,kBAAkB,CAAC;IAElF,IAAIL,mBAAmB,EAAE;MACvBK,SAAS,GAAGA,SAAS,CAACD,MAAM,CAAC,CAAC,uBAAuB,EAAE,wBAAwB,CAAC,CAAC;IACnF;IAEAC,SAAS,GAAGA,SAAS,CAACD,MAAM,CAAC,CAAC,uCAAuC,EAAE,uCAAuC,EAAE,6BAA6B,CAAC,CAAC;IAE/I,IAAIJ,mBAAmB,EAAE;MACvBK,SAAS,GAAGA,SAAS,CAACD,MAAM,CAAC,CAAC,yCAAyC,EAAE,yCAAyC,CAAC,CAAC;IACtH,CAAC,CAAC;;IAGF,IAAI7C,KAAK,CAAC0C,WAAW,CAACK,OAAO,CAAC,CAAC,CAACC,kBAAkB,CAAC,CAAC,KAAK,CAAC,IAAI,CAAChD,KAAK,CAACiD,YAAY,EAAE;MACjFL,QAAQ,GAAGA,QAAQ,CAACC,MAAM,CAAC,CAAC,mCAAmC,CAAC,CAAC;MACjEP,QAAQ,GAAG1F,gBAAgB,CAACsG,UAAU,CAACZ,QAAQ,EAAE,mBAAmB,EAAE,CAAC,6BAA6B,EAAE,mCAAmC,CAAC,CAAC,CAACa,MAAM;MAClJb,QAAQ,GAAG1F,gBAAgB,CAACsG,UAAU,CAACZ,QAAQ,EAAE,oBAAoB,EAAE,CAAC,qCAAqC,CAAC,CAAC,CAACa,MAAM;MACtHZ,QAAQ,GAAG3F,gBAAgB,CAACsG,UAAU,CAACX,QAAQ,EAAE,mBAAmB,EAAE,CAAC,gCAAgC,EAAE,+BAA+B,CAAC,CAAC,CAACY,MAAM;MACjJZ,QAAQ,GAAG3F,gBAAgB,CAACsG,UAAU,CAACX,QAAQ,EAAE,oBAAoB,EAAE,CAAC,+CAA+C,CAAC,CAAC,CAACY,MAAM;IAClI;IAEA,IAAInD,KAAK,CAAC0C,WAAW,CAACK,OAAO,CAAC,CAAC,CAACC,kBAAkB,CAAC,CAAC,KAAK,CAAC,IAAI,CAAChD,KAAK,CAACiD,YAAY,EAAE;MACjFT,QAAQ,GAAG5F,gBAAgB,CAACsG,UAAU,CAACV,QAAQ,EAAE,oBAAoB,EAAEM,SAAS,CAACD,MAAM,CAAC,CAAC,2CAA2C,EAAE,2CAA2C,EAAE,4CAA4C,CAAC,CAAC,CAAC,CAACM,MAAM;IAC3O,CAAC,MAAM;MACL,IAAInD,KAAK,CAACoD,UAAU,CAACC,kCAAkC,CAAC,CAAC,IAAIrD,KAAK,CAACoD,UAAU,CAACE,mBAAmB,CAAC,CAAC,IAAI,CAACtD,KAAK,CAACiD,YAAY,EAAE;QAC1HT,QAAQ,GAAG5F,gBAAgB,CAACsG,UAAU,CAACV,QAAQ,EAAE,oBAAoB,EAAEM,SAAS,CAACD,MAAM,CAAC,CAAC,6DAA6D,EAAE,gCAAgC,EAAE,gCAAgC,EAAE,iCAAiC,CAAC,CAAC,CAAC,CAACM,MAAM;MACzQ,CAAC,MAAM;QACL,IAAItB,KAAK,CAAC0B,mBAAmB,CAAC,CAAC,IAAI,CAACvD,KAAK,CAACiD,YAAY,EAAE;UACtDL,QAAQ,GAAGA,QAAQ,CAACC,MAAM,CAAC,CAAC,yDAAyD,EAAE,2DAA2D,EAAE,2DAA2D,EAAE,+DAA+D,EAAE,+DAA+D,CAAC,CAAC;UAEnV,IAAIJ,mBAAmB,EAAE;YACvBG,QAAQ,GAAGA,QAAQ,CAACC,MAAM,CAAC,CAAC,uEAAuE,EAAE,kEAAkE,EAAE,uCAAuC,CAAC,CAAC;YAClNC,SAAS,GAAGA,SAAS,CAACD,MAAM,CAAC,CAAC,gCAAgC,EAAE,8DAA8D,EAAE,8DAA8D,EAAE,iEAAiE,EAAE,2CAA2C,EAAE,iCAAiC,CAAC,CAAC;UACrV,CAAC,MAAM;YACLC,SAAS,GAAGA,SAAS,CAACD,MAAM,CAAC,CAAC,gCAAgC,EAAE,8DAA8D,EAAE,8DAA8D,EAAE,iCAAiC,CAAC,CAAC;UACrO;QACF;QAEA,IAAI7C,KAAK,CAACwD,eAAe,IAAI,CAACxD,KAAK,CAACiD,YAAY,EAAE;UAChDL,QAAQ,GAAGA,QAAQ,CAACC,MAAM,CAAC,CAAC,iCAAiC,CAAC,CAAC;QACjE;QAEAL,QAAQ,GAAG5F,gBAAgB,CAACsG,UAAU,CAACV,QAAQ,EAAE,oBAAoB,EAAEM,SAAS,CAAC,CAACK,MAAM;MAC1F;IACF;IAEAX,QAAQ,GAAG5F,gBAAgB,CAACsG,UAAU,CAACV,QAAQ,EAAE,mBAAmB,EAAEI,QAAQ,CAAC,CAACO,MAAM;IACtFlB,OAAO,CAACC,MAAM,GAAGI,QAAQ;IACzBL,OAAO,CAACG,QAAQ,GAAGG,QAAQ;IAC3BN,OAAO,CAACE,QAAQ,GAAGK,QAAQ;EAC7B,CAAC;EAEDzC,SAAS,CAAC0D,kBAAkB,GAAG,UAAUxB,OAAO,EAAEH,GAAG,EAAED,KAAK,EAAE;IAC5D,IAAIW,QAAQ,GAAGP,OAAO,CAACE,QAAQ,CAAC,CAAC;;IAEjC,IAAIuB,YAAY,GAAG,EAAE;IACrB,IAAIjB,mBAAmB,GAAGzC,KAAK,CAAC0C,WAAW,CAACC,kBAAkB,CAAC,qBAAqB,CAAC;IACrF,IAAIgB,cAAc,GAAG3D,KAAK,CAAC0C,WAAW,CAACC,kBAAkB,CAAC,gBAAgB,CAAC;IAC3E,IAAIiB,OAAO,GAAG,EAAE;IAEhB,QAAQnB,mBAAmB;MACzB,KAAK,CAAC;QACJ;QACAD,QAAQ,GAAG5F,gBAAgB,CAACsG,UAAU,CAACV,QAAQ,EAAE,oBAAoB,EAAE,CAAC,oFAAoF,EAAE,sBAAsB,CAAC,EAAE,KAAK,CAAC,CAACW,MAAM;QACpM;MAEF,KAAK,CAAC;QACJ;QACAX,QAAQ,GAAG5F,gBAAgB,CAACsG,UAAU,CAACV,QAAQ,EAAE,oBAAoB,EAAE,CAAC,4CAA4C,EAAE,sCAAsC,EAAE,sCAAsC,EAAE,wCAAwC,EAAE,uGAAuG,EAAE,sBAAsB,CAAC,EAAE,KAAK,CAAC,CAACW,MAAM;QAC/X;MAEF,KAAK,CAAC;QACJ;QACA,KAAK,IAAIU,EAAE,GAAG,CAAC,EAAEA,EAAE,GAAGF,cAAc,EAAE,EAAEE,EAAE,EAAE;UAC1CD,OAAO,GAAGA,OAAO,CAACf,MAAM,CAAC,CAAC,yBAAyB,CAACA,MAAM,CAACgB,EAAE,EAAE,GAAG,CAAC,EAAE,+BAA+B,CAAChB,MAAM,CAACgB,EAAE,EAAE,iBAAiB,CAAC,EAAE,+BAA+B,CAAChB,MAAM,CAACgB,EAAE,EAAE,iBAAiB,CAAC,CAAC,CAAC;QACrM;QAEArB,QAAQ,GAAG5F,gBAAgB,CAACsG,UAAU,CAACV,QAAQ,EAAE,mBAAmB,EAAEoB,OAAO,CAAC,CAACT,MAAM;QACrFS,OAAO,GAAG,CAAC,8BAA8B,EAAE,iCAAiC,EAAE,aAAa,CAAC;QAE5F,KAAK,IAAIE,GAAG,GAAG,CAAC,EAAEA,GAAG,GAAGH,cAAc,EAAE,EAAEG,GAAG,EAAE;UAC7CF,OAAO,GAAGA,OAAO,CAACf,MAAM,CAAC,CAAC,yDAAyD,CAACA,MAAM,CAACiB,GAAG,EAAE,KAAK,CAAC,EAAE,oBAAoB,CAACjB,MAAM,CAACa,YAAY,EAAE,gBAAgB,CAAC,CAACb,MAAM,CAACiB,GAAG,EAAE,IAAI,CAAC,EAAE,8CAA8C,CAACjB,MAAM,CAACiB,GAAG,EAAE,UAAU,CAAC,EAAE,OAAO,EAAE,mHAAmH,CAACjB,MAAM,CAACiB,GAAG,EAAE,8JAA8J,CAAC,EAAE,sBAAsB,CAACjB,MAAM,CAACa,YAAY,EAAE,eAAe,CAAC,CAACb,MAAM,CAACiB,GAAG,EAAE,IAAI,CAAC,EAAE,OAAO,CAAC,CAAC;QACpoB;QAEAF,OAAO,GAAGA,OAAO,CAACf,MAAM,CAAC,CAAC,uCAAuC,EAAE,0CAA0C,EAAE,uGAAuG,EAAE,sBAAsB,CAAC,CAAC;QAChPL,QAAQ,GAAG5F,gBAAgB,CAACsG,UAAU,CAACV,QAAQ,EAAE,oBAAoB,EAAEoB,OAAO,EAAE,KAAK,CAAC,CAACT,MAAM;QAC7F;MAEF,KAAK,CAAC;QACJ;QACA,KAAK,IAAIY,IAAI,GAAG,CAAC,EAAEA,IAAI,GAAGJ,cAAc,EAAE,EAAEI,IAAI,EAAE;UAChDH,OAAO,GAAGA,OAAO,CAACf,MAAM,CAAC,CAAC,yBAAyB,CAACA,MAAM,CAACkB,IAAI,EAAE,GAAG,CAAC,EAAE,+BAA+B,CAAClB,MAAM,CAACkB,IAAI,EAAE,iBAAiB,CAAC,EAAE,+BAA+B,CAAClB,MAAM,CAACkB,IAAI,EAAE,iBAAiB,CAAC,EAAE,8BAA8B,CAAClB,MAAM,CAACkB,IAAI,EAAE,GAAG,CAAC,EAAE,+BAA+B,CAAClB,MAAM,CAACkB,IAAI,EAAE,GAAG,CAAC,EAAE,8BAA8B,CAAClB,MAAM,CAACkB,IAAI,EAAE,GAAG,CAAC,EAAE,6BAA6B,CAAClB,MAAM,CAACkB,IAAI,EAAE,GAAG,CAAC,EAAE,6BAA6B,CAAClB,MAAM,CAACkB,IAAI,EAAE,GAAG,CAAC,CAAC,CAAC;QACpc;QAEAvB,QAAQ,GAAG5F,gBAAgB,CAACsG,UAAU,CAACV,QAAQ,EAAE,mBAAmB,EAAEoB,OAAO,CAAC,CAACT,MAAM;QACrFS,OAAO,GAAG,CAAC,8BAA8B,EAAE,iCAAiC,EAAE,8BAA8B,EAAE,sBAAsB,EAAE,aAAa,CAAC;QAEpJ,KAAK,IAAII,IAAI,GAAG,CAAC,EAAEA,IAAI,GAAGL,cAAc,EAAE,EAAEK,IAAI,EAAE;UAChDJ,OAAO,GAAGA,OAAO,CAACf,MAAM,CAAC,CAAC,sBAAsB,EAAE,uBAAuB,CAACA,MAAM,CAACmB,IAAI,EAAE,QAAQ,CAAC,EAAE,OAAO,EAAE,+CAA+C,CAACnB,MAAM,CAACmB,IAAI,EAAE,GAAG,CAAC,EAAE,OAAO,EAAE,QAAQ,EAAE,OAAO,EAAE,2DAA2D,CAACnB,MAAM,CAACmB,IAAI,EAAE,GAAG,CAAC,EAAE,sDAAsD,EAAE,6DAA6D,EAAE,yBAAyB,EAAE,yBAAyB,CAACnB,MAAM,CAACmB,IAAI,EAAE,IAAI,CAAC,EAAE,2BAA2B,CAACnB,MAAM,CAACmB,IAAI,EAAE,iBAAiB,CAAC,EAAE,2BAA2B,CAACnB,MAAM,CAACmB,IAAI,EAAE,gCAAgC,CAAC,EAAE,sEAAsE,EAAE,wBAAwB,CAACnB,MAAM,CAACmB,IAAI,EAAE,WAAW,CAAC,EAAE,SAAS,EAAE,kEAAkE,CAACnB,MAAM,CAACmB,IAAI,EAAE,IAAI,CAAC,EAAE,6BAA6B,EAAE,iDAAiD,CAACnB,MAAM,CAACmB,IAAI,EAAE,KAAK,CAAC,EAAE,WAAW,EAAE,gEAAgE,CAACnB,MAAM,CAACmB,IAAI,EAAE,IAAI,CAAC,EAAE,WAAW,EAAE,YAAY,EAAE,WAAW,EAAE,4BAA4B,EAAE,WAAW,EAAE,SAAS,EAAE,OAAO,EAAE,8EAA8E,EAAE,sBAAsB,CAACnB,MAAM,CAACa,YAAY,EAAE,gBAAgB,CAAC,CAACb,MAAM,CAACmB,IAAI,EAAE,IAAI,CAAC,EAAE,4DAA4D,EAAE,SAAS,EAAE,8IAA8I,CAACnB,MAAM,CAACmB,IAAI,EAAE,kQAAkQ,CAAC,EAAE,uBAAuB,CAACnB,MAAM,CAACa,YAAY,EAAE,gBAAgB,CAAC,CAACb,MAAM,CAACmB,IAAI,EAAE,IAAI,CAAC,EAAE,OAAO,CAAC,CAAC;QACz1D;QAEAJ,OAAO,GAAGA,OAAO,CAACf,MAAM,CAAC,CAAC,uCAAuC,EAAE,0CAA0C,EAAE,uGAAuG,EAAE,sBAAsB,CAAC,CAAC;QAChPL,QAAQ,GAAG5F,gBAAgB,CAACsG,UAAU,CAACV,QAAQ,EAAE,oBAAoB,EAAEoB,OAAO,EAAE,KAAK,CAAC,CAACT,MAAM;QAC7F;MAEF;QACElH,aAAa,CAAC,sBAAsB,CAAC;IACzC;IAEAgG,OAAO,CAACE,QAAQ,GAAGK,QAAQ;EAC7B,CAAC;EAEDzC,SAAS,CAACkE,mBAAmB,GAAG,UAAUhC,OAAO,EAAEH,GAAG,EAAED,KAAK,EAAE;IAC7D,IAAIY,mBAAmB,GAAGzC,KAAK,CAAC0C,WAAW,CAACC,kBAAkB,CAAC,qBAAqB,CAAC;IAErF,IAAIF,mBAAmB,GAAG,CAAC,EAAE;MAC3B,IAAIH,QAAQ,GAAGL,OAAO,CAACC,MAAM;MAC7B,IAAIK,QAAQ,GAAGN,OAAO,CAACG,QAAQ;MAC/B,IAAII,QAAQ,GAAGP,OAAO,CAACE,QAAQ;MAE/B,IAAInC,KAAK,CAAC0C,WAAW,CAACK,OAAO,CAAC,CAAC,CAACmB,eAAe,CAAC,CAAC,EAAE;QACjD5B,QAAQ,GAAG1F,gBAAgB,CAACsG,UAAU,CAACZ,QAAQ,EAAE,oBAAoB,EAAE,CAAC,0BAA0B,EAAE,4BAA4B,EAAE,gCAAgC,CAAC,CAAC,CAACa,MAAM;QAC3Kb,QAAQ,GAAG1F,gBAAgB,CAACsG,UAAU,CAACZ,QAAQ,EAAE,qBAAqB,EAAE,CAAC,6CAA6C,CAAC,CAAC,CAACa,MAAM;QAC/HZ,QAAQ,GAAG3F,gBAAgB,CAACsG,UAAU,CAACX,QAAQ,EAAE,oBAAoB,EAAE,CAAC,6BAA6B,EAAE,4BAA4B,CAAC,CAAC,CAACY,MAAM;QAC5IZ,QAAQ,GAAG3F,gBAAgB,CAACsG,UAAU,CAACX,QAAQ,EAAE,qBAAqB,EAAE,CAAC,yCAAyC,CAAC,CAAC,CAACY,MAAM;QAC3HX,QAAQ,GAAG5F,gBAAgB,CAACsG,UAAU,CAACV,QAAQ,EAAE,oBAAoB,EAAE,CAAC,gCAAgC,CAAC,CAAC,CAACW,MAAM;QACjHX,QAAQ,GAAG5F,gBAAgB,CAACsG,UAAU,CAACV,QAAQ,EAAE,qBAAqB,EAAE,CAAC,sDAAsD;QAAE;QACjI;QACA,0EAA0E,CAAC,CAAC,CAACW,MAAM;MACrF,CAAC,MAAM;QACL,IAAInD,KAAK,CAACmE,eAAe,EAAE;UACzB3B,QAAQ,GAAG5F,gBAAgB,CAACsG,UAAU,CAACV,QAAQ,EAAE,oBAAoB,EAAE,CAAC,4BAA4B,EAAE,iCAAiC,CAAC,CAAC,CAACW,MAAM;UAChJX,QAAQ,GAAG5F,gBAAgB,CAACsG,UAAU,CAACV,QAAQ,EAAE,qBAAqB,EAAE,CAAC,kDAAkD,EAAE,0EAA0E,EAAE,0EAA0E,CAAC,CAAC,CAACW,MAAM;QAC9R,CAAC,MAAM;UACL,IAAInD,KAAK,CAAC0C,WAAW,CAAC0B,aAAa,CAACvC,KAAK,CAACwC,WAAW,CAAC,CAAC,CAACC,iBAAiB,CAAC,CAAC,CAAC,KAAKtE,KAAK,CAACwB,OAAO,CAAC+C,KAAK,EAAE;YACpG;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA/B,QAAQ,GAAG5F,gBAAgB,CAACsG,UAAU,CAACV,QAAQ,EAAE,0BAA0B,EAAE,CAAC,kCAAkC,EAAE,kCAAkC,EAAE,4BAA4B,CAAC,CAAC;YACpL,CAAC,CAACW,MAAM;YACRX,QAAQ,GAAG5F,gBAAgB,CAACsG,UAAU,CAACV,QAAQ,EAAE,qBAAqB,EAAE,CAAC,wBAAwB,EAAE,yBAAyB,EAAE,mGAAmG,EAAE,qGAAqG,CAAC,CAAC,CAACW,MAAM;UACnV,CAAC,MAAM;YACLX,QAAQ,GAAG5F,gBAAgB,CAACsG,UAAU,CAACV,QAAQ,EAAE,oBAAoB,EAAE,CAAC,6BAA6B,CAAC,CAAC,CAACW,MAAM;YAC9GX,QAAQ,GAAG5F,gBAAgB,CAACsG,UAAU,CAACV,QAAQ,EAAE,0BAA0B,EAAE;YAAC;YAC9E;YACA,kCAAkC,EAAE,kCAAkC,EAAE,4BAA4B,CAAC,CAAC;YACtG,CAAC,CAACW,MAAM;YACRX,QAAQ,GAAG5F,gBAAgB,CAACsG,UAAU,CAACV,QAAQ,EAAE,qBAAqB,EAAE,CAAC,yBAAyB,EAAE,yBAAyB,EAAE,sDAAsD;YAAE;YACvL;YACA,sGAAsG,EAAE,sHAAsH,CAAC,CAAC,CAACW,MAAM;UACzO;QACF;MACF;MAEAlB,OAAO,CAACC,MAAM,GAAGI,QAAQ;MACzBL,OAAO,CAACG,QAAQ,GAAGG,QAAQ;MAC3BN,OAAO,CAACE,QAAQ,GAAGK,QAAQ;IAC7B;EACF,CAAC;EAEDzC,SAAS,CAACyE,uBAAuB,GAAG,UAAUvC,OAAO,EAAEH,GAAG,EAAED,KAAK,EAAE;IACjE;IACA7B,KAAK,CAAC0C,WAAW,CAAC8B,uBAAuB,CAACvC,OAAO,EAAEH,GAAG,EAAED,KAAK,CAAC;IAC9D,IAAIS,QAAQ,GAAGL,OAAO,CAACC,MAAM;IAC7B,IAAIK,QAAQ,GAAGN,OAAO,CAACG,QAAQ;IAC/B,IAAII,QAAQ,GAAGP,OAAO,CAACE,QAAQ,CAAC,CAAC;;IAEjC,IAAIM,mBAAmB,GAAGzC,KAAK,CAAC0C,WAAW,CAACC,kBAAkB,CAAC,qBAAqB,CAAC;IAErF,IAAIF,mBAAmB,GAAG,CAAC,EAAE;MAC3BH,QAAQ,GAAG1F,gBAAgB,CAACsG,UAAU,CAACZ,QAAQ,EAAE,wBAAwB,EAAE,CAAC,gCAAgC,CAAC,CAAC,CAACa,MAAM;MACrHb,QAAQ,GAAG1F,gBAAgB,CAACsG,UAAU,CAACZ,QAAQ,EAAE,yBAAyB,EAAE,CAAC,2CAA2C,EAAE,wCAAwC,CAAC,CAAC,CAACa,MAAM;MAC3Kb,QAAQ,GAAG1F,gBAAgB,CAACsG,UAAU,CAACZ,QAAQ,EAAE,oBAAoB,EAAE,CAAC,0BAA0B,EAAE,0BAA0B,CAAC,CAAC,CAACa,MAAM;MACvIZ,QAAQ,GAAG3F,gBAAgB,CAACsG,UAAU,CAACX,QAAQ,EAAE,wBAAwB,EAAE,CAAC,6BAA6B,EAAE,4BAA4B,CAAC,CAAC,CAACY,MAAM;MAChJZ,QAAQ,GAAG3F,gBAAgB,CAACsG,UAAU,CAACX,QAAQ,EAAE,yBAAyB,EAAE,CAAC,yCAAyC,CAAC,CAAC,CAACY,MAAM;MAC/HX,QAAQ,GAAG5F,gBAAgB,CAACsG,UAAU,CAACV,QAAQ,EAAE,wBAAwB,EAAE,CAAC,gCAAgC,CAAC,CAAC,CAACW,MAAM;MACrHX,QAAQ,GAAG5F,gBAAgB,CAACsG,UAAU,CAACV,QAAQ,EAAE,yBAAyB,EAAE,CAAC,mCAAmC,CAAC,CAAC,CAACW,MAAM;IAC3H,CAAC,MAAM;MACLb,QAAQ,GAAG1F,gBAAgB,CAACsG,UAAU,CAACZ,QAAQ,EAAE,oBAAoB,EAAE,CAAC,0BAA0B,CAAC,CAAC,CAACa,MAAM;MAC3Gb,QAAQ,GAAG1F,gBAAgB,CAACsG,UAAU,CAACZ,QAAQ,EAAE,yBAAyB,EAAE,CAAC,wCAAwC,CAAC,CAAC,CAACa,MAAM;IAChI;IAEAlB,OAAO,CAACC,MAAM,GAAGI,QAAQ;IACzBL,OAAO,CAACG,QAAQ,GAAGG,QAAQ;IAC3BN,OAAO,CAACE,QAAQ,GAAGK,QAAQ;EAC7B,CAAC;EAEDzC,SAAS,CAAC0E,mBAAmB,GAAG,UAAUxC,OAAO,EAAEH,GAAG,EAAED,KAAK,EAAE;IAC7D,IAAI7B,KAAK,CAAC0C,WAAW,CAACK,OAAO,CAAC,CAAC,CAAC2B,eAAe,CAAC,CAAC,EAAE;MACjD,IAAIpC,QAAQ,GAAGL,OAAO,CAACC,MAAM;MAC7B,IAAIK,QAAQ,GAAGN,OAAO,CAACG,QAAQ;MAC/B,IAAII,QAAQ,GAAGP,OAAO,CAACE,QAAQ;MAE/B,IAAInC,KAAK,CAACiD,YAAY,EAAE;QACtB;MACF;MAEAX,QAAQ,GAAG1F,gBAAgB,CAACsG,UAAU,CAACZ,QAAQ,EAAE,qBAAqB,EAAE,8BAA8B,CAAC,CAACa,MAAM,CAAC,CAAC;MAChH;MACA;MACA;;MAEA,IAAIwB,GAAG,GAAG3E,KAAK,CAACK,WAAW,CAACuE,iBAAiB,CAAC,CAAC;MAC/C,IAAIC,QAAQ,GAAG,CAAC;MAChB,IAAIC,KAAK,GAAG,CAAC;MAEb,IAAIH,GAAG,IAAIA,GAAG,CAACrG,MAAM,GAAG,CAAC,EAAE;QACzBuG,QAAQ,GAAGF,GAAG,CAAC,CAAC,CAAC,CAACI,aAAa,CAAC,CAAC;QAEjC,IAAIJ,GAAG,CAAC,CAAC,CAAC,CAACK,SAAS,CAAC,CAAC,KAAKhF,KAAK,CAACwB,OAAO,CAACyD,gBAAgB,EAAE;UACzDH,KAAK,GAAG,CAAC;QACX;MACF;MAEA,IAAI9E,KAAK,CAACoD,UAAU,CAAC8B,kBAAkB,CAAC,CAAC,EAAE;QACzCL,QAAQ,GAAG7E,KAAK,CAACoD,UAAU,CAAC8B,kBAAkB,CAAC,CAAC,CAACC,YAAY,CAAC,CAAC,CAACC,UAAU,CAAC,CAAC,CAACC,qBAAqB,CAAC,CAAC;QACpGP,KAAK,GAAG,CAAC;MACX;MAEA,IAAIA,KAAK,KAAK,CAAC,EAAE;QACfxC,QAAQ,GAAG1F,gBAAgB,CAACsG,UAAU,CAACZ,QAAQ,EAAE,oBAAoB,EAAE,yDAAyD,CAAC,CAACa,MAAM;QACxIZ,QAAQ,GAAG3F,gBAAgB,CAACsG,UAAU,CAACX,QAAQ,EAAE,oBAAoB,EAAE,CAAC,6BAA6B,EAAE,4BAA4B,CAAC,CAAC,CAACY,MAAM;QAC5IZ,QAAQ,GAAG3F,gBAAgB,CAACsG,UAAU,CAACX,QAAQ,EAAE,qBAAqB,EAAE,yCAAyC,CAAC,CAACY,MAAM;QACzHX,QAAQ,GAAG5F,gBAAgB,CAACsG,UAAU,CAACV,QAAQ,EAAE,oBAAoB,EAAE,CAAC,gCAAgC,EAAE,6BAA6B,CAAC,CAAC,CAACW,MAAM;QAEhJ,IAAIwB,GAAG,IAAIA,GAAG,CAACrG,MAAM,IAAI,CAAC,EAAE;UAC1B,QAAQuG,QAAQ;YACd,KAAK,CAAC;cACJrC,QAAQ,GAAG5F,gBAAgB,CAACsG,UAAU,CAACV,QAAQ,EAAE,qBAAqB,EAAE,CAAC,wDAAwD,EAAE,yCAAyC,EAAE,yCAAyC,CAAC,CAAC,CAACW,MAAM;cAChO;YAEF,KAAK,CAAC;cACJX,QAAQ,GAAG5F,gBAAgB,CAACsG,UAAU,CAACV,QAAQ,EAAE,qBAAqB,EAAE,CAAC,wDAAwD,EAAE,yCAAyC,EAAE,yCAAyC,EAAE,iCAAiC,CAAC,CAAC,CAACW,MAAM;cACnQ;YAEF;cACEX,QAAQ,GAAG5F,gBAAgB,CAACsG,UAAU,CAACV,QAAQ,EAAE,qBAAqB,EAAE,CAAC,wDAAwD,EAAE,2CAA2C,EAAE,2CAA2C,EAAE,iCAAiC,CAAC,CAAC,CAACW,MAAM;UAC3Q;QACF;MACF,CAAC,MAAM;QACLb,QAAQ,GAAG1F,gBAAgB,CAACsG,UAAU,CAACZ,QAAQ,EAAE,oBAAoB,EAAE,yDAAyD,CAAC,CAACa,MAAM;QACxIZ,QAAQ,GAAG3F,gBAAgB,CAACsG,UAAU,CAACX,QAAQ,EAAE,oBAAoB,EAAE,CAAC,6BAA6B,EAAE,4BAA4B,CAAC,CAAC,CAACY,MAAM;QAC5IZ,QAAQ,GAAG3F,gBAAgB,CAACsG,UAAU,CAACX,QAAQ,EAAE,qBAAqB,EAAE,yCAAyC,CAAC,CAACY,MAAM;QACzHX,QAAQ,GAAG5F,gBAAgB,CAACsG,UAAU,CAACV,QAAQ,EAAE,oBAAoB,EAAE,CAAC,gCAAgC,EAAE,+BAA+B,CAAC,CAAC,CAACW,MAAM;QAElJ,QAAQ0B,QAAQ;UACd,KAAK,CAAC;YACJrC,QAAQ,GAAG5F,gBAAgB,CAACsG,UAAU,CAACV,QAAQ,EAAE,qBAAqB,EAAE,CAAC,0DAA0D,EAAE,yCAAyC,EAAE,yCAAyC,CAAC,CAAC,CAACW,MAAM;YAClO;UAEF,KAAK,CAAC;YACJX,QAAQ,GAAG5F,gBAAgB,CAACsG,UAAU,CAACV,QAAQ,EAAE,qBAAqB,EAAE,CAAC,0DAA0D,EAAE,yCAAyC,EAAE,yCAAyC,EAAE,iCAAiC,CAAC,CAAC,CAACW,MAAM;YACrQ;UAEF;YACEX,QAAQ,GAAG5F,gBAAgB,CAACsG,UAAU,CAACV,QAAQ,EAAE,qBAAqB,EAAE,CAAC,0DAA0D,EAAE,2CAA2C,EAAE,2CAA2C,EAAE,iCAAiC,CAAC,CAAC,CAACW,MAAM;QAC7Q;MACF;MAEAlB,OAAO,CAACC,MAAM,GAAGI,QAAQ;MACzBL,OAAO,CAACG,QAAQ,GAAGG,QAAQ;MAC3BN,OAAO,CAACE,QAAQ,GAAGK,QAAQ;IAC7B;EACF,CAAC;EAEDzC,SAAS,CAACuF,iBAAiB,GAAG,UAAUrD,OAAO,EAAEH,GAAG,EAAED,KAAK,EAAE;IAC3D,IAAIS,QAAQ,GAAGL,OAAO,CAACC,MAAM;IAC7B,IAAIM,QAAQ,GAAGP,OAAO,CAACE,QAAQ;IAE/B,IAAInC,KAAK,CAACoD,UAAU,CAACmC,yBAAyB,CAAC,CAAC,EAAE;MAChD,IAAIC,aAAa,GAAGxF,KAAK,CAACoD,UAAU,CAACmC,yBAAyB,CAAC,CAAC;MAChEjD,QAAQ,GAAG1F,gBAAgB,CAACsG,UAAU,CAACZ,QAAQ,EAAE,kBAAkB,EAAE,CAAC,4BAA4B,EAAE,0BAA0B,CAACO,MAAM,CAAC2C,aAAa,EAAE,IAAI,CAAC,EAAE,sCAAsC,CAAC3C,MAAM,CAAC2C,aAAa,EAAE,IAAI,CAAC,CAAC,CAAC,CAACrC,MAAM;MACvOb,QAAQ,GAAG1F,gBAAgB,CAACsG,UAAU,CAACZ,QAAQ,EAAE,mBAAmB,EAAE,CAAC,oCAAoC,CAACO,MAAM,CAAC2C,aAAa,EAAE,eAAe,CAAC,EAAE,OAAO,EAAE,oCAAoC,EAAE,WAAW,EAAE,gBAAgB,EAAE,WAAW,EAAE,4EAA4E,EAAE,OAAO,CAAC,CAAC,CAACrC,MAAM;MAC7UX,QAAQ,GAAG5F,gBAAgB,CAACsG,UAAU,CAACV,QAAQ,EAAE,kBAAkB,EAAE,CAAC,4BAA4B,EAAE,sCAAsC,CAACK,MAAM,CAAC2C,aAAa,EAAE,IAAI,CAAC,CAAC,CAAC,CAACrC,MAAM;MAC/KX,QAAQ,GAAG5F,gBAAgB,CAACsG,UAAU,CAACV,QAAQ,EAAE,mBAAmB,EAAE,CAAC,oCAAoC,CAACK,MAAM,CAAC2C,aAAa,EAAE,eAAe,CAAC,EAAE,OAAO,EAAE,oCAAoC,EAAE,WAAW,EAAE,gBAAgB,EAAE,WAAW,EAAE,yDAAyD,EAAE,OAAO,CAAC,CAAC,CAACrC,MAAM;IAC5T;IAEAlB,OAAO,CAACC,MAAM,GAAGI,QAAQ;IACzBL,OAAO,CAACE,QAAQ,GAAGK,QAAQ;EAC7B,CAAC;EAEDzC,SAAS,CAAC0F,uBAAuB,GAAG,UAAU3D,GAAG,EAAED,KAAK,EAAE;IACxD;IACA;IACA,IAAI6D,EAAE,GAAG;MACPC,MAAM,EAAE,GAAG;MACXC,MAAM,EAAE;IACV,CAAC;IACD,IAAIC,IAAI,GAAGhE,KAAK,CAACwC,WAAW,CAAC,CAAC;IAE9B,IAAIrE,KAAK,CAACoD,UAAU,CAAC0C,4BAA4B,CAAC,CAAC,IAAID,IAAI,CAACE,iBAAiB,CAAC,CAAC,IAAIF,IAAI,CAACvB,iBAAiB,CAAC,CAAC,KAAKvF,cAAc,CAACiH,OAAO,EAAE;MACtI,IAAIC,QAAQ,GAAGjG,KAAK,CAAC0C,WAAW,CAACwD,gBAAgB,CAAC,CAAC;MAEnD,IAAID,QAAQ,KAAKnH,SAAS,CAACqH,MAAM,IAAIN,IAAI,CAACvB,iBAAiB,CAAC,CAAC,KAAKvF,cAAc,CAACqH,MAAM,EAAE;QACvFV,EAAE,GAAG1F,KAAK,CAACoD,UAAU,CAACiD,yCAAyC,CAAC,CAAC;MACnE,CAAC,MAAM,IAAIJ,QAAQ,KAAKnH,SAAS,CAACwH,KAAK,IAAIT,IAAI,CAACvB,iBAAiB,CAAC,CAAC,KAAKvF,cAAc,CAACwH,SAAS,EAAE;QAChGb,EAAE,GAAG1F,KAAK,CAACoD,UAAU,CAACoD,yCAAyC,CAAC,CAAC;MACnE,CAAC,MAAM,IAAIP,QAAQ,KAAKnH,SAAS,CAAC2H,IAAI,IAAIR,QAAQ,KAAKnH,SAAS,CAAC4H,SAAS,EAAE;QAC1EhB,EAAE,GAAG1F,KAAK,CAACoD,UAAU,CAACuD,4CAA4C,CAAC,CAAC;MACtE;MAEA,IAAIV,QAAQ,KAAKnH,SAAS,CAAC8H,SAAS,IAAIX,QAAQ,KAAKnH,SAAS,CAAC+H,cAAc,EAAE;QAC7EnB,EAAE,GAAG1F,KAAK,CAACoD,UAAU,CAACuD,4CAA4C,CAAC,CAAC;QACpEjB,EAAE,CAACC,MAAM,IAAI,GAAG;QAChBD,EAAE,CAACE,MAAM,IAAI,GAAG;MAClB;IACF,CAAC,CAAC;IACF;;IAGA,IAAIlG,QAAQ,GAAGM,KAAK,CAACO,eAAe,CAACZ,WAAW,CAAC,CAAC;IAElD,IAAID,QAAQ,IAAIA,QAAQ,CAACoH,mBAAmB,CAAC,CAAC,KAAKjI,iBAAiB,CAACkI,wBAAwB,EAAE;MAC7FrB,EAAE,CAACE,MAAM,IAAI,GAAG;IAClB;IAEA,OAAOF,EAAE;EACX,CAAC;EAED3F,SAAS,CAACiH,oBAAoB,GAAG,UAAU/E,OAAO,EAAEH,GAAG,EAAED,KAAK,EAAE;IAC9D,IAAIW,QAAQ,GAAGP,OAAO,CAACE,QAAQ;IAC/B,IAAIG,QAAQ,GAAGL,OAAO,CAACC,MAAM;IAC7BM,QAAQ,GAAG5F,gBAAgB,CAACsG,UAAU,CAACV,QAAQ,EAAE,qBAAqB,EAAE,CAAC,sBAAsB,EAAE,qBAAqB,CAAC,CAAC,CAACW,MAAM;IAE/H,IAAI,CAACnD,KAAK,CAACO,eAAe,CAACZ,WAAW,CAAC,CAAC,EAAE;MACxC;IACF;IAEA,IAAIK,KAAK,CAACiH,kBAAkB,KAAK9J,SAAS,CAAC+J,QAAQ,IAAIlH,KAAK,CAACiH,kBAAkB,KAAK9J,SAAS,CAACgK,SAAS,EAAE;MACvG7E,QAAQ,GAAG1F,gBAAgB,CAACsG,UAAU,CAACZ,QAAQ,EAAE,qBAAqB,EAAE,CAAC,kCAAkC,EAAE,+BAA+B,CAAC,CAAC,CAACa,MAAM;MACrJb,QAAQ,GAAG1F,gBAAgB,CAACsG,UAAU,CAACZ,QAAQ,EAAE,sBAAsB,EAAE,sDAAsD,CAAC,CAACa,MAAM;MACvIX,QAAQ,GAAG5F,gBAAgB,CAACsG,UAAU,CAACV,QAAQ,EAAE,qBAAqB,EAAE,iCAAiC,CAAC,CAACW,MAAM;MACjHX,QAAQ,GAAG5F,gBAAgB,CAACsG,UAAU,CAACV,QAAQ,EAAE,sBAAsB,EAAE,CAAC,+BAA+B,EAAE,sBAAsB,CAAC,CAAC,CAACW,MAAM;IAC5I;IAEA,QAAQnD,KAAK,CAACiH,kBAAkB;MAC9B,KAAK9J,SAAS,CAAC+J,QAAQ;QACrB1E,QAAQ,GAAG5F,gBAAgB,CAACsG,UAAU,CAACV,QAAQ,EAAE,sBAAsB,EAAE,+GAA+G,CAAC,CAACW,MAAM;QAChM;MAEF,KAAKhG,SAAS,CAACgK,SAAS;QACtB3E,QAAQ,GAAG5F,gBAAgB,CAACsG,UAAU,CAACV,QAAQ,EAAE,sBAAsB,EAAE,2DAA2D,CAAC,CAACW,MAAM;QAC5I;MAEF;QACEX,QAAQ,GAAG5F,gBAAgB,CAACsG,UAAU,CAACV,QAAQ,EAAE,qBAAqB,EAAE,2BAA2B,CAAC,CAACW,MAAM;QAC3GX,QAAQ,GAAG5F,gBAAgB,CAACsG,UAAU,CAACV,QAAQ,EAAE,sBAAsB,EAAE,2EAA2E,CAAC,CAACW,MAAM;IAChK;IAEAlB,OAAO,CAACE,QAAQ,GAAGK,QAAQ;IAC3BP,OAAO,CAACC,MAAM,GAAGI,QAAQ;EAC3B,CAAC;EAEDvC,SAAS,CAACqH,mBAAmB,GAAG,UAAUnF,OAAO,EAAEH,GAAG,EAAED,KAAK,EAAE;IAC7D9B,SAAS,CAACsC,kBAAkB,CAACJ,OAAO,EAAEH,GAAG,EAAED,KAAK,CAAC;IACjD9B,SAAS,CAACkE,mBAAmB,CAAChC,OAAO,EAAEH,GAAG,EAAED,KAAK,CAAC;IAClD9B,SAAS,CAAC0D,kBAAkB,CAACxB,OAAO,EAAEH,GAAG,EAAED,KAAK,CAAC;IACjD9B,SAAS,CAAC0E,mBAAmB,CAACxC,OAAO,EAAEH,GAAG,EAAED,KAAK,CAAC;IAClD9B,SAAS,CAACiH,oBAAoB,CAAC/E,OAAO,EAAEH,GAAG,EAAED,KAAK,CAAC;IACnD9B,SAAS,CAACuF,iBAAiB,CAACrD,OAAO,EAAEH,GAAG,EAAED,KAAK,CAAC;IAChD9B,SAAS,CAACsH,6BAA6B,CAACpF,OAAO,EAAEH,GAAG,EAAED,KAAK,CAAC;IAC5D9B,SAAS,CAACyE,uBAAuB,CAACvC,OAAO,EAAEH,GAAG,EAAED,KAAK,CAAC;IAEtD,IAAI7B,KAAK,CAACkB,oBAAoB,EAAE;MAC9B,IAAIsB,QAAQ,GAAGP,OAAO,CAACE,QAAQ;MAC/BK,QAAQ,GAAG5F,gBAAgB,CAACsG,UAAU,CAACV,QAAQ,EAAE,qBAAqB,EAAE,2BAA2B,CAAC,CAACW,MAAM;MAC3GX,QAAQ,GAAG5F,gBAAgB,CAACsG,UAAU,CAACV,QAAQ,EAAE,sBAAsB,EAAE,CAAC,0BAA0B,EAAE,iDAAiD,EAAE,mCAAmC,EAAE,iCAAiC,EAAE,4CAA4C,CAAC,CAAC,CAACW,MAAM;MACtRlB,OAAO,CAACE,QAAQ,GAAGK,QAAQ;IAC7B;EACF,CAAC;EAEDzC,SAAS,CAACuH,uBAAuB,GAAG,UAAUC,MAAM,EAAEzF,GAAG,EAAED,KAAK,EAAE;IAChE,IAAI2F,eAAe,GAAG,CAAC;IACvB,IAAIC,cAAc,GAAG,CAAC;IACtB,IAAIxB,QAAQ,GAAGsB,MAAM,CAACrB,gBAAgB,CAAC,CAAC;IACxC,IAAIwB,IAAI,GAAG1H,KAAK,CAAC2H,YAAY,CAAC,CAAC;;IAE/B,IAAIC,YAAY,GAAG,KAAK;IACxB,IAAIC,YAAY,GAAGH,IAAI,CAACvC,YAAY,CAAC,CAAC,CAAC2C,UAAU,CAAC,CAAC;IACnD,IAAIC,WAAW,GAAGL,IAAI,CAACM,WAAW,CAAC,CAAC,CAACF,UAAU,CAAC,CAAC;IACjD,IAAIG,IAAI,GAAGpG,KAAK,CAACwC,WAAW,CAAC,CAAC,CAAC6D,gBAAgB,CAAC,CAAC,KAAKlJ,OAAO,CAACmJ,IAAI;IAClE,IAAIC,cAAc,GAAGvG,KAAK,CAACwC,WAAW,CAAC,CAAC,CAACC,iBAAiB,CAAC,CAAC;IAC5D,IAAI+D,IAAI,GAAGd,MAAM,CAACnD,aAAa,CAACgE,cAAc,EAAEnC,QAAQ,CAAC,CAAC,CAAC;;IAE3D,IAAIoC,IAAI,KAAKrI,KAAK,CAACwB,OAAO,CAAC8G,SAAS,EAAE;MACpCV,YAAY,GAAG,IAAI,CAAC,CAAC;IACvB,CAAC,MAAM,IAAIG,WAAW,IAAI,CAACF,YAAY,EAAE;MACvCD,YAAY,GAAG,IAAI,CAAC,CAAC;IACvB,CAAC,MAAM,IAAI,CAACK,IAAI,IAAIJ,YAAY,EAAE;MAChCD,YAAY,GAAG,IAAI,CAAC,CAAC;IACvB,CAAC,MAAM,IAAI,CAACK,IAAI,IAAII,IAAI,KAAKrI,KAAK,CAACwB,OAAO,CAAC+C,KAAK,EAAE;MAChDqD,YAAY,GAAG,IAAI;IACrB,CAAC,CAAC;IACF;;IAGA,IAAI/F,KAAK,CAACwC,WAAW,CAAC,CAAC,CAACkE,WAAW,CAAC,CAAC,IAAIX,YAAY,EAAE;MACrD;MACA;MACAJ,eAAe,GAAG,CAAC;MACnB,IAAIgB,MAAM,GAAG1G,GAAG,CAAC2G,oBAAoB,CAAC,CAAC;MAEvC,KAAK,IAAIC,KAAK,GAAG,CAAC,EAAEA,KAAK,GAAGF,MAAM,CAAClK,MAAM,EAAE,EAAEoK,KAAK,EAAE;QAClD,IAAIC,KAAK,GAAGH,MAAM,CAACE,KAAK,CAAC;QACzB,IAAIE,MAAM,GAAGD,KAAK,CAACE,SAAS,CAAC,CAAC;QAE9B,IAAID,MAAM,GAAG,CAAC,EAAE;UACdnB,cAAc,EAAE;UAEhB,IAAID,eAAe,KAAK,CAAC,EAAE;YACzBA,eAAe,GAAG,CAAC;UACrB;QACF;QAEA,IAAIA,eAAe,KAAK,CAAC,KAAKC,cAAc,GAAG,CAAC,IAAIkB,KAAK,CAACG,YAAY,CAAC,CAAC,KAAK,GAAG,IAAI,CAACH,KAAK,CAACI,oBAAoB,CAAC,CAAC,CAAC,EAAE;UAClHvB,eAAe,GAAG,CAAC;QACrB;QAEA,IAAIA,eAAe,GAAG,CAAC,IAAImB,KAAK,CAACK,aAAa,CAAC,CAAC,EAAE;UAChDxB,eAAe,GAAG,CAAC;QACrB;MACF;IACF;IAEA,IAAIyB,WAAW,GAAG,KAAK;IACvB,IAAIxG,mBAAmB,GAAGzC,KAAK,CAAC0C,WAAW,CAACC,kBAAkB,CAAC,qBAAqB,CAAC;IACrF,IAAIgB,cAAc,GAAG3D,KAAK,CAAC0C,WAAW,CAACC,kBAAkB,CAAC,gBAAgB,CAAC;IAE3E,IAAIF,mBAAmB,KAAK+E,eAAe,IAAI7D,cAAc,KAAK8D,cAAc,EAAE;MAChFzH,KAAK,CAAC0C,WAAW,CAACwG,GAAG,CAAC;QACpBzG,mBAAmB,EAAE+E;MACvB,CAAC,EAAE,IAAI,CAAC;MACRxH,KAAK,CAAC0C,WAAW,CAACwG,GAAG,CAAC;QACpBvF,cAAc,EAAE8D;MAClB,CAAC,EAAE,IAAI,CAAC;MACRwB,WAAW,GAAG,IAAI;IACpB,CAAC,CAAC;;IAGF,IAAI,CAACjJ,KAAK,CAACI,iBAAiB,IAAIJ,KAAK,CAACmJ,+BAA+B,IAAInJ,KAAK,CAACI,iBAAiB,IAAIJ,KAAK,CAACI,iBAAiB,CAACgJ,oBAAoB,CAAC,CAAC,KAAKpJ,KAAK,CAACmJ,+BAA+B,EAAE;MAC5LF,WAAW,GAAG,IAAI;IACpB,CAAC,CAAC;IACF;IACA;IACA;IACA;IACA;;IAGA,IAAIjJ,KAAK,CAACqJ,wBAAwB,KAAKrJ,KAAK,CAACkB,oBAAoB,IAAIqG,MAAM,CAAC+B,mBAAmB,CAAC,CAAC,CAACC,QAAQ,CAAC,CAAC,GAAGvJ,KAAK,CAACoD,UAAU,CAACmG,QAAQ,CAAC,CAAC,IAAIhC,MAAM,CAAC+B,mBAAmB,CAAC,CAAC,CAACC,QAAQ,CAAC,CAAC,GAAGvJ,KAAK,CAAC2H,YAAY,CAAC4B,QAAQ,CAAC,CAAC,IAAIhC,MAAM,CAAC+B,mBAAmB,CAAC,CAAC,CAACC,QAAQ,CAAC,CAAC,GAAGvJ,KAAK,CAACwJ,qBAAqB,CAACD,QAAQ,CAAC,CAAC,IAAIN,WAAW,EAAE;MACxTjJ,KAAK,CAACqJ,wBAAwB,GAAGrJ,KAAK,CAACkB,oBAAoB;MAC3D,OAAO,IAAI;IACb;IAEA,OAAO,KAAK;EACd,CAAC;EAEDnB,SAAS,CAAC0J,qBAAqB,GAAG,UAAUlC,MAAM,EAAEzF,GAAG,EAAED,KAAK,EAAE;IAC9D,IAAI6H,aAAa,GAAG1J,KAAK,CAACoD,UAAU,CAACuG,yBAAyB,CAAC,CAAC,CAACC,gBAAgB;IAEjF,IAAIF,aAAa,EAAE;MACjBA,aAAa,CAAClL,OAAO,CAAC,UAAUlB,MAAM,EAAE;QACtCA,MAAM,CAACuM,QAAQ,CAACvM,MAAM,CAACwM,QAAQ,EAAEvC,MAAM,EAAEzF,GAAG,EAAED,KAAK,CAAC;MACtD,CAAC,CAAC;IACJ;EACF,CAAC;EAED9B,SAAS,CAACgK,yBAAyB,GAAG,UAAUxC,MAAM,EAAEzF,GAAG,EAAED,KAAK,EAAE;IAClE;IACA,IAAI0F,MAAM,CAACyC,UAAU,CAAC,CAAC,CAACC,aAAa,CAAC,mBAAmB,CAAC,EAAE;MAC1D1C,MAAM,CAACyC,UAAU,CAAC,CAAC,CAACE,WAAW,CAAC,mBAAmB,EAAElK,KAAK,CAACmK,iBAAiB,CAAC;IAC/E;IAEA,IAAI5C,MAAM,CAACyC,UAAU,CAAC,CAAC,CAACC,aAAa,CAAC,gBAAgB,CAAC,EAAE;MACvD1C,MAAM,CAACyC,UAAU,CAAC,CAAC,CAACE,WAAW,CAAC,gBAAgB,EAAElK,KAAK,CAACoK,cAAc,CAAC;IACzE;IAEA,IAAI7C,MAAM,CAACxE,OAAO,CAAC,CAAC,CAACsH,eAAe,CAAC,CAAC,KAAKrK,KAAK,CAACsK,YAAY,CAACf,QAAQ,CAAC,CAAC,GAAGhC,MAAM,CAACgD,sBAAsB,CAAC,CAAC,CAAChB,QAAQ,CAAC,CAAC,IAAIhC,MAAM,CAAC+B,mBAAmB,CAAC,CAAC,CAACC,QAAQ,CAAC,CAAC,GAAGhC,MAAM,CAACgD,sBAAsB,CAAC,CAAC,CAAChB,QAAQ,CAAC,CAAC,CAAC,EAAE;MAC9M,IAAI9G,mBAAmB,GAAGzC,KAAK,CAAC0C,WAAW,CAACC,kBAAkB,CAAC,qBAAqB,CAAC;MAErF,IAAI4E,MAAM,CAACyC,UAAU,CAAC,CAAC,CAACQ,eAAe,CAAC,UAAU,CAAC,EAAE;QACnD,IAAI,CAACjD,MAAM,CAACkD,MAAM,CAAC,CAAC,CAACC,iBAAiB,CAACnD,MAAM,CAACyC,UAAU,CAAC,CAAC,EAAEzC,MAAM,CAACxE,OAAO,CAAC,CAAC,EAAE,UAAU,EAAEwE,MAAM,CAACxE,OAAO,CAAC,CAAC,CAAC4H,eAAe,CAAC,CAAC,EAAEpD,MAAM,CAACxE,OAAO,CAAC,CAAC,CAAC6H,SAAS,CAAC,CAAC,EAAE5K,KAAK,CAACwB,OAAO,CAACqJ,KAAK,EAAE,CAAC,EAAE,KAAK,CAAC,EAAE;UAC1L5O,aAAa,CAAC,uCAAuC,CAAC;QACxD;MACF;MAEA,IAAIsL,MAAM,CAACyC,UAAU,CAAC,CAAC,CAACQ,eAAe,CAAC,UAAU,CAAC,IAAIjD,MAAM,CAACxE,OAAO,CAAC,CAAC,CAACmB,eAAe,CAAC,CAAC,IAAIzB,mBAAmB,GAAG,CAAC,EAAE;QACpH,IAAI,CAAC8E,MAAM,CAACkD,MAAM,CAAC,CAAC,CAACC,iBAAiB,CAACnD,MAAM,CAACyC,UAAU,CAAC,CAAC,EAAEzC,MAAM,CAACxE,OAAO,CAAC,CAAC,EAAE,UAAU,EAAEwE,MAAM,CAACxE,OAAO,CAAC,CAAC,CAACmB,eAAe,CAAC,CAAC,EAAEqD,MAAM,CAACxE,OAAO,CAAC,CAAC,CAAC6H,SAAS,CAAC,CAAC,EAAE5K,KAAK,CAACwB,OAAO,CAACqJ,KAAK,EAAE,CAAC,EAAE,KAAK,CAAC,EAAE;UAC1L5O,aAAa,CAAC,uCAAuC,CAAC;QACxD;MACF,CAAC,MAAM;QACLsL,MAAM,CAACkD,MAAM,CAAC,CAAC,CAACK,oBAAoB,CAAC,UAAU,CAAC;MAClD;MAEA9K,KAAK,CAACoD,UAAU,CAAC2H,yBAAyB,CAAC,CAAC,CAACvM,OAAO,CAAC,UAAUwM,QAAQ,EAAEC,GAAG,EAAE;QAC5E,IAAI1D,MAAM,CAACyC,UAAU,CAAC,CAAC,CAACQ,eAAe,CAAC,EAAE,CAAC3H,MAAM,CAACmI,QAAQ,EAAE,IAAI,CAAC,CAAC,EAAE;UAClE,IAAI,CAACzD,MAAM,CAACkD,MAAM,CAAC,CAAC,CAACC,iBAAiB,CAACnD,MAAM,CAACyC,UAAU,CAAC,CAAC,EAAEzC,MAAM,CAACxE,OAAO,CAAC,CAAC,EAAE,EAAE,CAACF,MAAM,CAACmI,QAAQ,EAAE,IAAI,CAAC,EAAEzD,MAAM,CAACxE,OAAO,CAAC,CAAC,CAACmI,aAAa,CAAC,CAAC,CAACD,GAAG,CAAC,CAACrF,MAAM,EAAE2B,MAAM,CAACxE,OAAO,CAAC,CAAC,CAAC6H,SAAS,CAAC,CAAC,EAAE5K,KAAK,CAACwB,OAAO,CAACqJ,KAAK,EAAEtD,MAAM,CAACxE,OAAO,CAAC,CAAC,CAACmI,aAAa,CAAC,CAAC,CAACD,GAAG,CAAC,CAACE,UAAU,EAAE,KAAK,CAAC,EAAE;YAClQlP,aAAa,CAAC,gBAAgB,CAAC4G,MAAM,CAACmI,QAAQ,EAAE,mBAAmB,CAAC,CAAC;UACvE;QACF;MACF,CAAC,CAAC;MAEF,IAAIzD,MAAM,CAACyC,UAAU,CAAC,CAAC,CAACQ,eAAe,CAAC,UAAU,CAAC,IAAIjD,MAAM,CAACxE,OAAO,CAAC,CAAC,CAAC2B,eAAe,CAAC,CAAC,EAAE;QACzF,IAAI,CAAC6C,MAAM,CAACkD,MAAM,CAAC,CAAC,CAACC,iBAAiB,CAACnD,MAAM,CAACyC,UAAU,CAAC,CAAC,EAAEzC,MAAM,CAACxE,OAAO,CAAC,CAAC,EAAE,UAAU,EAAEwE,MAAM,CAACxE,OAAO,CAAC,CAAC,CAAC2B,eAAe,CAAC,CAAC,EAAE6C,MAAM,CAACxE,OAAO,CAAC,CAAC,CAAC6H,SAAS,CAAC,CAAC,EAAE5K,KAAK,CAACwB,OAAO,CAACqJ,KAAK,EAAEtD,MAAM,CAACxE,OAAO,CAAC,CAAC,CAACqI,mBAAmB,CAAC,CAAC,EAAE,KAAK,CAAC,EAAE;UAC/NnP,aAAa,CAAC,uCAAuC,CAAC;QACxD;MACF,CAAC,MAAM;QACLsL,MAAM,CAACkD,MAAM,CAAC,CAAC,CAACK,oBAAoB,CAAC,UAAU,CAAC;MAClD;MAEA,IAAIvD,MAAM,CAACyC,UAAU,CAAC,CAAC,CAACQ,eAAe,CAAC,aAAa,CAAC,IAAIjD,MAAM,CAACxE,OAAO,CAAC,CAAC,CAACC,kBAAkB,CAAC,CAAC,EAAE;QAC/F,IAAI,CAACuE,MAAM,CAACkD,MAAM,CAAC,CAAC,CAACC,iBAAiB,CAACnD,MAAM,CAACyC,UAAU,CAAC,CAAC,EAAEzC,MAAM,CAACxE,OAAO,CAAC,CAAC,CAACsI,UAAU,CAAC,CAAC,EAAE,aAAa,EAAE9D,MAAM,CAACxE,OAAO,CAAC,CAAC,CAACuI,cAAc,CAAC,CAAC,EAAE/D,MAAM,CAACxE,OAAO,CAAC,CAAC,CAACwI,gBAAgB,CAAC,CAAC,EAAEvL,KAAK,CAACwB,OAAO,CAACgK,aAAa,EAAE,CAAC,EAAE,IAAI,CAAC,EAAE;UACvNvP,aAAa,CAAC,0CAA0C,CAAC;QAC3D;MACF,CAAC,MAAM;QACLsL,MAAM,CAACkD,MAAM,CAAC,CAAC,CAACK,oBAAoB,CAAC,aAAa,CAAC;MACrD;MAEAvD,MAAM,CAACgD,sBAAsB,CAAC,CAAC,CAACkB,QAAQ,CAAC,CAAC;IAC5C;IAEA,IAAIzL,KAAK,CAACoD,UAAU,CAACmC,yBAAyB,CAAC,CAAC,EAAE;MAChD;MACA,IAAIC,aAAa,GAAGxF,KAAK,CAACoD,UAAU,CAACmC,yBAAyB,CAAC,CAAC;MAChE,IAAImG,cAAc,GAAG,EAAE;MACvB,IAAIC,iBAAiB,GAAGpE,MAAM,CAACxE,OAAO,CAAC,CAAC,CAAC6I,4BAA4B,CAAC,CAAC;MACvE,IAAIC,uBAAuB,GAAGF,iBAAiB,GAAGpE,MAAM,CAACxE,OAAO,CAAC,CAAC,CAAC+I,6BAA6B,CAAC,CAAC,GAAG,IAAI;MACzG,IAAIC,GAAG,GAAGF,uBAAuB,GAAGlQ,IAAI,CAACqQ,IAAI,CAAChM,KAAK,CAACiM,OAAO,EAAEpK,KAAK,CAACqK,SAAS,CAAC,CAAC,CAAC,GAAGrK,KAAK,CAACqK,SAAS,CAAC,CAAC;MAEnG,IAAIL,uBAAuB,EAAE;QAC3BlQ,IAAI,CAACwQ,SAAS,CAACJ,GAAG,EAAEA,GAAG,CAAC;QACxBpQ,IAAI,CAACyQ,QAAQ,CAACL,GAAG,EAAEA,GAAG,EAAEF,uBAAuB,CAAC;QAChDlQ,IAAI,CAACwQ,SAAS,CAACJ,GAAG,EAAEA,GAAG,CAAC;MAC1B;MAEA,KAAK,IAAI3N,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGoH,aAAa,EAAEpH,CAAC,EAAE,EAAE;QACtC,IAAIiO,aAAa,GAAG,EAAE;QACtBrM,KAAK,CAACoD,UAAU,CAACkJ,4BAA4B,CAACP,GAAG,EAAE3N,CAAC,EAAEiO,aAAa,CAAC;QAEpE,KAAK,IAAIE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,CAAC,EAAEA,CAAC,EAAE,EAAE;UAC1Bb,cAAc,CAAC1N,IAAI,CAACqO,aAAa,CAACE,CAAC,CAAC,CAAC;QACvC;MACF;MAEAhF,MAAM,CAACyC,UAAU,CAAC,CAAC,CAACE,WAAW,CAAC,eAAe,EAAE1E,aAAa,CAAC;MAC/D+B,MAAM,CAACyC,UAAU,CAAC,CAAC,CAACwC,aAAa,CAAC,YAAY,EAAEd,cAAc,CAAC;IACjE;IAEA,IAAI1L,KAAK,CAACyM,oBAAoB,IAAIlF,MAAM,CAACyC,UAAU,CAAC,CAAC,CAACC,aAAa,CAAC,UAAU,CAAC,EAAE;MAC/E1C,MAAM,CAACyC,UAAU,CAAC,CAAC,CAACE,WAAW,CAAC,UAAU,EAAElK,KAAK,CAACyM,oBAAoB,CAACC,cAAc,CAAC,CAAC,CAAC;IAC1F;IAEA,IAAI/H,GAAG,GAAG3E,KAAK,CAACK,WAAW,CAACuE,iBAAiB,CAAC,CAAC;IAE/C,IAAID,GAAG,EAAE;MACP,KAAK,IAAI+D,KAAK,GAAG,CAAC,EAAEA,KAAK,GAAG/D,GAAG,CAACrG,MAAM,EAAE,EAAEoK,KAAK,EAAE;QAC/C,IAAIiE,GAAG,GAAGhI,GAAG,CAAC+D,KAAK,CAAC;QACpB,IAAIkE,OAAO,GAAGD,GAAG,CAACD,cAAc,CAAC,CAAC;QAClC,IAAIG,KAAK,GAAG,SAAS,CAAChK,MAAM,CAAC+J,OAAO,GAAG,CAAC,CAAC;QAEzC,IAAIrF,MAAM,CAACyC,UAAU,CAAC,CAAC,CAACC,aAAa,CAAC4C,KAAK,CAAC,EAAE;UAC5CtF,MAAM,CAACyC,UAAU,CAAC,CAAC,CAACE,WAAW,CAAC2C,KAAK,EAAED,OAAO,CAAC;QACjD;MACF;IACF,CAAC,CAAC;;IAGF,IAAI5M,KAAK,CAACkB,oBAAoB,EAAE;MAC9BqG,MAAM,CAACyC,UAAU,CAAC,CAAC,CAACE,WAAW,CAAC,cAAc,EAAElK,KAAK,CAACmB,WAAW,GAAG,CAAC,GAAG,CAAC,CAAC;IAC5E,CAAC,CAAC;;IAGF,IAAIoG,MAAM,CAACyC,UAAU,CAAC,CAAC,CAACC,aAAa,CAAC,SAAS,CAAC,EAAE;MAChD,IAAIvE,EAAE,GAAG3F,SAAS,CAAC0F,uBAAuB,CAAC3D,GAAG,EAAED,KAAK,CAAC;MACtD0F,MAAM,CAACyC,UAAU,CAAC,CAAC,CAAC8C,WAAW,CAAC,SAAS,EAAEpH,EAAE,CAACE,MAAM,CAAC,CAAC,CAAC;;MAEvD,IAAI2B,MAAM,CAACyC,UAAU,CAAC,CAAC,CAACC,aAAa,CAAC,SAAS,CAAC,EAAE;QAChD1C,MAAM,CAACyC,UAAU,CAAC,CAAC,CAAC8C,WAAW,CAAC,SAAS,EAAEpH,EAAE,CAACC,MAAM,CAAC;MACvD;IACF,CAAC,CAAC;;IAGF4B,MAAM,CAACwC,yBAAyB,CAACjI,GAAG,EAAED,KAAK,EAAE7B,KAAK,CAACO,eAAe,CAACwM,qBAAqB,CAAC,CAAC,CAAC;IAE3F,IAAIrN,QAAQ,GAAGM,KAAK,CAACO,eAAe,CAACZ,WAAW,CAAC,CAAC;IAElD4H,MAAM,CAACyC,UAAU,CAAC,CAAC,CAACgD,iBAAiB,CAAC,aAAa,EAAEtN,QAAQ,GAAGA,QAAQ,CAACuN,iBAAiB,CAAC,CAAC,GAAG,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC,CAAC;IAC/G1F,MAAM,CAACyC,UAAU,CAAC,CAAC,CAACE,WAAW,CAAC,SAAS,EAAExK,QAAQ,GAAGA,QAAQ,CAACE,cAAc,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;EAC1F,CAAC;EAEDG,SAAS,CAACmN,2BAA2B,GAAG,UAAU3F,MAAM,EAAEzF,GAAG,EAAED,KAAK,EAAE;IACpE;IACA,IAAIY,mBAAmB,GAAGzC,KAAK,CAAC0C,WAAW,CAACC,kBAAkB,CAAC,qBAAqB,CAAC;IAErF,IAAIF,mBAAmB,GAAG,CAAC,EAAE;MAC3B;IACF;IAEA,IAAI0K,OAAO,GAAG5F,MAAM,CAACyC,UAAU,CAAC,CAAC,CAAC,CAAC;;IAEnC,IAAIvC,cAAc,GAAG,CAAC;IACtB,IAAIe,MAAM,GAAG1G,GAAG,CAAC2G,oBAAoB,CAAC,CAAC;IAEvC,KAAK,IAAIC,KAAK,GAAG,CAAC,EAAEA,KAAK,GAAGF,MAAM,CAAClK,MAAM,EAAE,EAAEoK,KAAK,EAAE;MAClD,IAAIC,KAAK,GAAGH,MAAM,CAACE,KAAK,CAAC;MACzB,IAAIE,MAAM,GAAGD,KAAK,CAACE,SAAS,CAAC,CAAC;MAE9B,IAAID,MAAM,GAAG,GAAG,EAAE;QAChB,IAAIwE,MAAM,GAAGzE,KAAK,CAAC0E,mBAAmB,CAAC,CAAC;QACxC,IAAIC,SAAS,GAAG3E,KAAK,CAACG,YAAY,CAAC,CAAC;QACpC9I,KAAK,CAACuN,UAAU,CAAC,CAAC,CAAC,GAAGH,MAAM,CAAC,CAAC,CAAC,GAAGE,SAAS;QAC3CtN,KAAK,CAACuN,UAAU,CAAC,CAAC,CAAC,GAAGH,MAAM,CAAC,CAAC,CAAC,GAAGE,SAAS;QAC3CtN,KAAK,CAACuN,UAAU,CAAC,CAAC,CAAC,GAAGH,MAAM,CAAC,CAAC,CAAC,GAAGE,SAAS,CAAC,CAAC;;QAE7C,IAAIE,EAAE,GAAG7E,KAAK,CAAC8E,YAAY,CAAC,CAAC;QAC7B,IAAIC,SAAS,GAAG5L,GAAG,CAACjB,eAAe,CAAC,CAAC,CAAC8M,aAAa,CAAC,CAAC;QAErD,IAAIC,iBAAiB,GAAGnS,kBAAkB,CAAC+R,EAAE,CAAC;QAE9C,IAAI7E,KAAK,CAACkF,qBAAqB,CAAC,CAAC,EAAE;UACjCD,iBAAiB,CAAC,CAAC,CAAC,GAAGF,SAAS,CAAC,CAAC,CAAC,GAAGF,EAAE,CAAC,CAAC,CAAC,GAAGE,SAAS,CAAC,CAAC,CAAC,GAAGF,EAAE,CAAC,CAAC,CAAC,GAAGE,SAAS,CAAC,CAAC,CAAC,GAAGF,EAAE,CAAC,CAAC,CAAC;UACzFI,iBAAiB,CAAC,CAAC,CAAC,GAAGF,SAAS,CAAC,CAAC,CAAC,GAAGF,EAAE,CAAC,CAAC,CAAC,GAAGE,SAAS,CAAC,CAAC,CAAC,GAAGF,EAAE,CAAC,CAAC,CAAC,GAAGE,SAAS,CAAC,CAAC,CAAC,GAAGF,EAAE,CAAC,CAAC,CAAC;UACzFI,iBAAiB,CAAC,CAAC,CAAC,GAAGF,SAAS,CAAC,CAAC,CAAC,GAAGF,EAAE,CAAC,CAAC,CAAC,GAAGE,SAAS,CAAC,CAAC,CAAC,GAAGF,EAAE,CAAC,CAAC,CAAC,GAAGE,SAAS,CAAC,EAAE,CAAC,GAAGF,EAAE,CAAC,CAAC,CAAC;UAC1FlR,SAAS,CAACsR,iBAAiB,CAAC;QAC9B;QAEA5N,KAAK,CAAC8N,cAAc,CAAC,CAAC,CAAC,GAAGF,iBAAiB,CAAC,CAAC,CAAC;QAC9C5N,KAAK,CAAC8N,cAAc,CAAC,CAAC,CAAC,GAAGF,iBAAiB,CAAC,CAAC,CAAC;QAC9C5N,KAAK,CAAC8N,cAAc,CAAC,CAAC,CAAC,GAAGF,iBAAiB,CAAC,CAAC,CAAC;QAC9CtR,SAAS,CAAC0D,KAAK,CAAC8N,cAAc,CAAC;QAC/BX,OAAO,CAACH,iBAAiB,CAAC,YAAY,CAACnK,MAAM,CAAC4E,cAAc,CAAC,EAAEzH,KAAK,CAACuN,UAAU,CAAC;QAChFJ,OAAO,CAACH,iBAAiB,CAAC,kBAAkB,CAACnK,MAAM,CAAC4E,cAAc,CAAC,EAAEzH,KAAK,CAAC8N,cAAc,CAAC;QAC1FrG,cAAc,EAAE;MAClB;IACF,CAAC,CAAC;;IAGF,IAAIhF,mBAAmB,GAAG,CAAC,EAAE;MAC3B;IACF,CAAC,CAAC;;IAGF,IAAIsL,GAAG,GAAGjM,GAAG,CAACjB,eAAe,CAAC,CAAC;IAC/B,IAAImN,MAAM,GAAGD,GAAG,CAACJ,aAAa,CAAC,CAAC;IAChChS,IAAI,CAACwQ,SAAS,CAAC6B,MAAM,EAAEA,MAAM,CAAC;IAC9BvG,cAAc,GAAG,CAAC;IAElB,KAAK,IAAIwG,MAAM,GAAG,CAAC,EAAEA,MAAM,GAAGzF,MAAM,CAAClK,MAAM,EAAE,EAAE2P,MAAM,EAAE;MACrD,IAAIC,MAAM,GAAG1F,MAAM,CAACyF,MAAM,CAAC;MAE3B,IAAIE,OAAO,GAAGD,MAAM,CAACrF,SAAS,CAAC,CAAC;MAEhC,IAAIsF,OAAO,GAAG,GAAG,EAAE;QACjB,IAAIC,EAAE,GAAGF,MAAM,CAACG,sBAAsB,CAAC,CAAC;QAExC,IAAIC,EAAE,GAAG,IAAIC,YAAY,CAAC,CAAC,CAAC;QAC5B3S,IAAI,CAAC4S,aAAa,CAACF,EAAE,EAAEF,EAAE,EAAEJ,MAAM,CAAC;QAClCb,OAAO,CAACH,iBAAiB,CAAC,kBAAkB,CAACnK,MAAM,CAAC4E,cAAc,CAAC,EAAEyG,MAAM,CAACO,+BAA+B,CAAC,CAAC,CAAC;QAC9GtB,OAAO,CAACjD,WAAW,CAAC,iBAAiB,CAACrH,MAAM,CAAC4E,cAAc,CAAC,EAAEyG,MAAM,CAAClF,aAAa,CAAC,CAAC,CAAC;QACrFmE,OAAO,CAACL,WAAW,CAAC,eAAe,CAACjK,MAAM,CAAC4E,cAAc,CAAC,EAAEyG,MAAM,CAACQ,WAAW,CAAC,CAAC,CAAC;QACjFvB,OAAO,CAACL,WAAW,CAAC,gBAAgB,CAACjK,MAAM,CAAC4E,cAAc,CAAC,EAAEyG,MAAM,CAACS,YAAY,CAAC,CAAC,CAAC;QACnFxB,OAAO,CAACH,iBAAiB,CAAC,iBAAiB,CAACnK,MAAM,CAAC4E,cAAc,CAAC,EAAE,CAAC6G,EAAE,CAAC,CAAC,CAAC,EAAEA,EAAE,CAAC,CAAC,CAAC,EAAEA,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC;QAC1F7G,cAAc,EAAE;MAClB;IACF;EACF,CAAC;EAED,SAASmH,kBAAkBA,CAACC,WAAW,EAAEC,UAAU,EAAEC,MAAM,EAAE;IAC3DD,UAAU,CAACE,QAAQ,CAACD,MAAM,CAAC;IAC3B,OAAOF,WAAW,CAACI,MAAM,CAAC,UAAUC,GAAG,EAAEC,MAAM,EAAEzG,KAAK,EAAE;MACtD,IAAIA,KAAK,KAAK,CAAC,EAAE;QACf,OAAOyG,MAAM,GAAGL,UAAU,CAAC9C,IAAI,CAACkD,GAAG,EAAEC,MAAM,CAAC,GAAGL,UAAU,CAACE,QAAQ,CAACE,GAAG,CAAC;MACzE;MAEA,OAAOC,MAAM,GAAGL,UAAU,CAAC1C,QAAQ,CAAC8C,GAAG,EAAEA,GAAG,EAAEC,MAAM,CAAC,GAAGD,GAAG;IAC7D,CAAC,EAAEH,MAAM,CAAC;EACZ;EAEAhP,SAAS,CAACqP,yBAAyB,GAAG,UAAU7H,MAAM,EAAEzF,GAAG,EAAED,KAAK,EAAE;IAClE,IAAIsL,OAAO,GAAG5F,MAAM,CAACyC,UAAU,CAAC,CAAC,CAAC,CAAC;IACnC;;IAEA,IAAIqF,OAAO,GAAGrP,KAAK,CAACU,YAAY,CAAC4O,cAAc,CAACxN,GAAG,CAAC;IACpD,IAAIiM,GAAG,GAAGjM,GAAG,CAACjB,eAAe,CAAC,CAAC;IAC/B,IAAI0O,IAAI,GAAGvP,KAAK,CAACU,YAAY,CAAC8O,gBAAgB,CAAC,CAAC,CAACjG,QAAQ,CAAC,CAAC;IAC3D,IAAIkG,KAAK,GAAGtC,OAAO,CAACuC,kBAAkB,CAAC,CAAC;IACxC,IAAI/D,iBAAiB,GAAGpE,MAAM,CAACxE,OAAO,CAAC,CAAC,CAAC6I,4BAA4B,CAAC,CAAC;IACvE,IAAIC,uBAAuB,GAAGF,iBAAiB,GAAGpE,MAAM,CAACxE,OAAO,CAAC,CAAC,CAAC+I,6BAA6B,CAAC,CAAC,GAAG,IAAI;IACzG,IAAI6D,eAAe,GAAG9N,KAAK,CAAC+N,aAAa,CAAC,CAAC;IAC3C,IAAIC,OAAO,GAAGF,eAAe,GAAG;MAC9BG,IAAI,EAAE,IAAI;MACVC,YAAY,EAAE;IAChB,CAAC,GAAG/P,KAAK,CAACK,WAAW,CAACiP,cAAc,CAAC,CAAC;IAEtC,IAAIzN,KAAK,CAACmO,mBAAmB,CAAC,CAAC,KAAKzQ,gBAAgB,CAAC0Q,OAAO,EAAE;MAC5D,IAAIC,IAAI,GAAGlQ,KAAK,CAACO,eAAe,CAACwM,qBAAqB,CAAC,CAAC;MAExDpR,IAAI,CAACqT,QAAQ,CAAChP,KAAK,CAACiM,OAAO,CAAC;MAC5BjM,KAAK,CAACiM,OAAO,CAAC,CAAC,CAAC,GAAG,GAAG,GAAGiE,IAAI,CAACC,KAAK;MACnCnQ,KAAK,CAACiM,OAAO,CAAC,EAAE,CAAC,GAAG,CAAC,GAAG;MACxBjM,KAAK,CAACiM,OAAO,CAAC,CAAC,CAAC,GAAG,GAAG,GAAGiE,IAAI,CAACE,KAAK;MACnCpQ,KAAK,CAACiM,OAAO,CAAC,EAAE,CAAC,GAAG,CAAC,GAAG;MACxBtQ,IAAI,CAACyQ,QAAQ,CAACpM,KAAK,CAACiM,OAAO,EAAEjM,KAAK,CAACiM,OAAO,EAAEJ,uBAAuB,CAAC;MACpEsB,OAAO,CAACkD,gBAAgB,CAAC,YAAY,EAAErQ,KAAK,CAACiM,OAAO,CAAC;IACvD,CAAC,MAAM;MACLkB,OAAO,CAACkD,gBAAgB,CAAC,YAAY,EAAEzB,kBAAkB,CAAC,CAACS,OAAO,CAACiB,IAAI,EAAET,OAAO,CAACC,IAAI,EAAEjE,uBAAuB,CAAC,EAAElQ,IAAI,EAAEqE,KAAK,CAACiM,OAAO,CAAC,CAAC;IACxI;IAEA,IAAIkB,OAAO,CAAClD,aAAa,CAAC,YAAY,CAAC,EAAE;MACvCkD,OAAO,CAACkD,gBAAgB,CAAC,YAAY,EAAEzB,kBAAkB,CAAC,CAACS,OAAO,CAACkB,IAAI,EAAEV,OAAO,CAACC,IAAI,EAAEjE,uBAAuB,CAAC,EAAElQ,IAAI,EAAEqE,KAAK,CAACiM,OAAO,CAAC,CAAC;IACxI;IAEA,IAAIkB,OAAO,CAAClD,aAAa,CAAC,cAAc,CAAC,EAAE;MACzCkD,OAAO,CAACqD,mBAAmB,CAAC,cAAc,EAAE5B,kBAAkB,CAAC,CAACS,OAAO,CAACU,YAAY,EAAEF,OAAO,CAACE,YAAY,CAAC,EAAErU,IAAI,EAAEsE,KAAK,CAACyQ,OAAO,CAAC,CAAC;IACpI;IAEA,IAAIhB,KAAK,KAAKF,IAAI,EAAE;MAClB,IAAIpC,OAAO,CAAClD,aAAa,CAAC,gBAAgB,CAAC,EAAE;QAC3CkD,OAAO,CAACjD,WAAW,CAAC,gBAAgB,EAAE6D,GAAG,CAAC2C,qBAAqB,CAAC,CAAC,CAAC;MACpE;MAEAvD,OAAO,CAACwD,kBAAkB,CAACpB,IAAI,CAAC;IAClC;IAEA,IAAI,CAACI,eAAe,EAAE;MACpB;MACAxC,OAAO,CAACwD,kBAAkB,CAAC,CAAC,CAAC;IAC/B;EACF,CAAC;EAED5Q,SAAS,CAAC6Q,2BAA2B,GAAG,UAAUrJ,MAAM,EAAEzF,GAAG,EAAED,KAAK,EAAE;IACpE,IAAIsL,OAAO,GAAG5F,MAAM,CAACyC,UAAU,CAAC,CAAC;IACjC,IAAI6G,IAAI,GAAGhP,KAAK,CAACwC,WAAW,CAAC,CAAC;IAC9B,IAAIyM,OAAO,GAAGD,IAAI,CAACE,UAAU,CAAC,CAAC;IAC/B,IAAIC,MAAM,GAAGhR,KAAK,CAACiD,YAAY,GAAG4N,IAAI,CAACI,uBAAuB,CAAC,CAAC,GAAGJ,IAAI,CAACK,0BAA0B,CAAC,CAAC;IACpG,IAAI9D,MAAM,GAAGpN,KAAK,CAACiD,YAAY,GAAG4N,IAAI,CAACI,uBAAuB,CAAC,CAAC,GAAGJ,IAAI,CAACM,0BAA0B,CAAC,CAAC;IACpG,IAAIC,UAAU,GAAGpR,KAAK,CAACiD,YAAY,GAAG,GAAG,GAAG4N,IAAI,CAACQ,UAAU,CAAC,CAAC;IAC7D,IAAIC,UAAU,GAAGtR,KAAK,CAACiD,YAAY,GAAG,GAAG,GAAG4N,IAAI,CAACU,UAAU,CAAC,CAAC;IAC7D,IAAIC,UAAU,GAAGxR,KAAK,CAACiD,YAAY,GAAG,GAAG,GAAG4N,IAAI,CAACY,WAAW,CAAC,CAAC;IAC9D,IAAIC,aAAa,GAAGb,IAAI,CAACc,gBAAgB,CAAC,CAAC;IAC3CxE,OAAO,CAACL,WAAW,CAAC,gBAAgB,EAAEgE,OAAO,CAAC;IAC9C3D,OAAO,CAACH,iBAAiB,CAAC,qBAAqB,EAAEgE,MAAM,CAAC;IACxD7D,OAAO,CAACH,iBAAiB,CAAC,qBAAqB,EAAEI,MAAM,CAAC;IACxDD,OAAO,CAACL,WAAW,CAAC,SAAS,EAAEsE,UAAU,CAAC;IAC1CjE,OAAO,CAACL,WAAW,CAAC,SAAS,EAAEwE,UAAU,CAAC,CAAC,CAAC;;IAE5C,IAAI7O,mBAAmB,GAAGzC,KAAK,CAAC0C,WAAW,CAACC,kBAAkB,CAAC,qBAAqB,CAAC;IAErF,IAAIF,mBAAmB,GAAG,CAAC,EAAE;MAC3B;IACF;IAEA,IAAImP,MAAM,GAAGf,IAAI,CAACgB,2BAA2B,CAAC,CAAC;IAC/C1E,OAAO,CAACH,iBAAiB,CAAC,sBAAsB,EAAE4E,MAAM,CAAC;IACzDzE,OAAO,CAACL,WAAW,CAAC,sBAAsB,EAAE4E,aAAa,CAAC;IAC1DvE,OAAO,CAACL,WAAW,CAAC,UAAU,EAAE0E,UAAU,CAAC,CAAC,CAAC;;IAE7C,IAAIrE,OAAO,CAAClD,aAAa,CAAC,oBAAoB,CAAC,EAAE;MAC/C4G,IAAI,GAAGhP,KAAK,CAAC0B,mBAAmB,CAAC,CAAC;MAClCuN,OAAO,GAAGD,IAAI,CAACE,UAAU,CAAC,CAAC;MAC3BC,MAAM,GAAGH,IAAI,CAACiB,eAAe,CAAC,CAAC;MAC/BV,UAAU,GAAGP,IAAI,CAACQ,UAAU,CAAC,CAAC;MAC9BjE,MAAM,GAAGyD,IAAI,CAACkB,eAAe,CAAC,CAAC;MAC/BT,UAAU,GAAGT,IAAI,CAACU,UAAU,CAAC,CAAC;MAC9BK,MAAM,GAAGf,IAAI,CAACmB,gBAAgB,CAAC,CAAC;MAChCR,UAAU,GAAGX,IAAI,CAACY,WAAW,CAAC,CAAC;MAC/BtE,OAAO,CAACL,WAAW,CAAC,oBAAoB,EAAEsE,UAAU,CAAC;MACrDjE,OAAO,CAACL,WAAW,CAAC,oBAAoB,EAAEwE,UAAU,CAAC;MACrDnE,OAAO,CAACL,WAAW,CAAC,kBAAkB,EAAEgE,OAAO,CAAC;MAChD3D,OAAO,CAACH,iBAAiB,CAAC,uBAAuB,EAAEgE,MAAM,CAAC;MAC1D7D,OAAO,CAACH,iBAAiB,CAAC,uBAAuB,EAAEI,MAAM,CAAC,CAAC,CAAC;;MAE5D,IAAI3K,mBAAmB,GAAG,CAAC,EAAE;QAC3B;MACF;MAEA0K,OAAO,CAACL,WAAW,CAAC,qBAAqB,EAAE0E,UAAU,CAAC;MACtDrE,OAAO,CAACH,iBAAiB,CAAC,wBAAwB,EAAE4E,MAAM,CAAC;MAC3DzE,OAAO,CAACL,WAAW,CAAC,wBAAwB,EAAE4E,aAAa,CAAC;IAC9D;EACF,CAAC;EAED3R,SAAS,CAACkS,yBAAyB,GAAG,UAAUnQ,GAAG,EAAED,KAAK,EAAE;IAC1D,IAAIqQ,qBAAqB,EAAEC,sBAAsB,EAAEC,sBAAsB,EAAEC,sBAAsB;IAEjG,IAAI3S,QAAQ,GAAGM,KAAK,CAACO,eAAe,CAACZ,WAAW,CAAC,CAAC;IAElD,IAAI,CAACD,QAAQ,EAAE;MACb;IACF;IAEA,IAAI,CAACwS,qBAAqB,GAAGlS,KAAK,CAACsS,yBAAyB,MAAM,IAAI,IAAIJ,qBAAqB,KAAK,KAAK,CAAC,IAAI,CAACC,sBAAsB,GAAGD,qBAAqB,CAACK,MAAM,MAAM,IAAI,IAAIJ,sBAAsB,KAAK,KAAK,CAAC,IAAIA,sBAAsB,CAAC7T,MAAM,EAAE;MACpP,IAAIA,MAAM,GAAG0B,KAAK,CAACsS,yBAAyB,CAACC,MAAM,CAACjU,MAAM;MAC1DoB,QAAQ,CAAC8S,iBAAiB,CAAClU,MAAM,GAAG,CAAC,CAAC;IACxC;IAEA,IAAI,CAAC8T,sBAAsB,GAAGpS,KAAK,CAACsS,yBAAyB,MAAM,IAAI,IAAIF,sBAAsB,KAAK,KAAK,CAAC,IAAI,CAACC,sBAAsB,GAAGD,sBAAsB,CAACK,KAAK,MAAM,IAAI,IAAIJ,sBAAsB,KAAK,KAAK,CAAC,IAAIA,sBAAsB,CAAC/T,MAAM,EAAE;MACtP,IAAIoU,OAAO,GAAG1S,KAAK,CAACsS,yBAAyB,CAACG,KAAK,CAACnU,MAAM;MAC1DoB,QAAQ,CAACiT,gBAAgB,CAACD,OAAO,GAAG,CAAC,CAAC;IACxC;IAEA,IAAIE,gBAAgB,GAAGlT,QAAQ,CAACoH,mBAAmB,CAAC,CAAC;IAErD,IAAI8L,gBAAgB,KAAK/T,iBAAiB,CAACkI,wBAAwB,EAAE;MACnE/G,KAAK,CAAC6S,YAAY,GAAG,IAAI;IAC3B;EACF,CAAC;EAED9S,SAAS,CAAC+S,gBAAgB,GAAG,UAAUhR,GAAG,EAAED,KAAK,EAAE;IACjD7B,KAAK,CAACmK,iBAAiB,GAAG,CAAC;IAC3BnK,KAAK,CAACoK,cAAc,GAAG,CAAC;IACxB,IAAI2I,OAAO,GAAGvT,YAAY,CAACQ,KAAK,CAACO,eAAe,CAAC;IAEjD,IAAIP,KAAK,CAACiH,kBAAkB,KAAK8L,OAAO,EAAE;MACxC/S,KAAK,CAACwJ,qBAAqB,CAACiC,QAAQ,CAAC,CAAC;MACtCzL,KAAK,CAACiH,kBAAkB,GAAG8L,OAAO;IACpC;IAEA,IAAI/S,KAAK,CAACO,eAAe,CAACZ,WAAW,CAAC,CAAC,EAAE;MACvC,QAAQoT,OAAO;QACb;UACE/S,KAAK,CAACO,eAAe,CAACZ,WAAW,CAAC,CAAC,CAACqT,UAAU,CAACnR,KAAK,CAAC;MAEzD;IACF,CAAC,CAAC;;IAGF9B,SAAS,CAACkT,mBAAmB,CAACnR,GAAG,EAAED,KAAK,CAAC,CAAC,CAAC;IAC3C;;IAEA,IAAI7B,KAAK,CAACoD,UAAU,CAAC8B,kBAAkB,CAAC,CAAC,EAAE;MACzClF,KAAK,CAACyM,oBAAoB,CAACyG,QAAQ,CAAC,CAAC;IACvC,CAAC,CAAC;;IAGFlT,KAAK,CAAC0C,WAAW,GAAG,IAAI;EAC1B,CAAC;EAED3C,SAAS,CAACoT,eAAe,GAAG,UAAUrR,GAAG,EAAED,KAAK,EAAE;IAChD,IAAIuG,cAAc,GAAGvG,KAAK,CAACwC,WAAW,CAAC,CAAC,CAACC,iBAAiB,CAAC,CAAC;IAC5D,IAAI8O,oBAAoB,GAAGvR,KAAK,CAACwC,WAAW,CAAC,CAAC,CAAC0B,iBAAiB,CAAC,CAAC,IAAIqC,cAAc,KAAKrJ,cAAc,CAACiH,OAAO;IAE/G,IAAItG,QAAQ,GAAGM,KAAK,CAACO,eAAe,CAACZ,WAAW,CAAC,CAAC,CAAC,CAAC;;IAGpD,IAAIkT,YAAY,GAAGnT,QAAQ,IAAIA,QAAQ,CAACoH,mBAAmB,CAAC,CAAC,KAAKjI,iBAAiB,CAACkI,wBAAwB,KAAK/G,KAAK,CAACiH,kBAAkB,KAAK9J,SAAS,CAAC+J,QAAQ,IAAIlH,KAAK,CAACiH,kBAAkB,KAAK9J,SAAS,CAACgK,SAAS,CAAC,CAAC,CAAC;;IAEvN,KAAK,IAAI/I,CAAC,GAAGU,SAAS,CAAC2C,KAAK,EAAErD,CAAC,GAAGU,SAAS,CAAC4C,GAAG,EAAEtD,CAAC,EAAE,EAAE;MACpD4B,KAAK,CAAC2B,UAAU,CAACvD,CAAC,CAAC,CAACiV,eAAe,CAACR,YAAY,CAAC;MACjD,IAAIS,IAAI,GAAGtT,KAAK,CAAC2B,UAAU,CAACvD,CAAC,CAAC,CAAC2E,OAAO,CAAC,CAAC;MAExC,IAAIuQ,IAAI,CAACjJ,eAAe,CAAC,CAAC,EAAE;QAC1B;QACArK,KAAK,CAACiD,YAAY,GAAGmQ,oBAAoB,KAAKhV,CAAC,KAAKU,SAAS,CAAC8H,SAAS,IAAIxI,CAAC,KAAKU,SAAS,CAAC+H,cAAc,CAAC,CAAC,CAAC;;QAE5G,IAAI,CAAC7G,KAAK,CAACiD,YAAY,IAAI,EAAEjD,KAAK,CAACmB,WAAW,IAAInB,KAAK,CAACiH,kBAAkB,IAAI,CAAC,CAAC,EAAE;UAChFjH,KAAK,CAAC0C,WAAW,GAAG1C,KAAK,CAAC2B,UAAU,CAACvD,CAAC,CAAC;UACvC4B,KAAK,CAACmK,iBAAiB,IAAInK,KAAK,CAAC2B,UAAU,CAACvD,CAAC,CAAC,CAACmV,UAAU,CAACzR,GAAG,EAAED,KAAK,EAAEuG,cAAc,EAAErI,SAAS,CAAC;UAChGC,KAAK,CAACoK,cAAc,IAAIpK,KAAK,CAAC2B,UAAU,CAACvD,CAAC,CAAC,CAAC2E,OAAO,CAAC,CAAC,CAACsH,eAAe,CAAC,CAAC;QACzE;MACF;IACF;EACF,CAAC;EAEDtK,SAAS,CAACyT,iBAAiB,GAAG,UAAU1R,GAAG,EAAED,KAAK,EAAE;IAClD,IAAI7B,KAAK,CAACyT,WAAW,EAAE;MACrBzT,KAAK,CAACyT,WAAW,CAAChJ,MAAM,CAAC,CAAC,CAACiJ,OAAO,CAAC,CAAC;IACtC;IAEA,IAAI1T,KAAK,CAACoD,UAAU,CAAC8B,kBAAkB,CAAC,CAAC,EAAE;MACzClF,KAAK,CAACyM,oBAAoB,CAACkH,UAAU,CAAC,CAAC;IACzC;EACF,CAAC;EAED5T,SAAS,CAACgC,WAAW,GAAG,UAAUD,GAAG,EAAED,KAAK,EAAE;IAC5C;IACA;IACA;IACA;IACA9B,SAAS,CAAC6T,WAAW,CAACxU,UAAU,CAAC;IAEjC,IAAI,CAACY,KAAK,CAACoD,UAAU,CAACyQ,SAAS,CAAC,CAAC,EAAE;MACjC7T,KAAK,CAACoD,UAAU,CAAC0Q,MAAM,CAAC,CAAC;IAC3B;IAEA9T,KAAK,CAAC2H,YAAY,GAAG3H,KAAK,CAACoD,UAAU,CAAC2Q,YAAY,CAAC,CAAC;IACpDhU,SAAS,CAAC6T,WAAW,CAACtU,QAAQ,CAAC;IAE/B,IAAI,CAACU,KAAK,CAAC2H,YAAY,EAAE;MACvB1L,aAAa,CAAC,WAAW,CAAC;MAC1B;IACF,CAAC,CAAC;;IAGF,IAAI,CAAC+D,KAAK,CAAC2H,YAAY,CAACqM,SAAS,IAAI,CAAChU,KAAK,CAAC2H,YAAY,CAACqM,SAAS,CAAC,CAAC,CAACC,iBAAiB,CAAC,CAAC,EAAE;MACxF;IACF,CAAC,CAAC;;IAGF,IAAIC,EAAE,GAAGlU,KAAK,CAACwB,OAAO;IACtB,IAAI2S,eAAe,GAAGtS,KAAK,CAACwC,WAAW,CAAC,CAAC,CAAC+P,kBAAkB,CAAC,CAAC;IAC9D,IAAIC,gBAAgB,GAAGxS,KAAK,CAACwC,WAAW,CAAC,CAAC,CAACiQ,mBAAmB,CAAC,CAAC;IAEhE,IAAI,CAACH,eAAe,IAAI,CAACE,gBAAgB,EAAE;MACzCrU,KAAK,CAACQ,mBAAmB,CAAC+T,eAAe,CAAC,CAAC;IAC7C,CAAC,MAAM,IAAIF,gBAAgB,EAAE;MAC3BrU,KAAK,CAACQ,mBAAmB,CAACgU,cAAc,CAAC,CAAC;MAE1CN,EAAE,CAACO,QAAQ,CAACP,EAAE,CAACQ,KAAK,CAAC;IACvB,CAAC,MAAM;MACL1U,KAAK,CAACQ,mBAAmB,CAACgU,cAAc,CAAC,CAAC;MAE1CN,EAAE,CAACO,QAAQ,CAACP,EAAE,CAACS,IAAI,CAAC;IACtB;IAEA5U,SAAS,CAAC+S,gBAAgB,CAAChR,GAAG,EAAED,KAAK,CAAC;IACtC9B,SAAS,CAACoT,eAAe,CAACrR,GAAG,EAAED,KAAK,CAAC;IACrC9B,SAAS,CAACyT,iBAAiB,CAAC1R,GAAG,EAAED,KAAK,CAAC;EACzC,CAAC;EAED9B,SAAS,CAAC6U,aAAa,GAAG,UAAU9S,GAAG,EAAED,KAAK,EAAE;IAC9C,IAAI,CAAC9B,SAAS,CAAC8U,QAAQ,CAAC,CAAC,EAAE;MACzBrY,kBAAkB,CAACwD,KAAK,CAAC8U,MAAM,CAAC;MAChC;IACF;IAEA9U,KAAK,CAAC8U,MAAM,GAAG/U,SAAS,CAAC8U,QAAQ,CAAC,CAAC,CAACE,SAAS,CAAC,CAAC;EACjD,CAAC;EAEDhV,SAAS,CAACkT,mBAAmB,GAAG,UAAUnR,GAAG,EAAED,KAAK,EAAE;IACpD;IACA,IAAI9B,SAAS,CAACiV,6BAA6B,CAAClT,GAAG,EAAED,KAAK,CAAC,EAAE;MACvD9B,SAAS,CAACkV,kBAAkB,CAACnT,GAAG,EAAED,KAAK,CAAC;IAC1C;EACF,CAAC;EAED9B,SAAS,CAACiV,6BAA6B,GAAG,UAAUlT,GAAG,EAAED,KAAK,EAAE;IAC9D;IACA;IACA,IAAIqT,MAAM,GAAGlV,KAAK,CAACsK,YAAY,CAACf,QAAQ,CAAC,CAAC;IAE1C,IAAI2L,MAAM,GAAGnV,SAAS,CAACwJ,QAAQ,CAAC,CAAC,IAAI2L,MAAM,GAAGlV,KAAK,CAACoD,UAAU,CAACmG,QAAQ,CAAC,CAAC,IAAI2L,MAAM,GAAGrT,KAAK,CAAC0H,QAAQ,CAAC,CAAC,IAAI2L,MAAM,GAAGlV,KAAK,CAAC2H,YAAY,CAAC4B,QAAQ,CAAC,CAAC,EAAE;MAChJ,OAAO,IAAI;IACb;IAEA,OAAO,KAAK;EACd,CAAC;EAEDxJ,SAAS,CAACkV,kBAAkB,GAAG,UAAUnT,GAAG,EAAED,KAAK,EAAE;IACnD,IAAI6F,IAAI,GAAG1H,KAAK,CAAC2H,YAAY;IAE7B,IAAID,IAAI,KAAK,IAAI,EAAE;MACjB;IACF;IAEA1H,KAAK,CAACoD,UAAU,CAAC+R,UAAU,CAACzN,IAAI,EAAE,GAAG,CAAC;IACtC,IAAI0N,CAAC,GAAGpV,KAAK,CAACoD,UAAU,CAACiS,iBAAiB,CAAC,CAAC;IAC5CrV,KAAK,CAACwD,eAAe,GAAG,KAAK;IAC7B,IAAI8R,UAAU,GAAGtV,KAAK,CAACoD,UAAU,CAACmS,aAAa,CAAC,CAAC;IAEjD,IAAIvV,KAAK,CAACoD,UAAU,CAACoS,mBAAmB,CAAC,CAAC,EAAE;MAC1C;MACA,IAAI,CAACF,UAAU,KAAKrW,UAAU,CAACwW,aAAa,IAAIH,UAAU,KAAKrW,UAAU,CAACyW,mBAAmB,IAAIJ,UAAU,KAAKrW,UAAU,CAAC0W,cAAc,IAAI,CAACjO,IAAI,CAACvC,YAAY,CAAC,CAAC,CAACC,UAAU,CAAC,CAAC,KAAKkQ,UAAU,KAAKrW,UAAU,CAAC2W,oBAAoB,IAAIR,CAAC,EAAE;QACtOpV,KAAK,CAACwD,eAAe,GAAG,IAAI;MAC9B;IACF,CAAC,CAAC;;IAGF,IAAIqS,CAAC,GAAGhU,KAAK,CAACwC,WAAW,CAAC,CAAC,CAAC6D,gBAAgB,CAAC,CAAC,KAAKlJ,OAAO,CAACmJ,IAAI,GAAGT,IAAI,CAACvC,YAAY,CAAC,CAAC,CAAC2C,UAAU,CAAC,CAAC,GAAG,IAAI;IAEzG,IAAI+N,CAAC,KAAK,IAAI,IAAInO,IAAI,CAACM,WAAW,CAAC,CAAC,CAACF,UAAU,CAAC,CAAC,EAAE;MACjD9H,KAAK,CAACmE,eAAe,GAAG,IAAI;MAC5B0R,CAAC,GAAGnO,IAAI,CAACM,WAAW,CAAC,CAAC,CAACF,UAAU,CAAC,CAAC;IACrC,CAAC,CAAC;IACF;IACA;IACA;IACA;;IAGA,IAAIM,cAAc,GAAGvG,KAAK,CAACwC,WAAW,CAAC,CAAC,CAACC,iBAAiB,CAAC,CAAC;IAC5D,IAAIwR,OAAO,GAAGpO,IAAI,CAACvC,YAAY,CAAC,CAAC,CAAC4Q,UAAU,CAAC,CAAC;IAE9C,IAAI,CAAC/V,KAAK,CAACK,WAAW,CAACuE,iBAAiB,CAAC,CAAC,EAAE;MAC1CkR,OAAO,GAAG,IAAI;IAChB,CAAC,CAAC;;IAGF,IAAI9V,KAAK,CAACoD,UAAU,CAACE,mBAAmB,CAAC,CAAC,EAAE;MAC1CwS,OAAO,GAAG9V,KAAK,CAACoD,UAAU,CAACE,mBAAmB,CAAC,CAAC;MAEhD,IAAI,CAACtD,KAAK,CAACyM,oBAAoB,EAAE;QAC/BzM,KAAK,CAACyM,oBAAoB,GAAGhQ,gBAAgB,CAACZ,WAAW,CAAC;UACxDma,SAAS,EAAE;QACb,CAAC,CAAC;MACJ;MAEA,IAAIrJ,GAAG,GAAG3M,KAAK,CAACyM,oBAAoB,CAAC,CAAC;;MAEtCE,GAAG,CAACsJ,qBAAqB,CAAC/W,MAAM,CAACgX,OAAO,CAAC;MACzCvJ,GAAG,CAACwJ,sBAAsB,CAACjX,MAAM,CAACgX,OAAO,CAAC;MAC1CvJ,GAAG,CAACyJ,QAAQ,CAACjX,IAAI,CAACkX,aAAa,CAAC;MAChC1J,GAAG,CAAC2J,QAAQ,CAACnX,IAAI,CAACkX,aAAa,CAAC;MAChC1J,GAAG,CAAC/K,qBAAqB,CAAC5B,KAAK,CAACQ,mBAAmB,CAAC;MACpD,IAAI+V,KAAK,GAAGvW,KAAK,CAACoD,UAAU,CAAC8B,kBAAkB,CAAC,CAAC;MACjD,IAAIsR,GAAG,GAAGD,KAAK,CAACE,SAAS,CAAC,CAAC;MAC3B,IAAIC,SAAS,GAAGH,KAAK,CAACpR,YAAY,CAAC,CAAC,CAACC,UAAU,CAAC,CAAC;MACjDuH,GAAG,CAACgK,eAAe,CAACH,GAAG,CAAC,CAAC,CAAC,GAAGA,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC,EAAEA,GAAG,CAAC,CAAC,CAAC,GAAGA,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC,EAAEE,SAAS,CAACrR,qBAAqB,CAAC,CAAC,EAAEqR,SAAS,CAACE,WAAW,CAAC,CAAC,EAAEF,SAAS,CAACG,OAAO,CAAC,CAAC,CAAC;MAC9IlK,GAAG,CAACuG,QAAQ,CAAC,CAAC;MACdvG,GAAG,CAACmK,cAAc,CAAC,CAAC;MACpBnK,GAAG,CAACgH,UAAU,CAAC,CAAC;IAClB;IAEA,IAAIoD,QAAQ,GAAG,EAAE,CAAClU,MAAM,CAAC6E,IAAI,CAAC6B,QAAQ,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC1G,MAAM,CAACuF,cAAc,EAAE,GAAG,CAAC,CAACvF,MAAM,CAAC6E,IAAI,CAAC6B,QAAQ,CAAC,CAAC,CAAC,GAAG,GAAG,CAAC1G,MAAM,CAACgT,CAAC,GAAGA,CAAC,CAACtM,QAAQ,CAAC,CAAC,GAAG,CAAC,EAAE,GAAG,CAAC,CAAC1G,MAAM,CAACuS,CAAC,GAAGA,CAAC,CAAC7L,QAAQ,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,GAAG,CAAC1G,MAAM,CAAChB,KAAK,CAACwC,WAAW,CAAC,CAAC,CAAC0B,iBAAiB,CAAC,CAAC,CAAC,GAAG,GAAG,CAAClD,MAAM,CAACiT,OAAO,GAAGA,OAAO,CAACvM,QAAQ,CAAC,CAAC,GAAG,CAAC,CAAC;IAE5Q,IAAIvJ,KAAK,CAACgX,cAAc,KAAKD,QAAQ,EAAE;MACrC;MACA,IAAIxE,MAAM,GAAG7K,IAAI,CAACsM,SAAS,CAAC,CAAC;MAC7B,IAAIiD,OAAO,GAAG;QACZ1E,MAAM,EAAEA,MAAM;QACd2E,OAAO,EAAErB,CAAC;QACVC,OAAO,EAAEA,OAAO;QAChBqB,MAAM,EAAE/B,CAAC;QACTgC,UAAU,EAAE,CAAC;QACbC,YAAY,EAAE,CAAC;QACf;QACA7T,eAAe,EAAExD,KAAK,CAACwD,eAAe;QACtCW,eAAe,EAAEnE,KAAK,CAACmE,eAAe;QACtCmT,gBAAgB,EAAEtX,KAAK,CAACoD,UAAU,CAAC2H,yBAAyB,CAAC,CAAC,CAACwM,GAAG,CAAC,UAAUC,SAAS,EAAE;UACtF,OAAO9P,IAAI,CAACvC,YAAY,CAAC,CAAC,CAACsS,cAAc,CAACD,SAAS,CAAC;QACtD,CAAC;MACH,CAAC;MAED,IAAIxX,KAAK,CAACoD,UAAU,CAACsU,4BAA4B,CAAC,CAAC,EAAE;QACnD1X,KAAK,CAACsS,yBAAyB,GAAG;UAChCC,MAAM,EAAE,IAAI;UACZE,KAAK,EAAE;QACT,CAAC;MACH;MAEA,IAAI9Q,UAAU,GAAG,CAAC;QAChBgW,KAAK,EAAE,OAAO;QACdlF,KAAK,EAAE/K,IAAI,CAACkQ,QAAQ,CAAC;MACvB,CAAC,EAAE;QACDD,KAAK,EAAE,OAAO;QACdlF,KAAK,EAAE/K,IAAI,CAACmQ,QAAQ,CAAC;MACvB,CAAC,EAAE;QACDF,KAAK,EAAE,OAAO;QACdlF,KAAK,EAAE/K,IAAI,CAACoQ,QAAQ,CAAC;MACvB,CAAC,EAAE;QACDH,KAAK,EAAE,QAAQ;QACflF,KAAK,EAAE/K,IAAI,CAACqQ,SAAS,CAAC;MACxB,CAAC,EAAE;QACDJ,KAAK,EAAE,OAAO;QACdlF,KAAK,EAAE/K,IAAI,CAACoQ,QAAQ,CAAC;MACvB,CAAC,EAAE;QACDH,KAAK,EAAE,QAAQ;QACflF,KAAK,EAAE/K,IAAI,CAACqQ,SAAS,CAAC;MACxB,CAAC,CAAC;MACF,IAAI3E,oBAAoB,GAAGvR,KAAK,CAACwC,WAAW,CAAC,CAAC,CAAC0B,iBAAiB,CAAC,CAAC,IAAIqC,cAAc,KAAKrJ,cAAc,CAACiH,OAAO;MAE/G,KAAK,IAAI5H,CAAC,GAAGU,SAAS,CAAC2C,KAAK,EAAErD,CAAC,GAAGU,SAAS,CAAC4C,GAAG,EAAEtD,CAAC,EAAE,EAAE;QACpD,IAAIA,CAAC,KAAKU,SAAS,CAAC8H,SAAS,IAAIxI,CAAC,KAAKU,SAAS,CAAC+H,cAAc,EAAE;UAC/DoQ,OAAO,CAACG,UAAU,IAAIpX,KAAK,CAAC2B,UAAU,CAACvD,CAAC,CAAC,CAAC2E,OAAO,CAAC,CAAC,CAACiV,SAAS,CAACrW,UAAU,CAACvD,CAAC,CAAC,CAACqU,KAAK,EAAE9Q,UAAU,CAACvD,CAAC,CAAC,CAACuZ,KAAK,EAAEvP,cAAc,EAAE6O,OAAO,EAAEjX,KAAK,CAACsS,yBAAyB,CAAC;UACjK2E,OAAO,CAACI,YAAY,IAAIrX,KAAK,CAAC2B,UAAU,CAACvD,CAAC,CAAC,CAAC2E,OAAO,CAAC,CAAC,CAACsH,eAAe,CAAC,CAAC;QACzE,CAAC,MAAM;UACL;UACA,IAAI+I,oBAAoB,EAAE;YACxB;YACA;YACA;YACApT,KAAK,CAAC2B,UAAU,CAACvD,CAAC,CAAC,CAAC2E,OAAO,CAAC,CAAC,CAACiV,SAAS,CAACrW,UAAU,CAACvD,CAAC,CAAC,CAACqU,KAAK,EAAE9Q,UAAU,CAACvD,CAAC,CAAC,CAACuZ,KAAK,EAAE5Y,cAAc,CAACwH,SAAS,EAAErI,aAAa,CAACA,aAAa,CAAC,CAAC,CAAC,EAAE+Y,OAAO,CAAC,EAAE,CAAC,CAAC,EAAE;cACxJnB,OAAO,EAAE,IAAI;cACbqB,MAAM,EAAE,IAAI;cACZ3T,eAAe,EAAE,KAAK;cACtBW,eAAe,EAAE;YACnB,CAAC,CAAC,CAAC;UACL,CAAC,MAAM;YACL;YACAnE,KAAK,CAAC2B,UAAU,CAACvD,CAAC,CAAC,CAAC6Z,wBAAwB,CAAC,CAAC;UAChD;QACF;MACF;MAEA,IAAIjY,KAAK,CAACoD,UAAU,CAACsU,4BAA4B,CAAC,CAAC,EAAE;QACnD1X,KAAK,CAACoD,UAAU,CAAC8U,4BAA4B,CAAClY,KAAK,CAACsS,yBAAyB,CAAC;QAC9EvS,SAAS,CAACkS,yBAAyB,CAAC,CAAC;MACvC;MAEAjS,KAAK,CAACsK,YAAY,CAACmB,QAAQ,CAAC,CAAC;MAC7BzL,KAAK,CAACgX,cAAc,GAAGD,QAAQ;IACjC;EACF,CAAC;AACH,CAAC,CAAC;AACF;AACA;;AAGA,IAAIoB,cAAc,GAAG;EACnB3W,OAAO,EAAE,IAAI;EACb8I,YAAY,EAAE,CAAC;EACf0M,cAAc,EAAE,IAAI;EACpBrV,UAAU,EAAE,IAAI;EAChB7C,SAAS,EAAE,IAAI;EACfsZ,mBAAmB,EAAE,IAAI;EACzBnM,OAAO,EAAE,IAAI;EACboM,YAAY,EAAE,EAAE;EAChB;EACAC,YAAY,EAAE,EAAE;EAChB;EACAC,aAAa,EAAE,EAAE;EACjB;EACAhL,UAAU,EAAE,EAAE;EACd;EACAO,cAAc,EAAE,EAAE;EAClB;EACAzE,wBAAwB,EAAE,KAAK;EAC/BnI,oBAAoB,EAAE,KAAK;EAC3B+F,kBAAkB,EAAE9J,SAAS,CAAC0C,cAAc,GAAG,CAAC;EAChD2J,qBAAqB,EAAE,IAAI;EAC3B8I,yBAAyB,EAAE,IAAI;EAC/BO,YAAY,EAAE;AAChB,CAAC,CAAC,CAAC;;AAEH,SAAS2F,MAAMA,CAACzY,SAAS,EAAEC,KAAK,EAAE;EAChC,IAAIyY,aAAa,GAAGpa,SAAS,CAACC,MAAM,GAAG,CAAC,IAAID,SAAS,CAAC,CAAC,CAAC,KAAKqa,SAAS,GAAGra,SAAS,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC;EAC1FZ,MAAM,CAACkb,MAAM,CAAC3Y,KAAK,EAAEmY,cAAc,EAAEM,aAAa,CAAC,CAAC,CAAC;;EAErD5b,WAAW,CAAC2b,MAAM,CAACzY,SAAS,EAAEC,KAAK,EAAEyY,aAAa,CAAC;EACnDxb,0BAA0B,CAAC2b,sCAAsC,CAAC7Y,SAAS,EAAEC,KAAK,EAAEyY,aAAa,CAAC;EAClGxb,0BAA0B,CAAC4b,qCAAqC,CAAC9Y,SAAS,EAAEC,KAAK,EAAEyY,aAAa,CAAC;EACjGzY,KAAK,CAAC2B,UAAU,GAAG,EAAE;EACrB3B,KAAK,CAAClB,SAAS,GAAGA,SAAS;EAC3BkB,KAAK,CAACyQ,OAAO,GAAG/U,IAAI,CAACsT,QAAQ,CAAC,IAAIT,YAAY,CAAC,CAAC,CAAC,CAAC;EAClDvO,KAAK,CAACiM,OAAO,GAAGtQ,IAAI,CAACqT,QAAQ,CAAC,IAAIT,YAAY,CAAC,EAAE,CAAC,CAAC;EAEnD,KAAK,IAAInQ,CAAC,GAAGU,SAAS,CAAC2C,KAAK,EAAErD,CAAC,GAAGU,SAAS,CAAC4C,GAAG,EAAEtD,CAAC,EAAE,EAAE;IACpD4B,KAAK,CAAC2B,UAAU,CAACvD,CAAC,CAAC,GAAGjC,SAAS,CAACN,WAAW,CAAC,CAAC;IAC7CmE,KAAK,CAAC2B,UAAU,CAACvD,CAAC,CAAC,CAAC0a,gBAAgB,CAAC1a,CAAC,CAAC;IACvC4B,KAAK,CAAC2B,UAAU,CAACvD,CAAC,CAAC,CAAC8K,GAAG,CAAC;MACtBzG,mBAAmB,EAAE,CAAC;MACtBkB,cAAc,EAAE,CAAC;MACjBoV,iBAAiB,EAAE;IACrB,CAAC,EAAE,IAAI,CAAC;EACV,CAAC,CAAC;;EAGFhd,MAAM,CAACgE,SAAS,EAAEC,KAAK,EAAE,CAAC,SAAS,CAAC,CAAC;EACrCA,KAAK,CAACsK,YAAY,GAAG,CAAC,CAAC;EACvBtO,GAAG,CAACgE,KAAK,CAACsK,YAAY,EAAE;IACtB0O,KAAK,EAAE;EACT,CAAC,CAAC;EACFhZ,KAAK,CAACwJ,qBAAqB,GAAG,CAAC,CAAC;EAChCxN,GAAG,CAACgE,KAAK,CAACwJ,qBAAqB,EAAE;IAC/BwP,KAAK,EAAE;EACT,CAAC,CAAC,CAAC,CAAC;;EAEJlZ,uBAAuB,CAACC,SAAS,EAAEC,KAAK,CAAC;AAC3C,CAAC,CAAC;;AAEF,IAAInE,WAAW,GAAGC,aAAa,CAAC0c,MAAM,EAAE,yBAAyB,CAAC,CAAC,CAAC;;AAEpE,IAAIS,yBAAyB,GAAG;EAC9Bpd,WAAW,EAAEA,WAAW;EACxB2c,MAAM,EAAEA;AACV,CAAC,CAAC,CAAC;;AAEHtb,gBAAgB,CAAC,WAAW,EAAErB,WAAW,CAAC;AAE1C,SAASod,yBAAyB,IAAIC,OAAO,EAAEV,MAAM,EAAE3c,WAAW"},"metadata":{},"sourceType":"module","externalDependencies":[]}