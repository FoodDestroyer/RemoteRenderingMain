{"ast":null,"code":"import _toConsumableArray from '@babel/runtime/helpers/toConsumableArray';\nimport macro from '../../macros.js';\nimport { mat4 } from 'gl-matrix';\nimport vtkWebGPUFullScreenQuad from './FullScreenQuad.js';\nimport vtkWebGPUUniformBuffer from './UniformBuffer.js';\nimport vtkWebGPUShaderCache from './ShaderCache.js';\nimport vtkWebGPUStorageBuffer from './StorageBuffer.js';\nimport vtkWebGPUSampler from './Sampler.js';\nimport vtkWebGPUTypes from './Types.js';\nimport { BlendMode } from '../Core/VolumeMapper/Constants.js';\nvar volFragTemplate = \"\\n//VTK::Renderer::Dec\\n\\n//VTK::Mapper::Dec\\n\\n//VTK::TCoord::Dec\\n\\n//VTK::Volume::TraverseDec\\n\\n//VTK::RenderEncoder::Dec\\n\\n//VTK::IOStructs::Dec\\n\\nfn getTextureValue(vTex: texture_3d<f32>, tpos: vec4<f32>) -> f32\\n{\\n  // todo multicomponent support\\n  return textureSampleLevel(vTex, clampSampler, tpos.xyz, 0.0).r;\\n}\\n\\nfn getGradient(vTex: texture_3d<f32>, tpos: vec4<f32>, vNum: i32, scalar: f32) -> vec4<f32>\\n{\\n  var result: vec4<f32>;\\n\\n  var tstep: vec4<f32> = volumeSSBO.values[vNum].tstep;\\n  result.x = getTextureValue(vTex, tpos + vec4<f32>(tstep.x, 0.0, 0.0, 1.0)) - scalar;\\n  result.y = getTextureValue(vTex, tpos + vec4<f32>(0.0, tstep.y, 0.0, 1.0)) - scalar;\\n  result.z = getTextureValue(vTex, tpos + vec4<f32>(0.0, 0.0, tstep.z, 1.0)) - scalar;\\n  result.w = 0.0;\\n\\n  // divide by spacing as that is our delta\\n  result = result / volumeSSBO.values[vNum].spacing;\\n  // now we have a gradient in unit tcoords\\n\\n  var grad: f32 = length(result.xyz);\\n  if (grad > 0.0)\\n  {\\n    // rotate to View Coords, needed for lighting and shading\\n    var nMat: mat4x4<f32> = rendererUBO.SCVCMatrix * volumeSSBO.values[vNum].planeNormals;\\n    result = nMat * result;\\n    result = result / length(result);\\n  }\\n\\n  // store gradient magnitude in .w\\n  result.w = grad;\\n\\n  return result;\\n}\\n\\nfn processVolume(vTex: texture_3d<f32>, vNum: i32, cNum: i32, posSC: vec4<f32>, tfunRows: f32) -> vec4<f32>\\n{\\n  var outColor: vec4<f32> = vec4<f32>(0.0, 0.0, 0.0, 0.0);\\n\\n  // convert to tcoords and reject if outside the volume\\n  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*posSC;\\n  if (tpos.x < 0.0 || tpos.y < 0.0 || tpos.z < 0.0 ||\\n      tpos.x > 1.0 || tpos.y > 1.0 || tpos.z > 1.0) { return outColor; }\\n\\n  var scalar: f32 = getTextureValue(vTex, tpos);\\n\\n  var coord: vec2<f32> =\\n    vec2<f32>(scalar * componentSSBO.values[cNum].cScale + componentSSBO.values[cNum].cShift,\\n      (0.5 + 2.0 * f32(vNum)) / tfunRows);\\n  var color: vec4<f32> = textureSampleLevel(tfunTexture, clampSampler, coord, 0.0);\\n\\n  var gofactor: f32 = 1.0;\\n  var normal: vec4<f32> = vec4<f32>(0.0,0.0,0.0,0.0);\\n  if (componentSSBO.values[cNum].gomin <  1.0 || volumeSSBO.values[vNum].shade[0] > 0.0)\\n  {\\n    normal = getGradient(vTex, tpos, vNum, scalar);\\n    if (componentSSBO.values[cNum].gomin <  1.0)\\n    {\\n      gofactor = clamp(normal.a*componentSSBO.values[cNum].goScale + componentSSBO.values[cNum].goShift,\\n      componentSSBO.values[cNum].gomin, componentSSBO.values[cNum].gomax);\\n    }\\n  }\\n\\n  coord.x = (scalar * componentSSBO.values[cNum].oScale + componentSSBO.values[cNum].oShift);\\n  var opacity: f32 = textureSampleLevel(ofunTexture, clampSampler, coord, 0.0).r;\\n\\n  if (volumeSSBO.values[vNum].shade[0] > 0.0)\\n  {\\n    color = color*abs(normal.z);\\n  }\\n\\n  outColor = vec4<f32>(color.rgb, gofactor * opacity);\\n\\n  return outColor;\\n}\\n\\n// adjust the start and end point of a raycast such that it intersects the unit cube.\\n// This function is used to take a raycast starting point and step vector\\n// and numSteps and return the startijng and ending steps for intersecting the\\n// unit cube. Recall for a 3D texture, the unit cube is the range of texture coordsinates\\n// that have valid values. So this funtion can be used to take a ray in texture coordinates\\n// and bound it to intersecting the texture.\\n//\\nfn adjustBounds(tpos: vec4<f32>, tstep: vec4<f32>, numSteps: f32) -> vec2<f32>\\n{\\n  var result: vec2<f32> = vec2<f32>(0.0, numSteps);\\n  var tpos2: vec4<f32> = tpos + tstep*numSteps;\\n\\n  // move tpos to the start of the volume\\n  var adjust: f32 =\\n    min(\\n      max(tpos.x/tstep.x, (tpos.x - 1.0)/tstep.x),\\n      min(\\n        max((tpos.y - 1.0)/tstep.y, tpos.y/tstep.y),\\n        max((tpos.z - 1.0)/tstep.z, tpos.z/tstep.z)));\\n  if (adjust < 0.0)\\n  {\\n    result.x = result.x - adjust;\\n  }\\n\\n  // adjust length to the end\\n  adjust =\\n    max(\\n      min(tpos2.x/tstep.x, (tpos2.x - 1.0)/tstep.x),\\n      max(\\n        min((tpos2.y - 1.0)/tstep.y, tpos2.y/tstep.y),\\n        min((tpos2.z - 1.0)/tstep.z, tpos2.z/tstep.z)));\\n  if (adjust > 0.0)\\n  {\\n    result.y = result.y - adjust;\\n  }\\n\\n  return result;\\n}\\n\\nfn getSimpleColor(scalar: f32, vNum: i32, cNum: i32) -> vec4<f32>\\n{\\n  // how many rows (tfuns) do we have in our tfunTexture\\n  var tfunRows: f32 = f32(textureDimensions(tfunTexture).y);\\n\\n  var coord: vec2<f32> =\\n    vec2<f32>(scalar * componentSSBO.values[cNum].cScale + componentSSBO.values[cNum].cShift,\\n      (0.5 + 2.0 * f32(vNum)) / tfunRows);\\n  var color: vec4<f32> = textureSampleLevel(tfunTexture, clampSampler, coord, 0.0);\\n  coord.x = (scalar * componentSSBO.values[cNum].oScale + componentSSBO.values[cNum].oShift);\\n  var opacity: f32 = textureSampleLevel(ofunTexture, clampSampler, coord, 0.0).r;\\n  return vec4<f32>(color.rgb, opacity);\\n}\\n\\nfn traverseMax(vTex: texture_3d<f32>, vNum: i32, cNum: i32, rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>)\\n{\\n  // convert to tcoords and reject if outside the volume\\n  var numSteps: f32 = rayLengthSC/mapperUBO.SampleDistance;\\n  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*minPosSC;\\n  var tpos2: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*(minPosSC + rayStepSC);\\n  var tstep: vec4<f32> = tpos2 - tpos;\\n\\n  var rayBounds: vec2<f32> = adjustBounds(tpos, tstep, numSteps);\\n\\n  // did we hit anything\\n  if (rayBounds.x >= rayBounds.y)\\n  {\\n    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);\\n    return;\\n  }\\n\\n  tpos = tpos + tstep*rayBounds.x;\\n  var curDist: f32 = rayBounds.x;\\n  var maxVal: f32 = -1.0e37;\\n  loop\\n  {\\n    var scalar: f32 = getTextureValue(vTex, tpos);\\n    if (scalar > maxVal)\\n    {\\n      maxVal = scalar;\\n    }\\n\\n    // increment position\\n    curDist = curDist + 1.0;\\n    tpos = tpos + tstep;\\n\\n    // check if we have reached a terminating condition\\n    if (curDist > rayBounds.y) { break; }\\n  }\\n\\n  // process to get the color and opacity\\n  traverseVals[vNum] = getSimpleColor(maxVal, vNum, cNum);\\n}\\n\\nfn traverseMin(vTex: texture_3d<f32>, vNum: i32, cNum: i32, rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>)\\n{\\n  // convert to tcoords and reject if outside the volume\\n  var numSteps: f32 = rayLengthSC/mapperUBO.SampleDistance;\\n  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*minPosSC;\\n  var tpos2: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*(minPosSC + rayStepSC);\\n  var tstep: vec4<f32> = tpos2 - tpos;\\n\\n  var rayBounds: vec2<f32> = adjustBounds(tpos, tstep, numSteps);\\n\\n  // did we hit anything\\n  if (rayBounds.x >= rayBounds.y)\\n  {\\n    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);\\n    return;\\n  }\\n\\n  tpos = tpos + tstep*rayBounds.x;\\n  var curDist: f32 = rayBounds.x;\\n  var minVal: f32 = 1.0e37;\\n  loop\\n  {\\n    var scalar: f32 = getTextureValue(vTex, tpos);\\n    if (scalar < minVal)\\n    {\\n      minVal = scalar;\\n    }\\n\\n    // increment position\\n    curDist = curDist + 1.0;\\n    tpos = tpos + tstep;\\n\\n    // check if we have reached a terminating condition\\n    if (curDist > rayBounds.y) { break; }\\n  }\\n\\n  // process to get the color and opacity\\n  traverseVals[vNum] = getSimpleColor(minVal, vNum, cNum);\\n}\\n\\nfn traverseAverage(vTex: texture_3d<f32>, vNum: i32, cNum: i32, rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>)\\n{\\n  // convert to tcoords and reject if outside the volume\\n  var numSteps: f32 = rayLengthSC/mapperUBO.SampleDistance;\\n  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*minPosSC;\\n  var tpos2: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*(minPosSC + rayStepSC);\\n  var tstep: vec4<f32> = tpos2 - tpos;\\n\\n  var rayBounds: vec2<f32> = adjustBounds(tpos, tstep, numSteps);\\n\\n  // did we hit anything\\n  if (rayBounds.x >= rayBounds.y)\\n  {\\n    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);\\n    return;\\n  }\\n\\n  let ipRange: vec4<f32> = volumeSSBO.values[vNum].ipScalarRange;\\n  tpos = tpos + tstep*rayBounds.x;\\n  var curDist: f32 = rayBounds.x;\\n  var avgVal: f32 = 0.0;\\n  var sampleCount: f32 = 0.0;\\n  loop\\n  {\\n    var sample: f32 = getTextureValue(vTex, tpos);\\n    // right now leave filtering off until WebGL changes get merged\\n    // if (ipRange.z == 0.0 || sample >= ipRange.x && sample <= ipRange.y)\\n    // {\\n      avgVal = avgVal + sample;\\n      sampleCount = sampleCount + 1.0;\\n    // }\\n\\n    // increment position\\n    curDist = curDist + 1.0;\\n    tpos = tpos + tstep;\\n\\n    // check if we have reached a terminating condition\\n    if (curDist > rayBounds.y) { break; }\\n  }\\n\\n  if (sampleCount <= 0.0)\\n  {\\n    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);\\n  }\\n\\n  // process to get the color and opacity\\n  traverseVals[vNum] = getSimpleColor(avgVal/sampleCount, vNum, cNum);\\n}\\n\\nfn traverseAdditive(vTex: texture_3d<f32>, vNum: i32, cNum: i32, rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>)\\n{\\n  // convert to tcoords and reject if outside the volume\\n  var numSteps: f32 = rayLengthSC/mapperUBO.SampleDistance;\\n  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*minPosSC;\\n  var tpos2: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*(minPosSC + rayStepSC);\\n  var tstep: vec4<f32> = tpos2 - tpos;\\n\\n  var rayBounds: vec2<f32> = adjustBounds(tpos, tstep, numSteps);\\n\\n  // did we hit anything\\n  if (rayBounds.x >= rayBounds.y)\\n  {\\n    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);\\n    return;\\n  }\\n\\n  let ipRange: vec4<f32> = volumeSSBO.values[vNum].ipScalarRange;\\n  tpos = tpos + tstep*rayBounds.x;\\n  var curDist: f32 = rayBounds.x;\\n  var sumVal: f32 = 0.0;\\n  loop\\n  {\\n    var sample: f32 = getTextureValue(vTex, tpos);\\n    // right now leave filtering off until WebGL changes get merged\\n    // if (ipRange.z == 0.0 || sample >= ipRange.x && sample <= ipRange.y)\\n    // {\\n      sumVal = sumVal + sample;\\n    // }\\n\\n    // increment position\\n    curDist = curDist + 1.0;\\n    tpos = tpos + tstep;\\n\\n    // check if we have reached a terminating condition\\n    if (curDist > rayBounds.y) { break; }\\n  }\\n\\n  // process to get the color and opacity\\n  traverseVals[vNum] = getSimpleColor(sumVal, vNum, cNum);\\n}\\n\\nfn composite(rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>) -> vec4<f32>\\n{\\n  // initial ray position is at the beginning\\n  var rayPosSC: vec4<f32> = minPosSC;\\n\\n  // how many rows (tfuns) do we have in our tfunTexture\\n  var tfunRows: f32 = f32(textureDimensions(tfunTexture).y);\\n\\n  var curDist: f32 = 0.0;\\n  var computedColor: vec4<f32> = vec4<f32>(0.0, 0.0, 0.0, 0.0);\\n  var sampleColor: vec4<f32>;\\n//VTK::Volume::TraverseCalls\\n\\n  loop\\n  {\\n    // for each volume, sample and accumulate color\\n//VTK::Volume::CompositeCalls\\n\\n    // increment position\\n    curDist = curDist + mapperUBO.SampleDistance;\\n    rayPosSC = rayPosSC + rayStepSC;\\n\\n    // check if we have reached a terminating condition\\n    if (curDist > rayLengthSC) { break; }\\n    if (computedColor.a > 0.98) { break; }\\n  }\\n  return computedColor;\\n}\\n\\n@fragment\\nfn main(\\n//VTK::IOStructs::Input\\n)\\n//VTK::IOStructs::Output\\n{\\n  var output: fragmentOutput;\\n\\n  var rayMax: f32 = textureSampleLevel(maxTexture, clampSampler, input.tcoordVS, 0.0).r;\\n  var rayMin: f32 = textureSampleLevel(minTexture, clampSampler, input.tcoordVS, 0.0).r;\\n\\n  // discard empty rays\\n  if (rayMax <= rayMin) { discard; }\\n  else\\n  {\\n    // compute start and end ray positions in view coordinates\\n    var minPosSC: vec4<f32> = rendererUBO.PCSCMatrix*vec4<f32>(2.0 * input.tcoordVS.x - 1.0, 1.0 - 2.0 * input.tcoordVS.y, rayMax, 1.0);\\n    minPosSC = minPosSC * (1.0 / minPosSC.w);\\n    var maxPosSC: vec4<f32> = rendererUBO.PCSCMatrix*vec4<f32>(2.0 * input.tcoordVS.x - 1.0, 1.0 - 2.0 * input.tcoordVS.y, rayMin, 1.0);\\n    maxPosSC = maxPosSC * (1.0 / maxPosSC.w);\\n\\n    var rayLengthSC: f32 = distance(minPosSC.xyz, maxPosSC.xyz);\\n    var rayStepSC: vec4<f32> = (maxPosSC - minPosSC)*(mapperUBO.SampleDistance/rayLengthSC);\\n    rayStepSC.w = 0.0;\\n\\n    var computedColor: vec4<f32>;\\n\\n//VTK::Volume::Loop\\n\\n//VTK::RenderEncoder::Impl\\n  }\\n\\n  return output;\\n}\\n\";\nvar tmpMat4 = new Float64Array(16);\nvar tmp2Mat4 = new Float64Array(16); // ----------------------------------------------------------------------------\n// vtkWebGPUVolumePassFSQ methods\n// ----------------------------------------------------------------------------\n\nfunction vtkWebGPUVolumePassFSQ(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkWebGPUVolumePassFSQ');\n  publicAPI.replaceShaderPosition = function (hash, pipeline, vertexInput) {\n    var vDesc = pipeline.getShaderDescription('vertex');\n    vDesc.addBuiltinOutput('vec4<f32>', '@builtin(position) Position');\n    var code = vDesc.getCode();\n    code = vtkWebGPUShaderCache.substitute(code, '//VTK::Position::Impl', ['output.tcoordVS = vec2<f32>(vertexBC.x * 0.5 + 0.5, 1.0 - vertexBC.y * 0.5 - 0.5);', 'output.Position = vec4<f32>(vertexBC, 1.0);']).result;\n    vDesc.setCode(code);\n    var fDesc = pipeline.getShaderDescription('fragment');\n    fDesc.addBuiltinInput('vec4<f32>', '@builtin(position) fragPos');\n  };\n  model.shaderReplacements.set('replaceShaderPosition', publicAPI.replaceShaderPosition);\n  publicAPI.replaceShaderVolume = function (hash, pipeline, vertexInput) {\n    var fDesc = pipeline.getShaderDescription('fragment');\n    var code = fDesc.getCode();\n    var compositeCalls = [];\n    var traverseCalls = [];\n    for (var i = 0; i < model.volumes.length; i++) {\n      // todo pass rowPos\n      var blendMode = model.volumes[i].getRenderable().getMapper().getBlendMode();\n      if (blendMode === BlendMode.COMPOSITE_BLEND) {\n        compositeCalls.push(\"    sampleColor = processVolume(volTexture\".concat(i, \", \").concat(i, \", \").concat(model.rowStarts[i], \", rayPosSC, tfunRows);\"));\n        compositeCalls.push(\"    computedColor = vec4<f32>(\\n          sampleColor.a * sampleColor.rgb * (1.0 - computedColor.a) + computedColor.rgb,\\n          (1.0 - computedColor.a)*sampleColor.a + computedColor.a);\");\n      } else {\n        traverseCalls.push(\"  sampleColor = traverseVals[\".concat(i, \"];\"));\n        traverseCalls.push(\"  computedColor = vec4<f32>(\\n          sampleColor.a * sampleColor.rgb * (1.0 - computedColor.a) + computedColor.rgb,\\n          (1.0 - computedColor.a)*sampleColor.a + computedColor.a);\");\n      }\n    }\n    code = vtkWebGPUShaderCache.substitute(code, '//VTK::Volume::CompositeCalls', compositeCalls).result;\n    code = vtkWebGPUShaderCache.substitute(code, '//VTK::Volume::TraverseCalls', traverseCalls).result;\n    code = vtkWebGPUShaderCache.substitute(code, '//VTK::Volume::TraverseDec', [\"var<private> traverseVals: array<vec4<f32>,\".concat(model.volumes.length, \">;\")]).result; // call the full and partial methods as needed\n\n    var compositeWhileTraversing = false;\n    for (var vidx = 0; vidx < model.volumes.length; vidx++) {\n      var _blendMode = model.volumes[vidx].getRenderable().getMapper().getBlendMode();\n      if (_blendMode === BlendMode.COMPOSITE_BLEND) {\n        compositeWhileTraversing = true;\n      } else if (_blendMode === BlendMode.MAXIMUM_INTENSITY_BLEND) {\n        code = vtkWebGPUShaderCache.substitute(code, '//VTK::Volume::Loop', [\"    traverseMax(volTexture\".concat(vidx, \", \").concat(vidx, \", \").concat(vidx, \", rayLengthSC, minPosSC, rayStepSC);\"), \"    computedColor = traverseVals[\".concat(vidx, \"];\"), '//VTK::Volume::Loop']).result;\n      } else if (_blendMode === BlendMode.MINIMUM_INTENSITY_BLEND) {\n        code = vtkWebGPUShaderCache.substitute(code, '//VTK::Volume::Loop', [\"    traverseMin(volTexture\".concat(vidx, \", \").concat(vidx, \", \").concat(vidx, \", rayLengthSC, minPosSC, rayStepSC);\"), \"    computedColor = traverseVals[\".concat(vidx, \"];\"), '//VTK::Volume::Loop']).result;\n      } else if (_blendMode === BlendMode.AVERAGE_INTENSITY_BLEND) {\n        code = vtkWebGPUShaderCache.substitute(code, '//VTK::Volume::Loop', [\"    traverseAverage(volTexture\".concat(vidx, \", \").concat(vidx, \", \").concat(vidx, \", rayLengthSC, minPosSC, rayStepSC);\"), \"    computedColor = traverseVals[\".concat(vidx, \"];\"), '//VTK::Volume::Loop']).result;\n      } else if (_blendMode === BlendMode.ADDITIVE_INTENSITY_BLEND) {\n        code = vtkWebGPUShaderCache.substitute(code, '//VTK::Volume::Loop', [\"    traverseAdditive(volTexture\".concat(vidx, \", \").concat(vidx, \", \").concat(vidx, \", rayLengthSC, minPosSC, rayStepSC);\"), \"    computedColor = traverseVals[\".concat(vidx, \"];\"), '//VTK::Volume::Loop']).result;\n      }\n    }\n    if (compositeWhileTraversing) {\n      code = vtkWebGPUShaderCache.substitute(code, '//VTK::Volume::Loop', ['    computedColor = composite(rayLengthSC, minPosSC, rayStepSC);']).result;\n    }\n    fDesc.setCode(code);\n  };\n  model.shaderReplacements.set('replaceShaderVolume', publicAPI.replaceShaderVolume);\n  publicAPI.updateLUTImage = function (device) {\n    // depends on\n    // - volumes array (length and values) - mtime\n    // - tfun arrays - renderable/property mtime\n    var mtime = publicAPI.getMTime();\n    for (var i = 0; i < model.volumes.length; i++) {\n      var vol = model.volumes[i].getRenderable();\n      var image = vol.getMapper().getInputData();\n      mtime = Math.max(mtime, vol.getMTime(), image.getMTime());\n    }\n    if (mtime < model.lutBuildTime.getMTime()) {\n      return;\n    } // first determine how large the image should be\n\n    model.numRows = 0;\n    model.rowStarts = [];\n    for (var vidx = 0; vidx < model.volumes.length; vidx++) {\n      model.rowStarts.push(model.numRows);\n      var webgpuvol = model.volumes[vidx];\n      var actor = webgpuvol.getRenderable();\n      var volMapr = actor.getMapper();\n      var vprop = actor.getProperty();\n      var _image = volMapr.getInputData();\n      var scalars = _image.getPointData() && _image.getPointData().getScalars();\n      var numComp = scalars.getNumberOfComponents();\n      var iComps = vprop.getIndependentComponents();\n      var numIComps = iComps ? numComp : 1;\n      model.numRows += numIComps;\n    } // allocate the image array\n\n    var colorArray = new Uint8Array(model.numRows * 2 * model.rowLength * 4);\n    var opacityArray = new Float32Array(model.numRows * 2 * model.rowLength);\n    var imgRow = 0;\n    var tmpTable = new Float32Array(model.rowLength * 3);\n    var rowLength = model.rowLength;\n    for (var _vidx = 0; _vidx < model.volumes.length; _vidx++) {\n      var _webgpuvol = model.volumes[_vidx];\n      var _actor = _webgpuvol.getRenderable();\n      var _volMapr = _actor.getMapper();\n      var _vprop = _actor.getProperty();\n      var _image2 = _volMapr.getInputData();\n      var _scalars = _image2.getPointData() && _image2.getPointData().getScalars();\n      var _numComp = _scalars.getNumberOfComponents();\n      var _iComps = _vprop.getIndependentComponents();\n      var _numIComps = _iComps ? _numComp : 1;\n      for (var c = 0; c < _numIComps; ++c) {\n        var cfun = _vprop.getRGBTransferFunction(c);\n        var cRange = cfun.getRange();\n        cfun.getTable(cRange[0], cRange[1], rowLength, tmpTable, 1);\n        var ioffset = imgRow * rowLength * 4;\n        for (var _i = 0; _i < rowLength; ++_i) {\n          colorArray[ioffset + _i * 4] = 255.0 * tmpTable[_i * 3];\n          colorArray[ioffset + _i * 4 + 1] = 255.0 * tmpTable[_i * 3 + 1];\n          colorArray[ioffset + _i * 4 + 2] = 255.0 * tmpTable[_i * 3 + 2];\n          colorArray[ioffset + _i * 4 + 3] = 255.0;\n          for (var co = 0; co < 4; co++) {\n            colorArray[ioffset + (rowLength + _i) * 4 + co] = colorArray[ioffset + _i * 4 + co];\n          }\n        }\n        var ofun = _vprop.getScalarOpacity(c);\n        var opacityFactor = model.sampleDist / _vprop.getScalarOpacityUnitDistance(c);\n        var oRange = ofun.getRange();\n        ofun.getTable(oRange[0], oRange[1], rowLength, tmpTable, 1); // adjust for sample distance etc\n\n        ioffset = imgRow * rowLength;\n        for (var _i2 = 0; _i2 < rowLength; ++_i2) {\n          opacityArray[ioffset + _i2] = 1.0 - Math.pow(1.0 - tmpTable[_i2], opacityFactor);\n          opacityArray[ioffset + _i2 + rowLength] = opacityArray[ioffset + _i2];\n        }\n        imgRow += 2;\n      }\n    }\n    {\n      var treq = {\n        nativeArray: colorArray,\n        width: model.rowLength,\n        height: model.numRows * 2,\n        depth: 1,\n        format: 'rgba8unorm'\n      };\n      var newTex = device.getTextureManager().getTexture(treq);\n      var tview = newTex.createView('tfunTexture');\n      model.textureViews[2] = tview;\n    }\n    {\n      var _treq = {\n        nativeArray: opacityArray,\n        width: model.rowLength,\n        height: model.numRows * 2,\n        depth: 1,\n        format: 'r16float'\n      };\n      var _newTex = device.getTextureManager().getTexture(_treq);\n      var _tview = _newTex.createView('ofunTexture');\n      model.textureViews[3] = _tview;\n    }\n    model.lutBuildTime.modified();\n  };\n  publicAPI.updateSSBO = function (device) {\n    // if any of\n    // - color or opacity tfun ranges changed - volume Mtime\n    // - any volume matrix changed - volume MTime\n    // - stabilized center changed - ren.stabilizedMTime\n    // - any volume's input data worldtoindex or dimensions changed - input's mtime\n    //\n    var mtime = Math.max(publicAPI.getMTime(), model.WebGPURenderer.getStabilizedTime());\n    for (var i = 0; i < model.volumes.length; i++) {\n      var vol = model.volumes[i].getRenderable();\n      var volMapr = vol.getMapper();\n      var image = volMapr.getInputData();\n      mtime = Math.max(mtime, vol.getMTime(), image.getMTime(), volMapr.getMTime());\n    }\n    if (mtime < model.SSBO.getSendTime()) {\n      return;\n    } // create the volumeSBBO\n\n    var center = model.WebGPURenderer.getStabilizedCenterByReference();\n    model.SSBO.clearData();\n    model.SSBO.setNumberOfInstances(model.volumes.length); // create SCTC matrices  SC -> world -> model -> index -> tcoord\n    //\n    // when doing coord conversions from A to C recall\n    // the order is mat4.mult(AtoC, BtoC, AtoB);\n    //\n\n    var marray = new Float64Array(model.volumes.length * 16);\n    var vPlaneArray = new Float64Array(model.volumes.length * 16);\n    var tstepArray = new Float64Array(model.volumes.length * 4);\n    var shadeArray = new Float64Array(model.volumes.length * 4);\n    var spacingArray = new Float64Array(model.volumes.length * 4);\n    var ipScalarRangeArray = new Float64Array(model.volumes.length * 4);\n    for (var vidx = 0; vidx < model.volumes.length; vidx++) {\n      var webgpuvol = model.volumes[vidx];\n      var actor = webgpuvol.getRenderable();\n      var _volMapr2 = actor.getMapper();\n      var _image3 = _volMapr2.getInputData();\n      mat4.identity(tmpMat4);\n      mat4.translate(tmpMat4, tmpMat4, center); // tmpMat4 is now SC->World\n\n      var mcwcmat = actor.getMatrix();\n      mat4.transpose(tmp2Mat4, mcwcmat);\n      mat4.invert(tmp2Mat4, tmp2Mat4); // tmp2Mat4 is now world to model\n\n      mat4.multiply(tmpMat4, tmp2Mat4, tmpMat4); // tmp4Mat is now SC->Model\n      // the method on the data is world to index but the volume is in\n      // model coordinates so really in this context it is model to index\n\n      var modelToIndex = _image3.getWorldToIndex();\n      mat4.multiply(tmpMat4, modelToIndex, tmpMat4); // tmpMat4 is now SC -> Index\n\n      var dims = _image3.getDimensions();\n      mat4.identity(tmp2Mat4);\n      mat4.scale(tmp2Mat4, tmp2Mat4, [1.0 / dims[0], 1.0 / dims[1], 1.0 / dims[2]]);\n      mat4.multiply(tmpMat4, tmp2Mat4, tmpMat4); // tmpMat4 is now SC -> Tcoord\n\n      for (var j = 0; j < 16; j++) {\n        marray[vidx * 16 + j] = tmpMat4[j];\n      }\n      mat4.invert(tmpMat4, tmpMat4); // now it is Tcoord To SC\n\n      for (var _j = 0; _j < 4; _j++) {\n        vPlaneArray[vidx * 16 + _j * 4] = tmpMat4[_j * 4];\n        vPlaneArray[vidx * 16 + _j * 4 + 1] = tmpMat4[_j * 4 + 1];\n        vPlaneArray[vidx * 16 + _j * 4 + 2] = tmpMat4[_j * 4 + 2];\n        vPlaneArray[vidx * 16 + _j * 4 + 3] = 0.0;\n      }\n      tstepArray[vidx * 4] = 1.0 / dims[0];\n      tstepArray[vidx * 4 + 1] = 1.0 / dims[1];\n      tstepArray[vidx * 4 + 2] = 1.0 / dims[2];\n      tstepArray[vidx * 4 + 3] = 1.0;\n      shadeArray[vidx * 4] = actor.getProperty().getShade() ? 1.0 : 0.0;\n      var spacing = _image3.getSpacing();\n      spacingArray[vidx * 4] = spacing[0];\n      spacingArray[vidx * 4 + 1] = spacing[1];\n      spacingArray[vidx * 4 + 2] = spacing[2];\n      spacingArray[vidx * 4 + 3] = 1.0; // handle filteringMode\n\n      var tScale = model.textureViews[vidx + 4].getTexture().getScale();\n      var ipScalarRange = _volMapr2.getIpScalarRange();\n      ipScalarRangeArray[vidx * 4] = ipScalarRange[0] / tScale;\n      ipScalarRangeArray[vidx * 4 + 1] = ipScalarRange[1] / tScale;\n      ipScalarRangeArray[vidx * 4 + 2] = _volMapr2.getFilterMode();\n    }\n    model.SSBO.addEntry('SCTCMatrix', 'mat4x4<f32>');\n    model.SSBO.addEntry('planeNormals', 'mat4x4<f32>');\n    model.SSBO.addEntry('shade', 'vec4<f32>');\n    model.SSBO.addEntry('tstep', 'vec4<f32>');\n    model.SSBO.addEntry('spacing', 'vec4<f32>');\n    model.SSBO.addEntry('ipScalarRange', 'vec4<f32>');\n    model.SSBO.setAllInstancesFromArray('SCTCMatrix', marray);\n    model.SSBO.setAllInstancesFromArray('planeNormals', vPlaneArray);\n    model.SSBO.setAllInstancesFromArray('shade', shadeArray);\n    model.SSBO.setAllInstancesFromArray('tstep', tstepArray);\n    model.SSBO.setAllInstancesFromArray('spacing', spacingArray);\n    model.SSBO.setAllInstancesFromArray('ipScalarRange', ipScalarRangeArray);\n    model.SSBO.send(device); // now create the componentSSBO\n\n    model.componentSSBO.clearData();\n    model.componentSSBO.setNumberOfInstances(model.numRows);\n    var cScaleArray = new Float64Array(model.numRows);\n    var cShiftArray = new Float64Array(model.numRows);\n    var oScaleArray = new Float64Array(model.numRows);\n    var oShiftArray = new Float64Array(model.numRows);\n    var gominArray = new Float64Array(model.numRows);\n    var gomaxArray = new Float64Array(model.numRows);\n    var goshiftArray = new Float64Array(model.numRows);\n    var goscaleArray = new Float64Array(model.numRows);\n    var rowIdx = 0;\n    for (var _vidx2 = 0; _vidx2 < model.volumes.length; _vidx2++) {\n      var _webgpuvol2 = model.volumes[_vidx2];\n      var _actor2 = _webgpuvol2.getRenderable();\n      var _volMapr3 = _actor2.getMapper();\n      var vprop = _actor2.getProperty();\n      var _image4 = _volMapr3.getInputData();\n      var scalars = _image4.getPointData() && _image4.getPointData().getScalars();\n      var numComp = scalars.getNumberOfComponents();\n      var iComps = vprop.getIndependentComponents(); // const numIComps = iComps ? numComp : 1;\n      // half float?\n\n      var tformat = model.textureViews[_vidx2 + 4].getTexture().getFormat();\n      var tDetails = vtkWebGPUTypes.getDetailsFromTextureFormat(tformat);\n      var halfFloat = tDetails.elementSize === 2 && tDetails.sampleType === 'float';\n      var volInfo = {\n        scale: [255.0],\n        offset: [0.0]\n      };\n      if (halfFloat) {\n        volInfo.scale[0] = 1.0;\n      } // three levels of shift scale combined into one\n      // for performance in the fragment shader\n\n      for (var compIdx = 0; compIdx < numComp; compIdx++) {\n        var target = iComps ? compIdx : 0;\n        var sscale = volInfo.scale[compIdx];\n        var ofun = vprop.getScalarOpacity(target);\n        var oRange = ofun.getRange();\n        var oscale = sscale / (oRange[1] - oRange[0]);\n        var oshift = (volInfo.offset[compIdx] - oRange[0]) / (oRange[1] - oRange[0]);\n        oShiftArray[rowIdx] = oshift;\n        oScaleArray[rowIdx] = oscale;\n        var cfun = vprop.getRGBTransferFunction(target);\n        var cRange = cfun.getRange();\n        cShiftArray[rowIdx] = (volInfo.offset[compIdx] - cRange[0]) / (cRange[1] - cRange[0]);\n        cScaleArray[rowIdx] = sscale / (cRange[1] - cRange[0]); // todo sscale for dependent should be based off of the A channel?\n        // not target (which is 0 in that case)\n\n        var useGO = vprop.getUseGradientOpacity(target);\n        if (useGO) {\n          var gomin = vprop.getGradientOpacityMinimumOpacity(target);\n          var gomax = vprop.getGradientOpacityMaximumOpacity(target);\n          gominArray[rowIdx] = gomin;\n          gomaxArray[rowIdx] = gomax;\n          var goRange = [vprop.getGradientOpacityMinimumValue(target), vprop.getGradientOpacityMaximumValue(target)];\n          goscaleArray[rowIdx] = sscale * (gomax - gomin) / (goRange[1] - goRange[0]);\n          goshiftArray[rowIdx] = -goRange[0] * (gomax - gomin) / (goRange[1] - goRange[0]) + gomin;\n        } else {\n          gominArray[rowIdx] = 1.0;\n          gomaxArray[rowIdx] = 1.0;\n          goscaleArray[rowIdx] = 0.0;\n          goshiftArray[rowIdx] = 1.0;\n        }\n        rowIdx++;\n      }\n    }\n    model.componentSSBO.addEntry('cScale', 'f32');\n    model.componentSSBO.addEntry('cShift', 'f32');\n    model.componentSSBO.addEntry('oScale', 'f32');\n    model.componentSSBO.addEntry('oShift', 'f32');\n    model.componentSSBO.addEntry('goShift', 'f32');\n    model.componentSSBO.addEntry('goScale', 'f32');\n    model.componentSSBO.addEntry('gomin', 'f32');\n    model.componentSSBO.addEntry('gomax', 'f32');\n    model.componentSSBO.setAllInstancesFromArray('cScale', cScaleArray);\n    model.componentSSBO.setAllInstancesFromArray('cShift', cShiftArray);\n    model.componentSSBO.setAllInstancesFromArray('oScale', oScaleArray);\n    model.componentSSBO.setAllInstancesFromArray('oShift', oShiftArray);\n    model.componentSSBO.setAllInstancesFromArray('goScale', goscaleArray);\n    model.componentSSBO.setAllInstancesFromArray('goShift', goshiftArray);\n    model.componentSSBO.setAllInstancesFromArray('gomin', gominArray);\n    model.componentSSBO.setAllInstancesFromArray('gomax', gomaxArray);\n    model.componentSSBO.send(device);\n  };\n  var superClassUpdateBuffers = publicAPI.updateBuffers;\n  publicAPI.updateBuffers = function () {\n    superClassUpdateBuffers(); // compute the min step size\n\n    var sampleDist = model.volumes[0].getRenderable().getMapper().getSampleDistance();\n    for (var i = 0; i < model.volumes.length; i++) {\n      var vol = model.volumes[i];\n      var volMapr = vol.getRenderable().getMapper();\n      var sd = volMapr.getSampleDistance();\n      if (sd < sampleDist) {\n        sampleDist = sd;\n      }\n    }\n    if (model.sampleDist !== sampleDist) {\n      model.sampleDist = sampleDist;\n      model.UBO.setValue('SampleDistance', sampleDist);\n      model.UBO.sendIfNeeded(model.device);\n    } // add in 3d volume textures\n\n    for (var vidx = 0; vidx < model.volumes.length; vidx++) {\n      var webgpuvol = model.volumes[vidx];\n      var actor = webgpuvol.getRenderable();\n      var _volMapr4 = actor.getMapper();\n      var image = _volMapr4.getInputData();\n      var newTex = model.device.getTextureManager().getTextureForImageData(image);\n      if (!model.textureViews[vidx + 4] || model.textureViews[vidx + 4].getTexture() !== newTex) {\n        var tview = newTex.createView(\"volTexture\".concat(vidx));\n        model.textureViews[vidx + 4] = tview;\n      }\n    } // clear any old leftovers\n\n    if (model.volumes.length < model.lastVolumeLength) {\n      // we may have gaps in the array right now so no splice\n      for (var _i3 = model.volumes.length; _i3 < model.lastVolumeLength; _i3++) {\n        model.textureViews.pop();\n      }\n    }\n    model.lastVolumeLength = model.volumes.length;\n    publicAPI.updateLUTImage(model.device);\n    publicAPI.updateSSBO(model.device);\n    if (!model.clampSampler) {\n      model.clampSampler = vtkWebGPUSampler.newInstance({\n        label: 'clampSampler'\n      });\n      model.clampSampler.create(model.device, {\n        minFilter: 'linear',\n        magFilter: 'linear'\n      });\n    }\n  };\n  publicAPI.computePipelineHash = function () {\n    model.pipelineHash = 'volfsq';\n    for (var vidx = 0; vidx < model.volumes.length; vidx++) {\n      var blendMode = model.volumes[vidx].getRenderable().getMapper().getBlendMode();\n      model.pipelineHash += \"\".concat(blendMode);\n    }\n  }; // marks modified when needed\n\n  publicAPI.setVolumes = function (val) {\n    if (!model.volumes || model.volumes.length !== val.length) {\n      model.volumes = _toConsumableArray(val);\n      publicAPI.modified();\n      return;\n    }\n    for (var i = 0; i < val.length; i++) {\n      if (val[i] !== model.volumes[i]) {\n        model.volumes = _toConsumableArray(val);\n        publicAPI.modified();\n        return;\n      }\n    }\n  };\n  var superclassGetBindables = publicAPI.getBindables;\n  publicAPI.getBindables = function () {\n    var bindables = superclassGetBindables();\n    bindables.push(model.componentSSBO);\n    bindables.push(model.clampSampler);\n    return bindables;\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nvar DEFAULT_VALUES = {\n  volumes: null,\n  rowLength: 1024,\n  lastVolumeLength: 0\n}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Inheritance\n\n  vtkWebGPUFullScreenQuad.extend(publicAPI, model, initialValues);\n  model.fragmentShaderTemplate = volFragTemplate;\n  model.UBO = vtkWebGPUUniformBuffer.newInstance({\n    label: 'mapperUBO'\n  });\n  model.UBO.addEntry('SampleDistance', 'f32');\n  model.SSBO = vtkWebGPUStorageBuffer.newInstance({\n    label: 'volumeSSBO'\n  });\n  model.componentSSBO = vtkWebGPUStorageBuffer.newInstance({\n    label: 'componentSSBO'\n  });\n  model.lutBuildTime = {};\n  macro.obj(model.lutBuildTime, {\n    mtime: 0\n  }); // Object methods\n\n  vtkWebGPUVolumePassFSQ(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = macro.newInstance(extend, 'vtkWebGPUVolumePassFSQ'); // ----------------------------------------------------------------------------\n\nvar vtkWebGPUVolumePassFSQ$1 = {\n  newInstance: newInstance,\n  extend: extend\n};\nexport { vtkWebGPUVolumePassFSQ$1 as default, extend, newInstance };","map":{"version":3,"names":["_toConsumableArray","macro","mat4","vtkWebGPUFullScreenQuad","vtkWebGPUUniformBuffer","vtkWebGPUShaderCache","vtkWebGPUStorageBuffer","vtkWebGPUSampler","vtkWebGPUTypes","BlendMode","volFragTemplate","tmpMat4","Float64Array","tmp2Mat4","vtkWebGPUVolumePassFSQ","publicAPI","model","classHierarchy","push","replaceShaderPosition","hash","pipeline","vertexInput","vDesc","getShaderDescription","addBuiltinOutput","code","getCode","substitute","result","setCode","fDesc","addBuiltinInput","shaderReplacements","set","replaceShaderVolume","compositeCalls","traverseCalls","i","volumes","length","blendMode","getRenderable","getMapper","getBlendMode","COMPOSITE_BLEND","concat","rowStarts","compositeWhileTraversing","vidx","_blendMode","MAXIMUM_INTENSITY_BLEND","MINIMUM_INTENSITY_BLEND","AVERAGE_INTENSITY_BLEND","ADDITIVE_INTENSITY_BLEND","updateLUTImage","device","mtime","getMTime","vol","image","getInputData","Math","max","lutBuildTime","numRows","webgpuvol","actor","volMapr","vprop","getProperty","_image","scalars","getPointData","getScalars","numComp","getNumberOfComponents","iComps","getIndependentComponents","numIComps","colorArray","Uint8Array","rowLength","opacityArray","Float32Array","imgRow","tmpTable","_vidx","_webgpuvol","_actor","_volMapr","_vprop","_image2","_scalars","_numComp","_iComps","_numIComps","c","cfun","getRGBTransferFunction","cRange","getRange","getTable","ioffset","_i","co","ofun","getScalarOpacity","opacityFactor","sampleDist","getScalarOpacityUnitDistance","oRange","_i2","pow","treq","nativeArray","width","height","depth","format","newTex","getTextureManager","getTexture","tview","createView","textureViews","_treq","_newTex","_tview","modified","updateSSBO","WebGPURenderer","getStabilizedTime","SSBO","getSendTime","center","getStabilizedCenterByReference","clearData","setNumberOfInstances","marray","vPlaneArray","tstepArray","shadeArray","spacingArray","ipScalarRangeArray","_volMapr2","_image3","identity","translate","mcwcmat","getMatrix","transpose","invert","multiply","modelToIndex","getWorldToIndex","dims","getDimensions","scale","j","_j","getShade","spacing","getSpacing","tScale","getScale","ipScalarRange","getIpScalarRange","getFilterMode","addEntry","setAllInstancesFromArray","send","componentSSBO","cScaleArray","cShiftArray","oScaleArray","oShiftArray","gominArray","gomaxArray","goshiftArray","goscaleArray","rowIdx","_vidx2","_webgpuvol2","_actor2","_volMapr3","_image4","tformat","getFormat","tDetails","getDetailsFromTextureFormat","halfFloat","elementSize","sampleType","volInfo","offset","compIdx","target","sscale","oscale","oshift","useGO","getUseGradientOpacity","gomin","getGradientOpacityMinimumOpacity","gomax","getGradientOpacityMaximumOpacity","goRange","getGradientOpacityMinimumValue","getGradientOpacityMaximumValue","superClassUpdateBuffers","updateBuffers","getSampleDistance","sd","UBO","setValue","sendIfNeeded","_volMapr4","getTextureForImageData","lastVolumeLength","_i3","pop","clampSampler","newInstance","label","create","minFilter","magFilter","computePipelineHash","pipelineHash","setVolumes","val","superclassGetBindables","getBindables","bindables","DEFAULT_VALUES","extend","initialValues","arguments","undefined","Object","assign","fragmentShaderTemplate","obj","vtkWebGPUVolumePassFSQ$1","default"],"sources":["/home/rakshith/Documents/RemoteRendering/vtk-js-react-app/node_modules/@kitware/vtk.js/Rendering/WebGPU/VolumePassFSQ.js"],"sourcesContent":["import _toConsumableArray from '@babel/runtime/helpers/toConsumableArray';\nimport macro from '../../macros.js';\nimport { mat4 } from 'gl-matrix';\nimport vtkWebGPUFullScreenQuad from './FullScreenQuad.js';\nimport vtkWebGPUUniformBuffer from './UniformBuffer.js';\nimport vtkWebGPUShaderCache from './ShaderCache.js';\nimport vtkWebGPUStorageBuffer from './StorageBuffer.js';\nimport vtkWebGPUSampler from './Sampler.js';\nimport vtkWebGPUTypes from './Types.js';\nimport { BlendMode } from '../Core/VolumeMapper/Constants.js';\n\nvar volFragTemplate = \"\\n//VTK::Renderer::Dec\\n\\n//VTK::Mapper::Dec\\n\\n//VTK::TCoord::Dec\\n\\n//VTK::Volume::TraverseDec\\n\\n//VTK::RenderEncoder::Dec\\n\\n//VTK::IOStructs::Dec\\n\\nfn getTextureValue(vTex: texture_3d<f32>, tpos: vec4<f32>) -> f32\\n{\\n  // todo multicomponent support\\n  return textureSampleLevel(vTex, clampSampler, tpos.xyz, 0.0).r;\\n}\\n\\nfn getGradient(vTex: texture_3d<f32>, tpos: vec4<f32>, vNum: i32, scalar: f32) -> vec4<f32>\\n{\\n  var result: vec4<f32>;\\n\\n  var tstep: vec4<f32> = volumeSSBO.values[vNum].tstep;\\n  result.x = getTextureValue(vTex, tpos + vec4<f32>(tstep.x, 0.0, 0.0, 1.0)) - scalar;\\n  result.y = getTextureValue(vTex, tpos + vec4<f32>(0.0, tstep.y, 0.0, 1.0)) - scalar;\\n  result.z = getTextureValue(vTex, tpos + vec4<f32>(0.0, 0.0, tstep.z, 1.0)) - scalar;\\n  result.w = 0.0;\\n\\n  // divide by spacing as that is our delta\\n  result = result / volumeSSBO.values[vNum].spacing;\\n  // now we have a gradient in unit tcoords\\n\\n  var grad: f32 = length(result.xyz);\\n  if (grad > 0.0)\\n  {\\n    // rotate to View Coords, needed for lighting and shading\\n    var nMat: mat4x4<f32> = rendererUBO.SCVCMatrix * volumeSSBO.values[vNum].planeNormals;\\n    result = nMat * result;\\n    result = result / length(result);\\n  }\\n\\n  // store gradient magnitude in .w\\n  result.w = grad;\\n\\n  return result;\\n}\\n\\nfn processVolume(vTex: texture_3d<f32>, vNum: i32, cNum: i32, posSC: vec4<f32>, tfunRows: f32) -> vec4<f32>\\n{\\n  var outColor: vec4<f32> = vec4<f32>(0.0, 0.0, 0.0, 0.0);\\n\\n  // convert to tcoords and reject if outside the volume\\n  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*posSC;\\n  if (tpos.x < 0.0 || tpos.y < 0.0 || tpos.z < 0.0 ||\\n      tpos.x > 1.0 || tpos.y > 1.0 || tpos.z > 1.0) { return outColor; }\\n\\n  var scalar: f32 = getTextureValue(vTex, tpos);\\n\\n  var coord: vec2<f32> =\\n    vec2<f32>(scalar * componentSSBO.values[cNum].cScale + componentSSBO.values[cNum].cShift,\\n      (0.5 + 2.0 * f32(vNum)) / tfunRows);\\n  var color: vec4<f32> = textureSampleLevel(tfunTexture, clampSampler, coord, 0.0);\\n\\n  var gofactor: f32 = 1.0;\\n  var normal: vec4<f32> = vec4<f32>(0.0,0.0,0.0,0.0);\\n  if (componentSSBO.values[cNum].gomin <  1.0 || volumeSSBO.values[vNum].shade[0] > 0.0)\\n  {\\n    normal = getGradient(vTex, tpos, vNum, scalar);\\n    if (componentSSBO.values[cNum].gomin <  1.0)\\n    {\\n      gofactor = clamp(normal.a*componentSSBO.values[cNum].goScale + componentSSBO.values[cNum].goShift,\\n      componentSSBO.values[cNum].gomin, componentSSBO.values[cNum].gomax);\\n    }\\n  }\\n\\n  coord.x = (scalar * componentSSBO.values[cNum].oScale + componentSSBO.values[cNum].oShift);\\n  var opacity: f32 = textureSampleLevel(ofunTexture, clampSampler, coord, 0.0).r;\\n\\n  if (volumeSSBO.values[vNum].shade[0] > 0.0)\\n  {\\n    color = color*abs(normal.z);\\n  }\\n\\n  outColor = vec4<f32>(color.rgb, gofactor * opacity);\\n\\n  return outColor;\\n}\\n\\n// adjust the start and end point of a raycast such that it intersects the unit cube.\\n// This function is used to take a raycast starting point and step vector\\n// and numSteps and return the startijng and ending steps for intersecting the\\n// unit cube. Recall for a 3D texture, the unit cube is the range of texture coordsinates\\n// that have valid values. So this funtion can be used to take a ray in texture coordinates\\n// and bound it to intersecting the texture.\\n//\\nfn adjustBounds(tpos: vec4<f32>, tstep: vec4<f32>, numSteps: f32) -> vec2<f32>\\n{\\n  var result: vec2<f32> = vec2<f32>(0.0, numSteps);\\n  var tpos2: vec4<f32> = tpos + tstep*numSteps;\\n\\n  // move tpos to the start of the volume\\n  var adjust: f32 =\\n    min(\\n      max(tpos.x/tstep.x, (tpos.x - 1.0)/tstep.x),\\n      min(\\n        max((tpos.y - 1.0)/tstep.y, tpos.y/tstep.y),\\n        max((tpos.z - 1.0)/tstep.z, tpos.z/tstep.z)));\\n  if (adjust < 0.0)\\n  {\\n    result.x = result.x - adjust;\\n  }\\n\\n  // adjust length to the end\\n  adjust =\\n    max(\\n      min(tpos2.x/tstep.x, (tpos2.x - 1.0)/tstep.x),\\n      max(\\n        min((tpos2.y - 1.0)/tstep.y, tpos2.y/tstep.y),\\n        min((tpos2.z - 1.0)/tstep.z, tpos2.z/tstep.z)));\\n  if (adjust > 0.0)\\n  {\\n    result.y = result.y - adjust;\\n  }\\n\\n  return result;\\n}\\n\\nfn getSimpleColor(scalar: f32, vNum: i32, cNum: i32) -> vec4<f32>\\n{\\n  // how many rows (tfuns) do we have in our tfunTexture\\n  var tfunRows: f32 = f32(textureDimensions(tfunTexture).y);\\n\\n  var coord: vec2<f32> =\\n    vec2<f32>(scalar * componentSSBO.values[cNum].cScale + componentSSBO.values[cNum].cShift,\\n      (0.5 + 2.0 * f32(vNum)) / tfunRows);\\n  var color: vec4<f32> = textureSampleLevel(tfunTexture, clampSampler, coord, 0.0);\\n  coord.x = (scalar * componentSSBO.values[cNum].oScale + componentSSBO.values[cNum].oShift);\\n  var opacity: f32 = textureSampleLevel(ofunTexture, clampSampler, coord, 0.0).r;\\n  return vec4<f32>(color.rgb, opacity);\\n}\\n\\nfn traverseMax(vTex: texture_3d<f32>, vNum: i32, cNum: i32, rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>)\\n{\\n  // convert to tcoords and reject if outside the volume\\n  var numSteps: f32 = rayLengthSC/mapperUBO.SampleDistance;\\n  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*minPosSC;\\n  var tpos2: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*(minPosSC + rayStepSC);\\n  var tstep: vec4<f32> = tpos2 - tpos;\\n\\n  var rayBounds: vec2<f32> = adjustBounds(tpos, tstep, numSteps);\\n\\n  // did we hit anything\\n  if (rayBounds.x >= rayBounds.y)\\n  {\\n    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);\\n    return;\\n  }\\n\\n  tpos = tpos + tstep*rayBounds.x;\\n  var curDist: f32 = rayBounds.x;\\n  var maxVal: f32 = -1.0e37;\\n  loop\\n  {\\n    var scalar: f32 = getTextureValue(vTex, tpos);\\n    if (scalar > maxVal)\\n    {\\n      maxVal = scalar;\\n    }\\n\\n    // increment position\\n    curDist = curDist + 1.0;\\n    tpos = tpos + tstep;\\n\\n    // check if we have reached a terminating condition\\n    if (curDist > rayBounds.y) { break; }\\n  }\\n\\n  // process to get the color and opacity\\n  traverseVals[vNum] = getSimpleColor(maxVal, vNum, cNum);\\n}\\n\\nfn traverseMin(vTex: texture_3d<f32>, vNum: i32, cNum: i32, rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>)\\n{\\n  // convert to tcoords and reject if outside the volume\\n  var numSteps: f32 = rayLengthSC/mapperUBO.SampleDistance;\\n  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*minPosSC;\\n  var tpos2: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*(minPosSC + rayStepSC);\\n  var tstep: vec4<f32> = tpos2 - tpos;\\n\\n  var rayBounds: vec2<f32> = adjustBounds(tpos, tstep, numSteps);\\n\\n  // did we hit anything\\n  if (rayBounds.x >= rayBounds.y)\\n  {\\n    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);\\n    return;\\n  }\\n\\n  tpos = tpos + tstep*rayBounds.x;\\n  var curDist: f32 = rayBounds.x;\\n  var minVal: f32 = 1.0e37;\\n  loop\\n  {\\n    var scalar: f32 = getTextureValue(vTex, tpos);\\n    if (scalar < minVal)\\n    {\\n      minVal = scalar;\\n    }\\n\\n    // increment position\\n    curDist = curDist + 1.0;\\n    tpos = tpos + tstep;\\n\\n    // check if we have reached a terminating condition\\n    if (curDist > rayBounds.y) { break; }\\n  }\\n\\n  // process to get the color and opacity\\n  traverseVals[vNum] = getSimpleColor(minVal, vNum, cNum);\\n}\\n\\nfn traverseAverage(vTex: texture_3d<f32>, vNum: i32, cNum: i32, rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>)\\n{\\n  // convert to tcoords and reject if outside the volume\\n  var numSteps: f32 = rayLengthSC/mapperUBO.SampleDistance;\\n  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*minPosSC;\\n  var tpos2: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*(minPosSC + rayStepSC);\\n  var tstep: vec4<f32> = tpos2 - tpos;\\n\\n  var rayBounds: vec2<f32> = adjustBounds(tpos, tstep, numSteps);\\n\\n  // did we hit anything\\n  if (rayBounds.x >= rayBounds.y)\\n  {\\n    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);\\n    return;\\n  }\\n\\n  let ipRange: vec4<f32> = volumeSSBO.values[vNum].ipScalarRange;\\n  tpos = tpos + tstep*rayBounds.x;\\n  var curDist: f32 = rayBounds.x;\\n  var avgVal: f32 = 0.0;\\n  var sampleCount: f32 = 0.0;\\n  loop\\n  {\\n    var sample: f32 = getTextureValue(vTex, tpos);\\n    // right now leave filtering off until WebGL changes get merged\\n    // if (ipRange.z == 0.0 || sample >= ipRange.x && sample <= ipRange.y)\\n    // {\\n      avgVal = avgVal + sample;\\n      sampleCount = sampleCount + 1.0;\\n    // }\\n\\n    // increment position\\n    curDist = curDist + 1.0;\\n    tpos = tpos + tstep;\\n\\n    // check if we have reached a terminating condition\\n    if (curDist > rayBounds.y) { break; }\\n  }\\n\\n  if (sampleCount <= 0.0)\\n  {\\n    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);\\n  }\\n\\n  // process to get the color and opacity\\n  traverseVals[vNum] = getSimpleColor(avgVal/sampleCount, vNum, cNum);\\n}\\n\\nfn traverseAdditive(vTex: texture_3d<f32>, vNum: i32, cNum: i32, rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>)\\n{\\n  // convert to tcoords and reject if outside the volume\\n  var numSteps: f32 = rayLengthSC/mapperUBO.SampleDistance;\\n  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*minPosSC;\\n  var tpos2: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*(minPosSC + rayStepSC);\\n  var tstep: vec4<f32> = tpos2 - tpos;\\n\\n  var rayBounds: vec2<f32> = adjustBounds(tpos, tstep, numSteps);\\n\\n  // did we hit anything\\n  if (rayBounds.x >= rayBounds.y)\\n  {\\n    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);\\n    return;\\n  }\\n\\n  let ipRange: vec4<f32> = volumeSSBO.values[vNum].ipScalarRange;\\n  tpos = tpos + tstep*rayBounds.x;\\n  var curDist: f32 = rayBounds.x;\\n  var sumVal: f32 = 0.0;\\n  loop\\n  {\\n    var sample: f32 = getTextureValue(vTex, tpos);\\n    // right now leave filtering off until WebGL changes get merged\\n    // if (ipRange.z == 0.0 || sample >= ipRange.x && sample <= ipRange.y)\\n    // {\\n      sumVal = sumVal + sample;\\n    // }\\n\\n    // increment position\\n    curDist = curDist + 1.0;\\n    tpos = tpos + tstep;\\n\\n    // check if we have reached a terminating condition\\n    if (curDist > rayBounds.y) { break; }\\n  }\\n\\n  // process to get the color and opacity\\n  traverseVals[vNum] = getSimpleColor(sumVal, vNum, cNum);\\n}\\n\\nfn composite(rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>) -> vec4<f32>\\n{\\n  // initial ray position is at the beginning\\n  var rayPosSC: vec4<f32> = minPosSC;\\n\\n  // how many rows (tfuns) do we have in our tfunTexture\\n  var tfunRows: f32 = f32(textureDimensions(tfunTexture).y);\\n\\n  var curDist: f32 = 0.0;\\n  var computedColor: vec4<f32> = vec4<f32>(0.0, 0.0, 0.0, 0.0);\\n  var sampleColor: vec4<f32>;\\n//VTK::Volume::TraverseCalls\\n\\n  loop\\n  {\\n    // for each volume, sample and accumulate color\\n//VTK::Volume::CompositeCalls\\n\\n    // increment position\\n    curDist = curDist + mapperUBO.SampleDistance;\\n    rayPosSC = rayPosSC + rayStepSC;\\n\\n    // check if we have reached a terminating condition\\n    if (curDist > rayLengthSC) { break; }\\n    if (computedColor.a > 0.98) { break; }\\n  }\\n  return computedColor;\\n}\\n\\n@fragment\\nfn main(\\n//VTK::IOStructs::Input\\n)\\n//VTK::IOStructs::Output\\n{\\n  var output: fragmentOutput;\\n\\n  var rayMax: f32 = textureSampleLevel(maxTexture, clampSampler, input.tcoordVS, 0.0).r;\\n  var rayMin: f32 = textureSampleLevel(minTexture, clampSampler, input.tcoordVS, 0.0).r;\\n\\n  // discard empty rays\\n  if (rayMax <= rayMin) { discard; }\\n  else\\n  {\\n    // compute start and end ray positions in view coordinates\\n    var minPosSC: vec4<f32> = rendererUBO.PCSCMatrix*vec4<f32>(2.0 * input.tcoordVS.x - 1.0, 1.0 - 2.0 * input.tcoordVS.y, rayMax, 1.0);\\n    minPosSC = minPosSC * (1.0 / minPosSC.w);\\n    var maxPosSC: vec4<f32> = rendererUBO.PCSCMatrix*vec4<f32>(2.0 * input.tcoordVS.x - 1.0, 1.0 - 2.0 * input.tcoordVS.y, rayMin, 1.0);\\n    maxPosSC = maxPosSC * (1.0 / maxPosSC.w);\\n\\n    var rayLengthSC: f32 = distance(minPosSC.xyz, maxPosSC.xyz);\\n    var rayStepSC: vec4<f32> = (maxPosSC - minPosSC)*(mapperUBO.SampleDistance/rayLengthSC);\\n    rayStepSC.w = 0.0;\\n\\n    var computedColor: vec4<f32>;\\n\\n//VTK::Volume::Loop\\n\\n//VTK::RenderEncoder::Impl\\n  }\\n\\n  return output;\\n}\\n\";\nvar tmpMat4 = new Float64Array(16);\nvar tmp2Mat4 = new Float64Array(16); // ----------------------------------------------------------------------------\n// vtkWebGPUVolumePassFSQ methods\n// ----------------------------------------------------------------------------\n\nfunction vtkWebGPUVolumePassFSQ(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkWebGPUVolumePassFSQ');\n\n  publicAPI.replaceShaderPosition = function (hash, pipeline, vertexInput) {\n    var vDesc = pipeline.getShaderDescription('vertex');\n    vDesc.addBuiltinOutput('vec4<f32>', '@builtin(position) Position');\n    var code = vDesc.getCode();\n    code = vtkWebGPUShaderCache.substitute(code, '//VTK::Position::Impl', ['output.tcoordVS = vec2<f32>(vertexBC.x * 0.5 + 0.5, 1.0 - vertexBC.y * 0.5 - 0.5);', 'output.Position = vec4<f32>(vertexBC, 1.0);']).result;\n    vDesc.setCode(code);\n    var fDesc = pipeline.getShaderDescription('fragment');\n    fDesc.addBuiltinInput('vec4<f32>', '@builtin(position) fragPos');\n  };\n\n  model.shaderReplacements.set('replaceShaderPosition', publicAPI.replaceShaderPosition);\n\n  publicAPI.replaceShaderVolume = function (hash, pipeline, vertexInput) {\n    var fDesc = pipeline.getShaderDescription('fragment');\n    var code = fDesc.getCode();\n    var compositeCalls = [];\n    var traverseCalls = [];\n\n    for (var i = 0; i < model.volumes.length; i++) {\n      // todo pass rowPos\n      var blendMode = model.volumes[i].getRenderable().getMapper().getBlendMode();\n\n      if (blendMode === BlendMode.COMPOSITE_BLEND) {\n        compositeCalls.push(\"    sampleColor = processVolume(volTexture\".concat(i, \", \").concat(i, \", \").concat(model.rowStarts[i], \", rayPosSC, tfunRows);\"));\n        compositeCalls.push(\"    computedColor = vec4<f32>(\\n          sampleColor.a * sampleColor.rgb * (1.0 - computedColor.a) + computedColor.rgb,\\n          (1.0 - computedColor.a)*sampleColor.a + computedColor.a);\");\n      } else {\n        traverseCalls.push(\"  sampleColor = traverseVals[\".concat(i, \"];\"));\n        traverseCalls.push(\"  computedColor = vec4<f32>(\\n          sampleColor.a * sampleColor.rgb * (1.0 - computedColor.a) + computedColor.rgb,\\n          (1.0 - computedColor.a)*sampleColor.a + computedColor.a);\");\n      }\n    }\n\n    code = vtkWebGPUShaderCache.substitute(code, '//VTK::Volume::CompositeCalls', compositeCalls).result;\n    code = vtkWebGPUShaderCache.substitute(code, '//VTK::Volume::TraverseCalls', traverseCalls).result;\n    code = vtkWebGPUShaderCache.substitute(code, '//VTK::Volume::TraverseDec', [\"var<private> traverseVals: array<vec4<f32>,\".concat(model.volumes.length, \">;\")]).result; // call the full and partial methods as needed\n\n    var compositeWhileTraversing = false;\n\n    for (var vidx = 0; vidx < model.volumes.length; vidx++) {\n      var _blendMode = model.volumes[vidx].getRenderable().getMapper().getBlendMode();\n\n      if (_blendMode === BlendMode.COMPOSITE_BLEND) {\n        compositeWhileTraversing = true;\n      } else if (_blendMode === BlendMode.MAXIMUM_INTENSITY_BLEND) {\n        code = vtkWebGPUShaderCache.substitute(code, '//VTK::Volume::Loop', [\"    traverseMax(volTexture\".concat(vidx, \", \").concat(vidx, \", \").concat(vidx, \", rayLengthSC, minPosSC, rayStepSC);\"), \"    computedColor = traverseVals[\".concat(vidx, \"];\"), '//VTK::Volume::Loop']).result;\n      } else if (_blendMode === BlendMode.MINIMUM_INTENSITY_BLEND) {\n        code = vtkWebGPUShaderCache.substitute(code, '//VTK::Volume::Loop', [\"    traverseMin(volTexture\".concat(vidx, \", \").concat(vidx, \", \").concat(vidx, \", rayLengthSC, minPosSC, rayStepSC);\"), \"    computedColor = traverseVals[\".concat(vidx, \"];\"), '//VTK::Volume::Loop']).result;\n      } else if (_blendMode === BlendMode.AVERAGE_INTENSITY_BLEND) {\n        code = vtkWebGPUShaderCache.substitute(code, '//VTK::Volume::Loop', [\"    traverseAverage(volTexture\".concat(vidx, \", \").concat(vidx, \", \").concat(vidx, \", rayLengthSC, minPosSC, rayStepSC);\"), \"    computedColor = traverseVals[\".concat(vidx, \"];\"), '//VTK::Volume::Loop']).result;\n      } else if (_blendMode === BlendMode.ADDITIVE_INTENSITY_BLEND) {\n        code = vtkWebGPUShaderCache.substitute(code, '//VTK::Volume::Loop', [\"    traverseAdditive(volTexture\".concat(vidx, \", \").concat(vidx, \", \").concat(vidx, \", rayLengthSC, minPosSC, rayStepSC);\"), \"    computedColor = traverseVals[\".concat(vidx, \"];\"), '//VTK::Volume::Loop']).result;\n      }\n    }\n\n    if (compositeWhileTraversing) {\n      code = vtkWebGPUShaderCache.substitute(code, '//VTK::Volume::Loop', ['    computedColor = composite(rayLengthSC, minPosSC, rayStepSC);']).result;\n    }\n\n    fDesc.setCode(code);\n  };\n\n  model.shaderReplacements.set('replaceShaderVolume', publicAPI.replaceShaderVolume);\n\n  publicAPI.updateLUTImage = function (device) {\n    // depends on\n    // - volumes array (length and values) - mtime\n    // - tfun arrays - renderable/property mtime\n    var mtime = publicAPI.getMTime();\n\n    for (var i = 0; i < model.volumes.length; i++) {\n      var vol = model.volumes[i].getRenderable();\n      var image = vol.getMapper().getInputData();\n      mtime = Math.max(mtime, vol.getMTime(), image.getMTime());\n    }\n\n    if (mtime < model.lutBuildTime.getMTime()) {\n      return;\n    } // first determine how large the image should be\n\n\n    model.numRows = 0;\n    model.rowStarts = [];\n\n    for (var vidx = 0; vidx < model.volumes.length; vidx++) {\n      model.rowStarts.push(model.numRows);\n      var webgpuvol = model.volumes[vidx];\n      var actor = webgpuvol.getRenderable();\n      var volMapr = actor.getMapper();\n      var vprop = actor.getProperty();\n\n      var _image = volMapr.getInputData();\n\n      var scalars = _image.getPointData() && _image.getPointData().getScalars();\n\n      var numComp = scalars.getNumberOfComponents();\n      var iComps = vprop.getIndependentComponents();\n      var numIComps = iComps ? numComp : 1;\n      model.numRows += numIComps;\n    } // allocate the image array\n\n\n    var colorArray = new Uint8Array(model.numRows * 2 * model.rowLength * 4);\n    var opacityArray = new Float32Array(model.numRows * 2 * model.rowLength);\n    var imgRow = 0;\n    var tmpTable = new Float32Array(model.rowLength * 3);\n    var rowLength = model.rowLength;\n\n    for (var _vidx = 0; _vidx < model.volumes.length; _vidx++) {\n      var _webgpuvol = model.volumes[_vidx];\n\n      var _actor = _webgpuvol.getRenderable();\n\n      var _volMapr = _actor.getMapper();\n\n      var _vprop = _actor.getProperty();\n\n      var _image2 = _volMapr.getInputData();\n\n      var _scalars = _image2.getPointData() && _image2.getPointData().getScalars();\n\n      var _numComp = _scalars.getNumberOfComponents();\n\n      var _iComps = _vprop.getIndependentComponents();\n\n      var _numIComps = _iComps ? _numComp : 1;\n\n      for (var c = 0; c < _numIComps; ++c) {\n        var cfun = _vprop.getRGBTransferFunction(c);\n\n        var cRange = cfun.getRange();\n        cfun.getTable(cRange[0], cRange[1], rowLength, tmpTable, 1);\n        var ioffset = imgRow * rowLength * 4;\n\n        for (var _i = 0; _i < rowLength; ++_i) {\n          colorArray[ioffset + _i * 4] = 255.0 * tmpTable[_i * 3];\n          colorArray[ioffset + _i * 4 + 1] = 255.0 * tmpTable[_i * 3 + 1];\n          colorArray[ioffset + _i * 4 + 2] = 255.0 * tmpTable[_i * 3 + 2];\n          colorArray[ioffset + _i * 4 + 3] = 255.0;\n\n          for (var co = 0; co < 4; co++) {\n            colorArray[ioffset + (rowLength + _i) * 4 + co] = colorArray[ioffset + _i * 4 + co];\n          }\n        }\n\n        var ofun = _vprop.getScalarOpacity(c);\n\n        var opacityFactor = model.sampleDist / _vprop.getScalarOpacityUnitDistance(c);\n\n        var oRange = ofun.getRange();\n        ofun.getTable(oRange[0], oRange[1], rowLength, tmpTable, 1); // adjust for sample distance etc\n\n        ioffset = imgRow * rowLength;\n\n        for (var _i2 = 0; _i2 < rowLength; ++_i2) {\n          opacityArray[ioffset + _i2] = 1.0 - Math.pow(1.0 - tmpTable[_i2], opacityFactor);\n          opacityArray[ioffset + _i2 + rowLength] = opacityArray[ioffset + _i2];\n        }\n\n        imgRow += 2;\n      }\n    }\n\n    {\n      var treq = {\n        nativeArray: colorArray,\n        width: model.rowLength,\n        height: model.numRows * 2,\n        depth: 1,\n        format: 'rgba8unorm'\n      };\n      var newTex = device.getTextureManager().getTexture(treq);\n      var tview = newTex.createView('tfunTexture');\n      model.textureViews[2] = tview;\n    }\n    {\n      var _treq = {\n        nativeArray: opacityArray,\n        width: model.rowLength,\n        height: model.numRows * 2,\n        depth: 1,\n        format: 'r16float'\n      };\n\n      var _newTex = device.getTextureManager().getTexture(_treq);\n\n      var _tview = _newTex.createView('ofunTexture');\n\n      model.textureViews[3] = _tview;\n    }\n    model.lutBuildTime.modified();\n  };\n\n  publicAPI.updateSSBO = function (device) {\n    // if any of\n    // - color or opacity tfun ranges changed - volume Mtime\n    // - any volume matrix changed - volume MTime\n    // - stabilized center changed - ren.stabilizedMTime\n    // - any volume's input data worldtoindex or dimensions changed - input's mtime\n    //\n    var mtime = Math.max(publicAPI.getMTime(), model.WebGPURenderer.getStabilizedTime());\n\n    for (var i = 0; i < model.volumes.length; i++) {\n      var vol = model.volumes[i].getRenderable();\n      var volMapr = vol.getMapper();\n      var image = volMapr.getInputData();\n      mtime = Math.max(mtime, vol.getMTime(), image.getMTime(), volMapr.getMTime());\n    }\n\n    if (mtime < model.SSBO.getSendTime()) {\n      return;\n    } // create the volumeSBBO\n\n\n    var center = model.WebGPURenderer.getStabilizedCenterByReference();\n    model.SSBO.clearData();\n    model.SSBO.setNumberOfInstances(model.volumes.length); // create SCTC matrices  SC -> world -> model -> index -> tcoord\n    //\n    // when doing coord conversions from A to C recall\n    // the order is mat4.mult(AtoC, BtoC, AtoB);\n    //\n\n    var marray = new Float64Array(model.volumes.length * 16);\n    var vPlaneArray = new Float64Array(model.volumes.length * 16);\n    var tstepArray = new Float64Array(model.volumes.length * 4);\n    var shadeArray = new Float64Array(model.volumes.length * 4);\n    var spacingArray = new Float64Array(model.volumes.length * 4);\n    var ipScalarRangeArray = new Float64Array(model.volumes.length * 4);\n\n    for (var vidx = 0; vidx < model.volumes.length; vidx++) {\n      var webgpuvol = model.volumes[vidx];\n      var actor = webgpuvol.getRenderable();\n\n      var _volMapr2 = actor.getMapper();\n\n      var _image3 = _volMapr2.getInputData();\n\n      mat4.identity(tmpMat4);\n      mat4.translate(tmpMat4, tmpMat4, center); // tmpMat4 is now SC->World\n\n      var mcwcmat = actor.getMatrix();\n      mat4.transpose(tmp2Mat4, mcwcmat);\n      mat4.invert(tmp2Mat4, tmp2Mat4); // tmp2Mat4 is now world to model\n\n      mat4.multiply(tmpMat4, tmp2Mat4, tmpMat4); // tmp4Mat is now SC->Model\n      // the method on the data is world to index but the volume is in\n      // model coordinates so really in this context it is model to index\n\n      var modelToIndex = _image3.getWorldToIndex();\n\n      mat4.multiply(tmpMat4, modelToIndex, tmpMat4); // tmpMat4 is now SC -> Index\n\n      var dims = _image3.getDimensions();\n\n      mat4.identity(tmp2Mat4);\n      mat4.scale(tmp2Mat4, tmp2Mat4, [1.0 / dims[0], 1.0 / dims[1], 1.0 / dims[2]]);\n      mat4.multiply(tmpMat4, tmp2Mat4, tmpMat4); // tmpMat4 is now SC -> Tcoord\n\n      for (var j = 0; j < 16; j++) {\n        marray[vidx * 16 + j] = tmpMat4[j];\n      }\n\n      mat4.invert(tmpMat4, tmpMat4); // now it is Tcoord To SC\n\n      for (var _j = 0; _j < 4; _j++) {\n        vPlaneArray[vidx * 16 + _j * 4] = tmpMat4[_j * 4];\n        vPlaneArray[vidx * 16 + _j * 4 + 1] = tmpMat4[_j * 4 + 1];\n        vPlaneArray[vidx * 16 + _j * 4 + 2] = tmpMat4[_j * 4 + 2];\n        vPlaneArray[vidx * 16 + _j * 4 + 3] = 0.0;\n      }\n\n      tstepArray[vidx * 4] = 1.0 / dims[0];\n      tstepArray[vidx * 4 + 1] = 1.0 / dims[1];\n      tstepArray[vidx * 4 + 2] = 1.0 / dims[2];\n      tstepArray[vidx * 4 + 3] = 1.0;\n      shadeArray[vidx * 4] = actor.getProperty().getShade() ? 1.0 : 0.0;\n\n      var spacing = _image3.getSpacing();\n\n      spacingArray[vidx * 4] = spacing[0];\n      spacingArray[vidx * 4 + 1] = spacing[1];\n      spacingArray[vidx * 4 + 2] = spacing[2];\n      spacingArray[vidx * 4 + 3] = 1.0; // handle filteringMode\n\n      var tScale = model.textureViews[vidx + 4].getTexture().getScale();\n\n      var ipScalarRange = _volMapr2.getIpScalarRange();\n\n      ipScalarRangeArray[vidx * 4] = ipScalarRange[0] / tScale;\n      ipScalarRangeArray[vidx * 4 + 1] = ipScalarRange[1] / tScale;\n      ipScalarRangeArray[vidx * 4 + 2] = _volMapr2.getFilterMode();\n    }\n\n    model.SSBO.addEntry('SCTCMatrix', 'mat4x4<f32>');\n    model.SSBO.addEntry('planeNormals', 'mat4x4<f32>');\n    model.SSBO.addEntry('shade', 'vec4<f32>');\n    model.SSBO.addEntry('tstep', 'vec4<f32>');\n    model.SSBO.addEntry('spacing', 'vec4<f32>');\n    model.SSBO.addEntry('ipScalarRange', 'vec4<f32>');\n    model.SSBO.setAllInstancesFromArray('SCTCMatrix', marray);\n    model.SSBO.setAllInstancesFromArray('planeNormals', vPlaneArray);\n    model.SSBO.setAllInstancesFromArray('shade', shadeArray);\n    model.SSBO.setAllInstancesFromArray('tstep', tstepArray);\n    model.SSBO.setAllInstancesFromArray('spacing', spacingArray);\n    model.SSBO.setAllInstancesFromArray('ipScalarRange', ipScalarRangeArray);\n    model.SSBO.send(device); // now create the componentSSBO\n\n    model.componentSSBO.clearData();\n    model.componentSSBO.setNumberOfInstances(model.numRows);\n    var cScaleArray = new Float64Array(model.numRows);\n    var cShiftArray = new Float64Array(model.numRows);\n    var oScaleArray = new Float64Array(model.numRows);\n    var oShiftArray = new Float64Array(model.numRows);\n    var gominArray = new Float64Array(model.numRows);\n    var gomaxArray = new Float64Array(model.numRows);\n    var goshiftArray = new Float64Array(model.numRows);\n    var goscaleArray = new Float64Array(model.numRows);\n    var rowIdx = 0;\n\n    for (var _vidx2 = 0; _vidx2 < model.volumes.length; _vidx2++) {\n      var _webgpuvol2 = model.volumes[_vidx2];\n\n      var _actor2 = _webgpuvol2.getRenderable();\n\n      var _volMapr3 = _actor2.getMapper();\n\n      var vprop = _actor2.getProperty();\n\n      var _image4 = _volMapr3.getInputData();\n\n      var scalars = _image4.getPointData() && _image4.getPointData().getScalars();\n\n      var numComp = scalars.getNumberOfComponents();\n      var iComps = vprop.getIndependentComponents(); // const numIComps = iComps ? numComp : 1;\n      // half float?\n\n      var tformat = model.textureViews[_vidx2 + 4].getTexture().getFormat();\n\n      var tDetails = vtkWebGPUTypes.getDetailsFromTextureFormat(tformat);\n      var halfFloat = tDetails.elementSize === 2 && tDetails.sampleType === 'float';\n      var volInfo = {\n        scale: [255.0],\n        offset: [0.0]\n      };\n\n      if (halfFloat) {\n        volInfo.scale[0] = 1.0;\n      } // three levels of shift scale combined into one\n      // for performance in the fragment shader\n\n\n      for (var compIdx = 0; compIdx < numComp; compIdx++) {\n        var target = iComps ? compIdx : 0;\n        var sscale = volInfo.scale[compIdx];\n        var ofun = vprop.getScalarOpacity(target);\n        var oRange = ofun.getRange();\n        var oscale = sscale / (oRange[1] - oRange[0]);\n        var oshift = (volInfo.offset[compIdx] - oRange[0]) / (oRange[1] - oRange[0]);\n        oShiftArray[rowIdx] = oshift;\n        oScaleArray[rowIdx] = oscale;\n        var cfun = vprop.getRGBTransferFunction(target);\n        var cRange = cfun.getRange();\n        cShiftArray[rowIdx] = (volInfo.offset[compIdx] - cRange[0]) / (cRange[1] - cRange[0]);\n        cScaleArray[rowIdx] = sscale / (cRange[1] - cRange[0]); // todo sscale for dependent should be based off of the A channel?\n        // not target (which is 0 in that case)\n\n        var useGO = vprop.getUseGradientOpacity(target);\n\n        if (useGO) {\n          var gomin = vprop.getGradientOpacityMinimumOpacity(target);\n          var gomax = vprop.getGradientOpacityMaximumOpacity(target);\n          gominArray[rowIdx] = gomin;\n          gomaxArray[rowIdx] = gomax;\n          var goRange = [vprop.getGradientOpacityMinimumValue(target), vprop.getGradientOpacityMaximumValue(target)];\n          goscaleArray[rowIdx] = sscale * (gomax - gomin) / (goRange[1] - goRange[0]);\n          goshiftArray[rowIdx] = -goRange[0] * (gomax - gomin) / (goRange[1] - goRange[0]) + gomin;\n        } else {\n          gominArray[rowIdx] = 1.0;\n          gomaxArray[rowIdx] = 1.0;\n          goscaleArray[rowIdx] = 0.0;\n          goshiftArray[rowIdx] = 1.0;\n        }\n\n        rowIdx++;\n      }\n    }\n\n    model.componentSSBO.addEntry('cScale', 'f32');\n    model.componentSSBO.addEntry('cShift', 'f32');\n    model.componentSSBO.addEntry('oScale', 'f32');\n    model.componentSSBO.addEntry('oShift', 'f32');\n    model.componentSSBO.addEntry('goShift', 'f32');\n    model.componentSSBO.addEntry('goScale', 'f32');\n    model.componentSSBO.addEntry('gomin', 'f32');\n    model.componentSSBO.addEntry('gomax', 'f32');\n    model.componentSSBO.setAllInstancesFromArray('cScale', cScaleArray);\n    model.componentSSBO.setAllInstancesFromArray('cShift', cShiftArray);\n    model.componentSSBO.setAllInstancesFromArray('oScale', oScaleArray);\n    model.componentSSBO.setAllInstancesFromArray('oShift', oShiftArray);\n    model.componentSSBO.setAllInstancesFromArray('goScale', goscaleArray);\n    model.componentSSBO.setAllInstancesFromArray('goShift', goshiftArray);\n    model.componentSSBO.setAllInstancesFromArray('gomin', gominArray);\n    model.componentSSBO.setAllInstancesFromArray('gomax', gomaxArray);\n    model.componentSSBO.send(device);\n  };\n\n  var superClassUpdateBuffers = publicAPI.updateBuffers;\n\n  publicAPI.updateBuffers = function () {\n    superClassUpdateBuffers(); // compute the min step size\n\n    var sampleDist = model.volumes[0].getRenderable().getMapper().getSampleDistance();\n\n    for (var i = 0; i < model.volumes.length; i++) {\n      var vol = model.volumes[i];\n      var volMapr = vol.getRenderable().getMapper();\n      var sd = volMapr.getSampleDistance();\n\n      if (sd < sampleDist) {\n        sampleDist = sd;\n      }\n    }\n\n    if (model.sampleDist !== sampleDist) {\n      model.sampleDist = sampleDist;\n      model.UBO.setValue('SampleDistance', sampleDist);\n      model.UBO.sendIfNeeded(model.device);\n    } // add in 3d volume textures\n\n\n    for (var vidx = 0; vidx < model.volumes.length; vidx++) {\n      var webgpuvol = model.volumes[vidx];\n      var actor = webgpuvol.getRenderable();\n\n      var _volMapr4 = actor.getMapper();\n\n      var image = _volMapr4.getInputData();\n\n      var newTex = model.device.getTextureManager().getTextureForImageData(image);\n\n      if (!model.textureViews[vidx + 4] || model.textureViews[vidx + 4].getTexture() !== newTex) {\n        var tview = newTex.createView(\"volTexture\".concat(vidx));\n        model.textureViews[vidx + 4] = tview;\n      }\n    } // clear any old leftovers\n\n\n    if (model.volumes.length < model.lastVolumeLength) {\n      // we may have gaps in the array right now so no splice\n      for (var _i3 = model.volumes.length; _i3 < model.lastVolumeLength; _i3++) {\n        model.textureViews.pop();\n      }\n    }\n\n    model.lastVolumeLength = model.volumes.length;\n    publicAPI.updateLUTImage(model.device);\n    publicAPI.updateSSBO(model.device);\n\n    if (!model.clampSampler) {\n      model.clampSampler = vtkWebGPUSampler.newInstance({\n        label: 'clampSampler'\n      });\n      model.clampSampler.create(model.device, {\n        minFilter: 'linear',\n        magFilter: 'linear'\n      });\n    }\n  };\n\n  publicAPI.computePipelineHash = function () {\n    model.pipelineHash = 'volfsq';\n\n    for (var vidx = 0; vidx < model.volumes.length; vidx++) {\n      var blendMode = model.volumes[vidx].getRenderable().getMapper().getBlendMode();\n      model.pipelineHash += \"\".concat(blendMode);\n    }\n  }; // marks modified when needed\n\n\n  publicAPI.setVolumes = function (val) {\n    if (!model.volumes || model.volumes.length !== val.length) {\n      model.volumes = _toConsumableArray(val);\n      publicAPI.modified();\n      return;\n    }\n\n    for (var i = 0; i < val.length; i++) {\n      if (val[i] !== model.volumes[i]) {\n        model.volumes = _toConsumableArray(val);\n        publicAPI.modified();\n        return;\n      }\n    }\n  };\n\n  var superclassGetBindables = publicAPI.getBindables;\n\n  publicAPI.getBindables = function () {\n    var bindables = superclassGetBindables();\n    bindables.push(model.componentSSBO);\n    bindables.push(model.clampSampler);\n    return bindables;\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\n\nvar DEFAULT_VALUES = {\n  volumes: null,\n  rowLength: 1024,\n  lastVolumeLength: 0\n}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Inheritance\n\n  vtkWebGPUFullScreenQuad.extend(publicAPI, model, initialValues);\n  model.fragmentShaderTemplate = volFragTemplate;\n  model.UBO = vtkWebGPUUniformBuffer.newInstance({\n    label: 'mapperUBO'\n  });\n  model.UBO.addEntry('SampleDistance', 'f32');\n  model.SSBO = vtkWebGPUStorageBuffer.newInstance({\n    label: 'volumeSSBO'\n  });\n  model.componentSSBO = vtkWebGPUStorageBuffer.newInstance({\n    label: 'componentSSBO'\n  });\n  model.lutBuildTime = {};\n  macro.obj(model.lutBuildTime, {\n    mtime: 0\n  }); // Object methods\n\n  vtkWebGPUVolumePassFSQ(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = macro.newInstance(extend, 'vtkWebGPUVolumePassFSQ'); // ----------------------------------------------------------------------------\n\nvar vtkWebGPUVolumePassFSQ$1 = {\n  newInstance: newInstance,\n  extend: extend\n};\n\nexport { vtkWebGPUVolumePassFSQ$1 as default, extend, newInstance };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}