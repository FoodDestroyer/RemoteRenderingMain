{"ast":null,"code":"/* eslint-disable no-bitwise */\n// ----------------------------------------------------------------------------\n// Decoding infrastructure\n// ----------------------------------------------------------------------------\nvar REVERSE_LOOKUP = [];\nREVERSE_LOOKUP['-'.charCodeAt(0)] = 62;\nREVERSE_LOOKUP['_'.charCodeAt(0)] = 63;\nvar BASE64_CODE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\nfor (var i = 0; i < BASE64_CODE.length; i++) {\n  REVERSE_LOOKUP[BASE64_CODE.charCodeAt(i)] = i;\n} // ----------------------------------------------------------------------------\n// Base64 analysis\n// ----------------------------------------------------------------------------\n\nfunction isValidChar(c) {\n  return REVERSE_LOOKUP[c.charCodeAt(0)] !== undefined;\n}\nfunction extractChunks(b64Str) {\n  var strSize = b64Str.length;\n  var chunks = [];\n  var currentChunk = null;\n  for (var _i = 0; _i < strSize; _i++) {\n    if (isValidChar(b64Str[_i])) {\n      if (!currentChunk) {\n        currentChunk = {\n          start: _i,\n          count: 0\n        };\n      }\n      currentChunk.count++;\n      currentChunk.end = _i;\n    } else if (b64Str[_i] === '=' && currentChunk) {\n      // End of chunk (found padding char)\n      chunks.push(currentChunk);\n      currentChunk = null;\n    }\n  }\n  if (currentChunk) {\n    chunks.push(currentChunk);\n  }\n  return chunks;\n}\nfunction writeChunk(b64Str, chunk, dstOffset, uint8) {\n  var start = chunk.start,\n    count = chunk.count;\n  var remain = count % 4;\n  var fourCharProcessCount = Math.floor(count / 4);\n  var charIdx = start;\n  var tmp = null;\n  var offset = dstOffset; // Handle 4=>3\n\n  for (var _i2 = 0; _i2 < fourCharProcessCount; _i2++) {\n    while (!isValidChar(b64Str[charIdx])) {\n      charIdx++;\n    }\n    tmp = REVERSE_LOOKUP[b64Str.charCodeAt(charIdx++)] << 18;\n    while (!isValidChar(b64Str[charIdx])) {\n      charIdx++;\n    }\n    tmp |= REVERSE_LOOKUP[b64Str.charCodeAt(charIdx++)] << 12;\n    while (!isValidChar(b64Str[charIdx])) {\n      charIdx++;\n    }\n    tmp |= REVERSE_LOOKUP[b64Str.charCodeAt(charIdx++)] << 6;\n    while (!isValidChar(b64Str[charIdx])) {\n      charIdx++;\n    }\n    tmp |= REVERSE_LOOKUP[b64Str.charCodeAt(charIdx++)];\n    uint8[offset++] = tmp >> 16 & 0xff;\n    uint8[offset++] = tmp >> 8 & 0xff;\n    uint8[offset++] = tmp & 0xff;\n  } // Handle remain\n\n  switch (remain) {\n    case 3:\n      while (!isValidChar(b64Str[charIdx])) {\n        charIdx++;\n      }\n      tmp = REVERSE_LOOKUP[b64Str.charCodeAt(charIdx++)] << 10;\n      while (!isValidChar(b64Str[charIdx])) {\n        charIdx++;\n      }\n      tmp |= REVERSE_LOOKUP[b64Str.charCodeAt(charIdx++)] << 4;\n      while (!isValidChar(b64Str[charIdx])) {\n        charIdx++;\n      }\n      tmp |= REVERSE_LOOKUP[b64Str.charCodeAt(charIdx++)] >> 2;\n      uint8[offset++] = tmp >> 8 & 0xff;\n      uint8[offset++] = tmp & 0xff;\n      break;\n    case 2:\n      while (!isValidChar(b64Str[charIdx])) {\n        charIdx++;\n      }\n      tmp = REVERSE_LOOKUP[b64Str.charCodeAt(charIdx++)] << 2;\n      while (!isValidChar(b64Str[charIdx])) {\n        charIdx++;\n      }\n      tmp |= REVERSE_LOOKUP[b64Str.charCodeAt(charIdx++)] >> 4;\n      uint8[offset++] = tmp & 0xff;\n      break;\n    case 1:\n      throw new Error('BASE64: remain 1 should not happen');\n  }\n  return offset;\n}\nfunction toArrayBuffer(b64Str) {\n  var chunks = extractChunks(b64Str);\n  var totalEncodedLength = chunks[chunks.length - 1].end + 1;\n  var padding = (4 - totalEncodedLength % 4) % 4; // -length mod 4\n  // Any padding chars in the middle of b64Str is to be interpreted as \\x00,\n  // whereas the terminating padding chars are to be interpreted as literal padding.\n\n  var totalSize = (totalEncodedLength + padding) * 3 / 4 - padding;\n  var arrayBuffer = new ArrayBuffer(totalSize);\n  var view = new Uint8Array(arrayBuffer);\n  var dstOffset = 0;\n  for (var _i3 = 0; _i3 < chunks.length; _i3++) {\n    dstOffset += writeChunk(b64Str, chunks[_i3], dstOffset, view);\n    dstOffset += (4 - chunks[_i3].count % 4) % 4;\n  }\n  return arrayBuffer;\n}\nfunction encodeTriplet(v1, v2, v3) {\n  var triplet = (v1 << 16) + (v2 << 8) + v3;\n  return BASE64_CODE[triplet >> 18] + BASE64_CODE[triplet >> 12 & 0x3f] + BASE64_CODE[triplet >> 6 & 0x3f] + BASE64_CODE[triplet & 0x3f];\n}\nfunction fromArrayBuffer(ab) {\n  var uint8 = new Uint8Array(ab);\n  var leftoverLength = ab.byteLength % 3;\n  var maxTripletIndex = ab.byteLength - leftoverLength;\n  var segments = Array(maxTripletIndex / 3);\n  for (var _i4 = 0; _i4 < segments.length; _i4++) {\n    var bufOffset = _i4 * 3;\n    segments[_i4] = encodeTriplet(uint8[bufOffset], uint8[bufOffset + 1], uint8[bufOffset + 2]);\n  }\n  if (leftoverLength > 0) {\n    var segment = encodeTriplet(uint8[maxTripletIndex], uint8[maxTripletIndex + 1] || 0, uint8[maxTripletIndex + 2] || 0);\n    if (leftoverLength === 1) {\n      segments.push(\"\".concat(segment.substr(0, 2), \"==\"));\n    } else if (leftoverLength === 2) {\n      segments.push(\"\".concat(segment.substr(0, 3), \"=\"));\n    }\n  }\n  return segments.join('');\n}\nvar Base64 = {\n  toArrayBuffer: toArrayBuffer,\n  fromArrayBuffer: fromArrayBuffer\n};\nexport { Base64 as default, fromArrayBuffer, toArrayBuffer };","map":{"version":3,"names":["REVERSE_LOOKUP","charCodeAt","BASE64_CODE","i","length","isValidChar","c","undefined","extractChunks","b64Str","strSize","chunks","currentChunk","_i","start","count","end","push","writeChunk","chunk","dstOffset","uint8","remain","fourCharProcessCount","Math","floor","charIdx","tmp","offset","_i2","Error","toArrayBuffer","totalEncodedLength","padding","totalSize","arrayBuffer","ArrayBuffer","view","Uint8Array","_i3","encodeTriplet","v1","v2","v3","triplet","fromArrayBuffer","ab","leftoverLength","byteLength","maxTripletIndex","segments","Array","_i4","bufOffset","segment","concat","substr","join","Base64","default"],"sources":["/home/rakshith/Documents/RemoteRendering/vtk-js-react-app/node_modules/@kitware/vtk.js/Common/Core/Base64.js"],"sourcesContent":["/* eslint-disable no-bitwise */\n// ----------------------------------------------------------------------------\n// Decoding infrastructure\n// ----------------------------------------------------------------------------\nvar REVERSE_LOOKUP = [];\nREVERSE_LOOKUP['-'.charCodeAt(0)] = 62;\nREVERSE_LOOKUP['_'.charCodeAt(0)] = 63;\nvar BASE64_CODE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\nfor (var i = 0; i < BASE64_CODE.length; i++) {\n  REVERSE_LOOKUP[BASE64_CODE.charCodeAt(i)] = i;\n} // ----------------------------------------------------------------------------\n// Base64 analysis\n// ----------------------------------------------------------------------------\n\n\nfunction isValidChar(c) {\n  return REVERSE_LOOKUP[c.charCodeAt(0)] !== undefined;\n}\n\nfunction extractChunks(b64Str) {\n  var strSize = b64Str.length;\n  var chunks = [];\n  var currentChunk = null;\n\n  for (var _i = 0; _i < strSize; _i++) {\n    if (isValidChar(b64Str[_i])) {\n      if (!currentChunk) {\n        currentChunk = {\n          start: _i,\n          count: 0\n        };\n      }\n\n      currentChunk.count++;\n      currentChunk.end = _i;\n    } else if (b64Str[_i] === '=' && currentChunk) {\n      // End of chunk (found padding char)\n      chunks.push(currentChunk);\n      currentChunk = null;\n    }\n  }\n\n  if (currentChunk) {\n    chunks.push(currentChunk);\n  }\n\n  return chunks;\n}\n\nfunction writeChunk(b64Str, chunk, dstOffset, uint8) {\n  var start = chunk.start,\n      count = chunk.count;\n  var remain = count % 4;\n  var fourCharProcessCount = Math.floor(count / 4);\n  var charIdx = start;\n  var tmp = null;\n  var offset = dstOffset; // Handle 4=>3\n\n  for (var _i2 = 0; _i2 < fourCharProcessCount; _i2++) {\n    while (!isValidChar(b64Str[charIdx])) {\n      charIdx++;\n    }\n\n    tmp = REVERSE_LOOKUP[b64Str.charCodeAt(charIdx++)] << 18;\n\n    while (!isValidChar(b64Str[charIdx])) {\n      charIdx++;\n    }\n\n    tmp |= REVERSE_LOOKUP[b64Str.charCodeAt(charIdx++)] << 12;\n\n    while (!isValidChar(b64Str[charIdx])) {\n      charIdx++;\n    }\n\n    tmp |= REVERSE_LOOKUP[b64Str.charCodeAt(charIdx++)] << 6;\n\n    while (!isValidChar(b64Str[charIdx])) {\n      charIdx++;\n    }\n\n    tmp |= REVERSE_LOOKUP[b64Str.charCodeAt(charIdx++)];\n    uint8[offset++] = tmp >> 16 & 0xff;\n    uint8[offset++] = tmp >> 8 & 0xff;\n    uint8[offset++] = tmp & 0xff;\n  } // Handle remain\n\n\n  switch (remain) {\n    case 3:\n      while (!isValidChar(b64Str[charIdx])) {\n        charIdx++;\n      }\n\n      tmp = REVERSE_LOOKUP[b64Str.charCodeAt(charIdx++)] << 10;\n\n      while (!isValidChar(b64Str[charIdx])) {\n        charIdx++;\n      }\n\n      tmp |= REVERSE_LOOKUP[b64Str.charCodeAt(charIdx++)] << 4;\n\n      while (!isValidChar(b64Str[charIdx])) {\n        charIdx++;\n      }\n\n      tmp |= REVERSE_LOOKUP[b64Str.charCodeAt(charIdx++)] >> 2;\n      uint8[offset++] = tmp >> 8 & 0xff;\n      uint8[offset++] = tmp & 0xff;\n      break;\n\n    case 2:\n      while (!isValidChar(b64Str[charIdx])) {\n        charIdx++;\n      }\n\n      tmp = REVERSE_LOOKUP[b64Str.charCodeAt(charIdx++)] << 2;\n\n      while (!isValidChar(b64Str[charIdx])) {\n        charIdx++;\n      }\n\n      tmp |= REVERSE_LOOKUP[b64Str.charCodeAt(charIdx++)] >> 4;\n      uint8[offset++] = tmp & 0xff;\n      break;\n\n    case 1:\n      throw new Error('BASE64: remain 1 should not happen');\n  }\n\n  return offset;\n}\n\nfunction toArrayBuffer(b64Str) {\n  var chunks = extractChunks(b64Str);\n  var totalEncodedLength = chunks[chunks.length - 1].end + 1;\n  var padding = (4 - totalEncodedLength % 4) % 4; // -length mod 4\n  // Any padding chars in the middle of b64Str is to be interpreted as \\x00,\n  // whereas the terminating padding chars are to be interpreted as literal padding.\n\n  var totalSize = (totalEncodedLength + padding) * 3 / 4 - padding;\n  var arrayBuffer = new ArrayBuffer(totalSize);\n  var view = new Uint8Array(arrayBuffer);\n  var dstOffset = 0;\n\n  for (var _i3 = 0; _i3 < chunks.length; _i3++) {\n    dstOffset += writeChunk(b64Str, chunks[_i3], dstOffset, view);\n    dstOffset += (4 - chunks[_i3].count % 4) % 4;\n  }\n\n  return arrayBuffer;\n}\n\nfunction encodeTriplet(v1, v2, v3) {\n  var triplet = (v1 << 16) + (v2 << 8) + v3;\n  return BASE64_CODE[triplet >> 18] + BASE64_CODE[triplet >> 12 & 0x3f] + BASE64_CODE[triplet >> 6 & 0x3f] + BASE64_CODE[triplet & 0x3f];\n}\n\nfunction fromArrayBuffer(ab) {\n  var uint8 = new Uint8Array(ab);\n  var leftoverLength = ab.byteLength % 3;\n  var maxTripletIndex = ab.byteLength - leftoverLength;\n  var segments = Array(maxTripletIndex / 3);\n\n  for (var _i4 = 0; _i4 < segments.length; _i4++) {\n    var bufOffset = _i4 * 3;\n    segments[_i4] = encodeTriplet(uint8[bufOffset], uint8[bufOffset + 1], uint8[bufOffset + 2]);\n  }\n\n  if (leftoverLength > 0) {\n    var segment = encodeTriplet(uint8[maxTripletIndex], uint8[maxTripletIndex + 1] || 0, uint8[maxTripletIndex + 2] || 0);\n\n    if (leftoverLength === 1) {\n      segments.push(\"\".concat(segment.substr(0, 2), \"==\"));\n    } else if (leftoverLength === 2) {\n      segments.push(\"\".concat(segment.substr(0, 3), \"=\"));\n    }\n  }\n\n  return segments.join('');\n}\nvar Base64 = {\n  toArrayBuffer: toArrayBuffer,\n  fromArrayBuffer: fromArrayBuffer\n};\n\nexport { Base64 as default, fromArrayBuffer, toArrayBuffer };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}