{"ast":null,"code":"import { mat4, vec3 } from 'gl-matrix';\nimport { newInstance as newInstance$1, get, setGet, getArray, setGetArray, moveToProtected, vtkDebugMacro as vtkDebugMacro$1, vtkErrorMacro as vtkErrorMacro$1, vtkWarningMacro as vtkWarningMacro$1 } from '../../macros.js';\nimport vtkCamera from './Camera.js';\nimport vtkLight from './Light.js';\nimport { P as areBoundsInitialized, u as uninitializeBounds, r as radiansFromDegrees, d as dot, F as createUninitializedBounds } from '../../Common/Core/Math/index.js';\nimport vtkViewport from './Viewport.js';\nimport vtkBoundingBox from '../../Common/DataModel/BoundingBox.js';\nvar vtkDebugMacro = vtkDebugMacro$1,\n  vtkErrorMacro = vtkErrorMacro$1,\n  vtkWarningMacro = vtkWarningMacro$1;\nfunction notImplemented(method) {\n  return function () {\n    return vtkErrorMacro(\"vtkRenderer::\".concat(method, \" - NOT IMPLEMENTED\"));\n  };\n} // ----------------------------------------------------------------------------\n// vtkRenderer methods\n// ----------------------------------------------------------------------------\n\nfunction vtkRenderer(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkRenderer'); // Events\n\n  var COMPUTE_VISIBLE_PROP_BOUNDS_EVENT = {\n    type: 'ComputeVisiblePropBoundsEvent',\n    renderer: publicAPI\n  };\n  var RESET_CAMERA_CLIPPING_RANGE_EVENT = {\n    type: 'ResetCameraClippingRangeEvent',\n    renderer: publicAPI\n  };\n  var RESET_CAMERA_EVENT = {\n    type: 'ResetCameraEvent',\n    renderer: publicAPI\n  };\n  publicAPI.updateCamera = function () {\n    if (!model.activeCamera) {\n      vtkDebugMacro('No cameras are on, creating one.'); // the get method will automagically create a camera\n      // and reset it since one hasn't been specified yet.\n\n      publicAPI.getActiveCameraAndResetIfCreated();\n    } // update the viewing transformation\n\n    model.activeCamera.render(publicAPI);\n    return true;\n  };\n  publicAPI.updateLightsGeometryToFollowCamera = function () {\n    // only update the light's geometry if this Renderer is tracking\n    // this lights.  That allows one renderer to view the lights that\n    // another renderer is setting up.\n    var camera = publicAPI.getActiveCameraAndResetIfCreated();\n    model.lights.forEach(function (light) {\n      if (light.lightTypeIsSceneLight()) ;else if (light.lightTypeIsHeadLight()) {\n        // update position and orientation of light to match camera.\n        light.setPositionFrom(camera.getPositionByReference());\n        light.setFocalPointFrom(camera.getFocalPointByReference());\n        light.modified(camera.getMTime());\n      } else if (light.lightTypeIsCameraLight()) {\n        light.setTransformMatrix(camera.getCameraLightTransformMatrix(mat4.create()));\n      } else {\n        vtkErrorMacro('light has unknown light type', light.get());\n      }\n    });\n  };\n  publicAPI.updateLightGeometry = function () {\n    if (model.lightFollowCamera) {\n      // only update the light's geometry if this Renderer is tracking\n      // this lights.  That allows one renderer to view the lights that\n      // another renderer is setting up.\n      return publicAPI.updateLightsGeometryToFollowCamera();\n    }\n    return true;\n  };\n  publicAPI.allocateTime = notImplemented('allocateTime');\n  publicAPI.updateGeometry = notImplemented('updateGeometry');\n  publicAPI.getVTKWindow = function () {\n    return model._renderWindow;\n  };\n  publicAPI.setLayer = function (layer) {\n    vtkDebugMacro(publicAPI.getClassName(), publicAPI, 'setting Layer to ', layer);\n    if (model.layer !== layer) {\n      model.layer = layer;\n      publicAPI.modified();\n    }\n    publicAPI.setPreserveColorBuffer(!!layer);\n  };\n  publicAPI.setActiveCamera = function (camera) {\n    if (model.activeCamera === camera) {\n      return false;\n    }\n    model.activeCamera = camera;\n    publicAPI.modified();\n    publicAPI.invokeEvent({\n      type: 'ActiveCameraEvent',\n      camera: camera\n    });\n    return true;\n  };\n  publicAPI.makeCamera = function () {\n    var camera = vtkCamera.newInstance();\n    publicAPI.invokeEvent({\n      type: 'CreateCameraEvent',\n      camera: camera\n    });\n    return camera;\n  }; // Replace the set/get macro method\n\n  publicAPI.getActiveCamera = function () {\n    if (!model.activeCamera) {\n      model.activeCamera = publicAPI.makeCamera();\n    }\n    return model.activeCamera;\n  };\n  publicAPI.getActiveCameraAndResetIfCreated = function () {\n    if (!model.activeCamera) {\n      publicAPI.getActiveCamera();\n      publicAPI.resetCamera();\n    }\n    return model.activeCamera;\n  };\n  publicAPI.getActors = function () {\n    model.actors = [];\n    model.props.forEach(function (prop) {\n      model.actors = model.actors.concat(prop.getActors());\n    });\n    return model.actors;\n  };\n  publicAPI.addActor = publicAPI.addViewProp;\n  publicAPI.removeActor = function (actor) {\n    model.actors = model.actors.filter(function (a) {\n      return a !== actor;\n    });\n    publicAPI.removeViewProp(actor);\n    publicAPI.modified();\n  };\n  publicAPI.removeAllActors = function () {\n    var actors = publicAPI.getActors();\n    actors.forEach(function (actor) {\n      publicAPI.removeViewProp(actor);\n    });\n    model.actors = [];\n    publicAPI.modified();\n  };\n  publicAPI.getVolumes = function () {\n    model.volumes = [];\n    model.props.forEach(function (prop) {\n      model.volumes = model.volumes.concat(prop.getVolumes());\n    });\n    return model.volumes;\n  };\n  publicAPI.addVolume = publicAPI.addViewProp;\n  publicAPI.removeVolume = function (volume) {\n    model.volumes = model.volumes.filter(function (v) {\n      return v !== volume;\n    });\n    publicAPI.removeViewProp(volume);\n    publicAPI.modified();\n  };\n  publicAPI.removeAllVolumes = function () {\n    var volumes = publicAPI.getVolumes();\n    volumes.forEach(function (volume) {\n      publicAPI.removeViewProp(volume);\n    });\n    model.volumes = [];\n    publicAPI.modified();\n  };\n  publicAPI.hasLight = function (light) {\n    return model.lights.includes(light);\n  };\n  publicAPI.addLight = function (light) {\n    if (light && !publicAPI.hasLight(light)) {\n      model.lights.push(light);\n      publicAPI.modified();\n    }\n  };\n  publicAPI.removeLight = function (light) {\n    model.lights = model.lights.filter(function (l) {\n      return l !== light;\n    });\n    publicAPI.modified();\n  };\n  publicAPI.removeAllLights = function () {\n    model.lights = [];\n    publicAPI.modified();\n  };\n  publicAPI.setLightCollection = function (lights) {\n    model.lights = lights;\n    publicAPI.modified();\n  };\n  publicAPI.makeLight = vtkLight.newInstance;\n  publicAPI.createLight = function () {\n    if (!model.automaticLightCreation) {\n      return;\n    }\n    if (model._createdLight) {\n      publicAPI.removeLight(model._createdLight);\n      model._createdLight.delete();\n      model._createdLight = null;\n    }\n    model._createdLight = publicAPI.makeLight();\n    publicAPI.addLight(model._createdLight);\n    model._createdLight.setLightTypeToHeadLight(); // set these values just to have a good default should LightFollowCamera\n    // be turned off.\n\n    model._createdLight.setPosition(publicAPI.getActiveCamera().getPosition());\n    model._createdLight.setFocalPoint(publicAPI.getActiveCamera().getFocalPoint());\n  }; // requires the aspect ratio of the viewport as X/Y\n\n  publicAPI.normalizedDisplayToWorld = function (x, y, z, aspect) {\n    var vpd = publicAPI.normalizedDisplayToProjection(x, y, z);\n    vpd = publicAPI.projectionToView(vpd[0], vpd[1], vpd[2], aspect);\n    return publicAPI.viewToWorld(vpd[0], vpd[1], vpd[2]);\n  }; // requires the aspect ratio of the viewport as X/Y\n\n  publicAPI.worldToNormalizedDisplay = function (x, y, z, aspect) {\n    var vpd = publicAPI.worldToView(x, y, z);\n    vpd = publicAPI.viewToProjection(vpd[0], vpd[1], vpd[2], aspect);\n    return publicAPI.projectionToNormalizedDisplay(vpd[0], vpd[1], vpd[2]);\n  }; // requires the aspect ratio of the viewport as X/Y\n\n  publicAPI.viewToWorld = function (x, y, z) {\n    if (model.activeCamera === null) {\n      vtkErrorMacro('ViewToWorld: no active camera, cannot compute view to world, returning 0,0,0');\n      return [0, 0, 0];\n    } // get the view matrix from the active camera\n\n    var matrix = model.activeCamera.getViewMatrix();\n    mat4.invert(matrix, matrix);\n    mat4.transpose(matrix, matrix); // Transform point to world coordinates\n\n    var result = new Float64Array([x, y, z]);\n    vec3.transformMat4(result, result, matrix);\n    return result;\n  };\n  publicAPI.projectionToView = function (x, y, z, aspect) {\n    if (model.activeCamera === null) {\n      vtkErrorMacro('ProjectionToView: no active camera, cannot compute projection to view, returning 0,0,0');\n      return [0, 0, 0];\n    } // get the projection transformation from the active camera\n\n    var matrix = model.activeCamera.getProjectionMatrix(aspect, -1.0, 1.0);\n    mat4.invert(matrix, matrix);\n    mat4.transpose(matrix, matrix); // Transform point to world coordinates\n\n    var result = new Float64Array([x, y, z]);\n    vec3.transformMat4(result, result, matrix);\n    return result;\n  }; // Convert world point coordinates to view coordinates.\n\n  publicAPI.worldToView = function (x, y, z) {\n    if (model.activeCamera === null) {\n      vtkErrorMacro('WorldToView: no active camera, cannot compute view to world, returning 0,0,0');\n      return [0, 0, 0];\n    } // get the view transformation from the active camera\n\n    var matrix = model.activeCamera.getViewMatrix();\n    mat4.transpose(matrix, matrix);\n    var result = new Float64Array([x, y, z]);\n    vec3.transformMat4(result, result, matrix);\n    return result;\n  }; // Convert world point coordinates to view coordinates.\n  // requires the aspect ratio of the viewport as X/Y\n\n  publicAPI.viewToProjection = function (x, y, z, aspect) {\n    if (model.activeCamera === null) {\n      vtkErrorMacro('ViewToProjection: no active camera, cannot compute view to projection, returning 0,0,0');\n      return [0, 0, 0];\n    } // get the projeciton transformation from the active camera\n\n    var matrix = model.activeCamera.getProjectionMatrix(aspect, -1.0, 1.0);\n    mat4.transpose(matrix, matrix);\n    var result = new Float64Array([x, y, z]);\n    vec3.transformMat4(result, result, matrix);\n    return result;\n  };\n  publicAPI.computeVisiblePropBounds = function () {\n    model.allBounds[0] = vtkBoundingBox.INIT_BOUNDS[0];\n    model.allBounds[1] = vtkBoundingBox.INIT_BOUNDS[1];\n    model.allBounds[2] = vtkBoundingBox.INIT_BOUNDS[2];\n    model.allBounds[3] = vtkBoundingBox.INIT_BOUNDS[3];\n    model.allBounds[4] = vtkBoundingBox.INIT_BOUNDS[4];\n    model.allBounds[5] = vtkBoundingBox.INIT_BOUNDS[5];\n    var nothingVisible = true;\n    publicAPI.invokeEvent(COMPUTE_VISIBLE_PROP_BOUNDS_EVENT); // loop through all props\n\n    for (var index = 0; index < model.props.length; ++index) {\n      var prop = model.props[index];\n      if (prop.getVisibility() && prop.getUseBounds()) {\n        var bounds = prop.getBounds();\n        if (bounds && areBoundsInitialized(bounds)) {\n          nothingVisible = false;\n          if (bounds[0] < model.allBounds[0]) {\n            model.allBounds[0] = bounds[0];\n          }\n          if (bounds[1] > model.allBounds[1]) {\n            model.allBounds[1] = bounds[1];\n          }\n          if (bounds[2] < model.allBounds[2]) {\n            model.allBounds[2] = bounds[2];\n          }\n          if (bounds[3] > model.allBounds[3]) {\n            model.allBounds[3] = bounds[3];\n          }\n          if (bounds[4] < model.allBounds[4]) {\n            model.allBounds[4] = bounds[4];\n          }\n          if (bounds[5] > model.allBounds[5]) {\n            model.allBounds[5] = bounds[5];\n          }\n        }\n      }\n    }\n    if (nothingVisible) {\n      uninitializeBounds(model.allBounds);\n      vtkDebugMacro(\"Can't compute bounds, no 3D props are visible\");\n    }\n    return model.allBounds;\n  };\n  publicAPI.resetCamera = function () {\n    var bounds = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    var boundsToUse = bounds || publicAPI.computeVisiblePropBounds();\n    var center = [0, 0, 0];\n    if (!areBoundsInitialized(boundsToUse)) {\n      vtkDebugMacro('Cannot reset camera!');\n      return false;\n    }\n    var vn = null;\n    if (publicAPI.getActiveCamera()) {\n      vn = model.activeCamera.getViewPlaneNormal();\n    } else {\n      vtkErrorMacro('Trying to reset non-existent camera');\n      return false;\n    } // Reset the perspective zoom factors, otherwise subsequent zooms will cause\n    // the view angle to become very small and cause bad depth sorting.\n\n    model.activeCamera.setViewAngle(30.0);\n    center[0] = (boundsToUse[0] + boundsToUse[1]) / 2.0;\n    center[1] = (boundsToUse[2] + boundsToUse[3]) / 2.0;\n    center[2] = (boundsToUse[4] + boundsToUse[5]) / 2.0;\n    var w1 = boundsToUse[1] - boundsToUse[0];\n    var w2 = boundsToUse[3] - boundsToUse[2];\n    var w3 = boundsToUse[5] - boundsToUse[4];\n    w1 *= w1;\n    w2 *= w2;\n    w3 *= w3;\n    var radius = w1 + w2 + w3; // If we have just a single point, pick a radius of 1.0\n\n    radius = radius === 0 ? 1.0 : radius; // compute the radius of the enclosing sphere\n\n    radius = Math.sqrt(radius) * 0.5; // default so that the bounding sphere fits within the view fustrum\n    // compute the distance from the intersection of the view frustum with the\n    // bounding sphere. Basically in 2D draw a circle representing the bounding\n    // sphere in 2D then draw a horizontal line going out from the center of\n    // the circle. That is the camera view. Then draw a line from the camera\n    // position to the point where it intersects the circle. (it will be tangent\n    // to the circle at this point, this is important, only go to the tangent\n    // point, do not draw all the way to the view plane). Then draw the radius\n    // from the tangent point to the center of the circle. You will note that\n    // this forms a right triangle with one side being the radius, another being\n    // the target distance for the camera, then just find the target dist using\n    // a sin.\n\n    var angle = radiansFromDegrees(model.activeCamera.getViewAngle());\n    var parallelScale = radius;\n    var distance = radius / Math.sin(angle * 0.5); // check view-up vector against view plane normal\n\n    var vup = model.activeCamera.getViewUp();\n    if (Math.abs(dot(vup, vn)) > 0.999) {\n      vtkWarningMacro('Resetting view-up since view plane normal is parallel');\n      model.activeCamera.setViewUp(-vup[2], vup[0], vup[1]);\n    } // update the camera\n\n    model.activeCamera.setFocalPoint(center[0], center[1], center[2]);\n    model.activeCamera.setPosition(center[0] + distance * vn[0], center[1] + distance * vn[1], center[2] + distance * vn[2]);\n    publicAPI.resetCameraClippingRange(boundsToUse); // setup default parallel scale\n\n    model.activeCamera.setParallelScale(parallelScale); // update reasonable world to physical values\n\n    model.activeCamera.setPhysicalScale(radius);\n    model.activeCamera.setPhysicalTranslation(-center[0], -center[1], -center[2]); // Here to let parallel/distributed compositing intercept\n    // and do the right thing.\n\n    publicAPI.invokeEvent(RESET_CAMERA_EVENT);\n    return true;\n  };\n  publicAPI.resetCameraClippingRange = function () {\n    var bounds = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    var boundsToUse = bounds || publicAPI.computeVisiblePropBounds();\n    if (!areBoundsInitialized(boundsToUse)) {\n      vtkDebugMacro('Cannot reset camera clipping range!');\n      return false;\n    } // Make sure we have an active camera\n\n    publicAPI.getActiveCameraAndResetIfCreated();\n    if (!model.activeCamera) {\n      vtkErrorMacro('Trying to reset clipping range of non-existent camera');\n      return false;\n    } // Get the exact range for the bounds\n\n    var range = model.activeCamera.computeClippingRange(boundsToUse); // do not let far - near be less than 0.1 of the window height\n    // this is for cases such as 2D images which may have zero range\n\n    var minGap = 0.0;\n    if (model.activeCamera.getParallelProjection()) {\n      minGap = 0.2 * model.activeCamera.getParallelScale();\n    } else {\n      var angle = radiansFromDegrees(model.activeCamera.getViewAngle());\n      minGap = 0.2 * Math.tan(angle / 2.0) * range[1];\n    }\n    if (range[1] - range[0] < minGap) {\n      minGap = minGap - range[1] + range[0];\n      range[1] += minGap / 2.0;\n      range[0] -= minGap / 2.0;\n    } // Do not let the range behind the camera throw off the calculation.\n\n    if (range[0] < 0.0) {\n      range[0] = 0.0;\n    } // Give ourselves a little breathing room\n\n    range[0] = 0.99 * range[0] - (range[1] - range[0]) * model.clippingRangeExpansion;\n    range[1] = 1.01 * range[1] + (range[1] - range[0]) * model.clippingRangeExpansion; // Make sure near is not bigger than far\n\n    range[0] = range[0] >= range[1] ? 0.01 * range[1] : range[0]; // Make sure near is at least some fraction of far - this prevents near\n    // from being behind the camera or too close in front. How close is too\n    // close depends on the resolution of the depth buffer\n\n    if (!model.nearClippingPlaneTolerance) {\n      model.nearClippingPlaneTolerance = 0.01;\n    } // make sure the front clipping range is not too far from the far clippnig\n    // range, this is to make sure that the zbuffer resolution is effectively\n    // used\n\n    if (range[0] < model.nearClippingPlaneTolerance * range[1]) {\n      range[0] = model.nearClippingPlaneTolerance * range[1];\n    }\n    model.activeCamera.setClippingRange(range[0], range[1]); // Here to let parallel/distributed compositing intercept\n    // and do the right thing.\n\n    publicAPI.invokeEvent(RESET_CAMERA_CLIPPING_RANGE_EVENT);\n    return false;\n  };\n  publicAPI.setRenderWindow = function (renderWindow) {\n    if (renderWindow !== model._renderWindow) {\n      model._vtkWindow = renderWindow;\n      model._renderWindow = renderWindow;\n    }\n  };\n  publicAPI.visibleActorCount = function () {\n    return model.props.filter(function (prop) {\n      return prop.getVisibility();\n    }).length;\n  };\n  publicAPI.visibleVolumeCount = publicAPI.visibleActorCount;\n  publicAPI.getMTime = function () {\n    var m1 = model.mtime;\n    var m2 = model.activeCamera ? model.activeCamera.getMTime() : 0;\n    if (m2 > m1) {\n      m1 = m2;\n    }\n    var m3 = model._createdLight ? model._createdLight.getMTime() : 0;\n    if (m3 > m1) {\n      m1 = m3;\n    }\n    return m1;\n  };\n  publicAPI.getTransparent = function () {\n    return !!model.preserveColorBuffer;\n  };\n  publicAPI.isActiveCameraCreated = function () {\n    return !!model.activeCamera;\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nvar DEFAULT_VALUES = {\n  pickedProp: null,\n  activeCamera: null,\n  allBounds: [],\n  ambient: [1, 1, 1],\n  allocatedRenderTime: 100,\n  timeFactor: 1,\n  automaticLightCreation: true,\n  twoSidedLighting: true,\n  lastRenderTimeInSeconds: -1,\n  renderWindow: null,\n  lights: [],\n  actors: [],\n  volumes: [],\n  lightFollowCamera: true,\n  numberOfPropsRendered: 0,\n  propArray: null,\n  pathArray: null,\n  layer: 0,\n  preserveColorBuffer: false,\n  preserveDepthBuffer: false,\n  computeVisiblePropBounds: createUninitializedBounds(),\n  interactive: true,\n  nearClippingPlaneTolerance: 0,\n  clippingRangeExpansion: 0.05,\n  erase: true,\n  draw: true,\n  useShadows: false,\n  useDepthPeeling: false,\n  occlusionRatio: 0,\n  maximumNumberOfPeels: 4,\n  selector: null,\n  delegate: null,\n  texturedBackground: false,\n  backgroundTexture: null,\n  environmentTexture: null,\n  environmentTextureDiffuseStrength: 1,\n  environmentTextureSpecularStrength: 1,\n  useEnvironmentTextureAsBackground: false,\n  pass: 0\n}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Inheritance\n\n  vtkViewport.extend(publicAPI, model, initialValues); // make sure background has 4 entries. Default to opaque black\n\n  if (!model.background) model.background = [0, 0, 0, 1];\n  while (model.background.length < 3) {\n    model.background.push(0);\n  }\n  if (model.background.length === 3) model.background.push(1); // Build VTK API\n\n  get(publicAPI, model, ['_renderWindow', 'allocatedRenderTime', 'timeFactor', 'lastRenderTimeInSeconds', 'numberOfPropsRendered', 'lastRenderingUsedDepthPeeling', 'selector']);\n  setGet(publicAPI, model, ['twoSidedLighting', 'lightFollowCamera', 'automaticLightCreation', 'erase', 'draw', 'nearClippingPlaneTolerance', 'clippingRangeExpansion', 'backingStore', 'interactive', 'layer', 'preserveColorBuffer', 'preserveDepthBuffer', 'useDepthPeeling', 'occlusionRatio', 'maximumNumberOfPeels', 'delegate', 'backgroundTexture', 'texturedBackground', 'environmentTexture', 'environmentTextureDiffuseStrength', 'environmentTextureSpecularStrength', 'useEnvironmentTextureAsBackground', 'useShadows', 'pass']);\n  getArray(publicAPI, model, ['actors', 'volumes', 'lights']);\n  setGetArray(publicAPI, model, ['background'], 4, 1.0);\n  moveToProtected(publicAPI, model, ['renderWindow']); // Object methods\n\n  vtkRenderer(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = newInstance$1(extend, 'vtkRenderer'); // ----------------------------------------------------------------------------\n\nvar vtkRenderer$1 = {\n  newInstance: newInstance,\n  extend: extend\n};\nexport { vtkRenderer$1 as default, extend, newInstance };","map":{"version":3,"names":["mat4","vec3","newInstance","newInstance$1","get","setGet","getArray","setGetArray","moveToProtected","vtkDebugMacro","vtkDebugMacro$1","vtkErrorMacro","vtkErrorMacro$1","vtkWarningMacro","vtkWarningMacro$1","vtkCamera","vtkLight","P","areBoundsInitialized","u","uninitializeBounds","r","radiansFromDegrees","d","dot","F","createUninitializedBounds","vtkViewport","vtkBoundingBox","notImplemented","method","concat","vtkRenderer","publicAPI","model","classHierarchy","push","COMPUTE_VISIBLE_PROP_BOUNDS_EVENT","type","renderer","RESET_CAMERA_CLIPPING_RANGE_EVENT","RESET_CAMERA_EVENT","updateCamera","activeCamera","getActiveCameraAndResetIfCreated","render","updateLightsGeometryToFollowCamera","camera","lights","forEach","light","lightTypeIsSceneLight","lightTypeIsHeadLight","setPositionFrom","getPositionByReference","setFocalPointFrom","getFocalPointByReference","modified","getMTime","lightTypeIsCameraLight","setTransformMatrix","getCameraLightTransformMatrix","create","updateLightGeometry","lightFollowCamera","allocateTime","updateGeometry","getVTKWindow","_renderWindow","setLayer","layer","getClassName","setPreserveColorBuffer","setActiveCamera","invokeEvent","makeCamera","getActiveCamera","resetCamera","getActors","actors","props","prop","addActor","addViewProp","removeActor","actor","filter","a","removeViewProp","removeAllActors","getVolumes","volumes","addVolume","removeVolume","volume","v","removeAllVolumes","hasLight","includes","addLight","removeLight","l","removeAllLights","setLightCollection","makeLight","createLight","automaticLightCreation","_createdLight","delete","setLightTypeToHeadLight","setPosition","getPosition","setFocalPoint","getFocalPoint","normalizedDisplayToWorld","x","y","z","aspect","vpd","normalizedDisplayToProjection","projectionToView","viewToWorld","worldToNormalizedDisplay","worldToView","viewToProjection","projectionToNormalizedDisplay","matrix","getViewMatrix","invert","transpose","result","Float64Array","transformMat4","getProjectionMatrix","computeVisiblePropBounds","allBounds","INIT_BOUNDS","nothingVisible","index","length","getVisibility","getUseBounds","bounds","getBounds","arguments","undefined","boundsToUse","center","vn","getViewPlaneNormal","setViewAngle","w1","w2","w3","radius","Math","sqrt","angle","getViewAngle","parallelScale","distance","sin","vup","getViewUp","abs","setViewUp","resetCameraClippingRange","setParallelScale","setPhysicalScale","setPhysicalTranslation","range","computeClippingRange","minGap","getParallelProjection","getParallelScale","tan","clippingRangeExpansion","nearClippingPlaneTolerance","setClippingRange","setRenderWindow","renderWindow","_vtkWindow","visibleActorCount","visibleVolumeCount","m1","mtime","m2","m3","getTransparent","preserveColorBuffer","isActiveCameraCreated","DEFAULT_VALUES","pickedProp","ambient","allocatedRenderTime","timeFactor","twoSidedLighting","lastRenderTimeInSeconds","numberOfPropsRendered","propArray","pathArray","preserveDepthBuffer","interactive","erase","draw","useShadows","useDepthPeeling","occlusionRatio","maximumNumberOfPeels","selector","delegate","texturedBackground","backgroundTexture","environmentTexture","environmentTextureDiffuseStrength","environmentTextureSpecularStrength","useEnvironmentTextureAsBackground","pass","extend","initialValues","Object","assign","background","vtkRenderer$1","default"],"sources":["/home/rakshith/Documents/RemoteRendering/vtk-js-react-app/node_modules/@kitware/vtk.js/Rendering/Core/Renderer.js"],"sourcesContent":["import { mat4, vec3 } from 'gl-matrix';\nimport { newInstance as newInstance$1, get, setGet, getArray, setGetArray, moveToProtected, vtkDebugMacro as vtkDebugMacro$1, vtkErrorMacro as vtkErrorMacro$1, vtkWarningMacro as vtkWarningMacro$1 } from '../../macros.js';\nimport vtkCamera from './Camera.js';\nimport vtkLight from './Light.js';\nimport { P as areBoundsInitialized, u as uninitializeBounds, r as radiansFromDegrees, d as dot, F as createUninitializedBounds } from '../../Common/Core/Math/index.js';\nimport vtkViewport from './Viewport.js';\nimport vtkBoundingBox from '../../Common/DataModel/BoundingBox.js';\n\nvar vtkDebugMacro = vtkDebugMacro$1,\n    vtkErrorMacro = vtkErrorMacro$1,\n    vtkWarningMacro = vtkWarningMacro$1;\n\nfunction notImplemented(method) {\n  return function () {\n    return vtkErrorMacro(\"vtkRenderer::\".concat(method, \" - NOT IMPLEMENTED\"));\n  };\n} // ----------------------------------------------------------------------------\n// vtkRenderer methods\n// ----------------------------------------------------------------------------\n\n\nfunction vtkRenderer(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkRenderer'); // Events\n\n  var COMPUTE_VISIBLE_PROP_BOUNDS_EVENT = {\n    type: 'ComputeVisiblePropBoundsEvent',\n    renderer: publicAPI\n  };\n  var RESET_CAMERA_CLIPPING_RANGE_EVENT = {\n    type: 'ResetCameraClippingRangeEvent',\n    renderer: publicAPI\n  };\n  var RESET_CAMERA_EVENT = {\n    type: 'ResetCameraEvent',\n    renderer: publicAPI\n  };\n\n  publicAPI.updateCamera = function () {\n    if (!model.activeCamera) {\n      vtkDebugMacro('No cameras are on, creating one.'); // the get method will automagically create a camera\n      // and reset it since one hasn't been specified yet.\n\n      publicAPI.getActiveCameraAndResetIfCreated();\n    } // update the viewing transformation\n\n\n    model.activeCamera.render(publicAPI);\n    return true;\n  };\n\n  publicAPI.updateLightsGeometryToFollowCamera = function () {\n    // only update the light's geometry if this Renderer is tracking\n    // this lights.  That allows one renderer to view the lights that\n    // another renderer is setting up.\n    var camera = publicAPI.getActiveCameraAndResetIfCreated();\n    model.lights.forEach(function (light) {\n      if (light.lightTypeIsSceneLight()) ; else if (light.lightTypeIsHeadLight()) {\n        // update position and orientation of light to match camera.\n        light.setPositionFrom(camera.getPositionByReference());\n        light.setFocalPointFrom(camera.getFocalPointByReference());\n        light.modified(camera.getMTime());\n      } else if (light.lightTypeIsCameraLight()) {\n        light.setTransformMatrix(camera.getCameraLightTransformMatrix(mat4.create()));\n      } else {\n        vtkErrorMacro('light has unknown light type', light.get());\n      }\n    });\n  };\n\n  publicAPI.updateLightGeometry = function () {\n    if (model.lightFollowCamera) {\n      // only update the light's geometry if this Renderer is tracking\n      // this lights.  That allows one renderer to view the lights that\n      // another renderer is setting up.\n      return publicAPI.updateLightsGeometryToFollowCamera();\n    }\n\n    return true;\n  };\n\n  publicAPI.allocateTime = notImplemented('allocateTime');\n  publicAPI.updateGeometry = notImplemented('updateGeometry');\n\n  publicAPI.getVTKWindow = function () {\n    return model._renderWindow;\n  };\n\n  publicAPI.setLayer = function (layer) {\n    vtkDebugMacro(publicAPI.getClassName(), publicAPI, 'setting Layer to ', layer);\n\n    if (model.layer !== layer) {\n      model.layer = layer;\n      publicAPI.modified();\n    }\n\n    publicAPI.setPreserveColorBuffer(!!layer);\n  };\n\n  publicAPI.setActiveCamera = function (camera) {\n    if (model.activeCamera === camera) {\n      return false;\n    }\n\n    model.activeCamera = camera;\n    publicAPI.modified();\n    publicAPI.invokeEvent({\n      type: 'ActiveCameraEvent',\n      camera: camera\n    });\n    return true;\n  };\n\n  publicAPI.makeCamera = function () {\n    var camera = vtkCamera.newInstance();\n    publicAPI.invokeEvent({\n      type: 'CreateCameraEvent',\n      camera: camera\n    });\n    return camera;\n  }; // Replace the set/get macro method\n\n\n  publicAPI.getActiveCamera = function () {\n    if (!model.activeCamera) {\n      model.activeCamera = publicAPI.makeCamera();\n    }\n\n    return model.activeCamera;\n  };\n\n  publicAPI.getActiveCameraAndResetIfCreated = function () {\n    if (!model.activeCamera) {\n      publicAPI.getActiveCamera();\n      publicAPI.resetCamera();\n    }\n\n    return model.activeCamera;\n  };\n\n  publicAPI.getActors = function () {\n    model.actors = [];\n    model.props.forEach(function (prop) {\n      model.actors = model.actors.concat(prop.getActors());\n    });\n    return model.actors;\n  };\n\n  publicAPI.addActor = publicAPI.addViewProp;\n\n  publicAPI.removeActor = function (actor) {\n    model.actors = model.actors.filter(function (a) {\n      return a !== actor;\n    });\n    publicAPI.removeViewProp(actor);\n    publicAPI.modified();\n  };\n\n  publicAPI.removeAllActors = function () {\n    var actors = publicAPI.getActors();\n    actors.forEach(function (actor) {\n      publicAPI.removeViewProp(actor);\n    });\n    model.actors = [];\n    publicAPI.modified();\n  };\n\n  publicAPI.getVolumes = function () {\n    model.volumes = [];\n    model.props.forEach(function (prop) {\n      model.volumes = model.volumes.concat(prop.getVolumes());\n    });\n    return model.volumes;\n  };\n\n  publicAPI.addVolume = publicAPI.addViewProp;\n\n  publicAPI.removeVolume = function (volume) {\n    model.volumes = model.volumes.filter(function (v) {\n      return v !== volume;\n    });\n    publicAPI.removeViewProp(volume);\n    publicAPI.modified();\n  };\n\n  publicAPI.removeAllVolumes = function () {\n    var volumes = publicAPI.getVolumes();\n    volumes.forEach(function (volume) {\n      publicAPI.removeViewProp(volume);\n    });\n    model.volumes = [];\n    publicAPI.modified();\n  };\n\n  publicAPI.hasLight = function (light) {\n    return model.lights.includes(light);\n  };\n\n  publicAPI.addLight = function (light) {\n    if (light && !publicAPI.hasLight(light)) {\n      model.lights.push(light);\n      publicAPI.modified();\n    }\n  };\n\n  publicAPI.removeLight = function (light) {\n    model.lights = model.lights.filter(function (l) {\n      return l !== light;\n    });\n    publicAPI.modified();\n  };\n\n  publicAPI.removeAllLights = function () {\n    model.lights = [];\n    publicAPI.modified();\n  };\n\n  publicAPI.setLightCollection = function (lights) {\n    model.lights = lights;\n    publicAPI.modified();\n  };\n\n  publicAPI.makeLight = vtkLight.newInstance;\n\n  publicAPI.createLight = function () {\n    if (!model.automaticLightCreation) {\n      return;\n    }\n\n    if (model._createdLight) {\n      publicAPI.removeLight(model._createdLight);\n\n      model._createdLight.delete();\n\n      model._createdLight = null;\n    }\n\n    model._createdLight = publicAPI.makeLight();\n    publicAPI.addLight(model._createdLight);\n\n    model._createdLight.setLightTypeToHeadLight(); // set these values just to have a good default should LightFollowCamera\n    // be turned off.\n\n\n    model._createdLight.setPosition(publicAPI.getActiveCamera().getPosition());\n\n    model._createdLight.setFocalPoint(publicAPI.getActiveCamera().getFocalPoint());\n  }; // requires the aspect ratio of the viewport as X/Y\n\n\n  publicAPI.normalizedDisplayToWorld = function (x, y, z, aspect) {\n    var vpd = publicAPI.normalizedDisplayToProjection(x, y, z);\n    vpd = publicAPI.projectionToView(vpd[0], vpd[1], vpd[2], aspect);\n    return publicAPI.viewToWorld(vpd[0], vpd[1], vpd[2]);\n  }; // requires the aspect ratio of the viewport as X/Y\n\n\n  publicAPI.worldToNormalizedDisplay = function (x, y, z, aspect) {\n    var vpd = publicAPI.worldToView(x, y, z);\n    vpd = publicAPI.viewToProjection(vpd[0], vpd[1], vpd[2], aspect);\n    return publicAPI.projectionToNormalizedDisplay(vpd[0], vpd[1], vpd[2]);\n  }; // requires the aspect ratio of the viewport as X/Y\n\n\n  publicAPI.viewToWorld = function (x, y, z) {\n    if (model.activeCamera === null) {\n      vtkErrorMacro('ViewToWorld: no active camera, cannot compute view to world, returning 0,0,0');\n      return [0, 0, 0];\n    } // get the view matrix from the active camera\n\n\n    var matrix = model.activeCamera.getViewMatrix();\n    mat4.invert(matrix, matrix);\n    mat4.transpose(matrix, matrix); // Transform point to world coordinates\n\n    var result = new Float64Array([x, y, z]);\n    vec3.transformMat4(result, result, matrix);\n    return result;\n  };\n\n  publicAPI.projectionToView = function (x, y, z, aspect) {\n    if (model.activeCamera === null) {\n      vtkErrorMacro('ProjectionToView: no active camera, cannot compute projection to view, returning 0,0,0');\n      return [0, 0, 0];\n    } // get the projection transformation from the active camera\n\n\n    var matrix = model.activeCamera.getProjectionMatrix(aspect, -1.0, 1.0);\n    mat4.invert(matrix, matrix);\n    mat4.transpose(matrix, matrix); // Transform point to world coordinates\n\n    var result = new Float64Array([x, y, z]);\n    vec3.transformMat4(result, result, matrix);\n    return result;\n  }; // Convert world point coordinates to view coordinates.\n\n\n  publicAPI.worldToView = function (x, y, z) {\n    if (model.activeCamera === null) {\n      vtkErrorMacro('WorldToView: no active camera, cannot compute view to world, returning 0,0,0');\n      return [0, 0, 0];\n    } // get the view transformation from the active camera\n\n\n    var matrix = model.activeCamera.getViewMatrix();\n    mat4.transpose(matrix, matrix);\n    var result = new Float64Array([x, y, z]);\n    vec3.transformMat4(result, result, matrix);\n    return result;\n  }; // Convert world point coordinates to view coordinates.\n  // requires the aspect ratio of the viewport as X/Y\n\n\n  publicAPI.viewToProjection = function (x, y, z, aspect) {\n    if (model.activeCamera === null) {\n      vtkErrorMacro('ViewToProjection: no active camera, cannot compute view to projection, returning 0,0,0');\n      return [0, 0, 0];\n    } // get the projeciton transformation from the active camera\n\n\n    var matrix = model.activeCamera.getProjectionMatrix(aspect, -1.0, 1.0);\n    mat4.transpose(matrix, matrix);\n    var result = new Float64Array([x, y, z]);\n    vec3.transformMat4(result, result, matrix);\n    return result;\n  };\n\n  publicAPI.computeVisiblePropBounds = function () {\n    model.allBounds[0] = vtkBoundingBox.INIT_BOUNDS[0];\n    model.allBounds[1] = vtkBoundingBox.INIT_BOUNDS[1];\n    model.allBounds[2] = vtkBoundingBox.INIT_BOUNDS[2];\n    model.allBounds[3] = vtkBoundingBox.INIT_BOUNDS[3];\n    model.allBounds[4] = vtkBoundingBox.INIT_BOUNDS[4];\n    model.allBounds[5] = vtkBoundingBox.INIT_BOUNDS[5];\n    var nothingVisible = true;\n    publicAPI.invokeEvent(COMPUTE_VISIBLE_PROP_BOUNDS_EVENT); // loop through all props\n\n    for (var index = 0; index < model.props.length; ++index) {\n      var prop = model.props[index];\n\n      if (prop.getVisibility() && prop.getUseBounds()) {\n        var bounds = prop.getBounds();\n\n        if (bounds && areBoundsInitialized(bounds)) {\n          nothingVisible = false;\n\n          if (bounds[0] < model.allBounds[0]) {\n            model.allBounds[0] = bounds[0];\n          }\n\n          if (bounds[1] > model.allBounds[1]) {\n            model.allBounds[1] = bounds[1];\n          }\n\n          if (bounds[2] < model.allBounds[2]) {\n            model.allBounds[2] = bounds[2];\n          }\n\n          if (bounds[3] > model.allBounds[3]) {\n            model.allBounds[3] = bounds[3];\n          }\n\n          if (bounds[4] < model.allBounds[4]) {\n            model.allBounds[4] = bounds[4];\n          }\n\n          if (bounds[5] > model.allBounds[5]) {\n            model.allBounds[5] = bounds[5];\n          }\n        }\n      }\n    }\n\n    if (nothingVisible) {\n      uninitializeBounds(model.allBounds);\n      vtkDebugMacro(\"Can't compute bounds, no 3D props are visible\");\n    }\n\n    return model.allBounds;\n  };\n\n  publicAPI.resetCamera = function () {\n    var bounds = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    var boundsToUse = bounds || publicAPI.computeVisiblePropBounds();\n    var center = [0, 0, 0];\n\n    if (!areBoundsInitialized(boundsToUse)) {\n      vtkDebugMacro('Cannot reset camera!');\n      return false;\n    }\n\n    var vn = null;\n\n    if (publicAPI.getActiveCamera()) {\n      vn = model.activeCamera.getViewPlaneNormal();\n    } else {\n      vtkErrorMacro('Trying to reset non-existent camera');\n      return false;\n    } // Reset the perspective zoom factors, otherwise subsequent zooms will cause\n    // the view angle to become very small and cause bad depth sorting.\n\n\n    model.activeCamera.setViewAngle(30.0);\n    center[0] = (boundsToUse[0] + boundsToUse[1]) / 2.0;\n    center[1] = (boundsToUse[2] + boundsToUse[3]) / 2.0;\n    center[2] = (boundsToUse[4] + boundsToUse[5]) / 2.0;\n    var w1 = boundsToUse[1] - boundsToUse[0];\n    var w2 = boundsToUse[3] - boundsToUse[2];\n    var w3 = boundsToUse[5] - boundsToUse[4];\n    w1 *= w1;\n    w2 *= w2;\n    w3 *= w3;\n    var radius = w1 + w2 + w3; // If we have just a single point, pick a radius of 1.0\n\n    radius = radius === 0 ? 1.0 : radius; // compute the radius of the enclosing sphere\n\n    radius = Math.sqrt(radius) * 0.5; // default so that the bounding sphere fits within the view fustrum\n    // compute the distance from the intersection of the view frustum with the\n    // bounding sphere. Basically in 2D draw a circle representing the bounding\n    // sphere in 2D then draw a horizontal line going out from the center of\n    // the circle. That is the camera view. Then draw a line from the camera\n    // position to the point where it intersects the circle. (it will be tangent\n    // to the circle at this point, this is important, only go to the tangent\n    // point, do not draw all the way to the view plane). Then draw the radius\n    // from the tangent point to the center of the circle. You will note that\n    // this forms a right triangle with one side being the radius, another being\n    // the target distance for the camera, then just find the target dist using\n    // a sin.\n\n    var angle = radiansFromDegrees(model.activeCamera.getViewAngle());\n    var parallelScale = radius;\n    var distance = radius / Math.sin(angle * 0.5); // check view-up vector against view plane normal\n\n    var vup = model.activeCamera.getViewUp();\n\n    if (Math.abs(dot(vup, vn)) > 0.999) {\n      vtkWarningMacro('Resetting view-up since view plane normal is parallel');\n      model.activeCamera.setViewUp(-vup[2], vup[0], vup[1]);\n    } // update the camera\n\n\n    model.activeCamera.setFocalPoint(center[0], center[1], center[2]);\n    model.activeCamera.setPosition(center[0] + distance * vn[0], center[1] + distance * vn[1], center[2] + distance * vn[2]);\n    publicAPI.resetCameraClippingRange(boundsToUse); // setup default parallel scale\n\n    model.activeCamera.setParallelScale(parallelScale); // update reasonable world to physical values\n\n    model.activeCamera.setPhysicalScale(radius);\n    model.activeCamera.setPhysicalTranslation(-center[0], -center[1], -center[2]); // Here to let parallel/distributed compositing intercept\n    // and do the right thing.\n\n    publicAPI.invokeEvent(RESET_CAMERA_EVENT);\n    return true;\n  };\n\n  publicAPI.resetCameraClippingRange = function () {\n    var bounds = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    var boundsToUse = bounds || publicAPI.computeVisiblePropBounds();\n\n    if (!areBoundsInitialized(boundsToUse)) {\n      vtkDebugMacro('Cannot reset camera clipping range!');\n      return false;\n    } // Make sure we have an active camera\n\n\n    publicAPI.getActiveCameraAndResetIfCreated();\n\n    if (!model.activeCamera) {\n      vtkErrorMacro('Trying to reset clipping range of non-existent camera');\n      return false;\n    } // Get the exact range for the bounds\n\n\n    var range = model.activeCamera.computeClippingRange(boundsToUse); // do not let far - near be less than 0.1 of the window height\n    // this is for cases such as 2D images which may have zero range\n\n    var minGap = 0.0;\n\n    if (model.activeCamera.getParallelProjection()) {\n      minGap = 0.2 * model.activeCamera.getParallelScale();\n    } else {\n      var angle = radiansFromDegrees(model.activeCamera.getViewAngle());\n      minGap = 0.2 * Math.tan(angle / 2.0) * range[1];\n    }\n\n    if (range[1] - range[0] < minGap) {\n      minGap = minGap - range[1] + range[0];\n      range[1] += minGap / 2.0;\n      range[0] -= minGap / 2.0;\n    } // Do not let the range behind the camera throw off the calculation.\n\n\n    if (range[0] < 0.0) {\n      range[0] = 0.0;\n    } // Give ourselves a little breathing room\n\n\n    range[0] = 0.99 * range[0] - (range[1] - range[0]) * model.clippingRangeExpansion;\n    range[1] = 1.01 * range[1] + (range[1] - range[0]) * model.clippingRangeExpansion; // Make sure near is not bigger than far\n\n    range[0] = range[0] >= range[1] ? 0.01 * range[1] : range[0]; // Make sure near is at least some fraction of far - this prevents near\n    // from being behind the camera or too close in front. How close is too\n    // close depends on the resolution of the depth buffer\n\n    if (!model.nearClippingPlaneTolerance) {\n      model.nearClippingPlaneTolerance = 0.01;\n    } // make sure the front clipping range is not too far from the far clippnig\n    // range, this is to make sure that the zbuffer resolution is effectively\n    // used\n\n\n    if (range[0] < model.nearClippingPlaneTolerance * range[1]) {\n      range[0] = model.nearClippingPlaneTolerance * range[1];\n    }\n\n    model.activeCamera.setClippingRange(range[0], range[1]); // Here to let parallel/distributed compositing intercept\n    // and do the right thing.\n\n    publicAPI.invokeEvent(RESET_CAMERA_CLIPPING_RANGE_EVENT);\n    return false;\n  };\n\n  publicAPI.setRenderWindow = function (renderWindow) {\n    if (renderWindow !== model._renderWindow) {\n      model._vtkWindow = renderWindow;\n      model._renderWindow = renderWindow;\n    }\n  };\n\n  publicAPI.visibleActorCount = function () {\n    return model.props.filter(function (prop) {\n      return prop.getVisibility();\n    }).length;\n  };\n\n  publicAPI.visibleVolumeCount = publicAPI.visibleActorCount;\n\n  publicAPI.getMTime = function () {\n    var m1 = model.mtime;\n    var m2 = model.activeCamera ? model.activeCamera.getMTime() : 0;\n\n    if (m2 > m1) {\n      m1 = m2;\n    }\n\n    var m3 = model._createdLight ? model._createdLight.getMTime() : 0;\n\n    if (m3 > m1) {\n      m1 = m3;\n    }\n\n    return m1;\n  };\n\n  publicAPI.getTransparent = function () {\n    return !!model.preserveColorBuffer;\n  };\n\n  publicAPI.isActiveCameraCreated = function () {\n    return !!model.activeCamera;\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\n\nvar DEFAULT_VALUES = {\n  pickedProp: null,\n  activeCamera: null,\n  allBounds: [],\n  ambient: [1, 1, 1],\n  allocatedRenderTime: 100,\n  timeFactor: 1,\n  automaticLightCreation: true,\n  twoSidedLighting: true,\n  lastRenderTimeInSeconds: -1,\n  renderWindow: null,\n  lights: [],\n  actors: [],\n  volumes: [],\n  lightFollowCamera: true,\n  numberOfPropsRendered: 0,\n  propArray: null,\n  pathArray: null,\n  layer: 0,\n  preserveColorBuffer: false,\n  preserveDepthBuffer: false,\n  computeVisiblePropBounds: createUninitializedBounds(),\n  interactive: true,\n  nearClippingPlaneTolerance: 0,\n  clippingRangeExpansion: 0.05,\n  erase: true,\n  draw: true,\n  useShadows: false,\n  useDepthPeeling: false,\n  occlusionRatio: 0,\n  maximumNumberOfPeels: 4,\n  selector: null,\n  delegate: null,\n  texturedBackground: false,\n  backgroundTexture: null,\n  environmentTexture: null,\n  environmentTextureDiffuseStrength: 1,\n  environmentTextureSpecularStrength: 1,\n  useEnvironmentTextureAsBackground: false,\n  pass: 0\n}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Inheritance\n\n  vtkViewport.extend(publicAPI, model, initialValues); // make sure background has 4 entries. Default to opaque black\n\n  if (!model.background) model.background = [0, 0, 0, 1];\n\n  while (model.background.length < 3) {\n    model.background.push(0);\n  }\n\n  if (model.background.length === 3) model.background.push(1); // Build VTK API\n\n  get(publicAPI, model, ['_renderWindow', 'allocatedRenderTime', 'timeFactor', 'lastRenderTimeInSeconds', 'numberOfPropsRendered', 'lastRenderingUsedDepthPeeling', 'selector']);\n  setGet(publicAPI, model, ['twoSidedLighting', 'lightFollowCamera', 'automaticLightCreation', 'erase', 'draw', 'nearClippingPlaneTolerance', 'clippingRangeExpansion', 'backingStore', 'interactive', 'layer', 'preserveColorBuffer', 'preserveDepthBuffer', 'useDepthPeeling', 'occlusionRatio', 'maximumNumberOfPeels', 'delegate', 'backgroundTexture', 'texturedBackground', 'environmentTexture', 'environmentTextureDiffuseStrength', 'environmentTextureSpecularStrength', 'useEnvironmentTextureAsBackground', 'useShadows', 'pass']);\n  getArray(publicAPI, model, ['actors', 'volumes', 'lights']);\n  setGetArray(publicAPI, model, ['background'], 4, 1.0);\n  moveToProtected(publicAPI, model, ['renderWindow']); // Object methods\n\n  vtkRenderer(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = newInstance$1(extend, 'vtkRenderer'); // ----------------------------------------------------------------------------\n\nvar vtkRenderer$1 = {\n  newInstance: newInstance,\n  extend: extend\n};\n\nexport { vtkRenderer$1 as default, extend, newInstance };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}