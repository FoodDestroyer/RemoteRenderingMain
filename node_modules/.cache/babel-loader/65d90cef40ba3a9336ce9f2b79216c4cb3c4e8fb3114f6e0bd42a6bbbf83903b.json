{"ast":null,"code":"import { vec3, mat4, quat } from 'gl-matrix';\nimport macro from '../../macros.js';\nimport vtkBufferObject from './BufferObject.js';\nimport { ObjectType } from './BufferObject/Constants.js';\nimport { Representation } from '../Core/Property/Constants.js';\nvar vtkErrorMacro = macro.vtkErrorMacro; // ----------------------------------------------------------------------------\n// Static functions\n// ----------------------------------------------------------------------------\n\nfunction computeInverseShiftAndScaleMatrix(coordShift, coordScale) {\n  var inverseScale = new Float64Array(3);\n  vec3.inverse(inverseScale, coordScale);\n  var matrix = new Float64Array(16);\n  mat4.fromRotationTranslationScale(matrix, quat.create(), coordShift, inverseScale);\n  return matrix;\n}\nfunction shouldApplyCoordShiftAndScale(coordShift, coordScale) {\n  if (coordShift === null || coordScale === null) {\n    return false;\n  }\n  return !(vec3.exactEquals(coordShift, [0, 0, 0]) && vec3.exactEquals(coordScale, [1, 1, 1]));\n} // ----------------------------------------------------------------------------\n// vtkOpenGLCellArrayBufferObject methods\n// ----------------------------------------------------------------------------\n\nfunction vtkOpenGLCellArrayBufferObject(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkOpenGLCellArrayBufferObject');\n  publicAPI.setType(ObjectType.ARRAY_BUFFER);\n  publicAPI.createVBO = function (cellArray, inRep, outRep, options) {\n    var selectionMaps = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n    if (!cellArray.getData() || !cellArray.getData().length) {\n      model.elementCount = 0;\n      return 0;\n    } // Figure out how big each block will be, currently 6 or 7 floats.\n\n    model.blockSize = 3;\n    model.vertexOffset = 0;\n    model.normalOffset = 0;\n    model.tCoordOffset = 0;\n    model.tCoordComponents = 0;\n    model.colorComponents = 0;\n    model.colorOffset = 0;\n    model.customData = [];\n    var pointData = options.points.getData();\n    var normalData = null;\n    var tcoordData = null;\n    var colorData = null;\n    var colorComponents = options.colors ? options.colors.getNumberOfComponents() : 0;\n    var textureComponents = options.tcoords ? options.tcoords.getNumberOfComponents() : 0; // the values of 4 below are because floats are 4 bytes\n\n    if (options.normals) {\n      model.normalOffset = 4 * model.blockSize;\n      model.blockSize += 3;\n      normalData = options.normals.getData();\n    }\n    if (options.customAttributes) {\n      options.customAttributes.forEach(function (a) {\n        if (a) {\n          model.customData.push({\n            data: a.getData(),\n            offset: 4 * model.blockSize,\n            components: a.getNumberOfComponents(),\n            name: a.getName()\n          });\n          model.blockSize += a.getNumberOfComponents();\n        }\n      });\n    }\n    if (options.tcoords) {\n      model.tCoordOffset = 4 * model.blockSize;\n      model.tCoordComponents = textureComponents;\n      model.blockSize += textureComponents;\n      tcoordData = options.tcoords.getData();\n    }\n    if (options.colors) {\n      model.colorComponents = options.colors.getNumberOfComponents();\n      model.colorOffset = 0;\n      colorData = options.colors.getData();\n      if (!model.colorBO) {\n        model.colorBO = vtkBufferObject.newInstance();\n      }\n      model.colorBO.setOpenGLRenderWindow(model._openGLRenderWindow);\n    } else {\n      model.colorBO = null;\n    }\n    model.stride = 4 * model.blockSize;\n    var pointIdx = 0;\n    var normalIdx = 0;\n    var tcoordIdx = 0;\n    var colorIdx = 0;\n    var custIdx = 0;\n    var cellCount = 0;\n    var addAPoint;\n    var cellBuilders = {\n      // easy, every input point becomes an output point\n      anythingToPoints: function anythingToPoints(numPoints, cellPts, offset) {\n        for (var i = 0; i < numPoints; ++i) {\n          addAPoint(cellPts[offset + i]);\n        }\n      },\n      linesToWireframe: function linesToWireframe(numPoints, cellPts, offset) {\n        // for lines we add a bunch of segments\n        for (var i = 0; i < numPoints - 1; ++i) {\n          addAPoint(cellPts[offset + i]);\n          addAPoint(cellPts[offset + i + 1]);\n        }\n      },\n      polysToWireframe: function polysToWireframe(numPoints, cellPts, offset) {\n        // for polys we add a bunch of segments and close it\n        if (numPoints > 2) {\n          for (var i = 0; i < numPoints; ++i) {\n            addAPoint(cellPts[offset + i]);\n            addAPoint(cellPts[offset + (i + 1) % numPoints]);\n          }\n        }\n      },\n      stripsToWireframe: function stripsToWireframe(numPoints, cellPts, offset) {\n        if (numPoints > 2) {\n          // for strips we add a bunch of segments and close it\n          for (var i = 0; i < numPoints - 1; ++i) {\n            addAPoint(cellPts[offset + i]);\n            addAPoint(cellPts[offset + i + 1]);\n          }\n          for (var _i = 0; _i < numPoints - 2; _i++) {\n            addAPoint(cellPts[offset + _i]);\n            addAPoint(cellPts[offset + _i + 2]);\n          }\n        }\n      },\n      polysToSurface: function polysToSurface(npts, cellPts, offset) {\n        for (var i = 0; i < npts - 2; i++) {\n          addAPoint(cellPts[offset + 0]);\n          addAPoint(cellPts[offset + i + 1]);\n          addAPoint(cellPts[offset + i + 2]);\n        }\n      },\n      stripsToSurface: function stripsToSurface(npts, cellPts, offset) {\n        for (var i = 0; i < npts - 2; i++) {\n          addAPoint(cellPts[offset + i]);\n          addAPoint(cellPts[offset + i + 1 + i % 2]);\n          addAPoint(cellPts[offset + i + 1 + (i + 1) % 2]);\n        }\n      }\n    };\n    var cellCounters = {\n      // easy, every input point becomes an output point\n      anythingToPoints: function anythingToPoints(numPoints, cellPts) {\n        return numPoints;\n      },\n      linesToWireframe: function linesToWireframe(numPoints, cellPts) {\n        if (numPoints > 1) {\n          return (numPoints - 1) * 2;\n        }\n        return 0;\n      },\n      polysToWireframe: function polysToWireframe(numPoints, cellPts) {\n        if (numPoints > 2) {\n          return numPoints * 2;\n        }\n        return 0;\n      },\n      stripsToWireframe: function stripsToWireframe(numPoints, cellPts) {\n        if (numPoints > 2) {\n          return numPoints * 4 - 6;\n        }\n        return 0;\n      },\n      polysToSurface: function polysToSurface(npts, cellPts) {\n        if (npts > 2) {\n          return (npts - 2) * 3;\n        }\n        return 0;\n      },\n      stripsToSurface: function stripsToSurface(npts, cellPts, offset) {\n        if (npts > 2) {\n          return (npts - 2) * 3;\n        }\n        return 0;\n      }\n    };\n    var func = null;\n    var countFunc = null;\n    if (outRep === Representation.POINTS || inRep === 'verts') {\n      func = cellBuilders.anythingToPoints;\n      countFunc = cellCounters.anythingToPoints;\n    } else if (outRep === Representation.WIREFRAME || inRep === 'lines') {\n      func = cellBuilders[\"\".concat(inRep, \"ToWireframe\")];\n      countFunc = cellCounters[\"\".concat(inRep, \"ToWireframe\")];\n    } else {\n      func = cellBuilders[\"\".concat(inRep, \"ToSurface\")];\n      countFunc = cellCounters[\"\".concat(inRep, \"ToSurface\")];\n    }\n    var array = cellArray.getData();\n    var size = array.length;\n    var caboCount = 0;\n    for (var index = 0; index < size;) {\n      caboCount += countFunc(array[index], array);\n      index += array[index] + 1;\n    }\n    var packedUCVBO = null;\n    var packedVBO = new Float32Array(caboCount * model.blockSize);\n    if (colorData) {\n      packedUCVBO = new Uint8Array(caboCount * 4);\n    }\n    var vboidx = 0;\n    var ucidx = 0; // Find out if shift scale should be used\n    // Compute squares of diagonal size and distance from the origin\n\n    var diagSq = 0.0;\n    var distSq = 0.0;\n    for (var i = 0; i < 3; ++i) {\n      var range = options.points.getRange(i);\n      var delta = range[1] - range[0];\n      diagSq += delta * delta;\n      var distShift = 0.5 * (range[1] + range[0]);\n      distSq += distShift * distShift;\n    }\n    var useShiftAndScale = diagSq > 0 && (Math.abs(distSq) / diagSq > 1.0e6 ||\n    // If data is far from the origin relative to its size\n    Math.abs(Math.log10(diagSq)) > 3.0 ||\n    // If the size is huge when not far from the origin\n    diagSq === 0 && distSq > 1.0e6); // If data is a point, but far from the origin\n\n    if (useShiftAndScale) {\n      // Compute shift and scale vectors\n      var coordShift = new Float64Array(3);\n      var coordScale = new Float64Array(3);\n      for (var _i2 = 0; _i2 < 3; ++_i2) {\n        var _range = options.points.getRange(_i2);\n        var _delta = _range[1] - _range[0];\n        coordShift[_i2] = 0.5 * (_range[1] + _range[0]);\n        coordScale[_i2] = _delta > 0 ? 1.0 / _delta : 1.0;\n      }\n      publicAPI.setCoordShiftAndScale(coordShift, coordScale);\n    } else if (model.coordShiftAndScaleEnabled === true) {\n      // Make sure to reset\n      publicAPI.setCoordShiftAndScale(null, null);\n    } // Initialize the structures used to keep track of point ids and cell ids for selectors\n\n    if (selectionMaps) {\n      if (!selectionMaps.points && !selectionMaps.cells) {\n        selectionMaps.points = new Int32Array(caboCount);\n        selectionMaps.cells = new Int32Array(caboCount);\n      } else {\n        var newPoints = new Int32Array(caboCount + selectionMaps.points.length);\n        newPoints.set(selectionMaps.points);\n        selectionMaps.points = newPoints;\n        var newCells = new Int32Array(caboCount + selectionMaps.cells.length);\n        newCells.set(selectionMaps.cells);\n        selectionMaps.cells = newCells;\n      }\n    }\n    var pointCount = options.vertexOffset;\n    addAPoint = function addAPointFunc(i) {\n      // Keep track of original point and cell ids, for selection\n      if (selectionMaps) {\n        selectionMaps.points[pointCount] = i;\n        selectionMaps.cells[pointCount] = cellCount + options.cellOffset;\n      }\n      ++pointCount; // Vertices\n\n      pointIdx = i * 3;\n      if (!model.coordShiftAndScaleEnabled) {\n        packedVBO[vboidx++] = pointData[pointIdx++];\n        packedVBO[vboidx++] = pointData[pointIdx++];\n        packedVBO[vboidx++] = pointData[pointIdx++];\n      } else {\n        // Apply shift and scale\n        packedVBO[vboidx++] = (pointData[pointIdx++] - model.coordShift[0]) * model.coordScale[0];\n        packedVBO[vboidx++] = (pointData[pointIdx++] - model.coordShift[1]) * model.coordScale[1];\n        packedVBO[vboidx++] = (pointData[pointIdx++] - model.coordShift[2]) * model.coordScale[2];\n      }\n      if (normalData !== null) {\n        if (options.haveCellNormals) {\n          normalIdx = (cellCount + options.cellOffset) * 3;\n        } else {\n          normalIdx = i * 3;\n        }\n        packedVBO[vboidx++] = normalData[normalIdx++];\n        packedVBO[vboidx++] = normalData[normalIdx++];\n        packedVBO[vboidx++] = normalData[normalIdx++];\n      }\n      model.customData.forEach(function (attr) {\n        custIdx = i * attr.components;\n        for (var j = 0; j < attr.components; ++j) {\n          packedVBO[vboidx++] = attr.data[custIdx++];\n        }\n      });\n      if (tcoordData !== null) {\n        tcoordIdx = i * textureComponents;\n        for (var j = 0; j < textureComponents; ++j) {\n          packedVBO[vboidx++] = tcoordData[tcoordIdx++];\n        }\n      }\n      if (colorData !== null) {\n        if (options.haveCellScalars) {\n          colorIdx = (cellCount + options.cellOffset) * colorComponents;\n        } else {\n          colorIdx = i * colorComponents;\n        }\n        packedUCVBO[ucidx++] = colorData[colorIdx++];\n        packedUCVBO[ucidx++] = colorData[colorIdx++];\n        packedUCVBO[ucidx++] = colorData[colorIdx++];\n        packedUCVBO[ucidx++] = colorComponents === 4 ? colorData[colorIdx++] : 255;\n      }\n    };\n    for (var _index = 0; _index < size;) {\n      func(array[_index], array, _index + 1);\n      _index += array[_index] + 1;\n      cellCount++;\n    }\n    model.elementCount = caboCount;\n    publicAPI.upload(packedVBO, ObjectType.ARRAY_BUFFER);\n    if (model.colorBO) {\n      model.colorBOStride = 4;\n      model.colorBO.upload(packedUCVBO, ObjectType.ARRAY_BUFFER);\n    }\n    return cellCount;\n  };\n  publicAPI.setCoordShiftAndScale = function (coordShift, coordScale) {\n    if (coordShift !== null && (coordShift.constructor !== Float64Array || coordShift.length !== 3)) {\n      vtkErrorMacro('Wrong type for coordShift, expected vec3 or null');\n      return;\n    }\n    if (coordScale !== null && (coordScale.constructor !== Float64Array || coordScale.length !== 3)) {\n      vtkErrorMacro('Wrong type for coordScale, expected vec3 or null');\n      return;\n    }\n    if (model.coordShift === null || coordShift === null || !vec3.equals(coordShift, model.coordShift)) {\n      model.coordShift = coordShift;\n    }\n    if (model.coordScale === null || coordScale === null || !vec3.equals(coordScale, model.coordScale)) {\n      model.coordScale = coordScale;\n    }\n    model.coordShiftAndScaleEnabled = shouldApplyCoordShiftAndScale(model.coordShift, model.coordScale);\n    if (model.coordShiftAndScaleEnabled) {\n      model.inverseShiftAndScaleMatrix = computeInverseShiftAndScaleMatrix(model.coordShift, model.coordScale);\n    } else {\n      model.inverseShiftAndScaleMatrix = null;\n    }\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nvar DEFAULT_VALUES = {\n  elementCount: 0,\n  stride: 0,\n  colorBOStride: 0,\n  vertexOffset: 0,\n  normalOffset: 0,\n  tCoordOffset: 0,\n  tCoordComponents: 0,\n  colorOffset: 0,\n  colorComponents: 0,\n  tcoordBO: null,\n  customData: [],\n  coordShift: null,\n  coordScale: null,\n  coordShiftAndScaleEnabled: false,\n  inverseShiftAndScaleMatrix: null\n}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Inheritance\n\n  vtkBufferObject.extend(publicAPI, model, initialValues);\n  macro.setGet(publicAPI, model, ['colorBO', 'elementCount', 'stride', 'colorBOStride', 'vertexOffset', 'normalOffset', 'tCoordOffset', 'tCoordComponents', 'colorOffset', 'colorComponents', 'customData']);\n  macro.get(publicAPI, model, ['coordShift', 'coordScale', 'coordShiftAndScaleEnabled', 'inverseShiftAndScaleMatrix']); // Object specific methods\n\n  vtkOpenGLCellArrayBufferObject(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = macro.newInstance(extend); // ----------------------------------------------------------------------------\n\nvar vtkCellArrayBufferObject = {\n  newInstance: newInstance,\n  extend: extend\n};\nexport { vtkCellArrayBufferObject as default, extend, newInstance };","map":{"version":3,"names":["vec3","mat4","quat","macro","vtkBufferObject","ObjectType","Representation","vtkErrorMacro","computeInverseShiftAndScaleMatrix","coordShift","coordScale","inverseScale","Float64Array","inverse","matrix","fromRotationTranslationScale","create","shouldApplyCoordShiftAndScale","exactEquals","vtkOpenGLCellArrayBufferObject","publicAPI","model","classHierarchy","push","setType","ARRAY_BUFFER","createVBO","cellArray","inRep","outRep","options","selectionMaps","arguments","length","undefined","getData","elementCount","blockSize","vertexOffset","normalOffset","tCoordOffset","tCoordComponents","colorComponents","colorOffset","customData","pointData","points","normalData","tcoordData","colorData","colors","getNumberOfComponents","textureComponents","tcoords","normals","customAttributes","forEach","a","data","offset","components","name","getName","colorBO","newInstance","setOpenGLRenderWindow","_openGLRenderWindow","stride","pointIdx","normalIdx","tcoordIdx","colorIdx","custIdx","cellCount","addAPoint","cellBuilders","anythingToPoints","numPoints","cellPts","i","linesToWireframe","polysToWireframe","stripsToWireframe","_i","polysToSurface","npts","stripsToSurface","cellCounters","func","countFunc","POINTS","WIREFRAME","concat","array","size","caboCount","index","packedUCVBO","packedVBO","Float32Array","Uint8Array","vboidx","ucidx","diagSq","distSq","range","getRange","delta","distShift","useShiftAndScale","Math","abs","log10","_i2","_range","_delta","setCoordShiftAndScale","coordShiftAndScaleEnabled","cells","Int32Array","newPoints","set","newCells","pointCount","addAPointFunc","cellOffset","haveCellNormals","attr","j","haveCellScalars","_index","upload","colorBOStride","constructor","equals","inverseShiftAndScaleMatrix","DEFAULT_VALUES","tcoordBO","extend","initialValues","Object","assign","setGet","get","vtkCellArrayBufferObject","default"],"sources":["/home/rakshith/Documents/RemoteRendering/vtk-js-react-app/node_modules/@kitware/vtk.js/Rendering/OpenGL/CellArrayBufferObject.js"],"sourcesContent":["import { vec3, mat4, quat } from 'gl-matrix';\nimport macro from '../../macros.js';\nimport vtkBufferObject from './BufferObject.js';\nimport { ObjectType } from './BufferObject/Constants.js';\nimport { Representation } from '../Core/Property/Constants.js';\n\nvar vtkErrorMacro = macro.vtkErrorMacro; // ----------------------------------------------------------------------------\n// Static functions\n// ----------------------------------------------------------------------------\n\nfunction computeInverseShiftAndScaleMatrix(coordShift, coordScale) {\n  var inverseScale = new Float64Array(3);\n  vec3.inverse(inverseScale, coordScale);\n  var matrix = new Float64Array(16);\n  mat4.fromRotationTranslationScale(matrix, quat.create(), coordShift, inverseScale);\n  return matrix;\n}\n\nfunction shouldApplyCoordShiftAndScale(coordShift, coordScale) {\n  if (coordShift === null || coordScale === null) {\n    return false;\n  }\n\n  return !(vec3.exactEquals(coordShift, [0, 0, 0]) && vec3.exactEquals(coordScale, [1, 1, 1]));\n} // ----------------------------------------------------------------------------\n// vtkOpenGLCellArrayBufferObject methods\n// ----------------------------------------------------------------------------\n\n\nfunction vtkOpenGLCellArrayBufferObject(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkOpenGLCellArrayBufferObject');\n  publicAPI.setType(ObjectType.ARRAY_BUFFER);\n\n  publicAPI.createVBO = function (cellArray, inRep, outRep, options) {\n    var selectionMaps = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n\n    if (!cellArray.getData() || !cellArray.getData().length) {\n      model.elementCount = 0;\n      return 0;\n    } // Figure out how big each block will be, currently 6 or 7 floats.\n\n\n    model.blockSize = 3;\n    model.vertexOffset = 0;\n    model.normalOffset = 0;\n    model.tCoordOffset = 0;\n    model.tCoordComponents = 0;\n    model.colorComponents = 0;\n    model.colorOffset = 0;\n    model.customData = [];\n    var pointData = options.points.getData();\n    var normalData = null;\n    var tcoordData = null;\n    var colorData = null;\n    var colorComponents = options.colors ? options.colors.getNumberOfComponents() : 0;\n    var textureComponents = options.tcoords ? options.tcoords.getNumberOfComponents() : 0; // the values of 4 below are because floats are 4 bytes\n\n    if (options.normals) {\n      model.normalOffset = 4 * model.blockSize;\n      model.blockSize += 3;\n      normalData = options.normals.getData();\n    }\n\n    if (options.customAttributes) {\n      options.customAttributes.forEach(function (a) {\n        if (a) {\n          model.customData.push({\n            data: a.getData(),\n            offset: 4 * model.blockSize,\n            components: a.getNumberOfComponents(),\n            name: a.getName()\n          });\n          model.blockSize += a.getNumberOfComponents();\n        }\n      });\n    }\n\n    if (options.tcoords) {\n      model.tCoordOffset = 4 * model.blockSize;\n      model.tCoordComponents = textureComponents;\n      model.blockSize += textureComponents;\n      tcoordData = options.tcoords.getData();\n    }\n\n    if (options.colors) {\n      model.colorComponents = options.colors.getNumberOfComponents();\n      model.colorOffset = 0;\n      colorData = options.colors.getData();\n\n      if (!model.colorBO) {\n        model.colorBO = vtkBufferObject.newInstance();\n      }\n\n      model.colorBO.setOpenGLRenderWindow(model._openGLRenderWindow);\n    } else {\n      model.colorBO = null;\n    }\n\n    model.stride = 4 * model.blockSize;\n    var pointIdx = 0;\n    var normalIdx = 0;\n    var tcoordIdx = 0;\n    var colorIdx = 0;\n    var custIdx = 0;\n    var cellCount = 0;\n    var addAPoint;\n    var cellBuilders = {\n      // easy, every input point becomes an output point\n      anythingToPoints: function anythingToPoints(numPoints, cellPts, offset) {\n        for (var i = 0; i < numPoints; ++i) {\n          addAPoint(cellPts[offset + i]);\n        }\n      },\n      linesToWireframe: function linesToWireframe(numPoints, cellPts, offset) {\n        // for lines we add a bunch of segments\n        for (var i = 0; i < numPoints - 1; ++i) {\n          addAPoint(cellPts[offset + i]);\n          addAPoint(cellPts[offset + i + 1]);\n        }\n      },\n      polysToWireframe: function polysToWireframe(numPoints, cellPts, offset) {\n        // for polys we add a bunch of segments and close it\n        if (numPoints > 2) {\n          for (var i = 0; i < numPoints; ++i) {\n            addAPoint(cellPts[offset + i]);\n            addAPoint(cellPts[offset + (i + 1) % numPoints]);\n          }\n        }\n      },\n      stripsToWireframe: function stripsToWireframe(numPoints, cellPts, offset) {\n        if (numPoints > 2) {\n          // for strips we add a bunch of segments and close it\n          for (var i = 0; i < numPoints - 1; ++i) {\n            addAPoint(cellPts[offset + i]);\n            addAPoint(cellPts[offset + i + 1]);\n          }\n\n          for (var _i = 0; _i < numPoints - 2; _i++) {\n            addAPoint(cellPts[offset + _i]);\n            addAPoint(cellPts[offset + _i + 2]);\n          }\n        }\n      },\n      polysToSurface: function polysToSurface(npts, cellPts, offset) {\n        for (var i = 0; i < npts - 2; i++) {\n          addAPoint(cellPts[offset + 0]);\n          addAPoint(cellPts[offset + i + 1]);\n          addAPoint(cellPts[offset + i + 2]);\n        }\n      },\n      stripsToSurface: function stripsToSurface(npts, cellPts, offset) {\n        for (var i = 0; i < npts - 2; i++) {\n          addAPoint(cellPts[offset + i]);\n          addAPoint(cellPts[offset + i + 1 + i % 2]);\n          addAPoint(cellPts[offset + i + 1 + (i + 1) % 2]);\n        }\n      }\n    };\n    var cellCounters = {\n      // easy, every input point becomes an output point\n      anythingToPoints: function anythingToPoints(numPoints, cellPts) {\n        return numPoints;\n      },\n      linesToWireframe: function linesToWireframe(numPoints, cellPts) {\n        if (numPoints > 1) {\n          return (numPoints - 1) * 2;\n        }\n\n        return 0;\n      },\n      polysToWireframe: function polysToWireframe(numPoints, cellPts) {\n        if (numPoints > 2) {\n          return numPoints * 2;\n        }\n\n        return 0;\n      },\n      stripsToWireframe: function stripsToWireframe(numPoints, cellPts) {\n        if (numPoints > 2) {\n          return numPoints * 4 - 6;\n        }\n\n        return 0;\n      },\n      polysToSurface: function polysToSurface(npts, cellPts) {\n        if (npts > 2) {\n          return (npts - 2) * 3;\n        }\n\n        return 0;\n      },\n      stripsToSurface: function stripsToSurface(npts, cellPts, offset) {\n        if (npts > 2) {\n          return (npts - 2) * 3;\n        }\n\n        return 0;\n      }\n    };\n    var func = null;\n    var countFunc = null;\n\n    if (outRep === Representation.POINTS || inRep === 'verts') {\n      func = cellBuilders.anythingToPoints;\n      countFunc = cellCounters.anythingToPoints;\n    } else if (outRep === Representation.WIREFRAME || inRep === 'lines') {\n      func = cellBuilders[\"\".concat(inRep, \"ToWireframe\")];\n      countFunc = cellCounters[\"\".concat(inRep, \"ToWireframe\")];\n    } else {\n      func = cellBuilders[\"\".concat(inRep, \"ToSurface\")];\n      countFunc = cellCounters[\"\".concat(inRep, \"ToSurface\")];\n    }\n\n    var array = cellArray.getData();\n    var size = array.length;\n    var caboCount = 0;\n\n    for (var index = 0; index < size;) {\n      caboCount += countFunc(array[index], array);\n      index += array[index] + 1;\n    }\n\n    var packedUCVBO = null;\n    var packedVBO = new Float32Array(caboCount * model.blockSize);\n\n    if (colorData) {\n      packedUCVBO = new Uint8Array(caboCount * 4);\n    }\n\n    var vboidx = 0;\n    var ucidx = 0; // Find out if shift scale should be used\n    // Compute squares of diagonal size and distance from the origin\n\n    var diagSq = 0.0;\n    var distSq = 0.0;\n\n    for (var i = 0; i < 3; ++i) {\n      var range = options.points.getRange(i);\n      var delta = range[1] - range[0];\n      diagSq += delta * delta;\n      var distShift = 0.5 * (range[1] + range[0]);\n      distSq += distShift * distShift;\n    }\n\n    var useShiftAndScale = diagSq > 0 && (Math.abs(distSq) / diagSq > 1.0e6 || // If data is far from the origin relative to its size\n    Math.abs(Math.log10(diagSq)) > 3.0 || // If the size is huge when not far from the origin\n    diagSq === 0 && distSq > 1.0e6); // If data is a point, but far from the origin\n\n    if (useShiftAndScale) {\n      // Compute shift and scale vectors\n      var coordShift = new Float64Array(3);\n      var coordScale = new Float64Array(3);\n\n      for (var _i2 = 0; _i2 < 3; ++_i2) {\n        var _range = options.points.getRange(_i2);\n\n        var _delta = _range[1] - _range[0];\n\n        coordShift[_i2] = 0.5 * (_range[1] + _range[0]);\n        coordScale[_i2] = _delta > 0 ? 1.0 / _delta : 1.0;\n      }\n\n      publicAPI.setCoordShiftAndScale(coordShift, coordScale);\n    } else if (model.coordShiftAndScaleEnabled === true) {\n      // Make sure to reset\n      publicAPI.setCoordShiftAndScale(null, null);\n    } // Initialize the structures used to keep track of point ids and cell ids for selectors\n\n\n    if (selectionMaps) {\n      if (!selectionMaps.points && !selectionMaps.cells) {\n        selectionMaps.points = new Int32Array(caboCount);\n        selectionMaps.cells = new Int32Array(caboCount);\n      } else {\n        var newPoints = new Int32Array(caboCount + selectionMaps.points.length);\n        newPoints.set(selectionMaps.points);\n        selectionMaps.points = newPoints;\n        var newCells = new Int32Array(caboCount + selectionMaps.cells.length);\n        newCells.set(selectionMaps.cells);\n        selectionMaps.cells = newCells;\n      }\n    }\n\n    var pointCount = options.vertexOffset;\n\n    addAPoint = function addAPointFunc(i) {\n      // Keep track of original point and cell ids, for selection\n      if (selectionMaps) {\n        selectionMaps.points[pointCount] = i;\n        selectionMaps.cells[pointCount] = cellCount + options.cellOffset;\n      }\n\n      ++pointCount; // Vertices\n\n      pointIdx = i * 3;\n\n      if (!model.coordShiftAndScaleEnabled) {\n        packedVBO[vboidx++] = pointData[pointIdx++];\n        packedVBO[vboidx++] = pointData[pointIdx++];\n        packedVBO[vboidx++] = pointData[pointIdx++];\n      } else {\n        // Apply shift and scale\n        packedVBO[vboidx++] = (pointData[pointIdx++] - model.coordShift[0]) * model.coordScale[0];\n        packedVBO[vboidx++] = (pointData[pointIdx++] - model.coordShift[1]) * model.coordScale[1];\n        packedVBO[vboidx++] = (pointData[pointIdx++] - model.coordShift[2]) * model.coordScale[2];\n      }\n\n      if (normalData !== null) {\n        if (options.haveCellNormals) {\n          normalIdx = (cellCount + options.cellOffset) * 3;\n        } else {\n          normalIdx = i * 3;\n        }\n\n        packedVBO[vboidx++] = normalData[normalIdx++];\n        packedVBO[vboidx++] = normalData[normalIdx++];\n        packedVBO[vboidx++] = normalData[normalIdx++];\n      }\n\n      model.customData.forEach(function (attr) {\n        custIdx = i * attr.components;\n\n        for (var j = 0; j < attr.components; ++j) {\n          packedVBO[vboidx++] = attr.data[custIdx++];\n        }\n      });\n\n      if (tcoordData !== null) {\n        tcoordIdx = i * textureComponents;\n\n        for (var j = 0; j < textureComponents; ++j) {\n          packedVBO[vboidx++] = tcoordData[tcoordIdx++];\n        }\n      }\n\n      if (colorData !== null) {\n        if (options.haveCellScalars) {\n          colorIdx = (cellCount + options.cellOffset) * colorComponents;\n        } else {\n          colorIdx = i * colorComponents;\n        }\n\n        packedUCVBO[ucidx++] = colorData[colorIdx++];\n        packedUCVBO[ucidx++] = colorData[colorIdx++];\n        packedUCVBO[ucidx++] = colorData[colorIdx++];\n        packedUCVBO[ucidx++] = colorComponents === 4 ? colorData[colorIdx++] : 255;\n      }\n    };\n\n    for (var _index = 0; _index < size;) {\n      func(array[_index], array, _index + 1);\n      _index += array[_index] + 1;\n      cellCount++;\n    }\n\n    model.elementCount = caboCount;\n    publicAPI.upload(packedVBO, ObjectType.ARRAY_BUFFER);\n\n    if (model.colorBO) {\n      model.colorBOStride = 4;\n      model.colorBO.upload(packedUCVBO, ObjectType.ARRAY_BUFFER);\n    }\n\n    return cellCount;\n  };\n\n  publicAPI.setCoordShiftAndScale = function (coordShift, coordScale) {\n    if (coordShift !== null && (coordShift.constructor !== Float64Array || coordShift.length !== 3)) {\n      vtkErrorMacro('Wrong type for coordShift, expected vec3 or null');\n      return;\n    }\n\n    if (coordScale !== null && (coordScale.constructor !== Float64Array || coordScale.length !== 3)) {\n      vtkErrorMacro('Wrong type for coordScale, expected vec3 or null');\n      return;\n    }\n\n    if (model.coordShift === null || coordShift === null || !vec3.equals(coordShift, model.coordShift)) {\n      model.coordShift = coordShift;\n    }\n\n    if (model.coordScale === null || coordScale === null || !vec3.equals(coordScale, model.coordScale)) {\n      model.coordScale = coordScale;\n    }\n\n    model.coordShiftAndScaleEnabled = shouldApplyCoordShiftAndScale(model.coordShift, model.coordScale);\n\n    if (model.coordShiftAndScaleEnabled) {\n      model.inverseShiftAndScaleMatrix = computeInverseShiftAndScaleMatrix(model.coordShift, model.coordScale);\n    } else {\n      model.inverseShiftAndScaleMatrix = null;\n    }\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\n\nvar DEFAULT_VALUES = {\n  elementCount: 0,\n  stride: 0,\n  colorBOStride: 0,\n  vertexOffset: 0,\n  normalOffset: 0,\n  tCoordOffset: 0,\n  tCoordComponents: 0,\n  colorOffset: 0,\n  colorComponents: 0,\n  tcoordBO: null,\n  customData: [],\n  coordShift: null,\n  coordScale: null,\n  coordShiftAndScaleEnabled: false,\n  inverseShiftAndScaleMatrix: null\n}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Inheritance\n\n  vtkBufferObject.extend(publicAPI, model, initialValues);\n  macro.setGet(publicAPI, model, ['colorBO', 'elementCount', 'stride', 'colorBOStride', 'vertexOffset', 'normalOffset', 'tCoordOffset', 'tCoordComponents', 'colorOffset', 'colorComponents', 'customData']);\n  macro.get(publicAPI, model, ['coordShift', 'coordScale', 'coordShiftAndScaleEnabled', 'inverseShiftAndScaleMatrix']); // Object specific methods\n\n  vtkOpenGLCellArrayBufferObject(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = macro.newInstance(extend); // ----------------------------------------------------------------------------\n\nvar vtkCellArrayBufferObject = {\n  newInstance: newInstance,\n  extend: extend\n};\n\nexport { vtkCellArrayBufferObject as default, extend, newInstance };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}