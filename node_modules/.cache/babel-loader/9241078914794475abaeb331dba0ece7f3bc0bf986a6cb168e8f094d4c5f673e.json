{"ast":null,"code":"import _toConsumableArray from '@babel/runtime/helpers/toConsumableArray';\nimport macro from '../../macros.js';\nimport vtkMouseRangeManipulator from '../../Interaction/Manipulators/MouseRangeManipulator.js';\nimport vtkViewProxy from './ViewProxy.js';\nimport { j as cross, E as getMajorAxisIndex, r as radiansFromDegrees } from '../../Common/Core/Math/index.js';\nimport { mat4, vec3 } from 'gl-matrix';\nimport vtkBoundingBox from '../../Common/DataModel/BoundingBox.js';\nvar DEFAULT_STEP_WIDTH = 512;\nfunction formatAnnotationValue(value) {\n  if (Array.isArray(value)) {\n    return value.map(formatAnnotationValue).join(', ');\n  }\n  if (Number.isInteger(value)) {\n    return value;\n  }\n  if (Number.isFinite(value)) {\n    if (Math.abs(value) < 0.01) {\n      return '0';\n    }\n    return value.toFixed(2);\n  }\n  return value;\n}\n/**\n * Returns an array of points in world coordinates creating a coarse hull\n * around the prop given in argument\n * The returned array is empty if the prop is not visible or doesn't use bounds\n *\n * How it works: if possible, combine the mapper bounds corners with the prop matrix\n * otherwise, returns the prop bounds corners\n */\n\nfunction getPropCoarseHull(prop) {\n  var _prop$getMapper, _mapper$getBounds;\n  if (!prop.getVisibility() || !prop.getUseBounds()) {\n    return [];\n  }\n  var finestBounds = prop.getBounds();\n  var finestMatrix = null; // Better bounds using mapper bounds and prop matrix\n\n  var mapper = prop === null || prop === void 0 ? void 0 : (_prop$getMapper = prop.getMapper) === null || _prop$getMapper === void 0 ? void 0 : _prop$getMapper.call(prop);\n  var mapperBounds = mapper === null || mapper === void 0 ? void 0 : (_mapper$getBounds = mapper.getBounds) === null || _mapper$getBounds === void 0 ? void 0 : _mapper$getBounds.call(mapper);\n  if (vtkBoundingBox.isValid(mapperBounds) && prop.getMatrix) {\n    var _mapper$getInputData;\n    finestBounds = mapperBounds;\n    finestMatrix = prop.getMatrix().slice();\n    mat4.transpose(finestMatrix, finestMatrix); // Better bounds using the image data matrix and prop matrix + imageData matrix\n\n    if (mapper.isA('vtkImageMapper') && (_mapper$getInputData = mapper.getInputData()) !== null && _mapper$getInputData !== void 0 && _mapper$getInputData.isA('vtkImageData')) {\n      prop.computeMatrix();\n      var imageData = mapper.getInputData();\n      finestBounds = imageData.getSpatialExtent();\n      var imageDataMatrix = imageData.getIndexToWorld();\n      mat4.mul(finestMatrix, finestMatrix, imageDataMatrix);\n    }\n  } // Compute corners and transform them if needed\n  // It gives a more accurate hull than computing the corners of a transformed bounding box\n\n  if (!vtkBoundingBox.isValid(finestBounds)) {\n    return [];\n  }\n  var corners = [];\n  vtkBoundingBox.getCorners(finestBounds, corners);\n  if (finestMatrix) {\n    corners.forEach(function (pt) {\n      return vec3.transformMat4(pt, pt, finestMatrix);\n    });\n  }\n  return corners;\n} // ----------------------------------------------------------------------------\n// vtkView2DProxy methods\n// ----------------------------------------------------------------------------\n\nfunction vtkView2DProxy(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkView2DProxy');\n  publicAPI.updateWidthHeightAnnotation = function () {\n    var _model$cornerAnnotati = model.cornerAnnotation.getMetadata(),\n      ijkOrientation = _model$cornerAnnotati.ijkOrientation,\n      dimensions = _model$cornerAnnotati.dimensions;\n    if (ijkOrientation && dimensions) {\n      var realDimensions = dimensions;\n      if (dimensions.length > 3) {\n        // the dimensions is a string\n        realDimensions = dimensions.split(',').map(Number);\n      }\n      var dop = model.camera.getDirectionOfProjection();\n      var viewUp = model.camera.getViewUp();\n      var viewRight = [0, 0, 0];\n      cross(dop, viewUp, viewRight);\n      var wIdx = getMajorAxisIndex(viewRight);\n      var hIdx = getMajorAxisIndex(viewUp);\n      var sliceWidth = realDimensions['IJK'.indexOf(ijkOrientation[wIdx])];\n      var sliceHeight = realDimensions['IJK'.indexOf(ijkOrientation[hIdx])];\n      publicAPI.updateCornerAnnotation({\n        sliceWidth: sliceWidth,\n        sliceHeight: sliceHeight\n      });\n    }\n  };\n  var superUpdateOrientation = publicAPI.updateOrientation;\n  publicAPI.updateOrientation = function (axisIndex, orientation, viewUp) {\n    var promise = superUpdateOrientation(axisIndex, orientation, viewUp);\n    var count = model.representations.length;\n    while (count--) {\n      var rep = model.representations[count];\n      var slicingMode = 'XYZ'[axisIndex];\n      if (rep.setSlicingMode) {\n        rep.setSlicingMode(slicingMode);\n      }\n    }\n    publicAPI.updateCornerAnnotation({\n      axis: 'XYZ'[axisIndex]\n    });\n    return promise;\n  };\n  var superAddRepresentation = publicAPI.addRepresentation;\n  publicAPI.addRepresentation = function (rep) {\n    superAddRepresentation(rep);\n    if (rep.setSlicingMode) {\n      rep.setSlicingMode('XYZ'[model.axis]);\n    }\n    publicAPI.bindRepresentationToManipulator(rep);\n  };\n  var superRemoveRepresentation = publicAPI.removeRepresentation;\n  publicAPI.removeRepresentation = function (rep) {\n    superRemoveRepresentation(rep);\n    if (rep === model.sliceRepresentation) {\n      publicAPI.bindRepresentationToManipulator(null);\n      var count = model.representations.length;\n      while (count--) {\n        if (publicAPI.bindRepresentationToManipulator(model.representations[count])) {\n          count = 0;\n        }\n      }\n    }\n  };\n  var superInternalResetCamera = model._resetCamera;\n  /**\n   * If fitProps is true, calling resetCamera will exactly fit the bounds in the view\n   * Exact fitting requires useParallelRendering, and an active camera\n   * Otherwise, the default renderer.resetCamera is used and it uses a larger bounding box\n   */\n\n  model._resetCamera = function () {\n    var bounds = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    // Always reset camera first to set physicalScale, physicalTranslation and trigger events\n    var initialReset = superInternalResetCamera(bounds);\n    if (!model.fitProps || !model.useParallelRendering || !initialReset) {\n      return initialReset;\n    } // For each visible prop get the smallest possible convex hull using bounds corners\n\n    var visiblePoints = [];\n    if (bounds) {\n      // Bounds are given as argument, use their corners\n      vtkBoundingBox.getCorners(bounds, visiblePoints);\n    } else {\n      publicAPI.getRepresentations().forEach(function (representationProxy) {\n        return [representationProxy.getActors(), representationProxy.getVolumes()].flat().forEach(function (prop) {\n          return visiblePoints.push.apply(visiblePoints, _toConsumableArray(getPropCoarseHull(prop)));\n        });\n      });\n    }\n    if (!visiblePoints) {\n      return initialReset;\n    } // Get the bounds in view coordinates\n\n    var viewBounds = vtkBoundingBox.reset([]);\n    var viewMatrix = model.camera.getViewMatrix();\n    mat4.transpose(viewMatrix, viewMatrix);\n    for (var i = 0; i < visiblePoints.length; ++i) {\n      var point = visiblePoints[i];\n      vec3.transformMat4(point, point, viewMatrix);\n      vtkBoundingBox.addPoint.apply(vtkBoundingBox, [viewBounds].concat(_toConsumableArray(point)));\n    } // Compute parallel scale\n\n    var view = model.renderer.getRenderWindow().getViews()[0];\n    var dims = view.getViewportSize(model.renderer);\n    var aspect = dims[1] && dims[0] ? dims[0] / dims[1] : 1;\n    var xLength = vtkBoundingBox.getLength(viewBounds, 0);\n    var yLength = vtkBoundingBox.getLength(viewBounds, 1);\n    var parallelScale = 0.5 * Math.max(yLength, xLength / aspect); // Compute focal point and position\n\n    var viewFocalPoint = vtkBoundingBox.getCenter(viewBounds); // Camera position in view coordinates is the center of the bounds in XY\n    // and is (the maximum bound) + (the distance to see the bounds in perspective) in Z\n\n    var perspectiveAngle = radiansFromDegrees(model.camera.getViewAngle());\n    var distance = parallelScale / Math.tan(perspectiveAngle * 0.5);\n    var viewPosition = [viewFocalPoint[0], viewFocalPoint[1], viewBounds[5] + distance];\n    var inverseViewMatrix = new Float64Array(16);\n    var worldFocalPoint = new Float64Array(3);\n    var worldPosition = new Float64Array(3);\n    mat4.invert(inverseViewMatrix, viewMatrix);\n    vec3.transformMat4(worldFocalPoint, viewFocalPoint, inverseViewMatrix);\n    vec3.transformMat4(worldPosition, viewPosition, inverseViewMatrix);\n    if (parallelScale <= 0) {\n      return initialReset;\n    } // Compute bounds in world coordinates\n\n    var worldBounds = vtkBoundingBox.transformBounds(viewBounds, inverseViewMatrix);\n    publicAPI.setCameraParameters({\n      position: worldPosition,\n      focalPoint: worldFocalPoint,\n      bounds: worldBounds,\n      parallelScale: parallelScale\n    });\n    return true;\n  }; // --------------------------------------------------------------------------\n  // Range Manipulator setup\n  // -------------------------------------------------------------------------\n\n  model.rangeManipulator = vtkMouseRangeManipulator.newInstance({\n    button: 1,\n    scrollEnabled: true\n  });\n  model.interactorStyle2D.addMouseManipulator(model.rangeManipulator);\n  function setWindowWidth(windowWidth) {\n    publicAPI.updateCornerAnnotation({\n      windowWidth: windowWidth\n    });\n    if (model.sliceRepresentation && model.sliceRepresentation.setWindowWidth) {\n      model.sliceRepresentation.setWindowWidth(windowWidth);\n    }\n  }\n  function setWindowLevel(windowLevel) {\n    publicAPI.updateCornerAnnotation({\n      windowLevel: windowLevel\n    });\n    if (model.sliceRepresentation && model.sliceRepresentation.setWindowLevel) {\n      model.sliceRepresentation.setWindowLevel(windowLevel);\n    }\n  }\n  function setSlice(sliceRaw) {\n    var numberSliceRaw = Number(sliceRaw);\n    var slice = Number.isInteger(numberSliceRaw) ? sliceRaw : numberSliceRaw.toFixed(2); // add 'slice' in annotation\n\n    var annotation = {\n      slice: slice\n    };\n    if (model.sliceRepresentation && model.sliceRepresentation.setSlice) {\n      model.sliceRepresentation.setSlice(numberSliceRaw);\n    } // extend annotation\n\n    if (model.sliceRepresentation && model.sliceRepresentation.getAnnotations) {\n      var addOn = model.sliceRepresentation.getAnnotations();\n      Object.keys(addOn).forEach(function (key) {\n        annotation[key] = formatAnnotationValue(addOn[key]);\n      });\n    }\n    publicAPI.updateCornerAnnotation(annotation);\n  }\n  publicAPI.bindRepresentationToManipulator = function (representation) {\n    var nbListeners = 0;\n    model.rangeManipulator.removeAllListeners();\n    model.sliceRepresentation = representation;\n    while (model.sliceRepresentationSubscriptions.length) {\n      model.sliceRepresentationSubscriptions.pop().unsubscribe();\n    }\n    if (representation) {\n      model.sliceRepresentationSubscriptions.push(model.camera.onModified(publicAPI.updateWidthHeightAnnotation));\n      if (representation.getWindowWidth) {\n        var update = function update() {\n          return setWindowWidth(representation.getWindowWidth());\n        };\n        var windowWidth = representation.getPropertyDomainByName('windowWidth');\n        var min = windowWidth.min,\n          max = windowWidth.max;\n        var step = windowWidth.step;\n        if (!step || step === 'any') {\n          step = 1 / DEFAULT_STEP_WIDTH;\n        }\n        model.rangeManipulator.setVerticalListener(min, max, step, representation.getWindowWidth, setWindowWidth);\n        model.sliceRepresentationSubscriptions.push(representation.onModified(update));\n        update();\n        nbListeners++;\n      }\n      if (representation.getWindowLevel) {\n        var _update = function _update() {\n          return setWindowLevel(representation.getWindowLevel());\n        };\n        var windowLevel = representation.getPropertyDomainByName('windowLevel');\n        var _min = windowLevel.min,\n          _max = windowLevel.max;\n        var _step = windowLevel.step;\n        if (!_step || _step === 'any') {\n          _step = 1 / DEFAULT_STEP_WIDTH;\n        }\n        model.rangeManipulator.setHorizontalListener(_min, _max, _step, representation.getWindowLevel, setWindowLevel);\n        model.sliceRepresentationSubscriptions.push(representation.onModified(_update));\n        _update();\n        nbListeners++;\n      }\n      var domain = representation.getPropertyDomainByName('slice');\n      if (representation.getSlice && domain) {\n        var _update2 = function _update2() {\n          return setSlice(representation.getSlice());\n        };\n        model.rangeManipulator.setScrollListener(domain.min, domain.max, domain.step, representation.getSlice, setSlice);\n        model.sliceRepresentationSubscriptions.push(representation.onModified(_update2));\n        _update2();\n        nbListeners++;\n      }\n    }\n    return nbListeners;\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nvar DEFAULT_VALUES = {\n  axis: 2,\n  orientation: -1,\n  viewUp: [0, 1, 0],\n  useParallelRendering: true,\n  sliceRepresentationSubscriptions: [],\n  fitProps: false\n}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n  vtkViewProxy.extend(publicAPI, model, initialValues);\n  macro.get(publicAPI, model, ['axis']);\n  macro.setGet(publicAPI, model, ['fitProps']); // Object specific methods\n\n  vtkView2DProxy(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = macro.newInstance(extend, 'vtkView2DProxy'); // ----------------------------------------------------------------------------\n\nvar vtkView2DProxy$1 = {\n  newInstance: newInstance,\n  extend: extend\n};\nexport { vtkView2DProxy$1 as default, extend, newInstance };","map":{"version":3,"names":["_toConsumableArray","macro","vtkMouseRangeManipulator","vtkViewProxy","j","cross","E","getMajorAxisIndex","r","radiansFromDegrees","mat4","vec3","vtkBoundingBox","DEFAULT_STEP_WIDTH","formatAnnotationValue","value","Array","isArray","map","join","Number","isInteger","isFinite","Math","abs","toFixed","getPropCoarseHull","prop","_prop$getMapper","_mapper$getBounds","getVisibility","getUseBounds","finestBounds","getBounds","finestMatrix","mapper","getMapper","call","mapperBounds","isValid","getMatrix","_mapper$getInputData","slice","transpose","isA","getInputData","computeMatrix","imageData","getSpatialExtent","imageDataMatrix","getIndexToWorld","mul","corners","getCorners","forEach","pt","transformMat4","vtkView2DProxy","publicAPI","model","classHierarchy","push","updateWidthHeightAnnotation","_model$cornerAnnotati","cornerAnnotation","getMetadata","ijkOrientation","dimensions","realDimensions","length","split","dop","camera","getDirectionOfProjection","viewUp","getViewUp","viewRight","wIdx","hIdx","sliceWidth","indexOf","sliceHeight","updateCornerAnnotation","superUpdateOrientation","updateOrientation","axisIndex","orientation","promise","count","representations","rep","slicingMode","setSlicingMode","axis","superAddRepresentation","addRepresentation","bindRepresentationToManipulator","superRemoveRepresentation","removeRepresentation","sliceRepresentation","superInternalResetCamera","_resetCamera","bounds","arguments","undefined","initialReset","fitProps","useParallelRendering","visiblePoints","getRepresentations","representationProxy","getActors","getVolumes","flat","apply","viewBounds","reset","viewMatrix","getViewMatrix","i","point","addPoint","concat","view","renderer","getRenderWindow","getViews","dims","getViewportSize","aspect","xLength","getLength","yLength","parallelScale","max","viewFocalPoint","getCenter","perspectiveAngle","getViewAngle","distance","tan","viewPosition","inverseViewMatrix","Float64Array","worldFocalPoint","worldPosition","invert","worldBounds","transformBounds","setCameraParameters","position","focalPoint","rangeManipulator","newInstance","button","scrollEnabled","interactorStyle2D","addMouseManipulator","setWindowWidth","windowWidth","setWindowLevel","windowLevel","setSlice","sliceRaw","numberSliceRaw","annotation","getAnnotations","addOn","Object","keys","key","representation","nbListeners","removeAllListeners","sliceRepresentationSubscriptions","pop","unsubscribe","onModified","getWindowWidth","update","getPropertyDomainByName","min","step","setVerticalListener","getWindowLevel","_update","_min","_max","_step","setHorizontalListener","domain","getSlice","_update2","setScrollListener","DEFAULT_VALUES","extend","initialValues","assign","get","setGet","vtkView2DProxy$1","default"],"sources":["/home/rakshith/Documents/RemoteRendering/vtk-js-react-app/node_modules/@kitware/vtk.js/Proxy/Core/View2DProxy.js"],"sourcesContent":["import _toConsumableArray from '@babel/runtime/helpers/toConsumableArray';\nimport macro from '../../macros.js';\nimport vtkMouseRangeManipulator from '../../Interaction/Manipulators/MouseRangeManipulator.js';\nimport vtkViewProxy from './ViewProxy.js';\nimport { j as cross, E as getMajorAxisIndex, r as radiansFromDegrees } from '../../Common/Core/Math/index.js';\nimport { mat4, vec3 } from 'gl-matrix';\nimport vtkBoundingBox from '../../Common/DataModel/BoundingBox.js';\n\nvar DEFAULT_STEP_WIDTH = 512;\n\nfunction formatAnnotationValue(value) {\n  if (Array.isArray(value)) {\n    return value.map(formatAnnotationValue).join(', ');\n  }\n\n  if (Number.isInteger(value)) {\n    return value;\n  }\n\n  if (Number.isFinite(value)) {\n    if (Math.abs(value) < 0.01) {\n      return '0';\n    }\n\n    return value.toFixed(2);\n  }\n\n  return value;\n}\n/**\n * Returns an array of points in world coordinates creating a coarse hull\n * around the prop given in argument\n * The returned array is empty if the prop is not visible or doesn't use bounds\n *\n * How it works: if possible, combine the mapper bounds corners with the prop matrix\n * otherwise, returns the prop bounds corners\n */\n\n\nfunction getPropCoarseHull(prop) {\n  var _prop$getMapper, _mapper$getBounds;\n\n  if (!prop.getVisibility() || !prop.getUseBounds()) {\n    return [];\n  }\n\n  var finestBounds = prop.getBounds();\n  var finestMatrix = null; // Better bounds using mapper bounds and prop matrix\n\n  var mapper = prop === null || prop === void 0 ? void 0 : (_prop$getMapper = prop.getMapper) === null || _prop$getMapper === void 0 ? void 0 : _prop$getMapper.call(prop);\n  var mapperBounds = mapper === null || mapper === void 0 ? void 0 : (_mapper$getBounds = mapper.getBounds) === null || _mapper$getBounds === void 0 ? void 0 : _mapper$getBounds.call(mapper);\n\n  if (vtkBoundingBox.isValid(mapperBounds) && prop.getMatrix) {\n    var _mapper$getInputData;\n\n    finestBounds = mapperBounds;\n    finestMatrix = prop.getMatrix().slice();\n    mat4.transpose(finestMatrix, finestMatrix); // Better bounds using the image data matrix and prop matrix + imageData matrix\n\n    if (mapper.isA('vtkImageMapper') && (_mapper$getInputData = mapper.getInputData()) !== null && _mapper$getInputData !== void 0 && _mapper$getInputData.isA('vtkImageData')) {\n      prop.computeMatrix();\n      var imageData = mapper.getInputData();\n      finestBounds = imageData.getSpatialExtent();\n      var imageDataMatrix = imageData.getIndexToWorld();\n      mat4.mul(finestMatrix, finestMatrix, imageDataMatrix);\n    }\n  } // Compute corners and transform them if needed\n  // It gives a more accurate hull than computing the corners of a transformed bounding box\n\n\n  if (!vtkBoundingBox.isValid(finestBounds)) {\n    return [];\n  }\n\n  var corners = [];\n  vtkBoundingBox.getCorners(finestBounds, corners);\n\n  if (finestMatrix) {\n    corners.forEach(function (pt) {\n      return vec3.transformMat4(pt, pt, finestMatrix);\n    });\n  }\n\n  return corners;\n} // ----------------------------------------------------------------------------\n// vtkView2DProxy methods\n// ----------------------------------------------------------------------------\n\n\nfunction vtkView2DProxy(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkView2DProxy');\n\n  publicAPI.updateWidthHeightAnnotation = function () {\n    var _model$cornerAnnotati = model.cornerAnnotation.getMetadata(),\n        ijkOrientation = _model$cornerAnnotati.ijkOrientation,\n        dimensions = _model$cornerAnnotati.dimensions;\n\n    if (ijkOrientation && dimensions) {\n      var realDimensions = dimensions;\n\n      if (dimensions.length > 3) {\n        // the dimensions is a string\n        realDimensions = dimensions.split(',').map(Number);\n      }\n\n      var dop = model.camera.getDirectionOfProjection();\n      var viewUp = model.camera.getViewUp();\n      var viewRight = [0, 0, 0];\n      cross(dop, viewUp, viewRight);\n      var wIdx = getMajorAxisIndex(viewRight);\n      var hIdx = getMajorAxisIndex(viewUp);\n      var sliceWidth = realDimensions['IJK'.indexOf(ijkOrientation[wIdx])];\n      var sliceHeight = realDimensions['IJK'.indexOf(ijkOrientation[hIdx])];\n      publicAPI.updateCornerAnnotation({\n        sliceWidth: sliceWidth,\n        sliceHeight: sliceHeight\n      });\n    }\n  };\n\n  var superUpdateOrientation = publicAPI.updateOrientation;\n\n  publicAPI.updateOrientation = function (axisIndex, orientation, viewUp) {\n    var promise = superUpdateOrientation(axisIndex, orientation, viewUp);\n    var count = model.representations.length;\n\n    while (count--) {\n      var rep = model.representations[count];\n      var slicingMode = 'XYZ'[axisIndex];\n\n      if (rep.setSlicingMode) {\n        rep.setSlicingMode(slicingMode);\n      }\n    }\n\n    publicAPI.updateCornerAnnotation({\n      axis: 'XYZ'[axisIndex]\n    });\n    return promise;\n  };\n\n  var superAddRepresentation = publicAPI.addRepresentation;\n\n  publicAPI.addRepresentation = function (rep) {\n    superAddRepresentation(rep);\n\n    if (rep.setSlicingMode) {\n      rep.setSlicingMode('XYZ'[model.axis]);\n    }\n\n    publicAPI.bindRepresentationToManipulator(rep);\n  };\n\n  var superRemoveRepresentation = publicAPI.removeRepresentation;\n\n  publicAPI.removeRepresentation = function (rep) {\n    superRemoveRepresentation(rep);\n\n    if (rep === model.sliceRepresentation) {\n      publicAPI.bindRepresentationToManipulator(null);\n      var count = model.representations.length;\n\n      while (count--) {\n        if (publicAPI.bindRepresentationToManipulator(model.representations[count])) {\n          count = 0;\n        }\n      }\n    }\n  };\n\n  var superInternalResetCamera = model._resetCamera;\n  /**\n   * If fitProps is true, calling resetCamera will exactly fit the bounds in the view\n   * Exact fitting requires useParallelRendering, and an active camera\n   * Otherwise, the default renderer.resetCamera is used and it uses a larger bounding box\n   */\n\n  model._resetCamera = function () {\n    var bounds = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    // Always reset camera first to set physicalScale, physicalTranslation and trigger events\n    var initialReset = superInternalResetCamera(bounds);\n\n    if (!model.fitProps || !model.useParallelRendering || !initialReset) {\n      return initialReset;\n    } // For each visible prop get the smallest possible convex hull using bounds corners\n\n\n    var visiblePoints = [];\n\n    if (bounds) {\n      // Bounds are given as argument, use their corners\n      vtkBoundingBox.getCorners(bounds, visiblePoints);\n    } else {\n      publicAPI.getRepresentations().forEach(function (representationProxy) {\n        return [representationProxy.getActors(), representationProxy.getVolumes()].flat().forEach(function (prop) {\n          return visiblePoints.push.apply(visiblePoints, _toConsumableArray(getPropCoarseHull(prop)));\n        });\n      });\n    }\n\n    if (!visiblePoints) {\n      return initialReset;\n    } // Get the bounds in view coordinates\n\n\n    var viewBounds = vtkBoundingBox.reset([]);\n    var viewMatrix = model.camera.getViewMatrix();\n    mat4.transpose(viewMatrix, viewMatrix);\n\n    for (var i = 0; i < visiblePoints.length; ++i) {\n      var point = visiblePoints[i];\n      vec3.transformMat4(point, point, viewMatrix);\n      vtkBoundingBox.addPoint.apply(vtkBoundingBox, [viewBounds].concat(_toConsumableArray(point)));\n    } // Compute parallel scale\n\n\n    var view = model.renderer.getRenderWindow().getViews()[0];\n    var dims = view.getViewportSize(model.renderer);\n    var aspect = dims[1] && dims[0] ? dims[0] / dims[1] : 1;\n    var xLength = vtkBoundingBox.getLength(viewBounds, 0);\n    var yLength = vtkBoundingBox.getLength(viewBounds, 1);\n    var parallelScale = 0.5 * Math.max(yLength, xLength / aspect); // Compute focal point and position\n\n    var viewFocalPoint = vtkBoundingBox.getCenter(viewBounds); // Camera position in view coordinates is the center of the bounds in XY\n    // and is (the maximum bound) + (the distance to see the bounds in perspective) in Z\n\n    var perspectiveAngle = radiansFromDegrees(model.camera.getViewAngle());\n    var distance = parallelScale / Math.tan(perspectiveAngle * 0.5);\n    var viewPosition = [viewFocalPoint[0], viewFocalPoint[1], viewBounds[5] + distance];\n    var inverseViewMatrix = new Float64Array(16);\n    var worldFocalPoint = new Float64Array(3);\n    var worldPosition = new Float64Array(3);\n    mat4.invert(inverseViewMatrix, viewMatrix);\n    vec3.transformMat4(worldFocalPoint, viewFocalPoint, inverseViewMatrix);\n    vec3.transformMat4(worldPosition, viewPosition, inverseViewMatrix);\n\n    if (parallelScale <= 0) {\n      return initialReset;\n    } // Compute bounds in world coordinates\n\n\n    var worldBounds = vtkBoundingBox.transformBounds(viewBounds, inverseViewMatrix);\n    publicAPI.setCameraParameters({\n      position: worldPosition,\n      focalPoint: worldFocalPoint,\n      bounds: worldBounds,\n      parallelScale: parallelScale\n    });\n    return true;\n  }; // --------------------------------------------------------------------------\n  // Range Manipulator setup\n  // -------------------------------------------------------------------------\n\n\n  model.rangeManipulator = vtkMouseRangeManipulator.newInstance({\n    button: 1,\n    scrollEnabled: true\n  });\n  model.interactorStyle2D.addMouseManipulator(model.rangeManipulator);\n\n  function setWindowWidth(windowWidth) {\n    publicAPI.updateCornerAnnotation({\n      windowWidth: windowWidth\n    });\n\n    if (model.sliceRepresentation && model.sliceRepresentation.setWindowWidth) {\n      model.sliceRepresentation.setWindowWidth(windowWidth);\n    }\n  }\n\n  function setWindowLevel(windowLevel) {\n    publicAPI.updateCornerAnnotation({\n      windowLevel: windowLevel\n    });\n\n    if (model.sliceRepresentation && model.sliceRepresentation.setWindowLevel) {\n      model.sliceRepresentation.setWindowLevel(windowLevel);\n    }\n  }\n\n  function setSlice(sliceRaw) {\n    var numberSliceRaw = Number(sliceRaw);\n    var slice = Number.isInteger(numberSliceRaw) ? sliceRaw : numberSliceRaw.toFixed(2); // add 'slice' in annotation\n\n    var annotation = {\n      slice: slice\n    };\n\n    if (model.sliceRepresentation && model.sliceRepresentation.setSlice) {\n      model.sliceRepresentation.setSlice(numberSliceRaw);\n    } // extend annotation\n\n\n    if (model.sliceRepresentation && model.sliceRepresentation.getAnnotations) {\n      var addOn = model.sliceRepresentation.getAnnotations();\n      Object.keys(addOn).forEach(function (key) {\n        annotation[key] = formatAnnotationValue(addOn[key]);\n      });\n    }\n\n    publicAPI.updateCornerAnnotation(annotation);\n  }\n\n  publicAPI.bindRepresentationToManipulator = function (representation) {\n    var nbListeners = 0;\n    model.rangeManipulator.removeAllListeners();\n    model.sliceRepresentation = representation;\n\n    while (model.sliceRepresentationSubscriptions.length) {\n      model.sliceRepresentationSubscriptions.pop().unsubscribe();\n    }\n\n    if (representation) {\n      model.sliceRepresentationSubscriptions.push(model.camera.onModified(publicAPI.updateWidthHeightAnnotation));\n\n      if (representation.getWindowWidth) {\n        var update = function update() {\n          return setWindowWidth(representation.getWindowWidth());\n        };\n\n        var windowWidth = representation.getPropertyDomainByName('windowWidth');\n        var min = windowWidth.min,\n            max = windowWidth.max;\n        var step = windowWidth.step;\n\n        if (!step || step === 'any') {\n          step = 1 / DEFAULT_STEP_WIDTH;\n        }\n\n        model.rangeManipulator.setVerticalListener(min, max, step, representation.getWindowWidth, setWindowWidth);\n        model.sliceRepresentationSubscriptions.push(representation.onModified(update));\n        update();\n        nbListeners++;\n      }\n\n      if (representation.getWindowLevel) {\n        var _update = function _update() {\n          return setWindowLevel(representation.getWindowLevel());\n        };\n\n        var windowLevel = representation.getPropertyDomainByName('windowLevel');\n        var _min = windowLevel.min,\n            _max = windowLevel.max;\n        var _step = windowLevel.step;\n\n        if (!_step || _step === 'any') {\n          _step = 1 / DEFAULT_STEP_WIDTH;\n        }\n\n        model.rangeManipulator.setHorizontalListener(_min, _max, _step, representation.getWindowLevel, setWindowLevel);\n        model.sliceRepresentationSubscriptions.push(representation.onModified(_update));\n\n        _update();\n\n        nbListeners++;\n      }\n\n      var domain = representation.getPropertyDomainByName('slice');\n\n      if (representation.getSlice && domain) {\n        var _update2 = function _update2() {\n          return setSlice(representation.getSlice());\n        };\n\n        model.rangeManipulator.setScrollListener(domain.min, domain.max, domain.step, representation.getSlice, setSlice);\n        model.sliceRepresentationSubscriptions.push(representation.onModified(_update2));\n\n        _update2();\n\n        nbListeners++;\n      }\n    }\n\n    return nbListeners;\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\n\nvar DEFAULT_VALUES = {\n  axis: 2,\n  orientation: -1,\n  viewUp: [0, 1, 0],\n  useParallelRendering: true,\n  sliceRepresentationSubscriptions: [],\n  fitProps: false\n}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n  vtkViewProxy.extend(publicAPI, model, initialValues);\n  macro.get(publicAPI, model, ['axis']);\n  macro.setGet(publicAPI, model, ['fitProps']); // Object specific methods\n\n  vtkView2DProxy(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = macro.newInstance(extend, 'vtkView2DProxy'); // ----------------------------------------------------------------------------\n\nvar vtkView2DProxy$1 = {\n  newInstance: newInstance,\n  extend: extend\n};\n\nexport { vtkView2DProxy$1 as default, extend, newInstance };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}