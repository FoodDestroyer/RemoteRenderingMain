{"ast":null,"code":"import macro from '../../macros.js';\nimport vtkCellArray from '../../Common/Core/CellArray.js';\nimport vtkDataArray from '../../Common/Core/DataArray.js';\nimport { l as normalize, j as cross, n as norm, d as dot, e as distance2BetweenPoints } from '../../Common/Core/Math/index.js';\nimport vtkPoints from '../../Common/Core/Points.js';\nimport vtkPolyData from '../../Common/DataModel/PolyData.js';\nimport { DesiredOutputPrecision } from '../../Common/DataModel/DataSetAttributes/Constants.js';\nimport { VtkDataTypes } from '../../Common/Core/DataArray/Constants.js';\nimport Constants from './TubeFilter/Constants.js';\nvar VaryRadius = Constants.VaryRadius,\n  GenerateTCoords = Constants.GenerateTCoords;\nvar vtkDebugMacro = macro.vtkDebugMacro,\n  vtkErrorMacro = macro.vtkErrorMacro,\n  vtkWarningMacro = macro.vtkWarningMacro; // ----------------------------------------------------------------------------\n// vtkTubeFilter methods\n// ----------------------------------------------------------------------------\n\nfunction vtkTubeFilter(publicAPI, model) {\n  // Set our classname\n  model.classHierarchy.push('vtkTubeFilter');\n  function computeOffset(offset, npts) {\n    var newOffset = offset;\n    if (model.sidesShareVertices) {\n      newOffset += model.numberOfSides * npts;\n    } else {\n      // points are duplicated\n      newOffset += 2 * model.numberOfSides * npts;\n    }\n    if (model.capping) {\n      // cap points are duplicated\n      newOffset += 2 * model.numberOfSides;\n    }\n    return newOffset;\n  }\n  function findNextValidSegment(points, pointIds, start) {\n    var ptId = pointIds[start];\n    var ps = points.slice(3 * ptId, 3 * (ptId + 1));\n    var end = start + 1;\n    while (end < pointIds.length) {\n      var endPtId = pointIds[end];\n      var pe = points.slice(3 * endPtId, 3 * (endPtId + 1));\n      if (ps !== pe) {\n        return end - 1;\n      }\n      ++end;\n    }\n    return pointIds.length;\n  }\n  function generateSlidingNormals(pts, lines, normals) {\n    var firstNormal = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n    var normal = [0.0, 0.0, 1.0];\n    var lineData = lines; // lid = 0;\n\n    var npts = lineData[0];\n    for (var i = 0; i < lineData.length; i += npts + 1) {\n      npts = lineData[i];\n      if (npts === 1) {\n        // return arbitrary\n        normals.setTuple(lineData[i + 1], normal);\n      } else if (npts > 1) {\n        var sNextId = 0;\n        var sPrev = [0, 0, 0];\n        var sNext = [0, 0, 0];\n        var linePts = lineData.slice(i + 1, i + 1 + npts);\n        sNextId = findNextValidSegment(pts, linePts, 0);\n        if (sNextId !== npts) {\n          (function () {\n            // at least one valid segment\n            var pt1Id = linePts[sNextId];\n            var pt1 = pts.slice(3 * pt1Id, 3 * (pt1Id + 1));\n            var pt2Id = linePts[sNextId + 1];\n            var pt2 = pts.slice(3 * pt2Id, 3 * (pt2Id + 1));\n            sPrev = pt2.map(function (elem, idx) {\n              return elem - pt1[idx];\n            });\n            normalize(sPrev); // compute first normal\n\n            if (firstNormal) {\n              normal = firstNormal;\n            } else {\n              // find the next valid, non-parallel segment\n              while (++sNextId < npts) {\n                sNextId = findNextValidSegment(pts, linePts, sNextId);\n                if (sNextId !== npts) {\n                  pt1Id = linePts[sNextId];\n                  pt1 = pts.slice(3 * pt1Id, 3 * (pt1Id + 1));\n                  pt2Id = linePts[sNextId + 1];\n                  pt2 = pts.slice(3 * pt2Id, 3 * (pt2Id + 1));\n                  for (var j = 0; j < 3; ++j) {\n                    sNext[j] = pt2[j] - pt1[j];\n                  }\n                  normalize(sNext); // now the starting normal should simply be the cross product.\n                  // In the following if statement, we check for the case where\n                  // the two segments are parallel, in which case, continue\n                  // searching for the next valid segment\n\n                  var n = [0.0, 0.0, 0.0];\n                  cross(sPrev, sNext, n);\n                  if (norm(n) > 1.0e-3) {\n                    normal = n;\n                    sPrev = sNext;\n                    break;\n                  }\n                }\n              }\n              if (sNextId >= npts) {\n                // only one valid segment\n                // a little trick to find orthogonal normal\n                for (var _j = 0; _j < 3; ++_j) {\n                  if (sPrev[_j] !== 0.0) {\n                    normal[(_j + 2) % 3] = 0.0;\n                    normal[(_j + 1) % 3] = 1.0;\n                    normal[_j] = -sPrev[(_j + 1) % 3] / sPrev[_j];\n                    break;\n                  }\n                }\n              }\n            }\n            normalize(normal); // compute remaining normals\n\n            var lastNormalId = 0;\n            while (++sNextId < npts) {\n              sNextId = findNextValidSegment(pts, linePts, sNextId);\n              if (sNextId === npts) {\n                break;\n              }\n              pt1Id = linePts[sNextId];\n              pt1 = pts.slice(3 * pt1Id, 3 * (pt1Id + 1));\n              pt2Id = linePts[sNextId + 1];\n              pt2 = pts.slice(3 * pt2Id, 3 * (pt2Id + 1));\n              for (var _j2 = 0; _j2 < 3; ++_j2) {\n                sNext[_j2] = pt2[_j2] - pt1[_j2];\n              }\n              normalize(sNext); // compute rotation vector\n\n              var w = [0.0, 0.0, 0.0];\n              cross(sPrev, normal, w);\n              if (normalize(w) !== 0.0) {\n                // can't use this segment otherwise\n                var q = [0.0, 0.0, 0.0];\n                cross(sNext, sPrev, q);\n                if (normalize(q) !== 0.0) {\n                  // can't use this segment otherwise\n                  var f1 = dot(q, normal);\n                  var f2 = 1.0 - f1 * f1;\n                  if (f2 > 0.0) {\n                    f2 = Math.sqrt(f2);\n                  } else {\n                    f2 = 0.0;\n                  }\n                  var c = [0, 0, 0];\n                  for (var _j3 = 0; _j3 < 3; ++_j3) {\n                    c[_j3] = sNext[_j3] + sPrev[_j3];\n                  }\n                  normalize(c);\n                  cross(c, q, w);\n                  cross(sPrev, q, c);\n                  if (dot(normal, c) * dot(w, c) < 0.0) {\n                    f2 *= -1.0;\n                  } // insert current normal before updating\n\n                  for (var _j4 = lastNormalId; _j4 < sNextId; ++_j4) {\n                    normals.setTuple(linePts[_j4], normal);\n                  }\n                  lastNormalId = sNextId;\n                  sPrev = sNext; // compute next normal\n\n                  normal = f1 * q + f2 * w;\n                }\n              }\n            } // insert last normal for the remaining points\n\n            for (var _j5 = lastNormalId; _j5 < npts; ++_j5) {\n              normals.setTuple(linePts[_j5], normal);\n            }\n          })();\n        } else {\n          // no valid segments\n          for (var j = 0; j < npts; ++j) {\n            normals.setTuple(linePts[j], normal);\n          }\n        }\n      }\n    }\n    return 1;\n  }\n  function generatePoints(offset, npts, pts, inPts, newPts, pd, outPD, newNormals, inScalars, range, inVectors, maxSpeed, inNormals, theta) {\n    // Use averaged segment to create beveled effect.\n    var sNext = [0.0, 0.0, 0.0];\n    var sPrev = [0.0, 0.0, 0.0];\n    var startCapNorm = [0.0, 0.0, 0.0];\n    var endCapNorm = [0.0, 0.0, 0.0];\n    var p = [0.0, 0.0, 0.0];\n    var pNext = [0.0, 0.0, 0.0];\n    var s = [0.0, 0.0, 0.0];\n    var n = [0.0, 0.0, 0.0];\n    var w = [0.0, 0.0, 0.0];\n    var nP = [0.0, 0.0, 0.0];\n    var normal = [0.0, 0.0, 0.0];\n    var sFactor = 1.0;\n    var ptId = offset;\n    var vector = [];\n    for (var j = 0; j < npts; ++j) {\n      // First point\n      if (j === 0) {\n        p = inPts.slice(3 * pts[0], 3 * (pts[0] + 1));\n        pNext = inPts.slice(3 * pts[1], 3 * (pts[1] + 1));\n        for (var i = 0; i < 3; ++i) {\n          sNext[i] = pNext[i] - p[i];\n          sPrev[i] = sNext[i];\n          startCapNorm[i] = -sPrev[i];\n        }\n        normalize(startCapNorm);\n      } else if (j === npts - 1) {\n        for (var _i = 0; _i < 3; ++_i) {\n          sPrev[_i] = sNext[_i];\n          p[_i] = pNext[_i];\n          endCapNorm[_i] = sNext[_i];\n        }\n        normalize(endCapNorm);\n      } else {\n        for (var _i2 = 0; _i2 < 3; ++_i2) {\n          p[_i2] = pNext[_i2];\n        }\n        pNext = inPts.slice(3 * pts[j + 1], 3 * (pts[j + 1] + 1));\n        for (var _i3 = 0; _i3 < 3; ++_i3) {\n          sPrev[_i3] = sNext[_i3];\n          sNext[_i3] = pNext[_i3] - p[_i3];\n        }\n      }\n      if (normalize(sNext) === 0.0) {\n        vtkWarningMacro('Coincident points!');\n        return 0;\n      }\n      for (var _i4 = 0; _i4 < 3; ++_i4) {\n        s[_i4] = (sPrev[_i4] + sNext[_i4]) / 2.0; // average vector\n      }\n\n      n = inNormals.slice(3 * pts[j], 3 * (pts[j] + 1)); // if s is zero then just use sPrev cross n\n\n      if (normalize(s) === 0.0) {\n        cross(sPrev, n, s);\n        if (normalize(s) === 0.0) {\n          vtkDebugMacro('Using alternate bevel vector');\n        }\n      }\n      cross(s, n, w);\n      if (normalize(w) === 0.0) {\n        var msg = 'Bad normal: s = ';\n        msg += \"\".concat(s[0], \",  \").concat(s[1], \", \").concat(s[2]);\n        msg += \" n = \".concat(n[0], \",  \").concat(n[1], \", \").concat(n[2]);\n        vtkWarningMacro(msg);\n        return 0;\n      }\n      cross(w, s, nP); // create orthogonal coordinate system\n\n      normalize(nP); // Compute a scalar factor based on scalars or vectors\n\n      if (inScalars && model.varyRadius === VaryRadius.VARY_RADIUS_BY_SCALAR) {\n        sFactor = 1.0 + (model.radiusFactor - 1.0) * (inScalars.getComponent(pts[j], 0) - range[0]) / (range[1] - range[0]);\n      } else if (inVectors && model.varyRadius === VaryRadius.VARY_RADIUS_BY_VECTOR) {\n        sFactor = Math.sqrt(maxSpeed / norm(inVectors.getTuple(pts[j], vector)));\n        if (sFactor > model.radiusFactor) {\n          sFactor = model.radiusFactor;\n        }\n      } else if (inScalars && model.varyRadius === VaryRadius.VARY_RADIUS_BY_ABSOLUTE_SCALAR) {\n        sFactor = inScalars.getComponent(pts[j], 0);\n        if (sFactor < 0.0) {\n          vtkWarningMacro('Scalar value less than zero, skipping line');\n          return 0;\n        }\n      } // create points around line\n\n      if (model.sidesShareVertices) {\n        for (var k = 0; k < model.numberOfSides; ++k) {\n          for (var _i5 = 0; _i5 < 3; ++_i5) {\n            normal[_i5] = w[_i5] * Math.cos(k * theta) + nP[_i5] * Math.sin(k * theta);\n            s[_i5] = p[_i5] + model.radius * sFactor * normal[_i5];\n            newPts[3 * ptId + _i5] = s[_i5];\n            newNormals[3 * ptId + _i5] = normal[_i5];\n          }\n          outPD.passData(pd, pts[j], ptId);\n          ptId++;\n        } // for each side\n      } else {\n        var nRight = [0, 0, 0];\n        var nLeft = [0, 0, 0];\n        for (var _k = 0; _k < model.numberOfSides; ++_k) {\n          for (var _i6 = 0; _i6 < 3; ++_i6) {\n            // Create duplicate vertices at each point\n            // and adjust the associated normals so that they are\n            // oriented with the facets. This preserves the tube's\n            // polygonal appearance, as if by flat-shading around the tube,\n            // while still allowing smooth (gouraud) shading along the\n            // tube as it bends.\n            normal[_i6] = w[_i6] * Math.cos(_k * theta) + nP[_i6] * Math.sin(_k * theta);\n            nRight[_i6] = w[_i6] * Math.cos((_k - 0.5) * theta) + nP[_i6] * Math.sin((_k - 0.5) * theta);\n            nLeft[_i6] = w[_i6] * Math.cos((_k + 0.5) * theta) + nP[_i6] * Math.sin((_k + 0.5) * theta);\n            s[_i6] = p[_i6] + model.radius * sFactor * normal[_i6];\n            newPts[3 * ptId + _i6] = s[_i6];\n            newNormals[3 * ptId + _i6] = nRight[_i6];\n            newPts[3 * (ptId + 1) + _i6] = s[_i6];\n            newNormals[3 * (ptId + 1) + _i6] = nLeft[_i6];\n          }\n          outPD.passData(pd, pts[j], ptId + 1);\n          ptId += 2;\n        } // for each side\n      } // else separate vertices\n    } // for all points in the polyline\n    // Produce end points for cap. They are placed at tail end of points.\n\n    if (model.capping) {\n      var numCapSides = model.numberOfSides;\n      var capIncr = 1;\n      if (!model.sidesShareVertices) {\n        numCapSides = 2 * model.numberOfSides;\n        capIncr = 2;\n      } // the start cap\n\n      for (var _k2 = 0; _k2 < numCapSides; _k2 += capIncr) {\n        s = newPts.slice(3 * (offset + _k2), 3 * (offset + _k2 + 1));\n        for (var _i7 = 0; _i7 < 3; ++_i7) {\n          newPts[3 * ptId + _i7] = s[_i7];\n          newNormals[3 * ptId + _i7] = startCapNorm[_i7];\n        }\n        outPD.passData(pd, pts[0], ptId);\n        ptId++;\n      } // the end cap\n\n      var endOffset = offset + (npts - 1) * model.numberOfSides;\n      if (!model.sidesShareVertices) {\n        endOffset = offset + 2 * (npts - 1) * model.numberOfSides;\n      }\n      for (var _k3 = 0; _k3 < numCapSides; _k3 += capIncr) {\n        s = newPts.slice(3 * (endOffset + _k3), 3 * (endOffset + _k3 + 1));\n        for (var _i8 = 0; _i8 < 3; ++_i8) {\n          newPts[3 * ptId + _i8] = s[_i8];\n          newNormals[3 * ptId + _i8] = endCapNorm[_i8];\n        }\n        outPD.passData(pd, pts[npts - 1], ptId);\n        ptId++;\n      }\n    } // if capping\n\n    return 1;\n  }\n  function generateStrips(offset, npts, inCellId, outCellId, inCD, outCD, newStrips) {\n    var i1 = 0;\n    var i2 = 0;\n    var i3 = 0;\n    var newOutCellId = outCellId;\n    var outCellIdx = 0;\n    var newStripsData = newStrips.getData();\n    var cellId = 0;\n    while (outCellIdx < newStripsData.length) {\n      if (cellId === outCellId) {\n        break;\n      }\n      outCellIdx += newStripsData[outCellIdx] + 1;\n      cellId++;\n    }\n    if (model.sidesShareVertices) {\n      for (var k = offset; k < model.numberOfSides + offset; k += model.onRatio) {\n        i1 = k % model.numberOfSides;\n        i2 = (k + 1) % model.numberOfSides;\n        newStripsData[outCellIdx++] = npts * 2;\n        for (var i = 0; i < npts; ++i) {\n          i3 = i * model.numberOfSides;\n          newStripsData[outCellIdx++] = offset + i2 + i3;\n          newStripsData[outCellIdx++] = offset + i1 + i3;\n        }\n        outCD.passData(inCD, inCellId, newOutCellId++);\n      } // for each side of the tube\n    } else {\n      for (var _k4 = offset; _k4 < model.numberOfSides + offset; _k4 += model.onRatio) {\n        i1 = 2 * (_k4 % model.numberOfSides) + 1;\n        i2 = 2 * ((_k4 + 1) % model.numberOfSides); // outCellId = newStrips.getNumberOfCells(true);\n\n        newStripsData[outCellIdx] = npts * 2;\n        outCellIdx++;\n        for (var _i9 = 0; _i9 < npts; ++_i9) {\n          i3 = _i9 * 2 * model.numberOfSides;\n          newStripsData[outCellIdx++] = offset + i2 + i3;\n          newStripsData[outCellIdx++] = offset + i1 + i3;\n        }\n        outCD.passData(inCD, inCellId, newOutCellId++);\n      } // for each side of the tube\n    } // Take care of capping. The caps are n-sided polygons that can be easily\n    // triangle stripped.\n\n    if (model.capping) {\n      var startIdx = offset + npts * model.numberOfSides;\n      var idx = 0;\n      if (!model.sidesShareVertices) {\n        startIdx = offset + 2 * npts * model.numberOfSides;\n      } // The start cap\n\n      newStripsData[outCellIdx++] = model.numberOfSides;\n      newStripsData[outCellIdx++] = startIdx;\n      newStripsData[outCellIdx++] = startIdx + 1;\n      var _k5 = 0;\n      for (i1 = model.numberOfSides - 1, i2 = 2, _k5 = 0; _k5 < model.numberOfSides - 2; ++_k5) {\n        if (_k5 % 2) {\n          idx = startIdx + i2;\n          newStripsData[outCellIdx++] = idx;\n          i2++;\n        } else {\n          idx = startIdx + i1;\n          newStripsData[outCellIdx++] = idx;\n          i1--;\n        }\n      }\n      outCD.passData(inCD, inCellId, newOutCellId++); // The end cap - reversed order to be consistent with normal\n\n      startIdx += model.numberOfSides;\n      newStripsData[outCellIdx++] = model.numberOfSides;\n      newStripsData[outCellIdx++] = startIdx;\n      newStripsData[outCellIdx++] = startIdx + model.numberOfSides - 1;\n      for (i1 = model.numberOfSides - 2, i2 = 1, _k5 = 0; _k5 < model.numberOfSides - 2; ++_k5) {\n        if (_k5 % 2) {\n          idx = startIdx + i1;\n          newStripsData[outCellIdx++] = idx;\n          i1--;\n        } else {\n          idx = startIdx + i2;\n          newStripsData[outCellIdx++] = idx;\n          i2++;\n        }\n      }\n      outCD.passData(inCD, inCellId, newOutCellId++);\n    }\n    return newOutCellId;\n  }\n  function generateTCoords(offset, npts, pts, inPts, inScalars, newTCoords) {\n    var numSides = model.numberOfSides;\n    if (!model.sidesShareVertices) {\n      numSides = 2 * model.numberOfSides;\n    }\n    var tc = 0.0;\n    var s0 = 0.0;\n    var s = 0.0;\n    var inScalarsData = inScalars.getData();\n    if (model.generateTCoords === GenerateTCoords.TCOORDS_FROM_SCALARS) {\n      s0 = inScalarsData[pts[0]];\n      for (var i = 0; i < npts; ++i) {\n        s = inScalarsData[pts[i]];\n        tc = (s - s0) / model.textureLength;\n        for (var k = 0; k < numSides; ++k) {\n          var tcy = k / (numSides - 1);\n          var tcId = 2 * (offset + i * numSides + k);\n          newTCoords[tcId] = tc;\n          newTCoords[tcId + 1] = tcy;\n        }\n      }\n    } else if (model.generateTCoords === GenerateTCoords.TCOORDS_FROM_LENGTH) {\n      var len = 0.0;\n      var xPrev = inPts.slice(3 * pts[0], 3 * (pts[0] + 1));\n      for (var _i10 = 0; _i10 < npts; ++_i10) {\n        var x = inPts.slice(3 * pts[_i10], 3 * (pts[_i10] + 1));\n        len += Math.sqrt(distance2BetweenPoints(x, xPrev));\n        tc = len / model.textureLength;\n        for (var _k6 = 0; _k6 < numSides; ++_k6) {\n          var _tcy = _k6 / (numSides - 1);\n          var _tcId = 2 * (offset + _i10 * numSides + _k6);\n          newTCoords[_tcId] = tc;\n          newTCoords[_tcId + 1] = _tcy;\n        }\n        for (var _k7 = 0; _k7 < 3; ++_k7) {\n          xPrev[_k7] = x[_k7];\n        }\n      }\n    } else if (model.generateTCoords === GenerateTCoords.TCOORDS_FROM_NORMALIZED_LENGTH) {\n      var _len = 0.0;\n      var len1 = 0.0;\n      var _xPrev = inPts.slice(3 * pts[0], 3 * (pts[0] + 1));\n      for (var _i11 = 0; _i11 < npts; ++_i11) {\n        var _x = inPts.slice(3 * pts[_i11], 3 * (pts[_i11] + 1));\n        len1 += Math.sqrt(distance2BetweenPoints(_x, _xPrev));\n        for (var _k8 = 0; _k8 < 3; ++_k8) {\n          _xPrev[_k8] = _x[_k8];\n        }\n      }\n      _xPrev = inPts.slice(3 * pts[0], 3 * (pts[0] + 1));\n      for (var _i12 = 0; _i12 < npts; ++_i12) {\n        var _x2 = inPts.slice(3 * pts[_i12], 3 * (pts[_i12] + 1));\n        _len += Math.sqrt(distance2BetweenPoints(_x2, _xPrev));\n        tc = _len / len1;\n        for (var _k9 = 0; _k9 < numSides; ++_k9) {\n          var _tcy2 = _k9 / (numSides - 1);\n          var _tcId2 = 2 * (offset + _i12 * numSides + _k9);\n          newTCoords[_tcId2] = tc;\n          newTCoords[_tcId2 + 1] = _tcy2;\n        }\n        for (var _k10 = 0; _k10 < 3; ++_k10) {\n          _xPrev[_k10] = _x2[_k10];\n        }\n      }\n    } // Capping, set the endpoints as appropriate\n\n    if (model.capping) {\n      var startIdx = offset + npts * numSides; // start cap\n\n      for (var ik = 0; ik < model.numberOfSides; ++ik) {\n        var _tcId3 = 2 * (startIdx + ik);\n        newTCoords[_tcId3] = 0.0;\n        newTCoords[_tcId3 + 1] = 0.0;\n      } // end cap\n\n      for (var _ik = 0; _ik < model.numberOfSides; ++_ik) {\n        var _tcId4 = 2 * (startIdx + model.numberOfSides + _ik);\n        newTCoords[_tcId4] = 0.0;\n        newTCoords[_tcId4 + 1] = 0.0;\n      }\n    }\n  }\n  publicAPI.requestData = function (inData, outData) {\n    // implement requestData\n    // pass through for now\n    var output = vtkPolyData.newInstance();\n    outData[0] = output;\n    var input = inData[0];\n    if (!input) {\n      vtkErrorMacro('Invalid or missing input');\n      return;\n    } // Allocate output\n\n    var inPts = input.getPoints();\n    if (!inPts) {\n      return;\n    }\n    var numPts = inPts.getNumberOfPoints();\n    if (numPts < 1) {\n      return;\n    }\n    var inLines = input.getLines();\n    if (!inLines) {\n      return;\n    }\n    var numLines = inLines.getNumberOfCells();\n    if (numLines < 1) {\n      return;\n    }\n    var numNewPts = 0;\n    var numStrips = 0;\n    var inLinesData = inLines.getData();\n    var npts = inLinesData[0];\n    for (var i = 0; i < inLinesData.length; i += npts + 1) {\n      npts = inLinesData[i];\n      numNewPts = computeOffset(numNewPts, npts);\n      numStrips += (2 * npts + 1) * Math.ceil(model.numberOfSides / model.onRatio);\n      if (model.capping) {\n        numStrips += 2 * (model.numberOfSides + 1);\n      }\n    }\n    var pointType = inPts.getDataType();\n    if (model.outputPointsPrecision === DesiredOutputPrecision.SINGLE) {\n      pointType = VtkDataTypes.FLOAT;\n    } else if (model.outputPointsPrecision === DesiredOutputPrecision.DOUBLE) {\n      pointType = VtkDataTypes.DOUBLE;\n    }\n    var newPts = vtkPoints.newInstance({\n      dataType: pointType,\n      size: numNewPts * 3,\n      numberOfComponents: 3\n    });\n    var numNormals = 3 * numNewPts;\n    var newNormalsData = new Float32Array(numNormals);\n    var newNormals = vtkDataArray.newInstance({\n      numberOfComponents: 3,\n      values: newNormalsData,\n      name: 'TubeNormals'\n    });\n    var newStripsData = new Uint32Array(numStrips);\n    var newStrips = vtkCellArray.newInstance({\n      values: newStripsData\n    });\n    var newStripId = 0;\n    var inNormals = input.getPointData().getNormals();\n    var inNormalsData = null;\n    var generateNormals = false;\n    if (!inNormals || model.useDefaultNormal) {\n      inNormalsData = new Float32Array(3 * numPts);\n      inNormals = vtkDataArray.newInstance({\n        numberOfComponents: 3,\n        values: inNormalsData,\n        name: 'Normals'\n      });\n      if (model.useDefaultNormal) {\n        inNormalsData = inNormalsData.map(function (elem, index) {\n          var i = index % 3;\n          return model.defaultNormal[i];\n        });\n      } else {\n        generateNormals = true;\n      }\n    } // loop over pointData arrays and resize based on numNewPts\n\n    var numArrays = input.getPointData().getNumberOfArrays();\n    var oldArray = null;\n    var newArray = null;\n    for (var _i13 = 0; _i13 < numArrays; _i13++) {\n      oldArray = input.getPointData().getArrayByIndex(_i13);\n      newArray = vtkDataArray.newInstance({\n        name: oldArray.getName(),\n        dataType: oldArray.getDataType(),\n        numberOfComponents: oldArray.getNumberOfComponents(),\n        size: numNewPts * oldArray.getNumberOfComponents()\n      });\n      output.getPointData().removeArrayByIndex(0); // remove oldArray from beginning\n\n      output.getPointData().addArray(newArray); // concat newArray to end\n    } // loop over cellData arrays and resize based on numNewCells\n\n    var numNewCells = inLines.getNumberOfCells() * model.numberOfSides;\n    if (model.capping) {\n      numNewCells += 2;\n    }\n    var numCellArrays = input.getCellData().getNumberOfArrays();\n    for (var _i14 = 0; _i14 < numCellArrays; _i14++) {\n      oldArray = input.getCellData().getArrayByIndex(_i14);\n      newArray = vtkDataArray.newInstance({\n        name: oldArray.getName(),\n        dataType: oldArray.getDataType(),\n        numberOfComponents: oldArray.getNumberOfComponents(),\n        size: numNewCells * oldArray.getNumberOfComponents()\n      });\n      output.getCellData().removeArrayByIndex(0); // remove oldArray from beginning\n\n      output.getCellData().addArray(newArray); // concat newArray to end\n    }\n\n    var inScalars = publicAPI.getInputArrayToProcess(0);\n    var outScalars = null;\n    var range = [];\n    if (inScalars) {\n      // allocate output scalar array\n      // assuming point scalars for now\n      outScalars = vtkDataArray.newInstance({\n        name: inScalars.getName(),\n        dataType: inScalars.getDataType(),\n        numberOfComponents: inScalars.getNumberOfComponents(),\n        size: numNewPts * inScalars.getNumberOfComponents()\n      });\n      range = inScalars.getRange();\n      if (range[1] - range[0] === 0.0) {\n        if (model.varyRadius === VaryRadius.VARY_RADIUS_BY_SCALAR) {\n          vtkWarningMacro('Scalar range is zero!');\n        }\n        range[1] = range[0] + 1.0;\n      }\n    }\n    var inVectors = publicAPI.getInputArrayToProcess(1);\n    var maxSpeed = 0;\n    if (inVectors) {\n      maxSpeed = inVectors.getMaxNorm();\n    }\n    var outCD = output.getCellData();\n    outCD.copyNormalsOff();\n    outCD.passData(input.getCellData());\n    var outPD = output.getPointData();\n    if (outPD.getNormals() !== null) {\n      outPD.copyNormalsOff();\n    }\n    if (inScalars && outScalars) {\n      outPD.setScalars(outScalars);\n    } // TCoords\n\n    var newTCoords = null;\n    if (model.generateTCoords === GenerateTCoords.TCOORDS_FROM_SCALARS && inScalars || model.generateTCoords === GenerateTCoords.TCOORDS_FROM_LENGTH || model.generateTCoords === GenerateTCoords.TCOORDS_FROM_NORMALIZED_LENGTH) {\n      var newTCoordsData = new Float32Array(2 * numNewPts);\n      newTCoords = vtkDataArray.newInstance({\n        numberOfComponents: 2,\n        values: newTCoordsData,\n        name: 'TCoords'\n      });\n      outPD.copyTCoordsOff();\n    }\n    outPD.passData(input.getPointData()); // Create points along each polyline that are connected into numberOfSides\n    // triangle strips.\n\n    var theta = 2.0 * Math.PI / model.numberOfSides;\n    npts = inLinesData[0];\n    var offset = 0;\n    var inCellId = input.getVerts().getNumberOfCells();\n    for (var _i15 = 0; _i15 < inLinesData.length; _i15 += npts + 1) {\n      npts = inLinesData[_i15];\n      var pts = inLinesData.slice(_i15 + 1, _i15 + 1 + npts);\n      if (npts > 1) {\n        // if not, skip tubing this line\n        if (generateNormals) {\n          var polyLine = inLinesData.slice(_i15, _i15 + npts + 1);\n          generateSlidingNormals(inPts.getData(), polyLine, inNormals);\n        }\n      } // generate points\n\n      if (generatePoints(offset, npts, pts, inPts.getData(), newPts.getData(), input.getPointData(), outPD, newNormalsData, inScalars, range, inVectors, maxSpeed, inNormalsData, theta)) {\n        // generate strips for the polyline\n        newStripId = generateStrips(offset, npts, inCellId, newStripId, input.getCellData(), outCD, newStrips); // generate texture coordinates for the polyline\n\n        if (newTCoords) {\n          generateTCoords(offset, npts, pts, inPts.getData(), inScalars, newTCoords.getData());\n        }\n      } else {\n        // skip tubing this line\n        vtkWarningMacro('Could not generate points');\n      } // lineIdx += npts;\n      // Compute the new offset for the next polyline\n\n      offset = computeOffset(offset, npts);\n      inCellId++;\n    }\n    output.setPoints(newPts);\n    output.setStrips(newStrips);\n    output.setPointData(outPD);\n    outPD.setNormals(newNormals);\n    outData[0] = output;\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nvar DEFAULT_VALUES = {\n  outputPointsPrecision: DesiredOutputPrecision.DEFAULT,\n  radius: 0.5,\n  varyRadius: VaryRadius.VARY_RADIUS_OFF,\n  numberOfSides: 3,\n  radiusFactor: 10,\n  defaultNormal: [0, 0, 1],\n  useDefaultNormal: false,\n  sidesShareVertices: true,\n  capping: false,\n  onRatio: 1,\n  offset: 0,\n  generateTCoords: GenerateTCoords.TCOORDS_OFF,\n  textureLength: 1.0\n}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Build VTK API\n\n  macro.setGet(publicAPI, model, ['outputPointsPrecision', 'radius', 'varyRadius', 'numberOfSides', 'radiusFactor', 'defaultNormal', 'useDefaultNormal', 'sidesShareVertices', 'capping', 'onRatio', 'offset', 'generateTCoords', 'textureLength']); // Make this a VTK object\n\n  macro.obj(publicAPI, model); // Also make it an algorithm with one input and one output\n\n  macro.algo(publicAPI, model, 1, 1); // Object specific methods\n\n  vtkTubeFilter(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = macro.newInstance(extend, 'vtkTubeFilter'); // ----------------------------------------------------------------------------\n\nvar vtkTubeFilter$1 = {\n  newInstance: newInstance,\n  extend: extend\n};\nexport { vtkTubeFilter$1 as default, extend, newInstance };","map":{"version":3,"names":["macro","vtkCellArray","vtkDataArray","l","normalize","j","cross","n","norm","d","dot","e","distance2BetweenPoints","vtkPoints","vtkPolyData","DesiredOutputPrecision","VtkDataTypes","Constants","VaryRadius","GenerateTCoords","vtkDebugMacro","vtkErrorMacro","vtkWarningMacro","vtkTubeFilter","publicAPI","model","classHierarchy","push","computeOffset","offset","npts","newOffset","sidesShareVertices","numberOfSides","capping","findNextValidSegment","points","pointIds","start","ptId","ps","slice","end","length","endPtId","pe","generateSlidingNormals","pts","lines","normals","firstNormal","arguments","undefined","normal","lineData","i","setTuple","sNextId","sPrev","sNext","linePts","pt1Id","pt1","pt2Id","pt2","map","elem","idx","_j","lastNormalId","_j2","w","q","f1","f2","Math","sqrt","c","_j3","_j4","_j5","generatePoints","inPts","newPts","pd","outPD","newNormals","inScalars","range","inVectors","maxSpeed","inNormals","theta","startCapNorm","endCapNorm","p","pNext","s","nP","sFactor","vector","_i","_i2","_i3","_i4","msg","concat","varyRadius","VARY_RADIUS_BY_SCALAR","radiusFactor","getComponent","VARY_RADIUS_BY_VECTOR","getTuple","VARY_RADIUS_BY_ABSOLUTE_SCALAR","k","_i5","cos","sin","radius","passData","nRight","nLeft","_k","_i6","numCapSides","capIncr","_k2","_i7","endOffset","_k3","_i8","generateStrips","inCellId","outCellId","inCD","outCD","newStrips","i1","i2","i3","newOutCellId","outCellIdx","newStripsData","getData","cellId","onRatio","_k4","_i9","startIdx","_k5","generateTCoords","newTCoords","numSides","tc","s0","inScalarsData","TCOORDS_FROM_SCALARS","textureLength","tcy","tcId","TCOORDS_FROM_LENGTH","len","xPrev","_i10","x","_k6","_tcy","_tcId","_k7","TCOORDS_FROM_NORMALIZED_LENGTH","_len","len1","_xPrev","_i11","_x","_k8","_i12","_x2","_k9","_tcy2","_tcId2","_k10","ik","_tcId3","_ik","_tcId4","requestData","inData","outData","output","newInstance","input","getPoints","numPts","getNumberOfPoints","inLines","getLines","numLines","getNumberOfCells","numNewPts","numStrips","inLinesData","ceil","pointType","getDataType","outputPointsPrecision","SINGLE","FLOAT","DOUBLE","dataType","size","numberOfComponents","numNormals","newNormalsData","Float32Array","values","name","Uint32Array","newStripId","getPointData","getNormals","inNormalsData","generateNormals","useDefaultNormal","index","defaultNormal","numArrays","getNumberOfArrays","oldArray","newArray","_i13","getArrayByIndex","getName","getNumberOfComponents","removeArrayByIndex","addArray","numNewCells","numCellArrays","getCellData","_i14","getInputArrayToProcess","outScalars","getRange","getMaxNorm","copyNormalsOff","setScalars","newTCoordsData","copyTCoordsOff","PI","getVerts","_i15","polyLine","setPoints","setStrips","setPointData","setNormals","DEFAULT_VALUES","DEFAULT","VARY_RADIUS_OFF","TCOORDS_OFF","extend","initialValues","Object","assign","setGet","obj","algo","vtkTubeFilter$1","default"],"sources":["/home/rakshith/Documents/RemoteRendering/vtk-js-react-app/node_modules/@kitware/vtk.js/Filters/General/TubeFilter.js"],"sourcesContent":["import macro from '../../macros.js';\nimport vtkCellArray from '../../Common/Core/CellArray.js';\nimport vtkDataArray from '../../Common/Core/DataArray.js';\nimport { l as normalize, j as cross, n as norm, d as dot, e as distance2BetweenPoints } from '../../Common/Core/Math/index.js';\nimport vtkPoints from '../../Common/Core/Points.js';\nimport vtkPolyData from '../../Common/DataModel/PolyData.js';\nimport { DesiredOutputPrecision } from '../../Common/DataModel/DataSetAttributes/Constants.js';\nimport { VtkDataTypes } from '../../Common/Core/DataArray/Constants.js';\nimport Constants from './TubeFilter/Constants.js';\n\nvar VaryRadius = Constants.VaryRadius,\n    GenerateTCoords = Constants.GenerateTCoords;\nvar vtkDebugMacro = macro.vtkDebugMacro,\n    vtkErrorMacro = macro.vtkErrorMacro,\n    vtkWarningMacro = macro.vtkWarningMacro; // ----------------------------------------------------------------------------\n// vtkTubeFilter methods\n// ----------------------------------------------------------------------------\n\nfunction vtkTubeFilter(publicAPI, model) {\n  // Set our classname\n  model.classHierarchy.push('vtkTubeFilter');\n\n  function computeOffset(offset, npts) {\n    var newOffset = offset;\n\n    if (model.sidesShareVertices) {\n      newOffset += model.numberOfSides * npts;\n    } else {\n      // points are duplicated\n      newOffset += 2 * model.numberOfSides * npts;\n    }\n\n    if (model.capping) {\n      // cap points are duplicated\n      newOffset += 2 * model.numberOfSides;\n    }\n\n    return newOffset;\n  }\n\n  function findNextValidSegment(points, pointIds, start) {\n    var ptId = pointIds[start];\n    var ps = points.slice(3 * ptId, 3 * (ptId + 1));\n    var end = start + 1;\n\n    while (end < pointIds.length) {\n      var endPtId = pointIds[end];\n      var pe = points.slice(3 * endPtId, 3 * (endPtId + 1));\n\n      if (ps !== pe) {\n        return end - 1;\n      }\n\n      ++end;\n    }\n\n    return pointIds.length;\n  }\n\n  function generateSlidingNormals(pts, lines, normals) {\n    var firstNormal = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n    var normal = [0.0, 0.0, 1.0];\n    var lineData = lines; // lid = 0;\n\n    var npts = lineData[0];\n\n    for (var i = 0; i < lineData.length; i += npts + 1) {\n      npts = lineData[i];\n\n      if (npts === 1) {\n        // return arbitrary\n        normals.setTuple(lineData[i + 1], normal);\n      } else if (npts > 1) {\n        var sNextId = 0;\n        var sPrev = [0, 0, 0];\n        var sNext = [0, 0, 0];\n        var linePts = lineData.slice(i + 1, i + 1 + npts);\n        sNextId = findNextValidSegment(pts, linePts, 0);\n\n        if (sNextId !== npts) {\n          (function () {\n            // at least one valid segment\n            var pt1Id = linePts[sNextId];\n            var pt1 = pts.slice(3 * pt1Id, 3 * (pt1Id + 1));\n            var pt2Id = linePts[sNextId + 1];\n            var pt2 = pts.slice(3 * pt2Id, 3 * (pt2Id + 1));\n            sPrev = pt2.map(function (elem, idx) {\n              return elem - pt1[idx];\n            });\n            normalize(sPrev); // compute first normal\n\n            if (firstNormal) {\n              normal = firstNormal;\n            } else {\n              // find the next valid, non-parallel segment\n              while (++sNextId < npts) {\n                sNextId = findNextValidSegment(pts, linePts, sNextId);\n\n                if (sNextId !== npts) {\n                  pt1Id = linePts[sNextId];\n                  pt1 = pts.slice(3 * pt1Id, 3 * (pt1Id + 1));\n                  pt2Id = linePts[sNextId + 1];\n                  pt2 = pts.slice(3 * pt2Id, 3 * (pt2Id + 1));\n\n                  for (var j = 0; j < 3; ++j) {\n                    sNext[j] = pt2[j] - pt1[j];\n                  }\n\n                  normalize(sNext); // now the starting normal should simply be the cross product.\n                  // In the following if statement, we check for the case where\n                  // the two segments are parallel, in which case, continue\n                  // searching for the next valid segment\n\n                  var n = [0.0, 0.0, 0.0];\n                  cross(sPrev, sNext, n);\n\n                  if (norm(n) > 1.0e-3) {\n                    normal = n;\n                    sPrev = sNext;\n                    break;\n                  }\n                }\n              }\n\n              if (sNextId >= npts) {\n                // only one valid segment\n                // a little trick to find orthogonal normal\n                for (var _j = 0; _j < 3; ++_j) {\n                  if (sPrev[_j] !== 0.0) {\n                    normal[(_j + 2) % 3] = 0.0;\n                    normal[(_j + 1) % 3] = 1.0;\n                    normal[_j] = -sPrev[(_j + 1) % 3] / sPrev[_j];\n                    break;\n                  }\n                }\n              }\n            }\n\n            normalize(normal); // compute remaining normals\n\n            var lastNormalId = 0;\n\n            while (++sNextId < npts) {\n              sNextId = findNextValidSegment(pts, linePts, sNextId);\n\n              if (sNextId === npts) {\n                break;\n              }\n\n              pt1Id = linePts[sNextId];\n              pt1 = pts.slice(3 * pt1Id, 3 * (pt1Id + 1));\n              pt2Id = linePts[sNextId + 1];\n              pt2 = pts.slice(3 * pt2Id, 3 * (pt2Id + 1));\n\n              for (var _j2 = 0; _j2 < 3; ++_j2) {\n                sNext[_j2] = pt2[_j2] - pt1[_j2];\n              }\n\n              normalize(sNext); // compute rotation vector\n\n              var w = [0.0, 0.0, 0.0];\n              cross(sPrev, normal, w);\n\n              if (normalize(w) !== 0.0) {\n                // can't use this segment otherwise\n                var q = [0.0, 0.0, 0.0];\n                cross(sNext, sPrev, q);\n\n                if (normalize(q) !== 0.0) {\n                  // can't use this segment otherwise\n                  var f1 = dot(q, normal);\n                  var f2 = 1.0 - f1 * f1;\n\n                  if (f2 > 0.0) {\n                    f2 = Math.sqrt(f2);\n                  } else {\n                    f2 = 0.0;\n                  }\n\n                  var c = [0, 0, 0];\n\n                  for (var _j3 = 0; _j3 < 3; ++_j3) {\n                    c[_j3] = sNext[_j3] + sPrev[_j3];\n                  }\n\n                  normalize(c);\n                  cross(c, q, w);\n                  cross(sPrev, q, c);\n\n                  if (dot(normal, c) * dot(w, c) < 0.0) {\n                    f2 *= -1.0;\n                  } // insert current normal before updating\n\n\n                  for (var _j4 = lastNormalId; _j4 < sNextId; ++_j4) {\n                    normals.setTuple(linePts[_j4], normal);\n                  }\n\n                  lastNormalId = sNextId;\n                  sPrev = sNext; // compute next normal\n\n                  normal = f1 * q + f2 * w;\n                }\n              }\n            } // insert last normal for the remaining points\n\n\n            for (var _j5 = lastNormalId; _j5 < npts; ++_j5) {\n              normals.setTuple(linePts[_j5], normal);\n            }\n          })();\n        } else {\n          // no valid segments\n          for (var j = 0; j < npts; ++j) {\n            normals.setTuple(linePts[j], normal);\n          }\n        }\n      }\n    }\n\n    return 1;\n  }\n\n  function generatePoints(offset, npts, pts, inPts, newPts, pd, outPD, newNormals, inScalars, range, inVectors, maxSpeed, inNormals, theta) {\n    // Use averaged segment to create beveled effect.\n    var sNext = [0.0, 0.0, 0.0];\n    var sPrev = [0.0, 0.0, 0.0];\n    var startCapNorm = [0.0, 0.0, 0.0];\n    var endCapNorm = [0.0, 0.0, 0.0];\n    var p = [0.0, 0.0, 0.0];\n    var pNext = [0.0, 0.0, 0.0];\n    var s = [0.0, 0.0, 0.0];\n    var n = [0.0, 0.0, 0.0];\n    var w = [0.0, 0.0, 0.0];\n    var nP = [0.0, 0.0, 0.0];\n    var normal = [0.0, 0.0, 0.0];\n    var sFactor = 1.0;\n    var ptId = offset;\n    var vector = [];\n\n    for (var j = 0; j < npts; ++j) {\n      // First point\n      if (j === 0) {\n        p = inPts.slice(3 * pts[0], 3 * (pts[0] + 1));\n        pNext = inPts.slice(3 * pts[1], 3 * (pts[1] + 1));\n\n        for (var i = 0; i < 3; ++i) {\n          sNext[i] = pNext[i] - p[i];\n          sPrev[i] = sNext[i];\n          startCapNorm[i] = -sPrev[i];\n        }\n\n        normalize(startCapNorm);\n      } else if (j === npts - 1) {\n        for (var _i = 0; _i < 3; ++_i) {\n          sPrev[_i] = sNext[_i];\n          p[_i] = pNext[_i];\n          endCapNorm[_i] = sNext[_i];\n        }\n\n        normalize(endCapNorm);\n      } else {\n        for (var _i2 = 0; _i2 < 3; ++_i2) {\n          p[_i2] = pNext[_i2];\n        }\n\n        pNext = inPts.slice(3 * pts[j + 1], 3 * (pts[j + 1] + 1));\n\n        for (var _i3 = 0; _i3 < 3; ++_i3) {\n          sPrev[_i3] = sNext[_i3];\n          sNext[_i3] = pNext[_i3] - p[_i3];\n        }\n      }\n\n      if (normalize(sNext) === 0.0) {\n        vtkWarningMacro('Coincident points!');\n        return 0;\n      }\n\n      for (var _i4 = 0; _i4 < 3; ++_i4) {\n        s[_i4] = (sPrev[_i4] + sNext[_i4]) / 2.0; // average vector\n      }\n\n      n = inNormals.slice(3 * pts[j], 3 * (pts[j] + 1)); // if s is zero then just use sPrev cross n\n\n      if (normalize(s) === 0.0) {\n        cross(sPrev, n, s);\n\n        if (normalize(s) === 0.0) {\n          vtkDebugMacro('Using alternate bevel vector');\n        }\n      }\n\n      cross(s, n, w);\n\n      if (normalize(w) === 0.0) {\n        var msg = 'Bad normal: s = ';\n        msg += \"\".concat(s[0], \",  \").concat(s[1], \", \").concat(s[2]);\n        msg += \" n = \".concat(n[0], \",  \").concat(n[1], \", \").concat(n[2]);\n        vtkWarningMacro(msg);\n        return 0;\n      }\n\n      cross(w, s, nP); // create orthogonal coordinate system\n\n      normalize(nP); // Compute a scalar factor based on scalars or vectors\n\n      if (inScalars && model.varyRadius === VaryRadius.VARY_RADIUS_BY_SCALAR) {\n        sFactor = 1.0 + (model.radiusFactor - 1.0) * (inScalars.getComponent(pts[j], 0) - range[0]) / (range[1] - range[0]);\n      } else if (inVectors && model.varyRadius === VaryRadius.VARY_RADIUS_BY_VECTOR) {\n        sFactor = Math.sqrt(maxSpeed / norm(inVectors.getTuple(pts[j], vector)));\n\n        if (sFactor > model.radiusFactor) {\n          sFactor = model.radiusFactor;\n        }\n      } else if (inScalars && model.varyRadius === VaryRadius.VARY_RADIUS_BY_ABSOLUTE_SCALAR) {\n        sFactor = inScalars.getComponent(pts[j], 0);\n\n        if (sFactor < 0.0) {\n          vtkWarningMacro('Scalar value less than zero, skipping line');\n          return 0;\n        }\n      } // create points around line\n\n\n      if (model.sidesShareVertices) {\n        for (var k = 0; k < model.numberOfSides; ++k) {\n          for (var _i5 = 0; _i5 < 3; ++_i5) {\n            normal[_i5] = w[_i5] * Math.cos(k * theta) + nP[_i5] * Math.sin(k * theta);\n            s[_i5] = p[_i5] + model.radius * sFactor * normal[_i5];\n            newPts[3 * ptId + _i5] = s[_i5];\n            newNormals[3 * ptId + _i5] = normal[_i5];\n          }\n\n          outPD.passData(pd, pts[j], ptId);\n          ptId++;\n        } // for each side\n\n      } else {\n        var nRight = [0, 0, 0];\n        var nLeft = [0, 0, 0];\n\n        for (var _k = 0; _k < model.numberOfSides; ++_k) {\n          for (var _i6 = 0; _i6 < 3; ++_i6) {\n            // Create duplicate vertices at each point\n            // and adjust the associated normals so that they are\n            // oriented with the facets. This preserves the tube's\n            // polygonal appearance, as if by flat-shading around the tube,\n            // while still allowing smooth (gouraud) shading along the\n            // tube as it bends.\n            normal[_i6] = w[_i6] * Math.cos(_k * theta) + nP[_i6] * Math.sin(_k * theta);\n            nRight[_i6] = w[_i6] * Math.cos((_k - 0.5) * theta) + nP[_i6] * Math.sin((_k - 0.5) * theta);\n            nLeft[_i6] = w[_i6] * Math.cos((_k + 0.5) * theta) + nP[_i6] * Math.sin((_k + 0.5) * theta);\n            s[_i6] = p[_i6] + model.radius * sFactor * normal[_i6];\n            newPts[3 * ptId + _i6] = s[_i6];\n            newNormals[3 * ptId + _i6] = nRight[_i6];\n            newPts[3 * (ptId + 1) + _i6] = s[_i6];\n            newNormals[3 * (ptId + 1) + _i6] = nLeft[_i6];\n          }\n\n          outPD.passData(pd, pts[j], ptId + 1);\n          ptId += 2;\n        } // for each side\n\n      } // else separate vertices\n\n    } // for all points in the polyline\n    // Produce end points for cap. They are placed at tail end of points.\n\n\n    if (model.capping) {\n      var numCapSides = model.numberOfSides;\n      var capIncr = 1;\n\n      if (!model.sidesShareVertices) {\n        numCapSides = 2 * model.numberOfSides;\n        capIncr = 2;\n      } // the start cap\n\n\n      for (var _k2 = 0; _k2 < numCapSides; _k2 += capIncr) {\n        s = newPts.slice(3 * (offset + _k2), 3 * (offset + _k2 + 1));\n\n        for (var _i7 = 0; _i7 < 3; ++_i7) {\n          newPts[3 * ptId + _i7] = s[_i7];\n          newNormals[3 * ptId + _i7] = startCapNorm[_i7];\n        }\n\n        outPD.passData(pd, pts[0], ptId);\n        ptId++;\n      } // the end cap\n\n\n      var endOffset = offset + (npts - 1) * model.numberOfSides;\n\n      if (!model.sidesShareVertices) {\n        endOffset = offset + 2 * (npts - 1) * model.numberOfSides;\n      }\n\n      for (var _k3 = 0; _k3 < numCapSides; _k3 += capIncr) {\n        s = newPts.slice(3 * (endOffset + _k3), 3 * (endOffset + _k3 + 1));\n\n        for (var _i8 = 0; _i8 < 3; ++_i8) {\n          newPts[3 * ptId + _i8] = s[_i8];\n          newNormals[3 * ptId + _i8] = endCapNorm[_i8];\n        }\n\n        outPD.passData(pd, pts[npts - 1], ptId);\n        ptId++;\n      }\n    } // if capping\n\n\n    return 1;\n  }\n\n  function generateStrips(offset, npts, inCellId, outCellId, inCD, outCD, newStrips) {\n    var i1 = 0;\n    var i2 = 0;\n    var i3 = 0;\n    var newOutCellId = outCellId;\n    var outCellIdx = 0;\n    var newStripsData = newStrips.getData();\n    var cellId = 0;\n\n    while (outCellIdx < newStripsData.length) {\n      if (cellId === outCellId) {\n        break;\n      }\n\n      outCellIdx += newStripsData[outCellIdx] + 1;\n      cellId++;\n    }\n\n    if (model.sidesShareVertices) {\n      for (var k = offset; k < model.numberOfSides + offset; k += model.onRatio) {\n        i1 = k % model.numberOfSides;\n        i2 = (k + 1) % model.numberOfSides;\n        newStripsData[outCellIdx++] = npts * 2;\n\n        for (var i = 0; i < npts; ++i) {\n          i3 = i * model.numberOfSides;\n          newStripsData[outCellIdx++] = offset + i2 + i3;\n          newStripsData[outCellIdx++] = offset + i1 + i3;\n        }\n\n        outCD.passData(inCD, inCellId, newOutCellId++);\n      } // for each side of the tube\n\n    } else {\n      for (var _k4 = offset; _k4 < model.numberOfSides + offset; _k4 += model.onRatio) {\n        i1 = 2 * (_k4 % model.numberOfSides) + 1;\n        i2 = 2 * ((_k4 + 1) % model.numberOfSides); // outCellId = newStrips.getNumberOfCells(true);\n\n        newStripsData[outCellIdx] = npts * 2;\n        outCellIdx++;\n\n        for (var _i9 = 0; _i9 < npts; ++_i9) {\n          i3 = _i9 * 2 * model.numberOfSides;\n          newStripsData[outCellIdx++] = offset + i2 + i3;\n          newStripsData[outCellIdx++] = offset + i1 + i3;\n        }\n\n        outCD.passData(inCD, inCellId, newOutCellId++);\n      } // for each side of the tube\n\n    } // Take care of capping. The caps are n-sided polygons that can be easily\n    // triangle stripped.\n\n\n    if (model.capping) {\n      var startIdx = offset + npts * model.numberOfSides;\n      var idx = 0;\n\n      if (!model.sidesShareVertices) {\n        startIdx = offset + 2 * npts * model.numberOfSides;\n      } // The start cap\n\n\n      newStripsData[outCellIdx++] = model.numberOfSides;\n      newStripsData[outCellIdx++] = startIdx;\n      newStripsData[outCellIdx++] = startIdx + 1;\n      var _k5 = 0;\n\n      for (i1 = model.numberOfSides - 1, i2 = 2, _k5 = 0; _k5 < model.numberOfSides - 2; ++_k5) {\n        if (_k5 % 2) {\n          idx = startIdx + i2;\n          newStripsData[outCellIdx++] = idx;\n          i2++;\n        } else {\n          idx = startIdx + i1;\n          newStripsData[outCellIdx++] = idx;\n          i1--;\n        }\n      }\n\n      outCD.passData(inCD, inCellId, newOutCellId++); // The end cap - reversed order to be consistent with normal\n\n      startIdx += model.numberOfSides;\n      newStripsData[outCellIdx++] = model.numberOfSides;\n      newStripsData[outCellIdx++] = startIdx;\n      newStripsData[outCellIdx++] = startIdx + model.numberOfSides - 1;\n\n      for (i1 = model.numberOfSides - 2, i2 = 1, _k5 = 0; _k5 < model.numberOfSides - 2; ++_k5) {\n        if (_k5 % 2) {\n          idx = startIdx + i1;\n          newStripsData[outCellIdx++] = idx;\n          i1--;\n        } else {\n          idx = startIdx + i2;\n          newStripsData[outCellIdx++] = idx;\n          i2++;\n        }\n      }\n\n      outCD.passData(inCD, inCellId, newOutCellId++);\n    }\n\n    return newOutCellId;\n  }\n\n  function generateTCoords(offset, npts, pts, inPts, inScalars, newTCoords) {\n    var numSides = model.numberOfSides;\n\n    if (!model.sidesShareVertices) {\n      numSides = 2 * model.numberOfSides;\n    }\n\n    var tc = 0.0;\n    var s0 = 0.0;\n    var s = 0.0;\n    var inScalarsData = inScalars.getData();\n\n    if (model.generateTCoords === GenerateTCoords.TCOORDS_FROM_SCALARS) {\n      s0 = inScalarsData[pts[0]];\n\n      for (var i = 0; i < npts; ++i) {\n        s = inScalarsData[pts[i]];\n        tc = (s - s0) / model.textureLength;\n\n        for (var k = 0; k < numSides; ++k) {\n          var tcy = k / (numSides - 1);\n          var tcId = 2 * (offset + i * numSides + k);\n          newTCoords[tcId] = tc;\n          newTCoords[tcId + 1] = tcy;\n        }\n      }\n    } else if (model.generateTCoords === GenerateTCoords.TCOORDS_FROM_LENGTH) {\n      var len = 0.0;\n      var xPrev = inPts.slice(3 * pts[0], 3 * (pts[0] + 1));\n\n      for (var _i10 = 0; _i10 < npts; ++_i10) {\n        var x = inPts.slice(3 * pts[_i10], 3 * (pts[_i10] + 1));\n        len += Math.sqrt(distance2BetweenPoints(x, xPrev));\n        tc = len / model.textureLength;\n\n        for (var _k6 = 0; _k6 < numSides; ++_k6) {\n          var _tcy = _k6 / (numSides - 1);\n\n          var _tcId = 2 * (offset + _i10 * numSides + _k6);\n\n          newTCoords[_tcId] = tc;\n          newTCoords[_tcId + 1] = _tcy;\n        }\n\n        for (var _k7 = 0; _k7 < 3; ++_k7) {\n          xPrev[_k7] = x[_k7];\n        }\n      }\n    } else if (model.generateTCoords === GenerateTCoords.TCOORDS_FROM_NORMALIZED_LENGTH) {\n      var _len = 0.0;\n      var len1 = 0.0;\n\n      var _xPrev = inPts.slice(3 * pts[0], 3 * (pts[0] + 1));\n\n      for (var _i11 = 0; _i11 < npts; ++_i11) {\n        var _x = inPts.slice(3 * pts[_i11], 3 * (pts[_i11] + 1));\n\n        len1 += Math.sqrt(distance2BetweenPoints(_x, _xPrev));\n\n        for (var _k8 = 0; _k8 < 3; ++_k8) {\n          _xPrev[_k8] = _x[_k8];\n        }\n      }\n\n      _xPrev = inPts.slice(3 * pts[0], 3 * (pts[0] + 1));\n\n      for (var _i12 = 0; _i12 < npts; ++_i12) {\n        var _x2 = inPts.slice(3 * pts[_i12], 3 * (pts[_i12] + 1));\n\n        _len += Math.sqrt(distance2BetweenPoints(_x2, _xPrev));\n        tc = _len / len1;\n\n        for (var _k9 = 0; _k9 < numSides; ++_k9) {\n          var _tcy2 = _k9 / (numSides - 1);\n\n          var _tcId2 = 2 * (offset + _i12 * numSides + _k9);\n\n          newTCoords[_tcId2] = tc;\n          newTCoords[_tcId2 + 1] = _tcy2;\n        }\n\n        for (var _k10 = 0; _k10 < 3; ++_k10) {\n          _xPrev[_k10] = _x2[_k10];\n        }\n      }\n    } // Capping, set the endpoints as appropriate\n\n\n    if (model.capping) {\n      var startIdx = offset + npts * numSides; // start cap\n\n      for (var ik = 0; ik < model.numberOfSides; ++ik) {\n        var _tcId3 = 2 * (startIdx + ik);\n\n        newTCoords[_tcId3] = 0.0;\n        newTCoords[_tcId3 + 1] = 0.0;\n      } // end cap\n\n\n      for (var _ik = 0; _ik < model.numberOfSides; ++_ik) {\n        var _tcId4 = 2 * (startIdx + model.numberOfSides + _ik);\n\n        newTCoords[_tcId4] = 0.0;\n        newTCoords[_tcId4 + 1] = 0.0;\n      }\n    }\n  }\n\n  publicAPI.requestData = function (inData, outData) {\n    // implement requestData\n    // pass through for now\n    var output = vtkPolyData.newInstance();\n    outData[0] = output;\n    var input = inData[0];\n\n    if (!input) {\n      vtkErrorMacro('Invalid or missing input');\n      return;\n    } // Allocate output\n\n\n    var inPts = input.getPoints();\n\n    if (!inPts) {\n      return;\n    }\n\n    var numPts = inPts.getNumberOfPoints();\n\n    if (numPts < 1) {\n      return;\n    }\n\n    var inLines = input.getLines();\n\n    if (!inLines) {\n      return;\n    }\n\n    var numLines = inLines.getNumberOfCells();\n\n    if (numLines < 1) {\n      return;\n    }\n\n    var numNewPts = 0;\n    var numStrips = 0;\n    var inLinesData = inLines.getData();\n    var npts = inLinesData[0];\n\n    for (var i = 0; i < inLinesData.length; i += npts + 1) {\n      npts = inLinesData[i];\n      numNewPts = computeOffset(numNewPts, npts);\n      numStrips += (2 * npts + 1) * Math.ceil(model.numberOfSides / model.onRatio);\n\n      if (model.capping) {\n        numStrips += 2 * (model.numberOfSides + 1);\n      }\n    }\n\n    var pointType = inPts.getDataType();\n\n    if (model.outputPointsPrecision === DesiredOutputPrecision.SINGLE) {\n      pointType = VtkDataTypes.FLOAT;\n    } else if (model.outputPointsPrecision === DesiredOutputPrecision.DOUBLE) {\n      pointType = VtkDataTypes.DOUBLE;\n    }\n\n    var newPts = vtkPoints.newInstance({\n      dataType: pointType,\n      size: numNewPts * 3,\n      numberOfComponents: 3\n    });\n    var numNormals = 3 * numNewPts;\n    var newNormalsData = new Float32Array(numNormals);\n    var newNormals = vtkDataArray.newInstance({\n      numberOfComponents: 3,\n      values: newNormalsData,\n      name: 'TubeNormals'\n    });\n    var newStripsData = new Uint32Array(numStrips);\n    var newStrips = vtkCellArray.newInstance({\n      values: newStripsData\n    });\n    var newStripId = 0;\n    var inNormals = input.getPointData().getNormals();\n    var inNormalsData = null;\n    var generateNormals = false;\n\n    if (!inNormals || model.useDefaultNormal) {\n      inNormalsData = new Float32Array(3 * numPts);\n      inNormals = vtkDataArray.newInstance({\n        numberOfComponents: 3,\n        values: inNormalsData,\n        name: 'Normals'\n      });\n\n      if (model.useDefaultNormal) {\n        inNormalsData = inNormalsData.map(function (elem, index) {\n          var i = index % 3;\n          return model.defaultNormal[i];\n        });\n      } else {\n        generateNormals = true;\n      }\n    } // loop over pointData arrays and resize based on numNewPts\n\n\n    var numArrays = input.getPointData().getNumberOfArrays();\n    var oldArray = null;\n    var newArray = null;\n\n    for (var _i13 = 0; _i13 < numArrays; _i13++) {\n      oldArray = input.getPointData().getArrayByIndex(_i13);\n      newArray = vtkDataArray.newInstance({\n        name: oldArray.getName(),\n        dataType: oldArray.getDataType(),\n        numberOfComponents: oldArray.getNumberOfComponents(),\n        size: numNewPts * oldArray.getNumberOfComponents()\n      });\n      output.getPointData().removeArrayByIndex(0); // remove oldArray from beginning\n\n      output.getPointData().addArray(newArray); // concat newArray to end\n    } // loop over cellData arrays and resize based on numNewCells\n\n\n    var numNewCells = inLines.getNumberOfCells() * model.numberOfSides;\n\n    if (model.capping) {\n      numNewCells += 2;\n    }\n\n    var numCellArrays = input.getCellData().getNumberOfArrays();\n\n    for (var _i14 = 0; _i14 < numCellArrays; _i14++) {\n      oldArray = input.getCellData().getArrayByIndex(_i14);\n      newArray = vtkDataArray.newInstance({\n        name: oldArray.getName(),\n        dataType: oldArray.getDataType(),\n        numberOfComponents: oldArray.getNumberOfComponents(),\n        size: numNewCells * oldArray.getNumberOfComponents()\n      });\n      output.getCellData().removeArrayByIndex(0); // remove oldArray from beginning\n\n      output.getCellData().addArray(newArray); // concat newArray to end\n    }\n\n    var inScalars = publicAPI.getInputArrayToProcess(0);\n    var outScalars = null;\n    var range = [];\n\n    if (inScalars) {\n      // allocate output scalar array\n      // assuming point scalars for now\n      outScalars = vtkDataArray.newInstance({\n        name: inScalars.getName(),\n        dataType: inScalars.getDataType(),\n        numberOfComponents: inScalars.getNumberOfComponents(),\n        size: numNewPts * inScalars.getNumberOfComponents()\n      });\n      range = inScalars.getRange();\n\n      if (range[1] - range[0] === 0.0) {\n        if (model.varyRadius === VaryRadius.VARY_RADIUS_BY_SCALAR) {\n          vtkWarningMacro('Scalar range is zero!');\n        }\n\n        range[1] = range[0] + 1.0;\n      }\n    }\n\n    var inVectors = publicAPI.getInputArrayToProcess(1);\n    var maxSpeed = 0;\n\n    if (inVectors) {\n      maxSpeed = inVectors.getMaxNorm();\n    }\n\n    var outCD = output.getCellData();\n    outCD.copyNormalsOff();\n    outCD.passData(input.getCellData());\n    var outPD = output.getPointData();\n\n    if (outPD.getNormals() !== null) {\n      outPD.copyNormalsOff();\n    }\n\n    if (inScalars && outScalars) {\n      outPD.setScalars(outScalars);\n    } // TCoords\n\n\n    var newTCoords = null;\n\n    if (model.generateTCoords === GenerateTCoords.TCOORDS_FROM_SCALARS && inScalars || model.generateTCoords === GenerateTCoords.TCOORDS_FROM_LENGTH || model.generateTCoords === GenerateTCoords.TCOORDS_FROM_NORMALIZED_LENGTH) {\n      var newTCoordsData = new Float32Array(2 * numNewPts);\n      newTCoords = vtkDataArray.newInstance({\n        numberOfComponents: 2,\n        values: newTCoordsData,\n        name: 'TCoords'\n      });\n      outPD.copyTCoordsOff();\n    }\n\n    outPD.passData(input.getPointData()); // Create points along each polyline that are connected into numberOfSides\n    // triangle strips.\n\n    var theta = 2.0 * Math.PI / model.numberOfSides;\n    npts = inLinesData[0];\n    var offset = 0;\n    var inCellId = input.getVerts().getNumberOfCells();\n\n    for (var _i15 = 0; _i15 < inLinesData.length; _i15 += npts + 1) {\n      npts = inLinesData[_i15];\n      var pts = inLinesData.slice(_i15 + 1, _i15 + 1 + npts);\n\n      if (npts > 1) {\n        // if not, skip tubing this line\n        if (generateNormals) {\n          var polyLine = inLinesData.slice(_i15, _i15 + npts + 1);\n          generateSlidingNormals(inPts.getData(), polyLine, inNormals);\n        }\n      } // generate points\n\n\n      if (generatePoints(offset, npts, pts, inPts.getData(), newPts.getData(), input.getPointData(), outPD, newNormalsData, inScalars, range, inVectors, maxSpeed, inNormalsData, theta)) {\n        // generate strips for the polyline\n        newStripId = generateStrips(offset, npts, inCellId, newStripId, input.getCellData(), outCD, newStrips); // generate texture coordinates for the polyline\n\n        if (newTCoords) {\n          generateTCoords(offset, npts, pts, inPts.getData(), inScalars, newTCoords.getData());\n        }\n      } else {\n        // skip tubing this line\n        vtkWarningMacro('Could not generate points');\n      } // lineIdx += npts;\n      // Compute the new offset for the next polyline\n\n\n      offset = computeOffset(offset, npts);\n      inCellId++;\n    }\n\n    output.setPoints(newPts);\n    output.setStrips(newStrips);\n    output.setPointData(outPD);\n    outPD.setNormals(newNormals);\n    outData[0] = output;\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\n\nvar DEFAULT_VALUES = {\n  outputPointsPrecision: DesiredOutputPrecision.DEFAULT,\n  radius: 0.5,\n  varyRadius: VaryRadius.VARY_RADIUS_OFF,\n  numberOfSides: 3,\n  radiusFactor: 10,\n  defaultNormal: [0, 0, 1],\n  useDefaultNormal: false,\n  sidesShareVertices: true,\n  capping: false,\n  onRatio: 1,\n  offset: 0,\n  generateTCoords: GenerateTCoords.TCOORDS_OFF,\n  textureLength: 1.0\n}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Build VTK API\n\n  macro.setGet(publicAPI, model, ['outputPointsPrecision', 'radius', 'varyRadius', 'numberOfSides', 'radiusFactor', 'defaultNormal', 'useDefaultNormal', 'sidesShareVertices', 'capping', 'onRatio', 'offset', 'generateTCoords', 'textureLength']); // Make this a VTK object\n\n  macro.obj(publicAPI, model); // Also make it an algorithm with one input and one output\n\n  macro.algo(publicAPI, model, 1, 1); // Object specific methods\n\n  vtkTubeFilter(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = macro.newInstance(extend, 'vtkTubeFilter'); // ----------------------------------------------------------------------------\n\nvar vtkTubeFilter$1 = {\n  newInstance: newInstance,\n  extend: extend\n};\n\nexport { vtkTubeFilter$1 as default, extend, newInstance };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}