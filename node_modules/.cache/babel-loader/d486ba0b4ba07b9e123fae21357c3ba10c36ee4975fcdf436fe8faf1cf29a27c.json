{"ast":null,"code":"import macro from '../../macros.js';\nimport { d as dot } from '../../Common/Core/Math/index.js';\nimport vtkPicker from './Picker.js';\nvar vtkErrorMacro = macro.vtkErrorMacro; // ----------------------------------------------------------------------------\n// vtkPointPicker methods\n// ----------------------------------------------------------------------------\n\nfunction vtkPointPicker(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkPointPicker');\n  publicAPI.intersectWithLine = function (p1, p2, tol, mapper) {\n    var tMin = Number.MAX_VALUE;\n    if (mapper.isA('vtkImageMapper') || mapper.isA('vtkImageArrayMapper')) {\n      var pickData = mapper.intersectWithLineForPointPicking(p1, p2);\n      if (pickData) {\n        tMin = pickData.t;\n        model.pointIJK = pickData.ijk;\n      }\n    } else if (mapper.isA('vtkMapper')) {\n      tMin = publicAPI.intersectActorWithLine(p1, p2, tol, mapper);\n    }\n    return tMin;\n  };\n  publicAPI.intersectActorWithLine = function (p1, p2, tol, mapper) {\n    // Get dataset\n    var input = mapper.getInputData(); // Determine appropriate info\n\n    var ptId = 0;\n    var numPts = input.getPoints().getNumberOfPoints();\n    if (numPts <= ptId) {\n      return 2.0;\n    }\n    var ray = [];\n    for (var i = 0; i < 3; i++) {\n      ray[i] = p2[i] - p1[i];\n    }\n    var rayFactor = dot(ray, ray);\n    if (rayFactor === 0.0) {\n      vtkErrorMacro('Cannot process points');\n      return 2.0;\n    }\n    var t;\n    var minPtId = -1;\n    var tMin = Number.MAX_VALUE;\n    var minPtDist = Number.MAX_VALUE;\n    var projXYZ = [];\n    var x = [];\n    var points = input.getPoints();\n    if (model.useCells) {\n      var cellData = input.getPolys().getData();\n      var nbPointsPerCell = cellData[0];\n      var nbCells = input.getPolys().getNumberOfCells();\n      for (var cellID = 0; cellID < nbCells; cellID++) {\n        var firstPointIndex = cellID * nbPointsPerCell + 1;\n        var lastPointIndex = firstPointIndex + nbPointsPerCell;\n        for (var pointIndex = firstPointIndex; pointIndex < lastPointIndex; pointIndex++) {\n          var pointDataIndex = cellData[pointIndex];\n          points.getPoint(pointDataIndex, x);\n          t = (ray[0] * (x[0] - p1[0]) + ray[1] * (x[1] - p1[1]) + ray[2] * (x[2] - p1[2])) / rayFactor; // If we find a point closer than we currently have, see whether it\n          // lies within the pick tolerance and clipping planes. We keep track\n          // of the point closest to the line (use a fudge factor for points\n          // nearly the same distance away.)\n\n          if (t >= 0.0 && t <= 1.0 && t <= tMin + model.tolerance) {\n            var maxDist = 0.0;\n            for (var _i = 0; _i < 3; _i++) {\n              projXYZ[_i] = p1[_i] + t * ray[_i];\n              var dist = Math.abs(x[_i] - projXYZ[_i]);\n              if (dist > maxDist) {\n                maxDist = dist;\n              }\n            } // end for i\n\n            if (maxDist <= tol && maxDist < minPtDist) {\n              // within tolerance\n              minPtId = ptId;\n              minPtDist = maxDist;\n              tMin = t;\n            }\n          }\n        } // end for pointIndex\n      } // end for cellID\n    } else {\n      // end if model.useCells\n      for (ptId = 0; ptId < numPts; ptId++) {\n        points.getPoint(ptId, x);\n        t = (ray[0] * (x[0] - p1[0]) + ray[1] * (x[1] - p1[1]) + ray[2] * (x[2] - p1[2])) / rayFactor; // If we find a point closer than we currently have, see whether it\n        // lies within the pick tolerance and clipping planes. We keep track\n        // of the point closest to the line (use a fudge factor for points\n        // nearly the same distance away.)\n\n        if (t >= 0.0 && t <= 1.0 && t <= tMin + model.tolerance) {\n          var _maxDist = 0.0;\n          for (var _i2 = 0; _i2 < 3; _i2++) {\n            projXYZ[_i2] = p1[_i2] + t * ray[_i2];\n            var _dist = Math.abs(x[_i2] - projXYZ[_i2]);\n            if (_dist > _maxDist) {\n              _maxDist = _dist;\n            }\n          } // end for i\n\n          if (_maxDist <= tol && _maxDist < minPtDist) {\n            // within tolerance\n            minPtId = ptId;\n            minPtDist = _maxDist;\n            tMin = t;\n          }\n        }\n      }\n    }\n    model.pointId = minPtId;\n    return tMin;\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nvar DEFAULT_VALUES = {\n  pointId: -1,\n  pointIJK: [],\n  useCells: false\n}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Inheritance\n\n  vtkPicker.extend(publicAPI, model, initialValues);\n  macro.getArray(publicAPI, model, ['pointIJK']);\n  macro.get(publicAPI, model, ['pointId']);\n  macro.setGet(publicAPI, model, ['useCells']);\n  vtkPointPicker(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = macro.newInstance(extend, 'vtkPointPicker'); // ----------------------------------------------------------------------------\n\nvar vtkPointPicker$1 = {\n  newInstance: newInstance,\n  extend: extend\n};\nexport { vtkPointPicker$1 as default, extend, newInstance };","map":{"version":3,"names":["macro","d","dot","vtkPicker","vtkErrorMacro","vtkPointPicker","publicAPI","model","classHierarchy","push","intersectWithLine","p1","p2","tol","mapper","tMin","Number","MAX_VALUE","isA","pickData","intersectWithLineForPointPicking","t","pointIJK","ijk","intersectActorWithLine","input","getInputData","ptId","numPts","getPoints","getNumberOfPoints","ray","i","rayFactor","minPtId","minPtDist","projXYZ","x","points","useCells","cellData","getPolys","getData","nbPointsPerCell","nbCells","getNumberOfCells","cellID","firstPointIndex","lastPointIndex","pointIndex","pointDataIndex","getPoint","tolerance","maxDist","_i","dist","Math","abs","_maxDist","_i2","_dist","pointId","DEFAULT_VALUES","extend","initialValues","arguments","length","undefined","Object","assign","getArray","get","setGet","newInstance","vtkPointPicker$1","default"],"sources":["/home/rakshith/Documents/RemoteRendering/vtk-js-react-app/node_modules/@kitware/vtk.js/Rendering/Core/PointPicker.js"],"sourcesContent":["import macro from '../../macros.js';\nimport { d as dot } from '../../Common/Core/Math/index.js';\nimport vtkPicker from './Picker.js';\n\nvar vtkErrorMacro = macro.vtkErrorMacro; // ----------------------------------------------------------------------------\n// vtkPointPicker methods\n// ----------------------------------------------------------------------------\n\nfunction vtkPointPicker(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkPointPicker');\n\n  publicAPI.intersectWithLine = function (p1, p2, tol, mapper) {\n    var tMin = Number.MAX_VALUE;\n\n    if (mapper.isA('vtkImageMapper') || mapper.isA('vtkImageArrayMapper')) {\n      var pickData = mapper.intersectWithLineForPointPicking(p1, p2);\n\n      if (pickData) {\n        tMin = pickData.t;\n        model.pointIJK = pickData.ijk;\n      }\n    } else if (mapper.isA('vtkMapper')) {\n      tMin = publicAPI.intersectActorWithLine(p1, p2, tol, mapper);\n    }\n\n    return tMin;\n  };\n\n  publicAPI.intersectActorWithLine = function (p1, p2, tol, mapper) {\n    // Get dataset\n    var input = mapper.getInputData(); // Determine appropriate info\n\n    var ptId = 0;\n    var numPts = input.getPoints().getNumberOfPoints();\n\n    if (numPts <= ptId) {\n      return 2.0;\n    }\n\n    var ray = [];\n\n    for (var i = 0; i < 3; i++) {\n      ray[i] = p2[i] - p1[i];\n    }\n\n    var rayFactor = dot(ray, ray);\n\n    if (rayFactor === 0.0) {\n      vtkErrorMacro('Cannot process points');\n      return 2.0;\n    }\n\n    var t;\n    var minPtId = -1;\n    var tMin = Number.MAX_VALUE;\n    var minPtDist = Number.MAX_VALUE;\n    var projXYZ = [];\n    var x = [];\n    var points = input.getPoints();\n\n    if (model.useCells) {\n      var cellData = input.getPolys().getData();\n      var nbPointsPerCell = cellData[0];\n      var nbCells = input.getPolys().getNumberOfCells();\n\n      for (var cellID = 0; cellID < nbCells; cellID++) {\n        var firstPointIndex = cellID * nbPointsPerCell + 1;\n        var lastPointIndex = firstPointIndex + nbPointsPerCell;\n\n        for (var pointIndex = firstPointIndex; pointIndex < lastPointIndex; pointIndex++) {\n          var pointDataIndex = cellData[pointIndex];\n          points.getPoint(pointDataIndex, x);\n          t = (ray[0] * (x[0] - p1[0]) + ray[1] * (x[1] - p1[1]) + ray[2] * (x[2] - p1[2])) / rayFactor; // If we find a point closer than we currently have, see whether it\n          // lies within the pick tolerance and clipping planes. We keep track\n          // of the point closest to the line (use a fudge factor for points\n          // nearly the same distance away.)\n\n          if (t >= 0.0 && t <= 1.0 && t <= tMin + model.tolerance) {\n            var maxDist = 0.0;\n\n            for (var _i = 0; _i < 3; _i++) {\n              projXYZ[_i] = p1[_i] + t * ray[_i];\n              var dist = Math.abs(x[_i] - projXYZ[_i]);\n\n              if (dist > maxDist) {\n                maxDist = dist;\n              }\n            } // end for i\n\n\n            if (maxDist <= tol && maxDist < minPtDist) {\n              // within tolerance\n              minPtId = ptId;\n              minPtDist = maxDist;\n              tMin = t;\n            }\n          }\n        } // end for pointIndex\n\n      } // end for cellID\n\n    } else {\n      // end if model.useCells\n      for (ptId = 0; ptId < numPts; ptId++) {\n        points.getPoint(ptId, x);\n        t = (ray[0] * (x[0] - p1[0]) + ray[1] * (x[1] - p1[1]) + ray[2] * (x[2] - p1[2])) / rayFactor; // If we find a point closer than we currently have, see whether it\n        // lies within the pick tolerance and clipping planes. We keep track\n        // of the point closest to the line (use a fudge factor for points\n        // nearly the same distance away.)\n\n        if (t >= 0.0 && t <= 1.0 && t <= tMin + model.tolerance) {\n          var _maxDist = 0.0;\n\n          for (var _i2 = 0; _i2 < 3; _i2++) {\n            projXYZ[_i2] = p1[_i2] + t * ray[_i2];\n\n            var _dist = Math.abs(x[_i2] - projXYZ[_i2]);\n\n            if (_dist > _maxDist) {\n              _maxDist = _dist;\n            }\n          } // end for i\n\n\n          if (_maxDist <= tol && _maxDist < minPtDist) {\n            // within tolerance\n            minPtId = ptId;\n            minPtDist = _maxDist;\n            tMin = t;\n          }\n        }\n      }\n    }\n\n    model.pointId = minPtId;\n    return tMin;\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\n\nvar DEFAULT_VALUES = {\n  pointId: -1,\n  pointIJK: [],\n  useCells: false\n}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Inheritance\n\n  vtkPicker.extend(publicAPI, model, initialValues);\n  macro.getArray(publicAPI, model, ['pointIJK']);\n  macro.get(publicAPI, model, ['pointId']);\n  macro.setGet(publicAPI, model, ['useCells']);\n  vtkPointPicker(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = macro.newInstance(extend, 'vtkPointPicker'); // ----------------------------------------------------------------------------\n\nvar vtkPointPicker$1 = {\n  newInstance: newInstance,\n  extend: extend\n};\n\nexport { vtkPointPicker$1 as default, extend, newInstance };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}