{"ast":null,"code":"import _toConsumableArray from '@babel/runtime/helpers/toConsumableArray';\nimport macro from '../../macros.js';\nimport vtkWebGPUBufferManager from './BufferManager.js';\nimport vtkWebGPUTypes from './Types.js';\nvar BufferUsage = vtkWebGPUBufferManager.BufferUsage;\nvar vtkErrorMacro = macro.vtkErrorMacro; // ----------------------------------------------------------------------------\n// vtkWebGPUUniformBuffer methods\n// ----------------------------------------------------------------------------\n\nfunction vtkWebGPUUniformBuffer(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkWebGPUUniformBuffer');\n  publicAPI.addEntry = function (name, type) {\n    if (model._bufferEntryNames.has(name)) {\n      vtkErrorMacro(\"entry named \".concat(name, \" already exists\"));\n      return;\n    }\n    model.sortDirty = true;\n    model._bufferEntryNames.set(name, model.bufferEntries.length);\n    model.bufferEntries.push({\n      name: name,\n      type: type,\n      sizeInBytes: vtkWebGPUTypes.getByteStrideFromShaderFormat(type),\n      offset: -1,\n      nativeType: vtkWebGPUTypes.getNativeTypeFromShaderFormat(type),\n      packed: false\n    });\n  }; // UBOs have layout rules in terms of how memory is aligned so we\n  // have to be careful how we order the entries. For example a vec4<f32>\n  // must be aligned on a 16 byte offset, etc. See\n  // https://gpuweb.github.io/gpuweb/wgsl/#memory-layouts\n  // for more details. Right now you can create a situation that would fail\n  // in the future we could add dummy spacer entries where needed to\n  // handle alignment issues\n\n  publicAPI.sortBufferEntries = function () {\n    if (!model.sortDirty) {\n      return;\n    }\n    var currOffset = 0;\n    var newEntries = []; // compute the max alignment, this is required as WebGPU defines a UBO to have\n    // a size that is a multiple of the maxAlignment\n\n    var maxAlignment = 4;\n    for (var i = 0; i < model.bufferEntries.length; i++) {\n      var entry = model.bufferEntries[i];\n      if (entry.sizeInBytes % 16 === 0) {\n        maxAlignment = Math.max(16, maxAlignment);\n      }\n      if (entry.sizeInBytes % 8 === 0) {\n        maxAlignment = Math.max(8, maxAlignment);\n      }\n    } // pack anything whose size is a multiple of 16 bytes first\n    // this includes a couple types that don't require 16 byte alignment\n    // such as mat2x2<f32> but that is OK\n\n    for (var _i = 0; _i < model.bufferEntries.length; _i++) {\n      var _entry = model.bufferEntries[_i];\n      if (_entry.packed === false && _entry.sizeInBytes % 16 === 0) {\n        _entry.packed = true;\n        _entry.offset = currOffset;\n        newEntries.push(_entry);\n        currOffset += _entry.sizeInBytes;\n      }\n    } // now it gets tough, we have the following common types (f32, i32, u32)\n    // - vec2<f32> 8 byte size, 8 byte alignment\n    // - vec3<f32> 12 byte size, 16 byte alignment\n    // - f32 4 byte size, 4 byte alignment\n    // try adding 12 byte, 4 byte pairs\n\n    for (var _i2 = 0; _i2 < model.bufferEntries.length; _i2++) {\n      var _entry2 = model.bufferEntries[_i2];\n      if (_entry2.packed === false && _entry2.sizeInBytes === 12) {\n        for (var i2 = 0; i2 < model.bufferEntries.length; i2++) {\n          var entry2 = model.bufferEntries[i2];\n          if (entry2.packed === false && entry2.sizeInBytes === 4) {\n            _entry2.packed = true;\n            _entry2.offset = currOffset;\n            newEntries.push(_entry2);\n            currOffset += _entry2.sizeInBytes;\n            entry2.packed = true;\n            entry2.offset = currOffset;\n            newEntries.push(entry2);\n            currOffset += entry2.sizeInBytes;\n            break;\n          }\n        }\n      }\n    } // try adding 8 byte, 8 byte pairs\n\n    for (var _i3 = 0; _i3 < model.bufferEntries.length; _i3++) {\n      var _entry3 = model.bufferEntries[_i3];\n      if (!_entry3.packed && _entry3.sizeInBytes % 8 === 0) {\n        for (var _i4 = _i3 + 1; _i4 < model.bufferEntries.length; _i4++) {\n          var _entry4 = model.bufferEntries[_i4];\n          if (!_entry4.packed && _entry4.sizeInBytes % 8 === 0) {\n            _entry3.packed = true;\n            _entry3.offset = currOffset;\n            newEntries.push(_entry3);\n            currOffset += _entry3.sizeInBytes;\n            _entry4.packed = true;\n            _entry4.offset = currOffset;\n            newEntries.push(_entry4);\n            currOffset += _entry4.sizeInBytes;\n            break;\n          }\n        }\n      }\n    } // try adding 8 byte, 4 byte 4 byte triplets\n\n    for (var _i5 = 0; _i5 < model.bufferEntries.length; _i5++) {\n      var _entry5 = model.bufferEntries[_i5];\n      if (!_entry5.packed && _entry5.sizeInBytes % 8 === 0) {\n        var found = false;\n        for (var _i6 = 0; !found && _i6 < model.bufferEntries.length; _i6++) {\n          var _entry6 = model.bufferEntries[_i6];\n          if (!_entry6.packed && _entry6.sizeInBytes === 4) {\n            for (var i3 = _i6 + 1; i3 < model.bufferEntries.length; i3++) {\n              var entry3 = model.bufferEntries[i3];\n              if (!entry3.packed && entry3.sizeInBytes === 4) {\n                _entry5.packed = true;\n                _entry5.offset = currOffset;\n                newEntries.push(_entry5);\n                currOffset += _entry5.sizeInBytes;\n                _entry6.packed = true;\n                _entry6.offset = currOffset;\n                newEntries.push(_entry6);\n                currOffset += _entry6.sizeInBytes;\n                entry3.packed = true;\n                entry3.offset = currOffset;\n                newEntries.push(entry3);\n                currOffset += entry3.sizeInBytes;\n                found = true;\n                break;\n              }\n            }\n          }\n        }\n      }\n    } // Add anything remaining that is larger than 4 bytes and hope we get lucky.\n    // Likely if there is more than one item added here it will result\n    // in a failed UBO\n\n    for (var _i7 = 0; _i7 < model.bufferEntries.length; _i7++) {\n      var _entry7 = model.bufferEntries[_i7];\n      if (!_entry7.packed && _entry7.sizeInBytes > 4) {\n        _entry7.packed = true;\n        _entry7.offset = currOffset;\n        newEntries.push(_entry7);\n        currOffset += _entry7.sizeInBytes;\n      }\n    } // finally add remaining 4 byte items\n\n    for (var _i8 = 0; _i8 < model.bufferEntries.length; _i8++) {\n      var _entry8 = model.bufferEntries[_i8];\n      if (!_entry8.packed) {\n        _entry8.packed = true;\n        _entry8.offset = currOffset;\n        newEntries.push(_entry8);\n        currOffset += _entry8.sizeInBytes;\n      }\n    } // update entries and entryNames\n\n    model.bufferEntries = newEntries;\n    model._bufferEntryNames.clear();\n    for (var _i9 = 0; _i9 < model.bufferEntries.length; _i9++) {\n      model._bufferEntryNames.set(model.bufferEntries[_i9].name, _i9);\n    }\n    model.sizeInBytes = currOffset;\n    model.sizeInBytes = maxAlignment * Math.ceil(model.sizeInBytes / maxAlignment);\n    model.sortDirty = false;\n  };\n  publicAPI.sendIfNeeded = function (device) {\n    if (!model.UBO) {\n      var req = {\n        nativeArray: model.Float32Array,\n        usage: BufferUsage.UniformArray,\n        label: model.label\n      };\n      model.UBO = device.getBufferManager().getBuffer(req);\n      model.bindGroupTime.modified();\n      model.sendDirty = false;\n    } // send data down if needed\n\n    if (model.sendDirty) {\n      device.getHandle().queue.writeBuffer(model.UBO.getHandle(), 0, model.arrayBuffer, 0, model.sizeInBytes);\n      model.sendDirty = false;\n    } // always updated as mappers depend on this time\n    // it is more of a sentIfNeededTime\n\n    model.sendTime.modified();\n  };\n  publicAPI.createView = function (type) {\n    if (type in model === false) {\n      if (!model.arrayBuffer) {\n        model.arrayBuffer = new ArrayBuffer(model.sizeInBytes);\n      }\n      model[type] = macro.newTypedArray(type, model.arrayBuffer);\n    }\n  };\n  publicAPI.setValue = function (name, val) {\n    publicAPI.sortBufferEntries();\n    var idx = model._bufferEntryNames.get(name);\n    if (idx === undefined) {\n      vtkErrorMacro(\"entry named \".concat(name, \" not found in UBO\"));\n      return;\n    }\n    var entry = model.bufferEntries[idx];\n    publicAPI.createView(entry.nativeType);\n    var view = model[entry.nativeType];\n    if (entry.lastValue !== val) {\n      view[entry.offset / view.BYTES_PER_ELEMENT] = val;\n      model.sendDirty = true;\n    }\n    entry.lastValue = val;\n  };\n  publicAPI.setArray = function (name, arr) {\n    publicAPI.sortBufferEntries();\n    var idx = model._bufferEntryNames.get(name);\n    if (idx === undefined) {\n      vtkErrorMacro(\"entry named \".concat(name, \" not found in UBO\"));\n      return;\n    }\n    var entry = model.bufferEntries[idx];\n    publicAPI.createView(entry.nativeType);\n    var view = model[entry.nativeType];\n    var changed = false;\n    for (var i = 0; i < arr.length; i++) {\n      if (!entry.lastValue || entry.lastValue[i] !== arr[i]) {\n        view[entry.offset / view.BYTES_PER_ELEMENT + i] = arr[i];\n        changed = true;\n      }\n    }\n    if (changed) {\n      model.sendDirty = true;\n      entry.lastValue = _toConsumableArray(arr);\n    }\n  };\n  publicAPI.getBindGroupEntry = function () {\n    var foo = {\n      resource: {\n        buffer: model.UBO.getHandle()\n      }\n    };\n    return foo;\n  };\n  publicAPI.getSendTime = function () {\n    return model.sendTime.getMTime();\n  };\n  publicAPI.getShaderCode = function (binding, group) {\n    // sort the entries\n    publicAPI.sortBufferEntries();\n    var lines = [\"struct \".concat(model.label, \"Struct\\n{\")];\n    for (var i = 0; i < model.bufferEntries.length; i++) {\n      var entry = model.bufferEntries[i];\n      lines.push(\"  \".concat(entry.name, \": \").concat(entry.type, \",\"));\n    }\n    lines.push(\"};\\n@binding(\".concat(binding, \") @group(\").concat(group, \") var<uniform> \").concat(model.label, \": \").concat(model.label, \"Struct;\"));\n    return lines.join('\\n');\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nvar DEFAULT_VALUES = {\n  bufferEntries: null,\n  bufferEntryNames: null,\n  sizeInBytes: 0,\n  label: null,\n  bindGroupLayoutEntry: null,\n  bindGroupEntry: null\n}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Build VTK API\n\n  macro.obj(publicAPI, model); // Internal objects\n\n  model._bufferEntryNames = new Map();\n  model.bufferEntries = []; // default UBO desc\n\n  model.bindGroupLayoutEntry = model.bindGroupLayoutEntry || {\n    buffer: {\n      type: 'uniform'\n    }\n  };\n  model.sendTime = {};\n  macro.obj(model.sendTime, {\n    mtime: 0\n  });\n  model.bindGroupTime = {};\n  macro.obj(model.bindGroupTime, {\n    mtime: 0\n  });\n  model.sendDirty = true;\n  model.sortDirty = true;\n  macro.get(publicAPI, model, ['binding', 'bindGroupTime']);\n  macro.setGet(publicAPI, model, ['bindGroupLayoutEntry', 'device', 'label', 'sizeInBytes']); // Object methods\n\n  vtkWebGPUUniformBuffer(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = macro.newInstance(extend, 'vtkWebGPUUniformBuffer'); // ----------------------------------------------------------------------------\n\nvar vtkWebGPUUniformBuffer$1 = {\n  newInstance: newInstance,\n  extend: extend\n};\nexport { vtkWebGPUUniformBuffer$1 as default, extend, newInstance };","map":{"version":3,"names":["_toConsumableArray","macro","vtkWebGPUBufferManager","vtkWebGPUTypes","BufferUsage","vtkErrorMacro","vtkWebGPUUniformBuffer","publicAPI","model","classHierarchy","push","addEntry","name","type","_bufferEntryNames","has","concat","sortDirty","set","bufferEntries","length","sizeInBytes","getByteStrideFromShaderFormat","offset","nativeType","getNativeTypeFromShaderFormat","packed","sortBufferEntries","currOffset","newEntries","maxAlignment","i","entry","Math","max","_i","_entry","_i2","_entry2","i2","entry2","_i3","_entry3","_i4","_entry4","_i5","_entry5","found","_i6","_entry6","i3","entry3","_i7","_entry7","_i8","_entry8","clear","_i9","ceil","sendIfNeeded","device","UBO","req","nativeArray","Float32Array","usage","UniformArray","label","getBufferManager","getBuffer","bindGroupTime","modified","sendDirty","getHandle","queue","writeBuffer","arrayBuffer","sendTime","createView","ArrayBuffer","newTypedArray","setValue","val","idx","get","undefined","view","lastValue","BYTES_PER_ELEMENT","setArray","arr","changed","getBindGroupEntry","foo","resource","buffer","getSendTime","getMTime","getShaderCode","binding","group","lines","join","DEFAULT_VALUES","bufferEntryNames","bindGroupLayoutEntry","bindGroupEntry","extend","initialValues","arguments","Object","assign","obj","Map","mtime","setGet","newInstance","vtkWebGPUUniformBuffer$1","default"],"sources":["/home/rakshith/Documents/RemoteRendering/vtk-js-react-app/node_modules/@kitware/vtk.js/Rendering/WebGPU/UniformBuffer.js"],"sourcesContent":["import _toConsumableArray from '@babel/runtime/helpers/toConsumableArray';\nimport macro from '../../macros.js';\nimport vtkWebGPUBufferManager from './BufferManager.js';\nimport vtkWebGPUTypes from './Types.js';\n\nvar BufferUsage = vtkWebGPUBufferManager.BufferUsage;\nvar vtkErrorMacro = macro.vtkErrorMacro; // ----------------------------------------------------------------------------\n// vtkWebGPUUniformBuffer methods\n// ----------------------------------------------------------------------------\n\nfunction vtkWebGPUUniformBuffer(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkWebGPUUniformBuffer');\n\n  publicAPI.addEntry = function (name, type) {\n    if (model._bufferEntryNames.has(name)) {\n      vtkErrorMacro(\"entry named \".concat(name, \" already exists\"));\n      return;\n    }\n\n    model.sortDirty = true;\n\n    model._bufferEntryNames.set(name, model.bufferEntries.length);\n\n    model.bufferEntries.push({\n      name: name,\n      type: type,\n      sizeInBytes: vtkWebGPUTypes.getByteStrideFromShaderFormat(type),\n      offset: -1,\n      nativeType: vtkWebGPUTypes.getNativeTypeFromShaderFormat(type),\n      packed: false\n    });\n  }; // UBOs have layout rules in terms of how memory is aligned so we\n  // have to be careful how we order the entries. For example a vec4<f32>\n  // must be aligned on a 16 byte offset, etc. See\n  // https://gpuweb.github.io/gpuweb/wgsl/#memory-layouts\n  // for more details. Right now you can create a situation that would fail\n  // in the future we could add dummy spacer entries where needed to\n  // handle alignment issues\n\n\n  publicAPI.sortBufferEntries = function () {\n    if (!model.sortDirty) {\n      return;\n    }\n\n    var currOffset = 0;\n    var newEntries = []; // compute the max alignment, this is required as WebGPU defines a UBO to have\n    // a size that is a multiple of the maxAlignment\n\n    var maxAlignment = 4;\n\n    for (var i = 0; i < model.bufferEntries.length; i++) {\n      var entry = model.bufferEntries[i];\n\n      if (entry.sizeInBytes % 16 === 0) {\n        maxAlignment = Math.max(16, maxAlignment);\n      }\n\n      if (entry.sizeInBytes % 8 === 0) {\n        maxAlignment = Math.max(8, maxAlignment);\n      }\n    } // pack anything whose size is a multiple of 16 bytes first\n    // this includes a couple types that don't require 16 byte alignment\n    // such as mat2x2<f32> but that is OK\n\n\n    for (var _i = 0; _i < model.bufferEntries.length; _i++) {\n      var _entry = model.bufferEntries[_i];\n\n      if (_entry.packed === false && _entry.sizeInBytes % 16 === 0) {\n        _entry.packed = true;\n        _entry.offset = currOffset;\n        newEntries.push(_entry);\n        currOffset += _entry.sizeInBytes;\n      }\n    } // now it gets tough, we have the following common types (f32, i32, u32)\n    // - vec2<f32> 8 byte size, 8 byte alignment\n    // - vec3<f32> 12 byte size, 16 byte alignment\n    // - f32 4 byte size, 4 byte alignment\n    // try adding 12 byte, 4 byte pairs\n\n\n    for (var _i2 = 0; _i2 < model.bufferEntries.length; _i2++) {\n      var _entry2 = model.bufferEntries[_i2];\n\n      if (_entry2.packed === false && _entry2.sizeInBytes === 12) {\n        for (var i2 = 0; i2 < model.bufferEntries.length; i2++) {\n          var entry2 = model.bufferEntries[i2];\n\n          if (entry2.packed === false && entry2.sizeInBytes === 4) {\n            _entry2.packed = true;\n            _entry2.offset = currOffset;\n            newEntries.push(_entry2);\n            currOffset += _entry2.sizeInBytes;\n            entry2.packed = true;\n            entry2.offset = currOffset;\n            newEntries.push(entry2);\n            currOffset += entry2.sizeInBytes;\n            break;\n          }\n        }\n      }\n    } // try adding 8 byte, 8 byte pairs\n\n\n    for (var _i3 = 0; _i3 < model.bufferEntries.length; _i3++) {\n      var _entry3 = model.bufferEntries[_i3];\n\n      if (!_entry3.packed && _entry3.sizeInBytes % 8 === 0) {\n        for (var _i4 = _i3 + 1; _i4 < model.bufferEntries.length; _i4++) {\n          var _entry4 = model.bufferEntries[_i4];\n\n          if (!_entry4.packed && _entry4.sizeInBytes % 8 === 0) {\n            _entry3.packed = true;\n            _entry3.offset = currOffset;\n            newEntries.push(_entry3);\n            currOffset += _entry3.sizeInBytes;\n            _entry4.packed = true;\n            _entry4.offset = currOffset;\n            newEntries.push(_entry4);\n            currOffset += _entry4.sizeInBytes;\n            break;\n          }\n        }\n      }\n    } // try adding 8 byte, 4 byte 4 byte triplets\n\n\n    for (var _i5 = 0; _i5 < model.bufferEntries.length; _i5++) {\n      var _entry5 = model.bufferEntries[_i5];\n\n      if (!_entry5.packed && _entry5.sizeInBytes % 8 === 0) {\n        var found = false;\n\n        for (var _i6 = 0; !found && _i6 < model.bufferEntries.length; _i6++) {\n          var _entry6 = model.bufferEntries[_i6];\n\n          if (!_entry6.packed && _entry6.sizeInBytes === 4) {\n            for (var i3 = _i6 + 1; i3 < model.bufferEntries.length; i3++) {\n              var entry3 = model.bufferEntries[i3];\n\n              if (!entry3.packed && entry3.sizeInBytes === 4) {\n                _entry5.packed = true;\n                _entry5.offset = currOffset;\n                newEntries.push(_entry5);\n                currOffset += _entry5.sizeInBytes;\n                _entry6.packed = true;\n                _entry6.offset = currOffset;\n                newEntries.push(_entry6);\n                currOffset += _entry6.sizeInBytes;\n                entry3.packed = true;\n                entry3.offset = currOffset;\n                newEntries.push(entry3);\n                currOffset += entry3.sizeInBytes;\n                found = true;\n                break;\n              }\n            }\n          }\n        }\n      }\n    } // Add anything remaining that is larger than 4 bytes and hope we get lucky.\n    // Likely if there is more than one item added here it will result\n    // in a failed UBO\n\n\n    for (var _i7 = 0; _i7 < model.bufferEntries.length; _i7++) {\n      var _entry7 = model.bufferEntries[_i7];\n\n      if (!_entry7.packed && _entry7.sizeInBytes > 4) {\n        _entry7.packed = true;\n        _entry7.offset = currOffset;\n        newEntries.push(_entry7);\n        currOffset += _entry7.sizeInBytes;\n      }\n    } // finally add remaining 4 byte items\n\n\n    for (var _i8 = 0; _i8 < model.bufferEntries.length; _i8++) {\n      var _entry8 = model.bufferEntries[_i8];\n\n      if (!_entry8.packed) {\n        _entry8.packed = true;\n        _entry8.offset = currOffset;\n        newEntries.push(_entry8);\n        currOffset += _entry8.sizeInBytes;\n      }\n    } // update entries and entryNames\n\n\n    model.bufferEntries = newEntries;\n\n    model._bufferEntryNames.clear();\n\n    for (var _i9 = 0; _i9 < model.bufferEntries.length; _i9++) {\n      model._bufferEntryNames.set(model.bufferEntries[_i9].name, _i9);\n    }\n\n    model.sizeInBytes = currOffset;\n    model.sizeInBytes = maxAlignment * Math.ceil(model.sizeInBytes / maxAlignment);\n    model.sortDirty = false;\n  };\n\n  publicAPI.sendIfNeeded = function (device) {\n    if (!model.UBO) {\n      var req = {\n        nativeArray: model.Float32Array,\n        usage: BufferUsage.UniformArray,\n        label: model.label\n      };\n      model.UBO = device.getBufferManager().getBuffer(req);\n      model.bindGroupTime.modified();\n      model.sendDirty = false;\n    } // send data down if needed\n\n\n    if (model.sendDirty) {\n      device.getHandle().queue.writeBuffer(model.UBO.getHandle(), 0, model.arrayBuffer, 0, model.sizeInBytes);\n      model.sendDirty = false;\n    } // always updated as mappers depend on this time\n    // it is more of a sentIfNeededTime\n\n\n    model.sendTime.modified();\n  };\n\n  publicAPI.createView = function (type) {\n    if (type in model === false) {\n      if (!model.arrayBuffer) {\n        model.arrayBuffer = new ArrayBuffer(model.sizeInBytes);\n      }\n\n      model[type] = macro.newTypedArray(type, model.arrayBuffer);\n    }\n  };\n\n  publicAPI.setValue = function (name, val) {\n    publicAPI.sortBufferEntries();\n\n    var idx = model._bufferEntryNames.get(name);\n\n    if (idx === undefined) {\n      vtkErrorMacro(\"entry named \".concat(name, \" not found in UBO\"));\n      return;\n    }\n\n    var entry = model.bufferEntries[idx];\n    publicAPI.createView(entry.nativeType);\n    var view = model[entry.nativeType];\n\n    if (entry.lastValue !== val) {\n      view[entry.offset / view.BYTES_PER_ELEMENT] = val;\n      model.sendDirty = true;\n    }\n\n    entry.lastValue = val;\n  };\n\n  publicAPI.setArray = function (name, arr) {\n    publicAPI.sortBufferEntries();\n\n    var idx = model._bufferEntryNames.get(name);\n\n    if (idx === undefined) {\n      vtkErrorMacro(\"entry named \".concat(name, \" not found in UBO\"));\n      return;\n    }\n\n    var entry = model.bufferEntries[idx];\n    publicAPI.createView(entry.nativeType);\n    var view = model[entry.nativeType];\n    var changed = false;\n\n    for (var i = 0; i < arr.length; i++) {\n      if (!entry.lastValue || entry.lastValue[i] !== arr[i]) {\n        view[entry.offset / view.BYTES_PER_ELEMENT + i] = arr[i];\n        changed = true;\n      }\n    }\n\n    if (changed) {\n      model.sendDirty = true;\n      entry.lastValue = _toConsumableArray(arr);\n    }\n  };\n\n  publicAPI.getBindGroupEntry = function () {\n    var foo = {\n      resource: {\n        buffer: model.UBO.getHandle()\n      }\n    };\n    return foo;\n  };\n\n  publicAPI.getSendTime = function () {\n    return model.sendTime.getMTime();\n  };\n\n  publicAPI.getShaderCode = function (binding, group) {\n    // sort the entries\n    publicAPI.sortBufferEntries();\n    var lines = [\"struct \".concat(model.label, \"Struct\\n{\")];\n\n    for (var i = 0; i < model.bufferEntries.length; i++) {\n      var entry = model.bufferEntries[i];\n      lines.push(\"  \".concat(entry.name, \": \").concat(entry.type, \",\"));\n    }\n\n    lines.push(\"};\\n@binding(\".concat(binding, \") @group(\").concat(group, \") var<uniform> \").concat(model.label, \": \").concat(model.label, \"Struct;\"));\n    return lines.join('\\n');\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\n\nvar DEFAULT_VALUES = {\n  bufferEntries: null,\n  bufferEntryNames: null,\n  sizeInBytes: 0,\n  label: null,\n  bindGroupLayoutEntry: null,\n  bindGroupEntry: null\n}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Build VTK API\n\n  macro.obj(publicAPI, model); // Internal objects\n\n  model._bufferEntryNames = new Map();\n  model.bufferEntries = []; // default UBO desc\n\n  model.bindGroupLayoutEntry = model.bindGroupLayoutEntry || {\n    buffer: {\n      type: 'uniform'\n    }\n  };\n  model.sendTime = {};\n  macro.obj(model.sendTime, {\n    mtime: 0\n  });\n  model.bindGroupTime = {};\n  macro.obj(model.bindGroupTime, {\n    mtime: 0\n  });\n  model.sendDirty = true;\n  model.sortDirty = true;\n  macro.get(publicAPI, model, ['binding', 'bindGroupTime']);\n  macro.setGet(publicAPI, model, ['bindGroupLayoutEntry', 'device', 'label', 'sizeInBytes']); // Object methods\n\n  vtkWebGPUUniformBuffer(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = macro.newInstance(extend, 'vtkWebGPUUniformBuffer'); // ----------------------------------------------------------------------------\n\nvar vtkWebGPUUniformBuffer$1 = {\n  newInstance: newInstance,\n  extend: extend\n};\n\nexport { vtkWebGPUUniformBuffer$1 as default, extend, newInstance };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}