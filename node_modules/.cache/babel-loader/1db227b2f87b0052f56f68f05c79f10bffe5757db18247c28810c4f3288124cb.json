{"ast":null,"code":"import macro from '../../macros.js';\nimport { ObjectType } from './BufferObject/Constants.js';\n\n// vtkOpenGLVertexArrayObject methods\n// ----------------------------------------------------------------------------\n\nfunction vtkOpenGLVertexArrayObject(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkOpenGLVertexArrayObject'); // Public API methods\n\n  publicAPI.exposedMethod = function () {// This is a publicly exposed method of this object\n  };\n  publicAPI.initialize = function () {\n    model.instancingExtension = null;\n    if (!model._openGLRenderWindow.getWebgl2()) {\n      model.instancingExtension = model.context.getExtension('ANGLE_instanced_arrays');\n    }\n    if (!model.forceEmulation && model._openGLRenderWindow && model._openGLRenderWindow.getWebgl2()) {\n      model.extension = null;\n      model.supported = true;\n      model.handleVAO = model.context.createVertexArray();\n    } else {\n      model.extension = model.context.getExtension('OES_vertex_array_object'); // Start setting up VAO\n\n      if (!model.forceEmulation && model.extension) {\n        model.supported = true;\n        model.handleVAO = model.extension.createVertexArrayOES();\n      } else {\n        model.supported = false;\n      }\n    }\n  };\n  publicAPI.isReady = function () {\n    return (\n      // We either probed and allocated a VAO, or are falling back as the current\n      // hardware does not support VAOs.\n      model.handleVAO !== 0 || model.supported === false\n    );\n  };\n  publicAPI.bind = function () {\n    // Either simply bind the VAO, or emulate behavior by binding all attributes.\n    if (!publicAPI.isReady()) {\n      publicAPI.initialize();\n    }\n    if (publicAPI.isReady() && model.supported) {\n      if (model.extension) {\n        model.extension.bindVertexArrayOES(model.handleVAO);\n      } else {\n        model.context.bindVertexArray(model.handleVAO);\n      }\n    } else if (publicAPI.isReady()) {\n      var gl = model.context;\n      for (var ibuff = 0; ibuff < model.buffers.length; ++ibuff) {\n        var buff = model.buffers[ibuff];\n        model.context.bindBuffer(gl.ARRAY_BUFFER, buff.buffer);\n        for (var iatt = 0; iatt < buff.attributes.length; ++iatt) {\n          var attrIt = buff.attributes[iatt];\n          var matrixCount = attrIt.isMatrix ? attrIt.size : 1;\n          for (var i = 0; i < matrixCount; ++i) {\n            gl.enableVertexAttribArray(attrIt.index + i);\n            gl.vertexAttribPointer(attrIt.index + i, attrIt.size, attrIt.type, attrIt.normalize, attrIt.stride, attrIt.offset + attrIt.stride * i / attrIt.size);\n            if (attrIt.divisor > 0) {\n              if (model.instancingExtension) {\n                model.instancingExtension.vertexAttribDivisorANGLE(attrIt.index + i, 1);\n              } else {\n                gl.vertexAttribDivisor(attrIt.index + i, 1);\n              }\n            }\n          }\n        }\n      }\n    }\n  };\n  publicAPI.release = function () {\n    // Either simply release the VAO, or emulate behavior by releasing all attributes.\n    if (publicAPI.isReady() && model.supported) {\n      if (model.extension) {\n        model.extension.bindVertexArrayOES(null);\n      } else {\n        model.context.bindVertexArray(null);\n      }\n    } else if (publicAPI.isReady()) {\n      var gl = model.context;\n      for (var ibuff = 0; ibuff < model.buffers.length; ++ibuff) {\n        var buff = model.buffers[ibuff];\n        model.context.bindBuffer(gl.ARRAY_BUFFER, buff.buffer);\n        for (var iatt = 0; iatt < buff.attributes.length; ++iatt) {\n          var attrIt = buff.attributes[iatt];\n          var matrixCount = attrIt.isMatrix ? attrIt.size : 1;\n          for (var i = 0; i < matrixCount; ++i) {\n            gl.enableVertexAttribArray(attrIt.index + i);\n            gl.vertexAttribPointer(attrIt.index + i, attrIt.size, attrIt.type, attrIt.normalize, attrIt.stride, attrIt.offset + attrIt.stride * i / attrIt.size);\n            if (attrIt.divisor > 0) {\n              if (model.instancingExtension) {\n                model.instancingExtension.vertexAttribDivisorANGLE(attrIt.index + i, 0);\n              } else {\n                gl.vertexAttribDivisor(attrIt.index + i, 0);\n              }\n            }\n            gl.disableVertexAttribArray(attrIt.index + i);\n          }\n        }\n      }\n    }\n  };\n  publicAPI.shaderProgramChanged = function () {\n    publicAPI.release();\n    if (model.handleVAO) {\n      if (model.extension) {\n        model.extension.deleteVertexArrayOES(model.handleVAO);\n      } else {\n        model.context.deleteVertexArray(model.handleVAO);\n      }\n    }\n    model.handleVAO = 0;\n    model.handleProgram = 0;\n  };\n  publicAPI.releaseGraphicsResources = function () {\n    publicAPI.shaderProgramChanged();\n    if (model.handleVAO) {\n      if (model.extension) {\n        model.extension.deleteVertexArrayOES(model.handleVAO);\n      } else {\n        model.context.deleteVertexArray(model.handleVAO);\n      }\n    }\n    model.handleVAO = 0;\n    model.supported = true;\n    model.handleProgram = 0;\n  };\n  publicAPI.addAttributeArray = function (program, buffer, name, offset, stride, elementType, elementTupleSize, normalize) {\n    return publicAPI.addAttributeArrayWithDivisor(program, buffer, name, offset, stride, elementType, elementTupleSize, normalize, 0, false);\n  };\n  publicAPI.addAttributeArrayWithDivisor = function (program, buffer, name, offset, stride, elementType, elementTupleSize, normalize, divisor, isMatrix) {\n    if (!program) {\n      return false;\n    } // Check the program is bound, and the buffer is valid.\n\n    if (!program.isBound() || buffer.getHandle() === 0 || buffer.getType() !== ObjectType.ARRAY_BUFFER) {\n      return false;\n    } // Perform initialization if necessary, ensure program matches VAOs.\n\n    if (model.handleProgram === 0) {\n      model.handleProgram = program.getHandle();\n    }\n    if (!publicAPI.isReady()) {\n      publicAPI.initialize();\n    }\n    if (!publicAPI.isReady() || model.handleProgram !== program.getHandle()) {\n      return false;\n    }\n    var gl = model.context;\n    var attribs = {};\n    attribs.name = name;\n    attribs.index = gl.getAttribLocation(model.handleProgram, name);\n    attribs.offset = offset;\n    attribs.stride = stride;\n    attribs.type = elementType;\n    attribs.size = elementTupleSize;\n    attribs.normalize = normalize;\n    attribs.isMatrix = isMatrix;\n    attribs.divisor = divisor;\n    if (attribs.Index === -1) {\n      return false;\n    } // Always make the call as even the first use wants the attrib pointer setting\n    // up when we are emulating.\n\n    buffer.bind();\n    gl.enableVertexAttribArray(attribs.index);\n    gl.vertexAttribPointer(attribs.index, attribs.size, attribs.type, attribs.normalize, attribs.stride, attribs.offset);\n    if (divisor > 0) {\n      if (model.instancingExtension) {\n        model.instancingExtension.vertexAttribDivisorANGLE(attribs.index, 1);\n      } else {\n        gl.vertexAttribDivisor(attribs.index, 1);\n      }\n    }\n    attribs.buffer = buffer.getHandle(); // If vertex array objects are not supported then build up our list.\n\n    if (!model.supported) {\n      // find the buffer\n      var buffFound = false;\n      for (var ibuff = 0; ibuff < model.buffers.length; ++ibuff) {\n        var buff = model.buffers[ibuff];\n        if (buff.buffer === attribs.buffer) {\n          buffFound = true;\n          var found = false;\n          for (var iatt = 0; iatt < buff.attributes.length; ++iatt) {\n            var attrIt = buff.attributes[iatt];\n            if (attrIt.name === name) {\n              found = true;\n              buff.attributes[iatt] = attribs;\n            }\n          }\n          if (!found) {\n            buff.attributes.push(attribs);\n          }\n        }\n      }\n      if (!buffFound) {\n        model.buffers.push({\n          buffer: attribs.buffer,\n          attributes: [attribs]\n        });\n      }\n    }\n    return true;\n  };\n  publicAPI.addAttributeMatrixWithDivisor = function (program, buffer, name, offset, stride, elementType, elementTupleSize, normalize, divisor) {\n    // bind the first row of values\n    var result = publicAPI.addAttributeArrayWithDivisor(program, buffer, name, offset, stride, elementType, elementTupleSize, normalize, divisor, true);\n    if (!result) {\n      return result;\n    }\n    var gl = model.context;\n    var index = gl.getAttribLocation(model.handleProgram, name);\n    for (var i = 1; i < elementTupleSize; i++) {\n      gl.enableVertexAttribArray(index + i);\n      gl.vertexAttribPointer(index + i, elementTupleSize, elementType, normalize, stride, offset + stride * i / elementTupleSize);\n      if (divisor > 0) {\n        if (model.instancingExtension) {\n          model.instancingExtension.vertexAttribDivisorANGLE(index + i, 1);\n        } else {\n          gl.vertexAttribDivisor(index + i, 1);\n        }\n      }\n    }\n    return true;\n  };\n  publicAPI.removeAttributeArray = function (name) {\n    if (!publicAPI.isReady() || model.handleProgram === 0) {\n      return false;\n    } // If we don't have real VAOs find the entry and remove it too.\n\n    if (!model.supported) {\n      for (var ibuff = 0; ibuff < model.buffers.length; ++ibuff) {\n        var buff = model.buffers[ibuff];\n        for (var iatt = 0; iatt < buff.attributes.length; ++iatt) {\n          var attrIt = buff.attributes[iatt];\n          if (attrIt.name === name) {\n            buff.attributes.splice(iatt, 1);\n            if (!buff.attributes.length) {\n              model.buffers.splice(ibuff, 1);\n            }\n            return true;\n          }\n        }\n      }\n    }\n    return true;\n  };\n  publicAPI.setOpenGLRenderWindow = function (rw) {\n    if (model._openGLRenderWindow === rw) {\n      return;\n    }\n    publicAPI.releaseGraphicsResources();\n    model._openGLRenderWindow = rw;\n    model.context = null;\n    if (rw) {\n      model.context = model._openGLRenderWindow.getContext();\n    }\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nvar DEFAULT_VALUES = {\n  forceEmulation: false,\n  handleVAO: 0,\n  handleProgram: 0,\n  supported: true,\n  buffers: null,\n  context: null // _openGLRenderWindow: null,\n}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Internal objects initialization\n\n  model.buffers = []; // Object methods\n\n  macro.obj(publicAPI, model); // Create get-only macros\n\n  macro.get(publicAPI, model, ['supported']); // Create get-set macros\n\n  macro.setGet(publicAPI, model, ['forceEmulation']); // For more macro methods, see \"Sources/macros.js\"\n  // Object specific methods\n\n  vtkOpenGLVertexArrayObject(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = macro.newInstance(extend, 'vtkOpenGLVertexArrayObject'); // ----------------------------------------------------------------------------\n\nvar vtkVertexArrayObject = {\n  newInstance: newInstance,\n  extend: extend\n};\nexport { vtkVertexArrayObject as default, extend, newInstance };","map":{"version":3,"names":["macro","ObjectType","vtkOpenGLVertexArrayObject","publicAPI","model","classHierarchy","push","exposedMethod","initialize","instancingExtension","_openGLRenderWindow","getWebgl2","context","getExtension","forceEmulation","extension","supported","handleVAO","createVertexArray","createVertexArrayOES","isReady","bind","bindVertexArrayOES","bindVertexArray","gl","ibuff","buffers","length","buff","bindBuffer","ARRAY_BUFFER","buffer","iatt","attributes","attrIt","matrixCount","isMatrix","size","i","enableVertexAttribArray","index","vertexAttribPointer","type","normalize","stride","offset","divisor","vertexAttribDivisorANGLE","vertexAttribDivisor","release","disableVertexAttribArray","shaderProgramChanged","deleteVertexArrayOES","deleteVertexArray","handleProgram","releaseGraphicsResources","addAttributeArray","program","name","elementType","elementTupleSize","addAttributeArrayWithDivisor","isBound","getHandle","getType","attribs","getAttribLocation","Index","buffFound","found","addAttributeMatrixWithDivisor","result","removeAttributeArray","splice","setOpenGLRenderWindow","rw","getContext","DEFAULT_VALUES","extend","initialValues","arguments","undefined","Object","assign","obj","get","setGet","newInstance","vtkVertexArrayObject","default"],"sources":["/home/rakshith/Documents/RemoteRendering/vtk-js-react-app/node_modules/@kitware/vtk.js/Rendering/OpenGL/VertexArrayObject.js"],"sourcesContent":["import macro from '../../macros.js';\nimport { ObjectType } from './BufferObject/Constants.js';\n\n// vtkOpenGLVertexArrayObject methods\n// ----------------------------------------------------------------------------\n\nfunction vtkOpenGLVertexArrayObject(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkOpenGLVertexArrayObject'); // Public API methods\n\n  publicAPI.exposedMethod = function () {// This is a publicly exposed method of this object\n  };\n\n  publicAPI.initialize = function () {\n    model.instancingExtension = null;\n\n    if (!model._openGLRenderWindow.getWebgl2()) {\n      model.instancingExtension = model.context.getExtension('ANGLE_instanced_arrays');\n    }\n\n    if (!model.forceEmulation && model._openGLRenderWindow && model._openGLRenderWindow.getWebgl2()) {\n      model.extension = null;\n      model.supported = true;\n      model.handleVAO = model.context.createVertexArray();\n    } else {\n      model.extension = model.context.getExtension('OES_vertex_array_object'); // Start setting up VAO\n\n      if (!model.forceEmulation && model.extension) {\n        model.supported = true;\n        model.handleVAO = model.extension.createVertexArrayOES();\n      } else {\n        model.supported = false;\n      }\n    }\n  };\n\n  publicAPI.isReady = function () {\n    return (// We either probed and allocated a VAO, or are falling back as the current\n      // hardware does not support VAOs.\n      model.handleVAO !== 0 || model.supported === false\n    );\n  };\n\n  publicAPI.bind = function () {\n    // Either simply bind the VAO, or emulate behavior by binding all attributes.\n    if (!publicAPI.isReady()) {\n      publicAPI.initialize();\n    }\n\n    if (publicAPI.isReady() && model.supported) {\n      if (model.extension) {\n        model.extension.bindVertexArrayOES(model.handleVAO);\n      } else {\n        model.context.bindVertexArray(model.handleVAO);\n      }\n    } else if (publicAPI.isReady()) {\n      var gl = model.context;\n\n      for (var ibuff = 0; ibuff < model.buffers.length; ++ibuff) {\n        var buff = model.buffers[ibuff];\n        model.context.bindBuffer(gl.ARRAY_BUFFER, buff.buffer);\n\n        for (var iatt = 0; iatt < buff.attributes.length; ++iatt) {\n          var attrIt = buff.attributes[iatt];\n          var matrixCount = attrIt.isMatrix ? attrIt.size : 1;\n\n          for (var i = 0; i < matrixCount; ++i) {\n            gl.enableVertexAttribArray(attrIt.index + i);\n            gl.vertexAttribPointer(attrIt.index + i, attrIt.size, attrIt.type, attrIt.normalize, attrIt.stride, attrIt.offset + attrIt.stride * i / attrIt.size);\n\n            if (attrIt.divisor > 0) {\n              if (model.instancingExtension) {\n                model.instancingExtension.vertexAttribDivisorANGLE(attrIt.index + i, 1);\n              } else {\n                gl.vertexAttribDivisor(attrIt.index + i, 1);\n              }\n            }\n          }\n        }\n      }\n    }\n  };\n\n  publicAPI.release = function () {\n    // Either simply release the VAO, or emulate behavior by releasing all attributes.\n    if (publicAPI.isReady() && model.supported) {\n      if (model.extension) {\n        model.extension.bindVertexArrayOES(null);\n      } else {\n        model.context.bindVertexArray(null);\n      }\n    } else if (publicAPI.isReady()) {\n      var gl = model.context;\n\n      for (var ibuff = 0; ibuff < model.buffers.length; ++ibuff) {\n        var buff = model.buffers[ibuff];\n        model.context.bindBuffer(gl.ARRAY_BUFFER, buff.buffer);\n\n        for (var iatt = 0; iatt < buff.attributes.length; ++iatt) {\n          var attrIt = buff.attributes[iatt];\n          var matrixCount = attrIt.isMatrix ? attrIt.size : 1;\n\n          for (var i = 0; i < matrixCount; ++i) {\n            gl.enableVertexAttribArray(attrIt.index + i);\n            gl.vertexAttribPointer(attrIt.index + i, attrIt.size, attrIt.type, attrIt.normalize, attrIt.stride, attrIt.offset + attrIt.stride * i / attrIt.size);\n\n            if (attrIt.divisor > 0) {\n              if (model.instancingExtension) {\n                model.instancingExtension.vertexAttribDivisorANGLE(attrIt.index + i, 0);\n              } else {\n                gl.vertexAttribDivisor(attrIt.index + i, 0);\n              }\n            }\n\n            gl.disableVertexAttribArray(attrIt.index + i);\n          }\n        }\n      }\n    }\n  };\n\n  publicAPI.shaderProgramChanged = function () {\n    publicAPI.release();\n\n    if (model.handleVAO) {\n      if (model.extension) {\n        model.extension.deleteVertexArrayOES(model.handleVAO);\n      } else {\n        model.context.deleteVertexArray(model.handleVAO);\n      }\n    }\n\n    model.handleVAO = 0;\n    model.handleProgram = 0;\n  };\n\n  publicAPI.releaseGraphicsResources = function () {\n    publicAPI.shaderProgramChanged();\n\n    if (model.handleVAO) {\n      if (model.extension) {\n        model.extension.deleteVertexArrayOES(model.handleVAO);\n      } else {\n        model.context.deleteVertexArray(model.handleVAO);\n      }\n    }\n\n    model.handleVAO = 0;\n    model.supported = true;\n    model.handleProgram = 0;\n  };\n\n  publicAPI.addAttributeArray = function (program, buffer, name, offset, stride, elementType, elementTupleSize, normalize) {\n    return publicAPI.addAttributeArrayWithDivisor(program, buffer, name, offset, stride, elementType, elementTupleSize, normalize, 0, false);\n  };\n\n  publicAPI.addAttributeArrayWithDivisor = function (program, buffer, name, offset, stride, elementType, elementTupleSize, normalize, divisor, isMatrix) {\n    if (!program) {\n      return false;\n    } // Check the program is bound, and the buffer is valid.\n\n\n    if (!program.isBound() || buffer.getHandle() === 0 || buffer.getType() !== ObjectType.ARRAY_BUFFER) {\n      return false;\n    } // Perform initialization if necessary, ensure program matches VAOs.\n\n\n    if (model.handleProgram === 0) {\n      model.handleProgram = program.getHandle();\n    }\n\n    if (!publicAPI.isReady()) {\n      publicAPI.initialize();\n    }\n\n    if (!publicAPI.isReady() || model.handleProgram !== program.getHandle()) {\n      return false;\n    }\n\n    var gl = model.context;\n    var attribs = {};\n    attribs.name = name;\n    attribs.index = gl.getAttribLocation(model.handleProgram, name);\n    attribs.offset = offset;\n    attribs.stride = stride;\n    attribs.type = elementType;\n    attribs.size = elementTupleSize;\n    attribs.normalize = normalize;\n    attribs.isMatrix = isMatrix;\n    attribs.divisor = divisor;\n\n    if (attribs.Index === -1) {\n      return false;\n    } // Always make the call as even the first use wants the attrib pointer setting\n    // up when we are emulating.\n\n\n    buffer.bind();\n    gl.enableVertexAttribArray(attribs.index);\n    gl.vertexAttribPointer(attribs.index, attribs.size, attribs.type, attribs.normalize, attribs.stride, attribs.offset);\n\n    if (divisor > 0) {\n      if (model.instancingExtension) {\n        model.instancingExtension.vertexAttribDivisorANGLE(attribs.index, 1);\n      } else {\n        gl.vertexAttribDivisor(attribs.index, 1);\n      }\n    }\n\n    attribs.buffer = buffer.getHandle(); // If vertex array objects are not supported then build up our list.\n\n    if (!model.supported) {\n      // find the buffer\n      var buffFound = false;\n\n      for (var ibuff = 0; ibuff < model.buffers.length; ++ibuff) {\n        var buff = model.buffers[ibuff];\n\n        if (buff.buffer === attribs.buffer) {\n          buffFound = true;\n          var found = false;\n\n          for (var iatt = 0; iatt < buff.attributes.length; ++iatt) {\n            var attrIt = buff.attributes[iatt];\n\n            if (attrIt.name === name) {\n              found = true;\n              buff.attributes[iatt] = attribs;\n            }\n          }\n\n          if (!found) {\n            buff.attributes.push(attribs);\n          }\n        }\n      }\n\n      if (!buffFound) {\n        model.buffers.push({\n          buffer: attribs.buffer,\n          attributes: [attribs]\n        });\n      }\n    }\n\n    return true;\n  };\n\n  publicAPI.addAttributeMatrixWithDivisor = function (program, buffer, name, offset, stride, elementType, elementTupleSize, normalize, divisor) {\n    // bind the first row of values\n    var result = publicAPI.addAttributeArrayWithDivisor(program, buffer, name, offset, stride, elementType, elementTupleSize, normalize, divisor, true);\n\n    if (!result) {\n      return result;\n    }\n\n    var gl = model.context;\n    var index = gl.getAttribLocation(model.handleProgram, name);\n\n    for (var i = 1; i < elementTupleSize; i++) {\n      gl.enableVertexAttribArray(index + i);\n      gl.vertexAttribPointer(index + i, elementTupleSize, elementType, normalize, stride, offset + stride * i / elementTupleSize);\n\n      if (divisor > 0) {\n        if (model.instancingExtension) {\n          model.instancingExtension.vertexAttribDivisorANGLE(index + i, 1);\n        } else {\n          gl.vertexAttribDivisor(index + i, 1);\n        }\n      }\n    }\n\n    return true;\n  };\n\n  publicAPI.removeAttributeArray = function (name) {\n    if (!publicAPI.isReady() || model.handleProgram === 0) {\n      return false;\n    } // If we don't have real VAOs find the entry and remove it too.\n\n\n    if (!model.supported) {\n      for (var ibuff = 0; ibuff < model.buffers.length; ++ibuff) {\n        var buff = model.buffers[ibuff];\n\n        for (var iatt = 0; iatt < buff.attributes.length; ++iatt) {\n          var attrIt = buff.attributes[iatt];\n\n          if (attrIt.name === name) {\n            buff.attributes.splice(iatt, 1);\n\n            if (!buff.attributes.length) {\n              model.buffers.splice(ibuff, 1);\n            }\n\n            return true;\n          }\n        }\n      }\n    }\n\n    return true;\n  };\n\n  publicAPI.setOpenGLRenderWindow = function (rw) {\n    if (model._openGLRenderWindow === rw) {\n      return;\n    }\n\n    publicAPI.releaseGraphicsResources();\n    model._openGLRenderWindow = rw;\n    model.context = null;\n\n    if (rw) {\n      model.context = model._openGLRenderWindow.getContext();\n    }\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\n\nvar DEFAULT_VALUES = {\n  forceEmulation: false,\n  handleVAO: 0,\n  handleProgram: 0,\n  supported: true,\n  buffers: null,\n  context: null // _openGLRenderWindow: null,\n\n}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Internal objects initialization\n\n  model.buffers = []; // Object methods\n\n  macro.obj(publicAPI, model); // Create get-only macros\n\n  macro.get(publicAPI, model, ['supported']); // Create get-set macros\n\n  macro.setGet(publicAPI, model, ['forceEmulation']); // For more macro methods, see \"Sources/macros.js\"\n  // Object specific methods\n\n  vtkOpenGLVertexArrayObject(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = macro.newInstance(extend, 'vtkOpenGLVertexArrayObject'); // ----------------------------------------------------------------------------\n\nvar vtkVertexArrayObject = {\n  newInstance: newInstance,\n  extend: extend\n};\n\nexport { vtkVertexArrayObject as default, extend, newInstance };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}