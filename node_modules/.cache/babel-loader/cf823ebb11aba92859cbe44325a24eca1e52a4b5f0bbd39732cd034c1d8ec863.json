{"ast":null,"code":"import _slicedToArray from '@babel/runtime/helpers/slicedToArray';\nimport { vec3 } from 'gl-matrix';\nimport WebworkerPromise from 'webworker-promise';\nimport macro from '../../macros.js';\nimport vtkImageData from '../../Common/DataModel/ImageData.js';\nimport vtkDataArray from '../../Common/Core/DataArray.js';\nimport vtkPolygon from '../../Common/DataModel/Polygon.js';\nimport { W as WorkerFactory } from '../../_virtual/rollup-plugin-worker-loader__module_Sources/Filters/General/PaintFilter/PaintFilter.worker.js';\nvar vtkErrorMacro = macro.vtkErrorMacro; // ----------------------------------------------------------------------------\n// vtkPaintFilter methods\n// ----------------------------------------------------------------------------\n\nfunction vtkPaintFilter(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkPaintFilter');\n  var worker = null;\n  var workerPromise = null;\n  var history = {}; // --------------------------------------------------------------------------\n\n  function resetHistory() {\n    history.index = -1;\n    history.snapshots = [];\n    history.labels = [];\n  }\n  function pushToHistory(snapshot, label) {\n    // Clear any \"redo\" info\n    var spliceIndex = history.index + 1;\n    var spliceLength = history.snapshots.length - history.index;\n    history.snapshots.splice(spliceIndex, spliceLength);\n    history.labels.splice(spliceIndex, spliceLength); // Push new snapshot\n\n    history.snapshots.push(snapshot);\n    history.labels.push(label);\n    history.index++;\n  } // --------------------------------------------------------------------------\n\n  publicAPI.startStroke = function () {\n    if (model.labelMap) {\n      if (!workerPromise) {\n        worker = new WorkerFactory();\n        workerPromise = new WebworkerPromise(worker);\n      }\n      workerPromise.exec('start', {\n        bufferType: 'Uint8Array',\n        dimensions: model.labelMap.getDimensions(),\n        slicingMode: model.slicingMode\n      });\n    }\n  }; // --------------------------------------------------------------------------\n\n  publicAPI.endStroke = function () {\n    var endStrokePromise;\n    if (workerPromise) {\n      endStrokePromise = workerPromise.exec('end');\n      endStrokePromise.then(function (strokeBuffer) {\n        publicAPI.applyBinaryMask(strokeBuffer);\n        worker.terminate();\n        worker = null;\n        workerPromise = null;\n      });\n    }\n    return endStrokePromise;\n  };\n  publicAPI.applyBinaryMask = function (maskBuffer) {\n    var scalars = model.labelMap.getPointData().getScalars();\n    var data = scalars.getData();\n    var maskLabelMap = new Uint8Array(maskBuffer);\n    var diffCount = 0;\n    for (var i = 0; i < maskLabelMap.length; i++) {\n      // maskLabelMap is a binary mask\n      diffCount += maskLabelMap[i];\n    } // Format: [ [index, oldLabel], ...]\n    // I could use an ArrayBuffer, which would place limits\n    // on the values of index/old, but will be more efficient.\n\n    var snapshot = new Array(diffCount);\n    var label = model.label;\n    var diffIdx = 0;\n    if (model.voxelFunc) {\n      var bgScalars = model.backgroundImage.getPointData().getScalars();\n      var voxel = [];\n      for (var _i = 0; _i < maskLabelMap.length; _i++) {\n        if (maskLabelMap[_i]) {\n          bgScalars.getTuple(_i, voxel); // might not fill up snapshot\n\n          if (model.voxelFunc(voxel, _i, label)) {\n            snapshot[diffIdx++] = [_i, data[_i]];\n            data[_i] = label;\n          }\n        }\n      }\n    } else {\n      for (var _i2 = 0; _i2 < maskLabelMap.length; _i2++) {\n        if (maskLabelMap[_i2]) {\n          if (data[_i2] !== label) {\n            snapshot[diffIdx++] = [_i2, data[_i2]];\n            data[_i2] = label;\n          }\n        }\n      }\n    }\n    pushToHistory(snapshot, label);\n    scalars.setData(data);\n    scalars.modified();\n    model.labelMap.modified();\n    publicAPI.modified();\n  }; // --------------------------------------------------------------------------\n\n  publicAPI.addPoint = function (point) {\n    if (workerPromise) {\n      var worldPt = [point[0], point[1], point[2]];\n      var indexPt = [0, 0, 0];\n      vec3.transformMat4(indexPt, worldPt, model.maskWorldToIndex);\n      indexPt[0] = Math.round(indexPt[0]);\n      indexPt[1] = Math.round(indexPt[1]);\n      indexPt[2] = Math.round(indexPt[2]);\n      var spacing = model.labelMap.getSpacing();\n      var radius = spacing.map(function (s) {\n        return model.radius / s;\n      });\n      workerPromise.exec('paint', {\n        point: indexPt,\n        radius: radius\n      });\n    }\n  }; // --------------------------------------------------------------------------\n\n  publicAPI.paintRectangle = function (point1, point2) {\n    if (workerPromise) {\n      var index1 = [0, 0, 0];\n      var index2 = [0, 0, 0];\n      vec3.transformMat4(index1, point1, model.maskWorldToIndex);\n      vec3.transformMat4(index2, point2, model.maskWorldToIndex);\n      index1[0] = Math.round(index1[0]);\n      index1[1] = Math.round(index1[1]);\n      index1[2] = Math.round(index1[2]);\n      index2[0] = Math.round(index2[0]);\n      index2[1] = Math.round(index2[1]);\n      index2[2] = Math.round(index2[2]);\n      workerPromise.exec('paintRectangle', {\n        point1: index1,\n        point2: index2\n      });\n    }\n  }; // --------------------------------------------------------------------------\n\n  publicAPI.paintEllipse = function (center, scale3) {\n    if (workerPromise) {\n      var realCenter = [0, 0, 0];\n      var origin = [0, 0, 0];\n      var realScale3 = [0, 0, 0];\n      vec3.transformMat4(realCenter, center, model.maskWorldToIndex);\n      vec3.transformMat4(origin, origin, model.maskWorldToIndex);\n      vec3.transformMat4(realScale3, scale3, model.maskWorldToIndex);\n      vec3.subtract(realScale3, realScale3, origin);\n      realScale3 = realScale3.map(function (s) {\n        return s === 0 ? 0.25 : Math.abs(s);\n      });\n      workerPromise.exec('paintEllipse', {\n        center: realCenter,\n        scale3: realScale3\n      });\n    }\n  }; // --------------------------------------------------------------------------\n\n  publicAPI.canUndo = function () {\n    return history.index > -1;\n  }; // --------------------------------------------------------------------------\n\n  publicAPI.paintPolygon = function (pointList) {\n    if (workerPromise && pointList.length > 0) {\n      var polygon = vtkPolygon.newInstance();\n      var poly = [];\n      for (var i = 0; i < pointList.length / 3; i++) {\n        poly.push([pointList[3 * i + 0], pointList[3 * i + 1], pointList[3 * i + 2]]);\n      }\n      polygon.setPoints(poly);\n      if (!polygon.triangulate()) {\n        console.log('triangulation failed!');\n      }\n      var points = polygon.getPointArray();\n      var triangleList = new Float32Array(points.length);\n      var numPoints = Math.floor(triangleList.length / 3);\n      for (var _i3 = 0; _i3 < numPoints; _i3++) {\n        var point = points.slice(3 * _i3, 3 * _i3 + 3);\n        var voxel = triangleList.subarray(3 * _i3, 3 * _i3 + 3);\n        vec3.transformMat4(voxel, point, model.maskWorldToIndex);\n      }\n      workerPromise.exec('paintTriangles', {\n        triangleList: triangleList\n      });\n    }\n  }; // --------------------------------------------------------------------------\n\n  publicAPI.applyLabelMap = function (labelMap) {\n    var currentMapData = model.labelMap.getPointData().getScalars().getData();\n    var newMapData = labelMap.getPointData().getScalars().getData(); // Compute snapshot\n\n    var snapshot = [];\n    for (var i = 0; i < newMapData.length; ++i) {\n      if (currentMapData[i] !== newMapData[i]) {\n        snapshot.push([i, currentMapData[i]]);\n      }\n    }\n    pushToHistory(snapshot, model.label);\n    model.labelMap = labelMap;\n    publicAPI.modified();\n  }; // --------------------------------------------------------------------------\n\n  publicAPI.undo = function () {\n    if (history.index > -1) {\n      var scalars = model.labelMap.getPointData().getScalars();\n      var data = scalars.getData();\n      var snapshot = history.snapshots[history.index];\n      for (var i = 0; i < snapshot.length; i++) {\n        if (!snapshot[i]) {\n          break;\n        }\n        var _snapshot$i = _slicedToArray(snapshot[i], 2),\n          index = _snapshot$i[0],\n          oldLabel = _snapshot$i[1];\n        data[index] = oldLabel;\n      }\n      history.index--;\n      scalars.setData(data);\n      scalars.modified();\n      model.labelMap.modified();\n      publicAPI.modified();\n    }\n  }; // --------------------------------------------------------------------------\n\n  publicAPI.canRedo = function () {\n    return history.index < history.labels.length - 1;\n  }; // --------------------------------------------------------------------------\n\n  publicAPI.redo = function () {\n    if (history.index < history.labels.length - 1) {\n      var scalars = model.labelMap.getPointData().getScalars();\n      var data = scalars.getData();\n      var redoLabel = history.labels[history.index + 1];\n      var snapshot = history.snapshots[history.index + 1];\n      for (var i = 0; i < snapshot.length; i++) {\n        if (!snapshot[i]) {\n          break;\n        }\n        var _snapshot$i2 = _slicedToArray(snapshot[i], 1),\n          index = _snapshot$i2[0];\n        data[index] = redoLabel;\n      }\n      history.index++;\n      scalars.setData(data);\n      scalars.modified();\n      model.labelMap.modified();\n      publicAPI.modified();\n    }\n  }; // --------------------------------------------------------------------------\n\n  var superSetLabelMap = publicAPI.setLabelMap;\n  publicAPI.setLabelMap = function (lm) {\n    if (superSetLabelMap(lm)) {\n      model.maskWorldToIndex = model.labelMap.getWorldToIndex();\n      resetHistory();\n      return true;\n    }\n    return false;\n  }; // --------------------------------------------------------------------------\n\n  publicAPI.requestData = function (inData, outData) {\n    if (!model.backgroundImage) {\n      vtkErrorMacro('No background image');\n      return;\n    }\n    if (!model.backgroundImage.getPointData().getScalars()) {\n      vtkErrorMacro('Background image has no scalars');\n      return;\n    }\n    if (!model.labelMap) {\n      // clone background image properties\n      var labelMap = vtkImageData.newInstance(model.backgroundImage.get('spacing', 'origin', 'direction'));\n      labelMap.setDimensions(model.backgroundImage.getDimensions());\n      labelMap.computeTransforms(); // right now only support 256 labels\n\n      var values = new Uint8Array(model.backgroundImage.getNumberOfPoints());\n      var dataArray = vtkDataArray.newInstance({\n        numberOfComponents: 1,\n        // labelmap with single component\n        values: values\n      });\n      labelMap.getPointData().setScalars(dataArray);\n      publicAPI.setLabelMap(labelMap);\n    }\n    if (!model.maskWorldToIndex) {\n      model.maskWorldToIndex = model.labelMap.getWorldToIndex();\n    }\n    var scalars = model.labelMap.getPointData().getScalars();\n    if (!scalars) {\n      vtkErrorMacro('Mask image has no scalars');\n      return;\n    }\n    model.labelMap.modified();\n    outData[0] = model.labelMap;\n  }; // --------------------------------------------------------------------------\n  // Initialization\n  // --------------------------------------------------------------------------\n\n  resetHistory();\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nvar DEFAULT_VALUES = {\n  backgroundImage: null,\n  labelMap: null,\n  maskWorldToIndex: null,\n  voxelFunc: null,\n  radius: 1,\n  label: 0,\n  slicingMode: null\n}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Make this a VTK object\n\n  macro.obj(publicAPI, model); // Also make it an algorithm with no input and one output\n\n  macro.algo(publicAPI, model, 0, 1);\n  macro.setGet(publicAPI, model, ['backgroundImage', 'labelMap', 'maskWorldToIndex', 'voxelFunc', 'label', 'radius', 'slicingMode']); // Object specific methods\n\n  vtkPaintFilter(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = macro.newInstance(extend, 'vtkPaintFilter'); // ----------------------------------------------------------------------------\n\nvar vtkPaintFilter$1 = {\n  newInstance: newInstance,\n  extend: extend\n};\nexport { vtkPaintFilter$1 as default, extend, newInstance };","map":{"version":3,"names":["_slicedToArray","vec3","WebworkerPromise","macro","vtkImageData","vtkDataArray","vtkPolygon","W","WorkerFactory","vtkErrorMacro","vtkPaintFilter","publicAPI","model","classHierarchy","push","worker","workerPromise","history","resetHistory","index","snapshots","labels","pushToHistory","snapshot","label","spliceIndex","spliceLength","length","splice","startStroke","labelMap","exec","bufferType","dimensions","getDimensions","slicingMode","endStroke","endStrokePromise","then","strokeBuffer","applyBinaryMask","terminate","maskBuffer","scalars","getPointData","getScalars","data","getData","maskLabelMap","Uint8Array","diffCount","i","Array","diffIdx","voxelFunc","bgScalars","backgroundImage","voxel","_i","getTuple","_i2","setData","modified","addPoint","point","worldPt","indexPt","transformMat4","maskWorldToIndex","Math","round","spacing","getSpacing","radius","map","s","paintRectangle","point1","point2","index1","index2","paintEllipse","center","scale3","realCenter","origin","realScale3","subtract","abs","canUndo","paintPolygon","pointList","polygon","newInstance","poly","setPoints","triangulate","console","log","points","getPointArray","triangleList","Float32Array","numPoints","floor","_i3","slice","subarray","applyLabelMap","currentMapData","newMapData","undo","_snapshot$i","oldLabel","canRedo","redo","redoLabel","_snapshot$i2","superSetLabelMap","setLabelMap","lm","getWorldToIndex","requestData","inData","outData","get","setDimensions","computeTransforms","values","getNumberOfPoints","dataArray","numberOfComponents","setScalars","DEFAULT_VALUES","extend","initialValues","arguments","undefined","Object","assign","obj","algo","setGet","vtkPaintFilter$1","default"],"sources":["/home/rakshith/Documents/RemoteRendering/vtk-js-react-app/node_modules/@kitware/vtk.js/Filters/General/PaintFilter.js"],"sourcesContent":["import _slicedToArray from '@babel/runtime/helpers/slicedToArray';\nimport { vec3 } from 'gl-matrix';\nimport WebworkerPromise from 'webworker-promise';\nimport macro from '../../macros.js';\nimport vtkImageData from '../../Common/DataModel/ImageData.js';\nimport vtkDataArray from '../../Common/Core/DataArray.js';\nimport vtkPolygon from '../../Common/DataModel/Polygon.js';\nimport { W as WorkerFactory } from '../../_virtual/rollup-plugin-worker-loader__module_Sources/Filters/General/PaintFilter/PaintFilter.worker.js';\n\nvar vtkErrorMacro = macro.vtkErrorMacro; // ----------------------------------------------------------------------------\n// vtkPaintFilter methods\n// ----------------------------------------------------------------------------\n\nfunction vtkPaintFilter(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkPaintFilter');\n  var worker = null;\n  var workerPromise = null;\n  var history = {}; // --------------------------------------------------------------------------\n\n  function resetHistory() {\n    history.index = -1;\n    history.snapshots = [];\n    history.labels = [];\n  }\n\n  function pushToHistory(snapshot, label) {\n    // Clear any \"redo\" info\n    var spliceIndex = history.index + 1;\n    var spliceLength = history.snapshots.length - history.index;\n    history.snapshots.splice(spliceIndex, spliceLength);\n    history.labels.splice(spliceIndex, spliceLength); // Push new snapshot\n\n    history.snapshots.push(snapshot);\n    history.labels.push(label);\n    history.index++;\n  } // --------------------------------------------------------------------------\n\n\n  publicAPI.startStroke = function () {\n    if (model.labelMap) {\n      if (!workerPromise) {\n        worker = new WorkerFactory();\n        workerPromise = new WebworkerPromise(worker);\n      }\n\n      workerPromise.exec('start', {\n        bufferType: 'Uint8Array',\n        dimensions: model.labelMap.getDimensions(),\n        slicingMode: model.slicingMode\n      });\n    }\n  }; // --------------------------------------------------------------------------\n\n\n  publicAPI.endStroke = function () {\n    var endStrokePromise;\n\n    if (workerPromise) {\n      endStrokePromise = workerPromise.exec('end');\n      endStrokePromise.then(function (strokeBuffer) {\n        publicAPI.applyBinaryMask(strokeBuffer);\n        worker.terminate();\n        worker = null;\n        workerPromise = null;\n      });\n    }\n\n    return endStrokePromise;\n  };\n\n  publicAPI.applyBinaryMask = function (maskBuffer) {\n    var scalars = model.labelMap.getPointData().getScalars();\n    var data = scalars.getData();\n    var maskLabelMap = new Uint8Array(maskBuffer);\n    var diffCount = 0;\n\n    for (var i = 0; i < maskLabelMap.length; i++) {\n      // maskLabelMap is a binary mask\n      diffCount += maskLabelMap[i];\n    } // Format: [ [index, oldLabel], ...]\n    // I could use an ArrayBuffer, which would place limits\n    // on the values of index/old, but will be more efficient.\n\n\n    var snapshot = new Array(diffCount);\n    var label = model.label;\n    var diffIdx = 0;\n\n    if (model.voxelFunc) {\n      var bgScalars = model.backgroundImage.getPointData().getScalars();\n      var voxel = [];\n\n      for (var _i = 0; _i < maskLabelMap.length; _i++) {\n        if (maskLabelMap[_i]) {\n          bgScalars.getTuple(_i, voxel); // might not fill up snapshot\n\n          if (model.voxelFunc(voxel, _i, label)) {\n            snapshot[diffIdx++] = [_i, data[_i]];\n            data[_i] = label;\n          }\n        }\n      }\n    } else {\n      for (var _i2 = 0; _i2 < maskLabelMap.length; _i2++) {\n        if (maskLabelMap[_i2]) {\n          if (data[_i2] !== label) {\n            snapshot[diffIdx++] = [_i2, data[_i2]];\n            data[_i2] = label;\n          }\n        }\n      }\n    }\n\n    pushToHistory(snapshot, label);\n    scalars.setData(data);\n    scalars.modified();\n    model.labelMap.modified();\n    publicAPI.modified();\n  }; // --------------------------------------------------------------------------\n\n\n  publicAPI.addPoint = function (point) {\n    if (workerPromise) {\n      var worldPt = [point[0], point[1], point[2]];\n      var indexPt = [0, 0, 0];\n      vec3.transformMat4(indexPt, worldPt, model.maskWorldToIndex);\n      indexPt[0] = Math.round(indexPt[0]);\n      indexPt[1] = Math.round(indexPt[1]);\n      indexPt[2] = Math.round(indexPt[2]);\n      var spacing = model.labelMap.getSpacing();\n      var radius = spacing.map(function (s) {\n        return model.radius / s;\n      });\n      workerPromise.exec('paint', {\n        point: indexPt,\n        radius: radius\n      });\n    }\n  }; // --------------------------------------------------------------------------\n\n\n  publicAPI.paintRectangle = function (point1, point2) {\n    if (workerPromise) {\n      var index1 = [0, 0, 0];\n      var index2 = [0, 0, 0];\n      vec3.transformMat4(index1, point1, model.maskWorldToIndex);\n      vec3.transformMat4(index2, point2, model.maskWorldToIndex);\n      index1[0] = Math.round(index1[0]);\n      index1[1] = Math.round(index1[1]);\n      index1[2] = Math.round(index1[2]);\n      index2[0] = Math.round(index2[0]);\n      index2[1] = Math.round(index2[1]);\n      index2[2] = Math.round(index2[2]);\n      workerPromise.exec('paintRectangle', {\n        point1: index1,\n        point2: index2\n      });\n    }\n  }; // --------------------------------------------------------------------------\n\n\n  publicAPI.paintEllipse = function (center, scale3) {\n    if (workerPromise) {\n      var realCenter = [0, 0, 0];\n      var origin = [0, 0, 0];\n      var realScale3 = [0, 0, 0];\n      vec3.transformMat4(realCenter, center, model.maskWorldToIndex);\n      vec3.transformMat4(origin, origin, model.maskWorldToIndex);\n      vec3.transformMat4(realScale3, scale3, model.maskWorldToIndex);\n      vec3.subtract(realScale3, realScale3, origin);\n      realScale3 = realScale3.map(function (s) {\n        return s === 0 ? 0.25 : Math.abs(s);\n      });\n      workerPromise.exec('paintEllipse', {\n        center: realCenter,\n        scale3: realScale3\n      });\n    }\n  }; // --------------------------------------------------------------------------\n\n\n  publicAPI.canUndo = function () {\n    return history.index > -1;\n  }; // --------------------------------------------------------------------------\n\n\n  publicAPI.paintPolygon = function (pointList) {\n    if (workerPromise && pointList.length > 0) {\n      var polygon = vtkPolygon.newInstance();\n      var poly = [];\n\n      for (var i = 0; i < pointList.length / 3; i++) {\n        poly.push([pointList[3 * i + 0], pointList[3 * i + 1], pointList[3 * i + 2]]);\n      }\n\n      polygon.setPoints(poly);\n\n      if (!polygon.triangulate()) {\n        console.log('triangulation failed!');\n      }\n\n      var points = polygon.getPointArray();\n      var triangleList = new Float32Array(points.length);\n      var numPoints = Math.floor(triangleList.length / 3);\n\n      for (var _i3 = 0; _i3 < numPoints; _i3++) {\n        var point = points.slice(3 * _i3, 3 * _i3 + 3);\n        var voxel = triangleList.subarray(3 * _i3, 3 * _i3 + 3);\n        vec3.transformMat4(voxel, point, model.maskWorldToIndex);\n      }\n\n      workerPromise.exec('paintTriangles', {\n        triangleList: triangleList\n      });\n    }\n  }; // --------------------------------------------------------------------------\n\n\n  publicAPI.applyLabelMap = function (labelMap) {\n    var currentMapData = model.labelMap.getPointData().getScalars().getData();\n    var newMapData = labelMap.getPointData().getScalars().getData(); // Compute snapshot\n\n    var snapshot = [];\n\n    for (var i = 0; i < newMapData.length; ++i) {\n      if (currentMapData[i] !== newMapData[i]) {\n        snapshot.push([i, currentMapData[i]]);\n      }\n    }\n\n    pushToHistory(snapshot, model.label);\n    model.labelMap = labelMap;\n    publicAPI.modified();\n  }; // --------------------------------------------------------------------------\n\n\n  publicAPI.undo = function () {\n    if (history.index > -1) {\n      var scalars = model.labelMap.getPointData().getScalars();\n      var data = scalars.getData();\n      var snapshot = history.snapshots[history.index];\n\n      for (var i = 0; i < snapshot.length; i++) {\n        if (!snapshot[i]) {\n          break;\n        }\n\n        var _snapshot$i = _slicedToArray(snapshot[i], 2),\n            index = _snapshot$i[0],\n            oldLabel = _snapshot$i[1];\n\n        data[index] = oldLabel;\n      }\n\n      history.index--;\n      scalars.setData(data);\n      scalars.modified();\n      model.labelMap.modified();\n      publicAPI.modified();\n    }\n  }; // --------------------------------------------------------------------------\n\n\n  publicAPI.canRedo = function () {\n    return history.index < history.labels.length - 1;\n  }; // --------------------------------------------------------------------------\n\n\n  publicAPI.redo = function () {\n    if (history.index < history.labels.length - 1) {\n      var scalars = model.labelMap.getPointData().getScalars();\n      var data = scalars.getData();\n      var redoLabel = history.labels[history.index + 1];\n      var snapshot = history.snapshots[history.index + 1];\n\n      for (var i = 0; i < snapshot.length; i++) {\n        if (!snapshot[i]) {\n          break;\n        }\n\n        var _snapshot$i2 = _slicedToArray(snapshot[i], 1),\n            index = _snapshot$i2[0];\n\n        data[index] = redoLabel;\n      }\n\n      history.index++;\n      scalars.setData(data);\n      scalars.modified();\n      model.labelMap.modified();\n      publicAPI.modified();\n    }\n  }; // --------------------------------------------------------------------------\n\n\n  var superSetLabelMap = publicAPI.setLabelMap;\n\n  publicAPI.setLabelMap = function (lm) {\n    if (superSetLabelMap(lm)) {\n      model.maskWorldToIndex = model.labelMap.getWorldToIndex();\n      resetHistory();\n      return true;\n    }\n\n    return false;\n  }; // --------------------------------------------------------------------------\n\n\n  publicAPI.requestData = function (inData, outData) {\n    if (!model.backgroundImage) {\n      vtkErrorMacro('No background image');\n      return;\n    }\n\n    if (!model.backgroundImage.getPointData().getScalars()) {\n      vtkErrorMacro('Background image has no scalars');\n      return;\n    }\n\n    if (!model.labelMap) {\n      // clone background image properties\n      var labelMap = vtkImageData.newInstance(model.backgroundImage.get('spacing', 'origin', 'direction'));\n      labelMap.setDimensions(model.backgroundImage.getDimensions());\n      labelMap.computeTransforms(); // right now only support 256 labels\n\n      var values = new Uint8Array(model.backgroundImage.getNumberOfPoints());\n      var dataArray = vtkDataArray.newInstance({\n        numberOfComponents: 1,\n        // labelmap with single component\n        values: values\n      });\n      labelMap.getPointData().setScalars(dataArray);\n      publicAPI.setLabelMap(labelMap);\n    }\n\n    if (!model.maskWorldToIndex) {\n      model.maskWorldToIndex = model.labelMap.getWorldToIndex();\n    }\n\n    var scalars = model.labelMap.getPointData().getScalars();\n\n    if (!scalars) {\n      vtkErrorMacro('Mask image has no scalars');\n      return;\n    }\n\n    model.labelMap.modified();\n    outData[0] = model.labelMap;\n  }; // --------------------------------------------------------------------------\n  // Initialization\n  // --------------------------------------------------------------------------\n\n\n  resetHistory();\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\n\nvar DEFAULT_VALUES = {\n  backgroundImage: null,\n  labelMap: null,\n  maskWorldToIndex: null,\n  voxelFunc: null,\n  radius: 1,\n  label: 0,\n  slicingMode: null\n}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Make this a VTK object\n\n  macro.obj(publicAPI, model); // Also make it an algorithm with no input and one output\n\n  macro.algo(publicAPI, model, 0, 1);\n  macro.setGet(publicAPI, model, ['backgroundImage', 'labelMap', 'maskWorldToIndex', 'voxelFunc', 'label', 'radius', 'slicingMode']); // Object specific methods\n\n  vtkPaintFilter(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = macro.newInstance(extend, 'vtkPaintFilter'); // ----------------------------------------------------------------------------\n\nvar vtkPaintFilter$1 = {\n  newInstance: newInstance,\n  extend: extend\n};\n\nexport { vtkPaintFilter$1 as default, extend, newInstance };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}