{"ast":null,"code":"import _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport { mat4, mat3 } from 'gl-matrix';\nimport { ObjectType } from './BufferObject/Constants.js';\nimport { newInstance as newInstance$1, vtkErrorMacro as vtkErrorMacro$1 } from '../../macros.js';\nimport vtkBufferObject from './BufferObject.js';\nimport { v as vtkStickMapperVS } from './glsl/vtkStickMapperVS.glsl.js';\nimport { v as vtkPolyDataFS } from './glsl/vtkPolyDataFS.glsl.js';\nimport vtkShaderProgram from './ShaderProgram.js';\nimport vtkOpenGLPolyDataMapper from './PolyDataMapper.js';\nimport { registerOverride } from './ViewNodeFactory.js';\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n  return target;\n}\nvar vtkErrorMacro = vtkErrorMacro$1; // ----------------------------------------------------------------------------\n// vtkOpenGLStickMapper methods\n// ----------------------------------------------------------------------------\n\nfunction vtkOpenGLStickMapper(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkOpenGLStickMapper'); // Capture 'parentClass' api for internal use\n\n  var superClass = _objectSpread({}, publicAPI);\n  publicAPI.getShaderTemplate = function (shaders, ren, actor) {\n    shaders.Vertex = vtkStickMapperVS;\n    shaders.Fragment = vtkPolyDataFS;\n    shaders.Geometry = '';\n  };\n  publicAPI.replaceShaderValues = function (shaders, ren, actor) {\n    var VSSource = shaders.Vertex;\n    var FSSource = shaders.Fragment;\n    VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::Camera::Dec', ['uniform mat4 VCPCMatrix;\\n', 'uniform mat4 MCVCMatrix;']).result;\n    FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::PositionVC::Dec', 'varying vec4 vertexVCVSOutput;').result; // we create vertexVC below, so turn off the default\n    // implementation\n\n    FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::PositionVC::Impl', '  vec4 vertexVC = vertexVCVSOutput;\\n').result; // for lights kit and positional the VCPC matrix is already defined\n    // so don't redefine it\n\n    var replacement = ['uniform int cameraParallel;\\n', 'varying float radiusVCVSOutput;\\n', 'varying vec3 orientVCVSOutput;\\n', 'varying float lengthVCVSOutput;\\n', 'varying vec3 centerVCVSOutput;\\n', 'uniform mat4 VCPCMatrix;\\n'];\n    FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Normal::Dec', replacement).result;\n    var fragString = '';\n    if (model.context.getExtension('EXT_frag_depth')) {\n      fragString = '  gl_FragDepthEXT = (pos.z / pos.w + 1.0) / 2.0;\\n';\n    }\n    if (model._openGLRenderWindow.getWebgl2()) {\n      fragString = 'gl_FragDepth = (pos.z / pos.w + 1.0) / 2.0;\\n';\n    } // see https://www.cl.cam.ac.uk/teaching/1999/AGraphHCI/SMAG/node2.html\n\n    FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Depth::Impl', [\n    // compute the eye position and unit direction\n    '  vec3 EyePos;\\n', '  vec3 EyeDir;\\n', '  if (cameraParallel != 0) {\\n', '    EyePos = vec3(vertexVC.x, vertexVC.y, vertexVC.z + 3.0*radiusVCVSOutput);\\n', '    EyeDir = vec3(0.0,0.0,-1.0); }\\n', '  else {\\n', '    EyeDir = vertexVC.xyz;\\n', '    EyePos = vec3(0.0,0.0,0.0);\\n', '    float lengthED = length(EyeDir);\\n', '    EyeDir = normalize(EyeDir);\\n',\n    // we adjust the EyePos to be closer if it is too far away\n    // to prevent floating point precision noise\n    '    if (lengthED > radiusVCVSOutput*3.0) {\\n', '      EyePos = vertexVC.xyz - EyeDir*3.0*radiusVCVSOutput; }\\n', '    }\\n',\n    // translate to Stick center\n    '  EyePos = EyePos - centerVCVSOutput;\\n',\n    // rotate to new basis\n    // base1, base2, orientVC\n    '  vec3 base1;\\n', '  if (abs(orientVCVSOutput.z) < 0.99) {\\n', '    base1 = normalize(cross(orientVCVSOutput,vec3(0.0,0.0,1.0))); }\\n', '  else {\\n', '    base1 = normalize(cross(orientVCVSOutput,vec3(0.0,1.0,0.0))); }\\n', '  vec3 base2 = cross(orientVCVSOutput,base1);\\n', '  EyePos = vec3(dot(EyePos,base1),dot(EyePos,base2),dot(EyePos,orientVCVSOutput));\\n', '  EyeDir = vec3(dot(EyeDir,base1),dot(EyeDir,base2),dot(EyeDir,orientVCVSOutput));\\n',\n    // scale by radius\n    '  EyePos = EyePos/radiusVCVSOutput;\\n',\n    // find the intersection\n    '  float a = EyeDir.x*EyeDir.x + EyeDir.y*EyeDir.y;\\n', '  float b = 2.0*(EyePos.x*EyeDir.x + EyePos.y*EyeDir.y);\\n', '  float c = EyePos.x*EyePos.x + EyePos.y*EyePos.y - 1.0;\\n', '  float d = b*b - 4.0*a*c;\\n', '  vec3 normalVCVSOutput = vec3(0.0,0.0,1.0);\\n', '  if (d < 0.0) { discard; }\\n', '  else {\\n', '    float t =  (-b - sqrt(d))/(2.0*a);\\n', '    float tz = EyePos.z + t*EyeDir.z;\\n', '    vec3 iPoint = EyePos + t*EyeDir;\\n', '    if (abs(iPoint.z)*radiusVCVSOutput > lengthVCVSOutput*0.5) {\\n',\n    // test for end cap\n    '      float t2 = (-b + sqrt(d))/(2.0*a);\\n', '      float tz2 = EyePos.z + t2*EyeDir.z;\\n', '      if (tz2*radiusVCVSOutput > lengthVCVSOutput*0.5 || tz*radiusVCVSOutput < -0.5*lengthVCVSOutput) { discard; }\\n', '      else {\\n', '        normalVCVSOutput = orientVCVSOutput;\\n', '        float t3 = (lengthVCVSOutput*0.5/radiusVCVSOutput - EyePos.z)/EyeDir.z;\\n', '        iPoint = EyePos + t3*EyeDir;\\n', '        vertexVC.xyz = radiusVCVSOutput*(iPoint.x*base1 + iPoint.y*base2 + iPoint.z*orientVCVSOutput) + centerVCVSOutput;\\n', '        }\\n', '      }\\n', '    else {\\n',\n    // The normal is the iPoint.xy rotated back into VC\n    '      normalVCVSOutput = iPoint.x*base1 + iPoint.y*base2;\\n',\n    // rescale rerotate and translate\n    '      vertexVC.xyz = radiusVCVSOutput*(normalVCVSOutput + iPoint.z*orientVCVSOutput) + centerVCVSOutput;\\n', '      }\\n', '    }\\n',\n    //    '  vec3 normalVC = vec3(0.0,0.0,1.0);\\n'\n    // compute the pixel's depth\n    '  vec4 pos = VCPCMatrix * vertexVC;\\n', fragString]).result; // Strip out the normal line -- the normal is computed as part of the depth\n\n    FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Normal::Impl', '').result;\n    if (model.haveSeenDepthRequest) {\n      // special depth impl\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::ZBuffer::Impl', ['if (depthRequest == 1) {', 'float computedZ = (pos.z / pos.w + 1.0) / 2.0;', 'float iz = floor(computedZ * 65535.0 + 0.1);', 'float rf = floor(iz/256.0)/255.0;', 'float gf = mod(iz,256.0)/255.0;', 'gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }']).result;\n    }\n    shaders.Vertex = VSSource;\n    shaders.Fragment = FSSource;\n    superClass.replaceShaderValues(shaders, ren, actor);\n  };\n  publicAPI.setMapperShaderParameters = function (cellBO, ren, actor) {\n    if (cellBO.getCABO().getElementCount() && (model.VBOBuildTime > cellBO.getAttributeUpdateTime().getMTime() || cellBO.getShaderSourceTime().getMTime() > cellBO.getAttributeUpdateTime().getMTime())) {\n      if (cellBO.getProgram().isAttributeUsed('orientMC')) {\n        if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO(), 'orientMC', 12,\n        // after X Y Z\n        cellBO.getCABO().getStride(), model.context.FLOAT, 3, false)) {\n          vtkErrorMacro(\"Error setting 'orientMC' in shader VAO.\");\n        }\n      }\n      if (cellBO.getProgram().isAttributeUsed('offsetMC')) {\n        if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO().getColorBO(), 'offsetMC', 0, cellBO.getCABO().getColorBOStride(), model.context.UNSIGNED_BYTE, 3, true)) {\n          vtkErrorMacro(\"Error setting 'offsetMC' in shader VAO.\");\n        }\n      }\n      if (cellBO.getProgram().isAttributeUsed('radiusMC')) {\n        if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO(), 'radiusMC', 24,\n        // X Y Z OX OY OZ\n        cellBO.getCABO().getStride(), model.context.FLOAT, 1, false)) {\n          vtkErrorMacro(\"Error setting 'radiusMC' in shader VAO.\");\n        }\n      }\n    }\n    superClass.setMapperShaderParameters(cellBO, ren, actor);\n  };\n  publicAPI.setCameraShaderParameters = function (cellBO, ren, actor) {\n    var program = cellBO.getProgram();\n    var cam = ren.getActiveCamera();\n    var keyMats = model.openGLCamera.getKeyMatrices(ren);\n    if (program.isUniformUsed('VCPCMatrix')) {\n      program.setUniformMatrix('VCPCMatrix', keyMats.vcpc);\n    }\n    if (!actor.getIsIdentity()) {\n      var actMats = model.openGLActor.getKeyMatrices();\n      if (program.isUniformUsed('MCVCMatrix')) {\n        var tmp4 = new Float64Array(16);\n        mat4.multiply(tmp4, keyMats.wcvc, actMats.mcwc);\n        program.setUniformMatrix('MCVCMatrix', tmp4);\n      }\n      if (program.isUniformUsed('normalMatrix')) {\n        var anorms = new Float64Array(9);\n        mat3.multiply(anorms, keyMats.normalMatrix, actMats.normalMatrix);\n        program.setUniformMatrix3x3('normalMatrix', anorms);\n      }\n    } else {\n      if (program.isUniformUsed('MCVCMatrix')) {\n        program.setUniformMatrix('MCVCMatrix', keyMats.wcvc);\n      }\n      if (program.isUniformUsed('normalMatrix')) {\n        program.setUniformMatrix3x3('normalMatrix', keyMats.normalMatrix);\n      }\n    }\n    if (program.isUniformUsed('cameraParallel')) {\n      cellBO.getProgram().setUniformi('cameraParallel', cam.getParallelProjection());\n    }\n  };\n  publicAPI.getOpenGLMode = function (rep, type) {\n    return model.context.TRIANGLES;\n  };\n  publicAPI.buildBufferObjects = function (ren, actor) {\n    var poly = model.currentInput;\n    if (poly === null) {\n      return;\n    }\n    model.renderable.mapScalars(poly, 1.0);\n    var c = model.renderable.getColorMapColors();\n    var vbo = model.primitives[model.primTypes.Tris].getCABO();\n    var pointData = poly.getPointData();\n    var points = poly.getPoints();\n    var numPoints = points.getNumberOfPoints();\n    var pointArray = points.getData();\n    var pointSize = 3; // x,y,z\n    // three more floats for orientation + 1 for radius\n\n    pointSize += 4;\n    var colorData = null;\n    var colorComponents = 0;\n    vbo.setColorBOStride(4);\n    if (!vbo.getColorBO()) {\n      vbo.setColorBO(vtkBufferObject.newInstance());\n    }\n    vbo.getColorBO().setOpenGLRenderWindow(model._openGLRenderWindow);\n    if (c) {\n      colorComponents = c.getNumberOfComponents();\n      vbo.setColorOffset(4);\n      colorData = c.getData();\n      vbo.setColorBOStride(8);\n    }\n    vbo.setColorComponents(colorComponents);\n    vbo.setStride(pointSize * 4); // Create a buffer, and copy the data over.\n\n    var packedVBO = new Float32Array(pointSize * numPoints * 12);\n    var packedUCVBO = new Uint8Array(12 * numPoints * (colorData ? 8 : 4));\n    var scales = null;\n    var orientationArray = null; //\n    // Generate points and point data for sides\n    //\n\n    if (model.renderable.getScaleArray() != null && pointData.hasArray(model.renderable.getScaleArray())) {\n      scales = pointData.getArray(model.renderable.getScaleArray()).getData();\n    }\n    if (model.renderable.getOrientationArray() != null && pointData.hasArray(model.renderable.getOrientationArray())) {\n      orientationArray = pointData.getArray(model.renderable.getOrientationArray()).getData();\n    } else {\n      vtkErrorMacro(['Error setting orientationArray.\\n', 'You have to specify the stick orientation']);\n    } // Vertices\n    // 013 - 032 - 324 - 453\n    //\n    //       _.4---_.5\n    //    .-*   .-*\n    //   2-----3\n    //   |    /|\n    //   |   / |\n    //   |  /  |\n    //   | /   |\n    //   |/    |\n    //   0-----1\n    //\n    // coord for each points\n    // 0: 000\n    // 1: 100\n    // 2: 001\n    // 3: 101\n    // 4: 011\n    // 5: 111\n    // prettier-ignore\n\n    var verticesArray = [0, 1, 3, 0, 3, 2, 2, 3, 5, 2, 5, 4];\n    var pointIdx = 0;\n    var colorIdx = 0;\n    var vboIdx = 0;\n    var ucIdx = 0;\n    for (var i = 0; i < numPoints; ++i) {\n      var length = model.renderable.getLength();\n      var radius = model.renderable.getRadius();\n      if (scales) {\n        length = scales[i * 2];\n        radius = scales[i * 2 + 1];\n      }\n      for (var j = 0; j < verticesArray.length; ++j) {\n        pointIdx = i * 3;\n        packedVBO[vboIdx++] = pointArray[pointIdx++];\n        packedVBO[vboIdx++] = pointArray[pointIdx++];\n        packedVBO[vboIdx++] = pointArray[pointIdx++];\n        pointIdx = i * 3;\n        packedVBO[vboIdx++] = orientationArray[pointIdx++] * length;\n        packedVBO[vboIdx++] = orientationArray[pointIdx++] * length;\n        packedVBO[vboIdx++] = orientationArray[pointIdx++] * length;\n        packedVBO[vboIdx++] = radius;\n        packedUCVBO[ucIdx++] = 255 * (verticesArray[j] % 2);\n        packedUCVBO[ucIdx++] = verticesArray[j] >= 4 ? 255 : 0;\n        packedUCVBO[ucIdx++] = verticesArray[j] >= 2 ? 255 : 0;\n        packedUCVBO[ucIdx++] = 255;\n        colorIdx = i * colorComponents;\n        if (colorData) {\n          packedUCVBO[ucIdx++] = colorData[colorIdx];\n          packedUCVBO[ucIdx++] = colorData[colorIdx + 1];\n          packedUCVBO[ucIdx++] = colorData[colorIdx + 2];\n          packedUCVBO[ucIdx++] = colorData[colorIdx + 3];\n        }\n      }\n    }\n    vbo.setElementCount(vboIdx / pointSize);\n    vbo.upload(packedVBO, ObjectType.ARRAY_BUFFER);\n    vbo.getColorBO().upload(packedUCVBO, ObjectType.ARRAY_BUFFER);\n    model.VBOBuildTime.modified();\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nvar DEFAULT_VALUES = {}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Inheritance\n\n  vtkOpenGLPolyDataMapper.extend(publicAPI, model, initialValues); // Object methods\n\n  vtkOpenGLStickMapper(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = newInstance$1(extend, 'vtkOpenGLStickMapper'); // ----------------------------------------------------------------------------\n\nvar vtkStickMapper = {\n  newInstance: newInstance,\n  extend: extend\n}; // Register ourself to OpenGL backend if imported\n\nregisterOverride('vtkStickMapper', newInstance);\nexport { vtkStickMapper as default, extend, newInstance };","map":{"version":3,"names":["_defineProperty","mat4","mat3","ObjectType","newInstance","newInstance$1","vtkErrorMacro","vtkErrorMacro$1","vtkBufferObject","v","vtkStickMapperVS","vtkPolyDataFS","vtkShaderProgram","vtkOpenGLPolyDataMapper","registerOverride","ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","getOwnPropertyDescriptors","defineProperties","defineProperty","vtkOpenGLStickMapper","publicAPI","model","classHierarchy","superClass","getShaderTemplate","shaders","ren","actor","Vertex","Fragment","Geometry","replaceShaderValues","VSSource","FSSource","substitute","result","replacement","fragString","context","getExtension","_openGLRenderWindow","getWebgl2","haveSeenDepthRequest","setMapperShaderParameters","cellBO","getCABO","getElementCount","VBOBuildTime","getAttributeUpdateTime","getMTime","getShaderSourceTime","getProgram","isAttributeUsed","getVAO","addAttributeArray","getStride","FLOAT","getColorBO","getColorBOStride","UNSIGNED_BYTE","setCameraShaderParameters","program","cam","getActiveCamera","keyMats","openGLCamera","getKeyMatrices","isUniformUsed","setUniformMatrix","vcpc","getIsIdentity","actMats","openGLActor","tmp4","Float64Array","multiply","wcvc","mcwc","anorms","normalMatrix","setUniformMatrix3x3","setUniformi","getParallelProjection","getOpenGLMode","rep","type","TRIANGLES","buildBufferObjects","poly","currentInput","renderable","mapScalars","c","getColorMapColors","vbo","primitives","primTypes","Tris","pointData","getPointData","points","getPoints","numPoints","getNumberOfPoints","pointArray","getData","pointSize","colorData","colorComponents","setColorBOStride","setColorBO","setOpenGLRenderWindow","getNumberOfComponents","setColorOffset","setColorComponents","setStride","packedVBO","Float32Array","packedUCVBO","Uint8Array","scales","orientationArray","getScaleArray","hasArray","getArray","getOrientationArray","verticesArray","pointIdx","colorIdx","vboIdx","ucIdx","getLength","radius","getRadius","j","setElementCount","upload","ARRAY_BUFFER","modified","DEFAULT_VALUES","extend","initialValues","undefined","assign","vtkStickMapper","default"],"sources":["/home/rakshith/Documents/RemoteRendering/vtk-js-react-app/node_modules/@kitware/vtk.js/Rendering/OpenGL/StickMapper.js"],"sourcesContent":["import _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport { mat4, mat3 } from 'gl-matrix';\nimport { ObjectType } from './BufferObject/Constants.js';\nimport { newInstance as newInstance$1, vtkErrorMacro as vtkErrorMacro$1 } from '../../macros.js';\nimport vtkBufferObject from './BufferObject.js';\nimport { v as vtkStickMapperVS } from './glsl/vtkStickMapperVS.glsl.js';\nimport { v as vtkPolyDataFS } from './glsl/vtkPolyDataFS.glsl.js';\nimport vtkShaderProgram from './ShaderProgram.js';\nimport vtkOpenGLPolyDataMapper from './PolyDataMapper.js';\nimport { registerOverride } from './ViewNodeFactory.js';\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nvar vtkErrorMacro = vtkErrorMacro$1; // ----------------------------------------------------------------------------\n// vtkOpenGLStickMapper methods\n// ----------------------------------------------------------------------------\n\nfunction vtkOpenGLStickMapper(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkOpenGLStickMapper'); // Capture 'parentClass' api for internal use\n\n  var superClass = _objectSpread({}, publicAPI);\n\n  publicAPI.getShaderTemplate = function (shaders, ren, actor) {\n    shaders.Vertex = vtkStickMapperVS;\n    shaders.Fragment = vtkPolyDataFS;\n    shaders.Geometry = '';\n  };\n\n  publicAPI.replaceShaderValues = function (shaders, ren, actor) {\n    var VSSource = shaders.Vertex;\n    var FSSource = shaders.Fragment;\n    VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::Camera::Dec', ['uniform mat4 VCPCMatrix;\\n', 'uniform mat4 MCVCMatrix;']).result;\n    FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::PositionVC::Dec', 'varying vec4 vertexVCVSOutput;').result; // we create vertexVC below, so turn off the default\n    // implementation\n\n    FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::PositionVC::Impl', '  vec4 vertexVC = vertexVCVSOutput;\\n').result; // for lights kit and positional the VCPC matrix is already defined\n    // so don't redefine it\n\n    var replacement = ['uniform int cameraParallel;\\n', 'varying float radiusVCVSOutput;\\n', 'varying vec3 orientVCVSOutput;\\n', 'varying float lengthVCVSOutput;\\n', 'varying vec3 centerVCVSOutput;\\n', 'uniform mat4 VCPCMatrix;\\n'];\n    FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Normal::Dec', replacement).result;\n    var fragString = '';\n\n    if (model.context.getExtension('EXT_frag_depth')) {\n      fragString = '  gl_FragDepthEXT = (pos.z / pos.w + 1.0) / 2.0;\\n';\n    }\n\n    if (model._openGLRenderWindow.getWebgl2()) {\n      fragString = 'gl_FragDepth = (pos.z / pos.w + 1.0) / 2.0;\\n';\n    } // see https://www.cl.cam.ac.uk/teaching/1999/AGraphHCI/SMAG/node2.html\n\n\n    FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Depth::Impl', [// compute the eye position and unit direction\n    '  vec3 EyePos;\\n', '  vec3 EyeDir;\\n', '  if (cameraParallel != 0) {\\n', '    EyePos = vec3(vertexVC.x, vertexVC.y, vertexVC.z + 3.0*radiusVCVSOutput);\\n', '    EyeDir = vec3(0.0,0.0,-1.0); }\\n', '  else {\\n', '    EyeDir = vertexVC.xyz;\\n', '    EyePos = vec3(0.0,0.0,0.0);\\n', '    float lengthED = length(EyeDir);\\n', '    EyeDir = normalize(EyeDir);\\n', // we adjust the EyePos to be closer if it is too far away\n    // to prevent floating point precision noise\n    '    if (lengthED > radiusVCVSOutput*3.0) {\\n', '      EyePos = vertexVC.xyz - EyeDir*3.0*radiusVCVSOutput; }\\n', '    }\\n', // translate to Stick center\n    '  EyePos = EyePos - centerVCVSOutput;\\n', // rotate to new basis\n    // base1, base2, orientVC\n    '  vec3 base1;\\n', '  if (abs(orientVCVSOutput.z) < 0.99) {\\n', '    base1 = normalize(cross(orientVCVSOutput,vec3(0.0,0.0,1.0))); }\\n', '  else {\\n', '    base1 = normalize(cross(orientVCVSOutput,vec3(0.0,1.0,0.0))); }\\n', '  vec3 base2 = cross(orientVCVSOutput,base1);\\n', '  EyePos = vec3(dot(EyePos,base1),dot(EyePos,base2),dot(EyePos,orientVCVSOutput));\\n', '  EyeDir = vec3(dot(EyeDir,base1),dot(EyeDir,base2),dot(EyeDir,orientVCVSOutput));\\n', // scale by radius\n    '  EyePos = EyePos/radiusVCVSOutput;\\n', // find the intersection\n    '  float a = EyeDir.x*EyeDir.x + EyeDir.y*EyeDir.y;\\n', '  float b = 2.0*(EyePos.x*EyeDir.x + EyePos.y*EyeDir.y);\\n', '  float c = EyePos.x*EyePos.x + EyePos.y*EyePos.y - 1.0;\\n', '  float d = b*b - 4.0*a*c;\\n', '  vec3 normalVCVSOutput = vec3(0.0,0.0,1.0);\\n', '  if (d < 0.0) { discard; }\\n', '  else {\\n', '    float t =  (-b - sqrt(d))/(2.0*a);\\n', '    float tz = EyePos.z + t*EyeDir.z;\\n', '    vec3 iPoint = EyePos + t*EyeDir;\\n', '    if (abs(iPoint.z)*radiusVCVSOutput > lengthVCVSOutput*0.5) {\\n', // test for end cap\n    '      float t2 = (-b + sqrt(d))/(2.0*a);\\n', '      float tz2 = EyePos.z + t2*EyeDir.z;\\n', '      if (tz2*radiusVCVSOutput > lengthVCVSOutput*0.5 || tz*radiusVCVSOutput < -0.5*lengthVCVSOutput) { discard; }\\n', '      else {\\n', '        normalVCVSOutput = orientVCVSOutput;\\n', '        float t3 = (lengthVCVSOutput*0.5/radiusVCVSOutput - EyePos.z)/EyeDir.z;\\n', '        iPoint = EyePos + t3*EyeDir;\\n', '        vertexVC.xyz = radiusVCVSOutput*(iPoint.x*base1 + iPoint.y*base2 + iPoint.z*orientVCVSOutput) + centerVCVSOutput;\\n', '        }\\n', '      }\\n', '    else {\\n', // The normal is the iPoint.xy rotated back into VC\n    '      normalVCVSOutput = iPoint.x*base1 + iPoint.y*base2;\\n', // rescale rerotate and translate\n    '      vertexVC.xyz = radiusVCVSOutput*(normalVCVSOutput + iPoint.z*orientVCVSOutput) + centerVCVSOutput;\\n', '      }\\n', '    }\\n', //    '  vec3 normalVC = vec3(0.0,0.0,1.0);\\n'\n    // compute the pixel's depth\n    '  vec4 pos = VCPCMatrix * vertexVC;\\n', fragString]).result; // Strip out the normal line -- the normal is computed as part of the depth\n\n    FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Normal::Impl', '').result;\n\n    if (model.haveSeenDepthRequest) {\n      // special depth impl\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::ZBuffer::Impl', ['if (depthRequest == 1) {', 'float computedZ = (pos.z / pos.w + 1.0) / 2.0;', 'float iz = floor(computedZ * 65535.0 + 0.1);', 'float rf = floor(iz/256.0)/255.0;', 'float gf = mod(iz,256.0)/255.0;', 'gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }']).result;\n    }\n\n    shaders.Vertex = VSSource;\n    shaders.Fragment = FSSource;\n    superClass.replaceShaderValues(shaders, ren, actor);\n  };\n\n  publicAPI.setMapperShaderParameters = function (cellBO, ren, actor) {\n    if (cellBO.getCABO().getElementCount() && (model.VBOBuildTime > cellBO.getAttributeUpdateTime().getMTime() || cellBO.getShaderSourceTime().getMTime() > cellBO.getAttributeUpdateTime().getMTime())) {\n      if (cellBO.getProgram().isAttributeUsed('orientMC')) {\n        if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO(), 'orientMC', 12, // after X Y Z\n        cellBO.getCABO().getStride(), model.context.FLOAT, 3, false)) {\n          vtkErrorMacro(\"Error setting 'orientMC' in shader VAO.\");\n        }\n      }\n\n      if (cellBO.getProgram().isAttributeUsed('offsetMC')) {\n        if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO().getColorBO(), 'offsetMC', 0, cellBO.getCABO().getColorBOStride(), model.context.UNSIGNED_BYTE, 3, true)) {\n          vtkErrorMacro(\"Error setting 'offsetMC' in shader VAO.\");\n        }\n      }\n\n      if (cellBO.getProgram().isAttributeUsed('radiusMC')) {\n        if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO(), 'radiusMC', 24, // X Y Z OX OY OZ\n        cellBO.getCABO().getStride(), model.context.FLOAT, 1, false)) {\n          vtkErrorMacro(\"Error setting 'radiusMC' in shader VAO.\");\n        }\n      }\n    }\n\n    superClass.setMapperShaderParameters(cellBO, ren, actor);\n  };\n\n  publicAPI.setCameraShaderParameters = function (cellBO, ren, actor) {\n    var program = cellBO.getProgram();\n    var cam = ren.getActiveCamera();\n    var keyMats = model.openGLCamera.getKeyMatrices(ren);\n\n    if (program.isUniformUsed('VCPCMatrix')) {\n      program.setUniformMatrix('VCPCMatrix', keyMats.vcpc);\n    }\n\n    if (!actor.getIsIdentity()) {\n      var actMats = model.openGLActor.getKeyMatrices();\n\n      if (program.isUniformUsed('MCVCMatrix')) {\n        var tmp4 = new Float64Array(16);\n        mat4.multiply(tmp4, keyMats.wcvc, actMats.mcwc);\n        program.setUniformMatrix('MCVCMatrix', tmp4);\n      }\n\n      if (program.isUniformUsed('normalMatrix')) {\n        var anorms = new Float64Array(9);\n        mat3.multiply(anorms, keyMats.normalMatrix, actMats.normalMatrix);\n        program.setUniformMatrix3x3('normalMatrix', anorms);\n      }\n    } else {\n      if (program.isUniformUsed('MCVCMatrix')) {\n        program.setUniformMatrix('MCVCMatrix', keyMats.wcvc);\n      }\n\n      if (program.isUniformUsed('normalMatrix')) {\n        program.setUniformMatrix3x3('normalMatrix', keyMats.normalMatrix);\n      }\n    }\n\n    if (program.isUniformUsed('cameraParallel')) {\n      cellBO.getProgram().setUniformi('cameraParallel', cam.getParallelProjection());\n    }\n  };\n\n  publicAPI.getOpenGLMode = function (rep, type) {\n    return model.context.TRIANGLES;\n  };\n\n  publicAPI.buildBufferObjects = function (ren, actor) {\n    var poly = model.currentInput;\n\n    if (poly === null) {\n      return;\n    }\n\n    model.renderable.mapScalars(poly, 1.0);\n    var c = model.renderable.getColorMapColors();\n    var vbo = model.primitives[model.primTypes.Tris].getCABO();\n    var pointData = poly.getPointData();\n    var points = poly.getPoints();\n    var numPoints = points.getNumberOfPoints();\n    var pointArray = points.getData();\n    var pointSize = 3; // x,y,z\n    // three more floats for orientation + 1 for radius\n\n    pointSize += 4;\n    var colorData = null;\n    var colorComponents = 0;\n    vbo.setColorBOStride(4);\n\n    if (!vbo.getColorBO()) {\n      vbo.setColorBO(vtkBufferObject.newInstance());\n    }\n\n    vbo.getColorBO().setOpenGLRenderWindow(model._openGLRenderWindow);\n\n    if (c) {\n      colorComponents = c.getNumberOfComponents();\n      vbo.setColorOffset(4);\n      colorData = c.getData();\n      vbo.setColorBOStride(8);\n    }\n\n    vbo.setColorComponents(colorComponents);\n    vbo.setStride(pointSize * 4); // Create a buffer, and copy the data over.\n\n    var packedVBO = new Float32Array(pointSize * numPoints * 12);\n    var packedUCVBO = new Uint8Array(12 * numPoints * (colorData ? 8 : 4));\n    var scales = null;\n    var orientationArray = null; //\n    // Generate points and point data for sides\n    //\n\n    if (model.renderable.getScaleArray() != null && pointData.hasArray(model.renderable.getScaleArray())) {\n      scales = pointData.getArray(model.renderable.getScaleArray()).getData();\n    }\n\n    if (model.renderable.getOrientationArray() != null && pointData.hasArray(model.renderable.getOrientationArray())) {\n      orientationArray = pointData.getArray(model.renderable.getOrientationArray()).getData();\n    } else {\n      vtkErrorMacro(['Error setting orientationArray.\\n', 'You have to specify the stick orientation']);\n    } // Vertices\n    // 013 - 032 - 324 - 453\n    //\n    //       _.4---_.5\n    //    .-*   .-*\n    //   2-----3\n    //   |    /|\n    //   |   / |\n    //   |  /  |\n    //   | /   |\n    //   |/    |\n    //   0-----1\n    //\n    // coord for each points\n    // 0: 000\n    // 1: 100\n    // 2: 001\n    // 3: 101\n    // 4: 011\n    // 5: 111\n    // prettier-ignore\n\n\n    var verticesArray = [0, 1, 3, 0, 3, 2, 2, 3, 5, 2, 5, 4];\n    var pointIdx = 0;\n    var colorIdx = 0;\n    var vboIdx = 0;\n    var ucIdx = 0;\n\n    for (var i = 0; i < numPoints; ++i) {\n      var length = model.renderable.getLength();\n      var radius = model.renderable.getRadius();\n\n      if (scales) {\n        length = scales[i * 2];\n        radius = scales[i * 2 + 1];\n      }\n\n      for (var j = 0; j < verticesArray.length; ++j) {\n        pointIdx = i * 3;\n        packedVBO[vboIdx++] = pointArray[pointIdx++];\n        packedVBO[vboIdx++] = pointArray[pointIdx++];\n        packedVBO[vboIdx++] = pointArray[pointIdx++];\n        pointIdx = i * 3;\n        packedVBO[vboIdx++] = orientationArray[pointIdx++] * length;\n        packedVBO[vboIdx++] = orientationArray[pointIdx++] * length;\n        packedVBO[vboIdx++] = orientationArray[pointIdx++] * length;\n        packedVBO[vboIdx++] = radius;\n        packedUCVBO[ucIdx++] = 255 * (verticesArray[j] % 2);\n        packedUCVBO[ucIdx++] = verticesArray[j] >= 4 ? 255 : 0;\n        packedUCVBO[ucIdx++] = verticesArray[j] >= 2 ? 255 : 0;\n        packedUCVBO[ucIdx++] = 255;\n        colorIdx = i * colorComponents;\n\n        if (colorData) {\n          packedUCVBO[ucIdx++] = colorData[colorIdx];\n          packedUCVBO[ucIdx++] = colorData[colorIdx + 1];\n          packedUCVBO[ucIdx++] = colorData[colorIdx + 2];\n          packedUCVBO[ucIdx++] = colorData[colorIdx + 3];\n        }\n      }\n    }\n\n    vbo.setElementCount(vboIdx / pointSize);\n    vbo.upload(packedVBO, ObjectType.ARRAY_BUFFER);\n    vbo.getColorBO().upload(packedUCVBO, ObjectType.ARRAY_BUFFER);\n    model.VBOBuildTime.modified();\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\n\nvar DEFAULT_VALUES = {}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Inheritance\n\n  vtkOpenGLPolyDataMapper.extend(publicAPI, model, initialValues); // Object methods\n\n  vtkOpenGLStickMapper(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = newInstance$1(extend, 'vtkOpenGLStickMapper'); // ----------------------------------------------------------------------------\n\nvar vtkStickMapper = {\n  newInstance: newInstance,\n  extend: extend\n}; // Register ourself to OpenGL backend if imported\n\nregisterOverride('vtkStickMapper', newInstance);\n\nexport { vtkStickMapper as default, extend, newInstance };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}