{"ast":null,"code":"import _slicedToArray from '@babel/runtime/helpers/slicedToArray';\nimport _toConsumableArray from '@babel/runtime/helpers/toConsumableArray';\nimport macro from '../../macros.js';\nimport { b as roundVector, c as clampVector } from '../Core/Math/index.js';\nimport vtkBoundingBox from './BoundingBox.js';\nimport vtkDataSet from './DataSet.js';\nimport vtkStructuredData from './StructuredData.js';\nimport { StructuredType } from './StructuredData/Constants.js';\nimport { mat3, mat4, vec3 } from 'gl-matrix';\nvar vtkErrorMacro = macro.vtkErrorMacro; // ----------------------------------------------------------------------------\n// vtkImageData methods\n// ----------------------------------------------------------------------------\n\nfunction vtkImageData(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkImageData');\n  publicAPI.setExtent = function () {\n    if (model.deleted) {\n      vtkErrorMacro('instance deleted - cannot call any method');\n      return false;\n    }\n    for (var _len = arguments.length, inExtent = new Array(_len), _key = 0; _key < _len; _key++) {\n      inExtent[_key] = arguments[_key];\n    }\n    var extentArray = inExtent.length === 1 ? inExtent[0] : inExtent;\n    if (extentArray.length !== 6) {\n      return false;\n    }\n    var changeDetected = model.extent.some(function (item, index) {\n      return item !== extentArray[index];\n    });\n    if (changeDetected) {\n      model.extent = extentArray.slice();\n      model.dataDescription = vtkStructuredData.getDataDescriptionFromExtent(model.extent);\n      publicAPI.modified();\n    }\n    return changeDetected;\n  };\n  publicAPI.setDimensions = function () {\n    var i;\n    var j;\n    var k;\n    if (model.deleted) {\n      vtkErrorMacro('instance deleted - cannot call any method');\n      return;\n    }\n    if (arguments.length === 1) {\n      var array = arguments.length <= 0 ? undefined : arguments[0];\n      i = array[0];\n      j = array[1];\n      k = array[2];\n    } else if (arguments.length === 3) {\n      i = arguments.length <= 0 ? undefined : arguments[0];\n      j = arguments.length <= 1 ? undefined : arguments[1];\n      k = arguments.length <= 2 ? undefined : arguments[2];\n    } else {\n      vtkErrorMacro('Bad dimension specification');\n      return;\n    }\n    publicAPI.setExtent(0, i - 1, 0, j - 1, 0, k - 1);\n  };\n  publicAPI.getDimensions = function () {\n    return [model.extent[1] - model.extent[0] + 1, model.extent[3] - model.extent[2] + 1, model.extent[5] - model.extent[4] + 1];\n  };\n  publicAPI.getNumberOfCells = function () {\n    var dims = publicAPI.getDimensions();\n    var nCells = 1;\n    for (var i = 0; i < 3; i++) {\n      if (dims[i] === 0) {\n        return 0;\n      }\n      if (dims[i] > 1) {\n        nCells *= dims[i] - 1;\n      }\n    }\n    return nCells;\n  };\n  publicAPI.getNumberOfPoints = function () {\n    var dims = publicAPI.getDimensions();\n    return dims[0] * dims[1] * dims[2];\n  };\n  publicAPI.getPoint = function (index) {\n    var dims = publicAPI.getDimensions();\n    if (dims[0] === 0 || dims[1] === 0 || dims[2] === 0) {\n      vtkErrorMacro('Requesting a point from an empty image.');\n      return null;\n    }\n    var ijk = new Float64Array(3);\n    switch (model.dataDescription) {\n      case StructuredType.EMPTY:\n        return null;\n      case StructuredType.SINGLE_POINT:\n        break;\n      case StructuredType.X_LINE:\n        ijk[0] = index;\n        break;\n      case StructuredType.Y_LINE:\n        ijk[1] = index;\n        break;\n      case StructuredType.Z_LINE:\n        ijk[2] = index;\n        break;\n      case StructuredType.XY_PLANE:\n        ijk[0] = index % dims[0];\n        ijk[1] = index / dims[0];\n        break;\n      case StructuredType.YZ_PLANE:\n        ijk[1] = index % dims[1];\n        ijk[2] = index / dims[1];\n        break;\n      case StructuredType.XZ_PLANE:\n        ijk[0] = index % dims[0];\n        ijk[2] = index / dims[0];\n        break;\n      case StructuredType.XYZ_GRID:\n        ijk[0] = index % dims[0];\n        ijk[1] = index / dims[0] % dims[1];\n        ijk[2] = index / (dims[0] * dims[1]);\n        break;\n      default:\n        vtkErrorMacro('Invalid dataDescription');\n        break;\n    }\n    var coords = [0, 0, 0];\n    publicAPI.indexToWorld(ijk, coords);\n    return coords;\n  }; // vtkCell *GetCell(vtkIdType cellId) VTK_OVERRIDE;\n  // void GetCell(vtkIdType cellId, vtkGenericCell *cell) VTK_OVERRIDE;\n  // void GetCellBounds(vtkIdType cellId, double bounds[6]) VTK_OVERRIDE;\n  // virtual vtkIdType FindPoint(double x, double y, double z)\n  // {\n  //   return this->vtkDataSet::FindPoint(x, y, z);\n  // }\n  // vtkIdType FindPoint(double x[3]) VTK_OVERRIDE;\n  // vtkIdType FindCell(\n  //   double x[3], vtkCell *cell, vtkIdType cellId, double tol2,\n  //   int& subId, double pcoords[3], double *weights) VTK_OVERRIDE;\n  // vtkIdType FindCell(\n  //   double x[3], vtkCell *cell, vtkGenericCell *gencell,\n  //   vtkIdType cellId, double tol2, int& subId,\n  //   double pcoords[3], double *weights) VTK_OVERRIDE;\n  // vtkCell *FindAndGetCell(double x[3], vtkCell *cell, vtkIdType cellId,\n  //                                 double tol2, int& subId, double pcoords[3],\n  //                                 double *weights) VTK_OVERRIDE;\n  // int GetCellType(vtkIdType cellId) VTK_OVERRIDE;\n  // void GetCellPoints(vtkIdType cellId, vtkIdList *ptIds) VTK_OVERRIDE\n  //   {vtkStructuredData::GetCellPoints(cellId,ptIds,this->DataDescription,\n  //                                     this->GetDimensions());}\n  // void GetPointCells(vtkIdType ptId, vtkIdList *cellIds) VTK_OVERRIDE\n  //   {vtkStructuredData::GetPointCells(ptId,cellIds,this->GetDimensions());}\n  // void ComputeBounds() VTK_OVERRIDE;\n  // int GetMaxCellSize() VTK_OVERRIDE {return 8;}; //voxel is the largest\n\n  publicAPI.getBounds = function () {\n    return publicAPI.extentToBounds(publicAPI.getSpatialExtent());\n  };\n  publicAPI.extentToBounds = function (ex) {\n    return vtkBoundingBox.transformBounds(ex, model.indexToWorld);\n  };\n  publicAPI.getSpatialExtent = function () {\n    return vtkBoundingBox.inflate(_toConsumableArray(model.extent), 0.5);\n  }; // Internal, shouldn't need to call this manually.\n\n  publicAPI.computeTransforms = function () {\n    mat4.fromTranslation(model.indexToWorld, model.origin);\n    model.indexToWorld[0] = model.direction[0];\n    model.indexToWorld[1] = model.direction[1];\n    model.indexToWorld[2] = model.direction[2];\n    model.indexToWorld[4] = model.direction[3];\n    model.indexToWorld[5] = model.direction[4];\n    model.indexToWorld[6] = model.direction[5];\n    model.indexToWorld[8] = model.direction[6];\n    model.indexToWorld[9] = model.direction[7];\n    model.indexToWorld[10] = model.direction[8];\n    mat4.scale(model.indexToWorld, model.indexToWorld, model.spacing);\n    mat4.invert(model.worldToIndex, model.indexToWorld);\n  };\n  publicAPI.indexToWorld = function (ain) {\n    var aout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    vec3.transformMat4(aout, ain, model.indexToWorld);\n    return aout;\n  };\n  publicAPI.indexToWorldVec3 = publicAPI.indexToWorld;\n  publicAPI.worldToIndex = function (ain) {\n    var aout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    vec3.transformMat4(aout, ain, model.worldToIndex);\n    return aout;\n  };\n  publicAPI.worldToIndexVec3 = publicAPI.worldToIndex;\n  publicAPI.indexToWorldBounds = function (bin) {\n    var bout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    return vtkBoundingBox.transformBounds(bin, model.indexToWorld, bout);\n  };\n  publicAPI.worldToIndexBounds = function (bin) {\n    var bout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    return vtkBoundingBox.transformBounds(bin, model.worldToIndex, bout);\n  }; // Make sure the transform is correct\n\n  publicAPI.onModified(publicAPI.computeTransforms);\n  publicAPI.computeTransforms();\n  publicAPI.getCenter = function () {\n    return vtkBoundingBox.getCenter(publicAPI.getBounds());\n  };\n  publicAPI.computeHistogram = function (worldBounds) {\n    var voxelFunc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    var bounds = [0, 0, 0, 0, 0, 0];\n    publicAPI.worldToIndexBounds(worldBounds, bounds);\n    var point1 = [0, 0, 0];\n    var point2 = [0, 0, 0];\n    vtkBoundingBox.computeCornerPoints(bounds, point1, point2);\n    roundVector(point1, point1);\n    roundVector(point2, point2);\n    var dimensions = publicAPI.getDimensions();\n    clampVector(point1, [0, 0, 0], [dimensions[0] - 1, dimensions[1] - 1, dimensions[2] - 1], point1);\n    clampVector(point2, [0, 0, 0], [dimensions[0] - 1, dimensions[1] - 1, dimensions[2] - 1], point2);\n    var yStride = dimensions[0];\n    var zStride = dimensions[0] * dimensions[1];\n    var pixels = publicAPI.getPointData().getScalars().getData();\n    var maximum = -Infinity;\n    var minimum = Infinity;\n    var sumOfSquares = 0;\n    var isum = 0;\n    var inum = 0;\n    for (var z = point1[2]; z <= point2[2]; z++) {\n      for (var y = point1[1]; y <= point2[1]; y++) {\n        var index = point1[0] + y * yStride + z * zStride;\n        for (var x = point1[0]; x <= point2[0]; x++) {\n          if (!voxelFunc || voxelFunc([x, y, z], bounds)) {\n            var pixel = pixels[index];\n            if (pixel > maximum) maximum = pixel;\n            if (pixel < minimum) minimum = pixel;\n            sumOfSquares += pixel * pixel;\n            isum += pixel;\n            inum += 1;\n          }\n          ++index;\n        }\n      }\n    }\n    var average = inum > 0 ? isum / inum : 0;\n    var variance = inum ? Math.abs(sumOfSquares / inum - average * average) : 0;\n    var sigma = Math.sqrt(variance);\n    return {\n      minimum: minimum,\n      maximum: maximum,\n      average: average,\n      variance: variance,\n      sigma: sigma,\n      count: inum\n    };\n  }; // TODO: use the unimplemented `vtkDataSetAttributes` for scalar length, that is currently also a TODO (GetNumberOfComponents).\n  // Scalar data could be tuples for color information?\n\n  publicAPI.computeIncrements = function (extent) {\n    var numberOfComponents = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    var increments = [];\n    var incr = numberOfComponents; // Calculate array increment offsets\n    // similar to c++ vtkImageData::ComputeIncrements\n\n    for (var idx = 0; idx < 3; ++idx) {\n      increments[idx] = incr;\n      incr *= extent[idx * 2 + 1] - extent[idx * 2] + 1;\n    }\n    return increments;\n  };\n  /**\n   * @param {Number[]} index the localized `[i,j,k]` pixel array position. Float values will be rounded.\n   * @return {Number} the corresponding flattened index in the scalar array\n   */\n\n  publicAPI.computeOffsetIndex = function (_ref) {\n    var _ref2 = _slicedToArray(_ref, 3),\n      i = _ref2[0],\n      j = _ref2[1],\n      k = _ref2[2];\n    var extent = publicAPI.getExtent();\n    var numberOfComponents = publicAPI.getPointData().getScalars().getNumberOfComponents();\n    var increments = publicAPI.computeIncrements(extent, numberOfComponents); // Use the array increments to find the pixel index\n    // similar to c++ vtkImageData::GetArrayPointer\n    // Math.floor to catch \"practically 0\" e^-15 scenarios.\n\n    return Math.floor((Math.round(i) - extent[0]) * increments[0] + (Math.round(j) - extent[2]) * increments[1] + (Math.round(k) - extent[4]) * increments[2]);\n  };\n  /**\n   * @param {Number[]} xyz the [x,y,z] Array in world coordinates\n   * @return {Number|NaN} the corresponding pixel's index in the scalar array\n   */\n\n  publicAPI.getOffsetIndexFromWorld = function (xyz) {\n    var extent = publicAPI.getExtent();\n    var index = publicAPI.worldToIndex(xyz); // Confirm indexed i,j,k coords are within the bounds of the volume\n\n    for (var idx = 0; idx < 3; ++idx) {\n      if (index[idx] < extent[idx * 2] || index[idx] > extent[idx * 2 + 1]) {\n        vtkErrorMacro(\"GetScalarPointer: Pixel \".concat(index, \" is not in memory. Current extent = \").concat(extent));\n        return NaN;\n      }\n    } // Assumed the index here is within 0 <-> scalarData.length, but doesn't hurt to check upstream\n\n    return publicAPI.computeOffsetIndex(index);\n  };\n  /**\n   * @param {Number[]} xyz the [x,y,z] Array in world coordinates\n   * @param {Number?} comp the scalar component index for multi-component scalars\n   * @return {Number|NaN} the corresponding pixel's scalar value\n   */\n\n  publicAPI.getScalarValueFromWorld = function (xyz) {\n    var comp = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    var numberOfComponents = publicAPI.getPointData().getScalars().getNumberOfComponents();\n    if (comp < 0 || comp >= numberOfComponents) {\n      vtkErrorMacro(\"GetScalarPointer: Scalar Component \".concat(comp, \" is not within bounds. Current Scalar numberOfComponents: \").concat(numberOfComponents));\n      return NaN;\n    }\n    var offsetIndex = publicAPI.getOffsetIndexFromWorld(xyz);\n    if (Number.isNaN(offsetIndex)) {\n      // VTK Error Macro will have been tripped already, no need to do it again,\n      return offsetIndex;\n    }\n    return publicAPI.getPointData().getScalars().getComponent(offsetIndex, comp);\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nvar DEFAULT_VALUES = {\n  direction: null,\n  // a mat3\n  indexToWorld: null,\n  // a mat4\n  worldToIndex: null,\n  // a mat4\n  spacing: [1.0, 1.0, 1.0],\n  origin: [0.0, 0.0, 0.0],\n  extent: [0, -1, 0, -1, 0, -1],\n  dataDescription: StructuredType.EMPTY\n}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Inheritance\n\n  vtkDataSet.extend(publicAPI, model, initialValues);\n  if (!model.direction) {\n    model.direction = mat3.identity(new Float64Array(9));\n  } else if (Array.isArray(model.direction)) {\n    model.direction = new Float64Array(model.direction.slice(0, 9));\n  }\n  model.indexToWorld = new Float64Array(16);\n  model.worldToIndex = new Float64Array(16); // Set/Get methods\n\n  macro.get(publicAPI, model, ['indexToWorld', 'worldToIndex']);\n  macro.setGetArray(publicAPI, model, ['origin', 'spacing'], 3);\n  macro.setGetArray(publicAPI, model, ['direction'], 9);\n  macro.getArray(publicAPI, model, ['extent'], 6); // Object specific methods\n\n  vtkImageData(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = macro.newInstance(extend, 'vtkImageData'); // ----------------------------------------------------------------------------\n\nvar vtkImageData$1 = {\n  newInstance: newInstance,\n  extend: extend\n};\nexport { vtkImageData$1 as default, extend, newInstance };","map":{"version":3,"names":["_slicedToArray","_toConsumableArray","macro","b","roundVector","c","clampVector","vtkBoundingBox","vtkDataSet","vtkStructuredData","StructuredType","mat3","mat4","vec3","vtkErrorMacro","vtkImageData","publicAPI","model","classHierarchy","push","setExtent","deleted","_len","arguments","length","inExtent","Array","_key","extentArray","changeDetected","extent","some","item","index","slice","dataDescription","getDataDescriptionFromExtent","modified","setDimensions","i","j","k","array","undefined","getDimensions","getNumberOfCells","dims","nCells","getNumberOfPoints","getPoint","ijk","Float64Array","EMPTY","SINGLE_POINT","X_LINE","Y_LINE","Z_LINE","XY_PLANE","YZ_PLANE","XZ_PLANE","XYZ_GRID","coords","indexToWorld","getBounds","extentToBounds","getSpatialExtent","ex","transformBounds","inflate","computeTransforms","fromTranslation","origin","direction","scale","spacing","invert","worldToIndex","ain","aout","transformMat4","indexToWorldVec3","worldToIndexVec3","indexToWorldBounds","bin","bout","worldToIndexBounds","onModified","getCenter","computeHistogram","worldBounds","voxelFunc","bounds","point1","point2","computeCornerPoints","dimensions","yStride","zStride","pixels","getPointData","getScalars","getData","maximum","Infinity","minimum","sumOfSquares","isum","inum","z","y","x","pixel","average","variance","Math","abs","sigma","sqrt","count","computeIncrements","numberOfComponents","increments","incr","idx","computeOffsetIndex","_ref","_ref2","getExtent","getNumberOfComponents","floor","round","getOffsetIndexFromWorld","xyz","concat","NaN","getScalarValueFromWorld","comp","offsetIndex","Number","isNaN","getComponent","DEFAULT_VALUES","extend","initialValues","Object","assign","identity","isArray","get","setGetArray","getArray","newInstance","vtkImageData$1","default"],"sources":["/home/rakshith/Documents/RemoteRendering/vtk-js-react-app/node_modules/@kitware/vtk.js/Common/DataModel/ImageData.js"],"sourcesContent":["import _slicedToArray from '@babel/runtime/helpers/slicedToArray';\nimport _toConsumableArray from '@babel/runtime/helpers/toConsumableArray';\nimport macro from '../../macros.js';\nimport { b as roundVector, c as clampVector } from '../Core/Math/index.js';\nimport vtkBoundingBox from './BoundingBox.js';\nimport vtkDataSet from './DataSet.js';\nimport vtkStructuredData from './StructuredData.js';\nimport { StructuredType } from './StructuredData/Constants.js';\nimport { mat3, mat4, vec3 } from 'gl-matrix';\n\nvar vtkErrorMacro = macro.vtkErrorMacro; // ----------------------------------------------------------------------------\n// vtkImageData methods\n// ----------------------------------------------------------------------------\n\nfunction vtkImageData(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkImageData');\n\n  publicAPI.setExtent = function () {\n    if (model.deleted) {\n      vtkErrorMacro('instance deleted - cannot call any method');\n      return false;\n    }\n\n    for (var _len = arguments.length, inExtent = new Array(_len), _key = 0; _key < _len; _key++) {\n      inExtent[_key] = arguments[_key];\n    }\n\n    var extentArray = inExtent.length === 1 ? inExtent[0] : inExtent;\n\n    if (extentArray.length !== 6) {\n      return false;\n    }\n\n    var changeDetected = model.extent.some(function (item, index) {\n      return item !== extentArray[index];\n    });\n\n    if (changeDetected) {\n      model.extent = extentArray.slice();\n      model.dataDescription = vtkStructuredData.getDataDescriptionFromExtent(model.extent);\n      publicAPI.modified();\n    }\n\n    return changeDetected;\n  };\n\n  publicAPI.setDimensions = function () {\n    var i;\n    var j;\n    var k;\n\n    if (model.deleted) {\n      vtkErrorMacro('instance deleted - cannot call any method');\n      return;\n    }\n\n    if (arguments.length === 1) {\n      var array = arguments.length <= 0 ? undefined : arguments[0];\n      i = array[0];\n      j = array[1];\n      k = array[2];\n    } else if (arguments.length === 3) {\n      i = arguments.length <= 0 ? undefined : arguments[0];\n      j = arguments.length <= 1 ? undefined : arguments[1];\n      k = arguments.length <= 2 ? undefined : arguments[2];\n    } else {\n      vtkErrorMacro('Bad dimension specification');\n      return;\n    }\n\n    publicAPI.setExtent(0, i - 1, 0, j - 1, 0, k - 1);\n  };\n\n  publicAPI.getDimensions = function () {\n    return [model.extent[1] - model.extent[0] + 1, model.extent[3] - model.extent[2] + 1, model.extent[5] - model.extent[4] + 1];\n  };\n\n  publicAPI.getNumberOfCells = function () {\n    var dims = publicAPI.getDimensions();\n    var nCells = 1;\n\n    for (var i = 0; i < 3; i++) {\n      if (dims[i] === 0) {\n        return 0;\n      }\n\n      if (dims[i] > 1) {\n        nCells *= dims[i] - 1;\n      }\n    }\n\n    return nCells;\n  };\n\n  publicAPI.getNumberOfPoints = function () {\n    var dims = publicAPI.getDimensions();\n    return dims[0] * dims[1] * dims[2];\n  };\n\n  publicAPI.getPoint = function (index) {\n    var dims = publicAPI.getDimensions();\n\n    if (dims[0] === 0 || dims[1] === 0 || dims[2] === 0) {\n      vtkErrorMacro('Requesting a point from an empty image.');\n      return null;\n    }\n\n    var ijk = new Float64Array(3);\n\n    switch (model.dataDescription) {\n      case StructuredType.EMPTY:\n        return null;\n\n      case StructuredType.SINGLE_POINT:\n        break;\n\n      case StructuredType.X_LINE:\n        ijk[0] = index;\n        break;\n\n      case StructuredType.Y_LINE:\n        ijk[1] = index;\n        break;\n\n      case StructuredType.Z_LINE:\n        ijk[2] = index;\n        break;\n\n      case StructuredType.XY_PLANE:\n        ijk[0] = index % dims[0];\n        ijk[1] = index / dims[0];\n        break;\n\n      case StructuredType.YZ_PLANE:\n        ijk[1] = index % dims[1];\n        ijk[2] = index / dims[1];\n        break;\n\n      case StructuredType.XZ_PLANE:\n        ijk[0] = index % dims[0];\n        ijk[2] = index / dims[0];\n        break;\n\n      case StructuredType.XYZ_GRID:\n        ijk[0] = index % dims[0];\n        ijk[1] = index / dims[0] % dims[1];\n        ijk[2] = index / (dims[0] * dims[1]);\n        break;\n\n      default:\n        vtkErrorMacro('Invalid dataDescription');\n        break;\n    }\n\n    var coords = [0, 0, 0];\n    publicAPI.indexToWorld(ijk, coords);\n    return coords;\n  }; // vtkCell *GetCell(vtkIdType cellId) VTK_OVERRIDE;\n  // void GetCell(vtkIdType cellId, vtkGenericCell *cell) VTK_OVERRIDE;\n  // void GetCellBounds(vtkIdType cellId, double bounds[6]) VTK_OVERRIDE;\n  // virtual vtkIdType FindPoint(double x, double y, double z)\n  // {\n  //   return this->vtkDataSet::FindPoint(x, y, z);\n  // }\n  // vtkIdType FindPoint(double x[3]) VTK_OVERRIDE;\n  // vtkIdType FindCell(\n  //   double x[3], vtkCell *cell, vtkIdType cellId, double tol2,\n  //   int& subId, double pcoords[3], double *weights) VTK_OVERRIDE;\n  // vtkIdType FindCell(\n  //   double x[3], vtkCell *cell, vtkGenericCell *gencell,\n  //   vtkIdType cellId, double tol2, int& subId,\n  //   double pcoords[3], double *weights) VTK_OVERRIDE;\n  // vtkCell *FindAndGetCell(double x[3], vtkCell *cell, vtkIdType cellId,\n  //                                 double tol2, int& subId, double pcoords[3],\n  //                                 double *weights) VTK_OVERRIDE;\n  // int GetCellType(vtkIdType cellId) VTK_OVERRIDE;\n  // void GetCellPoints(vtkIdType cellId, vtkIdList *ptIds) VTK_OVERRIDE\n  //   {vtkStructuredData::GetCellPoints(cellId,ptIds,this->DataDescription,\n  //                                     this->GetDimensions());}\n  // void GetPointCells(vtkIdType ptId, vtkIdList *cellIds) VTK_OVERRIDE\n  //   {vtkStructuredData::GetPointCells(ptId,cellIds,this->GetDimensions());}\n  // void ComputeBounds() VTK_OVERRIDE;\n  // int GetMaxCellSize() VTK_OVERRIDE {return 8;}; //voxel is the largest\n\n\n  publicAPI.getBounds = function () {\n    return publicAPI.extentToBounds(publicAPI.getSpatialExtent());\n  };\n\n  publicAPI.extentToBounds = function (ex) {\n    return vtkBoundingBox.transformBounds(ex, model.indexToWorld);\n  };\n\n  publicAPI.getSpatialExtent = function () {\n    return vtkBoundingBox.inflate(_toConsumableArray(model.extent), 0.5);\n  }; // Internal, shouldn't need to call this manually.\n\n\n  publicAPI.computeTransforms = function () {\n    mat4.fromTranslation(model.indexToWorld, model.origin);\n    model.indexToWorld[0] = model.direction[0];\n    model.indexToWorld[1] = model.direction[1];\n    model.indexToWorld[2] = model.direction[2];\n    model.indexToWorld[4] = model.direction[3];\n    model.indexToWorld[5] = model.direction[4];\n    model.indexToWorld[6] = model.direction[5];\n    model.indexToWorld[8] = model.direction[6];\n    model.indexToWorld[9] = model.direction[7];\n    model.indexToWorld[10] = model.direction[8];\n    mat4.scale(model.indexToWorld, model.indexToWorld, model.spacing);\n    mat4.invert(model.worldToIndex, model.indexToWorld);\n  };\n\n  publicAPI.indexToWorld = function (ain) {\n    var aout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    vec3.transformMat4(aout, ain, model.indexToWorld);\n    return aout;\n  };\n\n  publicAPI.indexToWorldVec3 = publicAPI.indexToWorld;\n\n  publicAPI.worldToIndex = function (ain) {\n    var aout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    vec3.transformMat4(aout, ain, model.worldToIndex);\n    return aout;\n  };\n\n  publicAPI.worldToIndexVec3 = publicAPI.worldToIndex;\n\n  publicAPI.indexToWorldBounds = function (bin) {\n    var bout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    return vtkBoundingBox.transformBounds(bin, model.indexToWorld, bout);\n  };\n\n  publicAPI.worldToIndexBounds = function (bin) {\n    var bout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    return vtkBoundingBox.transformBounds(bin, model.worldToIndex, bout);\n  }; // Make sure the transform is correct\n\n\n  publicAPI.onModified(publicAPI.computeTransforms);\n  publicAPI.computeTransforms();\n\n  publicAPI.getCenter = function () {\n    return vtkBoundingBox.getCenter(publicAPI.getBounds());\n  };\n\n  publicAPI.computeHistogram = function (worldBounds) {\n    var voxelFunc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    var bounds = [0, 0, 0, 0, 0, 0];\n    publicAPI.worldToIndexBounds(worldBounds, bounds);\n    var point1 = [0, 0, 0];\n    var point2 = [0, 0, 0];\n    vtkBoundingBox.computeCornerPoints(bounds, point1, point2);\n    roundVector(point1, point1);\n    roundVector(point2, point2);\n    var dimensions = publicAPI.getDimensions();\n    clampVector(point1, [0, 0, 0], [dimensions[0] - 1, dimensions[1] - 1, dimensions[2] - 1], point1);\n    clampVector(point2, [0, 0, 0], [dimensions[0] - 1, dimensions[1] - 1, dimensions[2] - 1], point2);\n    var yStride = dimensions[0];\n    var zStride = dimensions[0] * dimensions[1];\n    var pixels = publicAPI.getPointData().getScalars().getData();\n    var maximum = -Infinity;\n    var minimum = Infinity;\n    var sumOfSquares = 0;\n    var isum = 0;\n    var inum = 0;\n\n    for (var z = point1[2]; z <= point2[2]; z++) {\n      for (var y = point1[1]; y <= point2[1]; y++) {\n        var index = point1[0] + y * yStride + z * zStride;\n\n        for (var x = point1[0]; x <= point2[0]; x++) {\n          if (!voxelFunc || voxelFunc([x, y, z], bounds)) {\n            var pixel = pixels[index];\n            if (pixel > maximum) maximum = pixel;\n            if (pixel < minimum) minimum = pixel;\n            sumOfSquares += pixel * pixel;\n            isum += pixel;\n            inum += 1;\n          }\n\n          ++index;\n        }\n      }\n    }\n\n    var average = inum > 0 ? isum / inum : 0;\n    var variance = inum ? Math.abs(sumOfSquares / inum - average * average) : 0;\n    var sigma = Math.sqrt(variance);\n    return {\n      minimum: minimum,\n      maximum: maximum,\n      average: average,\n      variance: variance,\n      sigma: sigma,\n      count: inum\n    };\n  }; // TODO: use the unimplemented `vtkDataSetAttributes` for scalar length, that is currently also a TODO (GetNumberOfComponents).\n  // Scalar data could be tuples for color information?\n\n\n  publicAPI.computeIncrements = function (extent) {\n    var numberOfComponents = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    var increments = [];\n    var incr = numberOfComponents; // Calculate array increment offsets\n    // similar to c++ vtkImageData::ComputeIncrements\n\n    for (var idx = 0; idx < 3; ++idx) {\n      increments[idx] = incr;\n      incr *= extent[idx * 2 + 1] - extent[idx * 2] + 1;\n    }\n\n    return increments;\n  };\n  /**\n   * @param {Number[]} index the localized `[i,j,k]` pixel array position. Float values will be rounded.\n   * @return {Number} the corresponding flattened index in the scalar array\n   */\n\n\n  publicAPI.computeOffsetIndex = function (_ref) {\n    var _ref2 = _slicedToArray(_ref, 3),\n        i = _ref2[0],\n        j = _ref2[1],\n        k = _ref2[2];\n\n    var extent = publicAPI.getExtent();\n    var numberOfComponents = publicAPI.getPointData().getScalars().getNumberOfComponents();\n    var increments = publicAPI.computeIncrements(extent, numberOfComponents); // Use the array increments to find the pixel index\n    // similar to c++ vtkImageData::GetArrayPointer\n    // Math.floor to catch \"practically 0\" e^-15 scenarios.\n\n    return Math.floor((Math.round(i) - extent[0]) * increments[0] + (Math.round(j) - extent[2]) * increments[1] + (Math.round(k) - extent[4]) * increments[2]);\n  };\n  /**\n   * @param {Number[]} xyz the [x,y,z] Array in world coordinates\n   * @return {Number|NaN} the corresponding pixel's index in the scalar array\n   */\n\n\n  publicAPI.getOffsetIndexFromWorld = function (xyz) {\n    var extent = publicAPI.getExtent();\n    var index = publicAPI.worldToIndex(xyz); // Confirm indexed i,j,k coords are within the bounds of the volume\n\n    for (var idx = 0; idx < 3; ++idx) {\n      if (index[idx] < extent[idx * 2] || index[idx] > extent[idx * 2 + 1]) {\n        vtkErrorMacro(\"GetScalarPointer: Pixel \".concat(index, \" is not in memory. Current extent = \").concat(extent));\n        return NaN;\n      }\n    } // Assumed the index here is within 0 <-> scalarData.length, but doesn't hurt to check upstream\n\n\n    return publicAPI.computeOffsetIndex(index);\n  };\n  /**\n   * @param {Number[]} xyz the [x,y,z] Array in world coordinates\n   * @param {Number?} comp the scalar component index for multi-component scalars\n   * @return {Number|NaN} the corresponding pixel's scalar value\n   */\n\n\n  publicAPI.getScalarValueFromWorld = function (xyz) {\n    var comp = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    var numberOfComponents = publicAPI.getPointData().getScalars().getNumberOfComponents();\n\n    if (comp < 0 || comp >= numberOfComponents) {\n      vtkErrorMacro(\"GetScalarPointer: Scalar Component \".concat(comp, \" is not within bounds. Current Scalar numberOfComponents: \").concat(numberOfComponents));\n      return NaN;\n    }\n\n    var offsetIndex = publicAPI.getOffsetIndexFromWorld(xyz);\n\n    if (Number.isNaN(offsetIndex)) {\n      // VTK Error Macro will have been tripped already, no need to do it again,\n      return offsetIndex;\n    }\n\n    return publicAPI.getPointData().getScalars().getComponent(offsetIndex, comp);\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\n\nvar DEFAULT_VALUES = {\n  direction: null,\n  // a mat3\n  indexToWorld: null,\n  // a mat4\n  worldToIndex: null,\n  // a mat4\n  spacing: [1.0, 1.0, 1.0],\n  origin: [0.0, 0.0, 0.0],\n  extent: [0, -1, 0, -1, 0, -1],\n  dataDescription: StructuredType.EMPTY\n}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Inheritance\n\n  vtkDataSet.extend(publicAPI, model, initialValues);\n\n  if (!model.direction) {\n    model.direction = mat3.identity(new Float64Array(9));\n  } else if (Array.isArray(model.direction)) {\n    model.direction = new Float64Array(model.direction.slice(0, 9));\n  }\n\n  model.indexToWorld = new Float64Array(16);\n  model.worldToIndex = new Float64Array(16); // Set/Get methods\n\n  macro.get(publicAPI, model, ['indexToWorld', 'worldToIndex']);\n  macro.setGetArray(publicAPI, model, ['origin', 'spacing'], 3);\n  macro.setGetArray(publicAPI, model, ['direction'], 9);\n  macro.getArray(publicAPI, model, ['extent'], 6); // Object specific methods\n\n  vtkImageData(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = macro.newInstance(extend, 'vtkImageData'); // ----------------------------------------------------------------------------\n\nvar vtkImageData$1 = {\n  newInstance: newInstance,\n  extend: extend\n};\n\nexport { vtkImageData$1 as default, extend, newInstance };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}