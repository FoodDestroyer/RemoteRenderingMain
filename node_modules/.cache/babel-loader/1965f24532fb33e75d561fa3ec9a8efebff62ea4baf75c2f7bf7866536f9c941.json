{"ast":null,"code":"import _toConsumableArray from '@babel/runtime/helpers/toConsumableArray';\nimport vtkBoundingBox, { STATIC } from '../../../Common/DataModel/BoundingBox.js';\nimport vtkCubeSource from '../../../Filters/Sources/CubeSource.js';\nimport vtkCutter from '../../../Filters/Core/Cutter.js';\nimport vtkPlane from '../../../Common/DataModel/Plane.js';\nimport { s as subtract, l as normalize, j as cross, w as multiplyScalar, m as multiplyAccumulate, S as signedAngleBetweenVectors } from '../../../Common/Core/Math/index.js';\nimport vtkMatrixBuilder from '../../../Common/Core/MatrixBuilder.js';\nimport { viewTypeToPlaneName, planeNameToViewType, planeNames } from './Constants.js';\nvar EPSILON = 10e-7;\n/**\n * Fit the plane defined by origin, p1, p2 onto the bounds.\n * Plane is untouched if does not intersect bounds.\n * @param {Array} bounds\n * @param {Array} origin\n * @param {Array} p1\n * @param {Array} p2\n * @return {Boolean} false if no bounds have been found, else true\n */\n\nfunction boundPlane(bounds, origin, p1, p2) {\n  var v1 = [];\n  subtract(p1, origin, v1);\n  normalize(v1);\n  var v2 = [];\n  subtract(p2, origin, v2);\n  normalize(v2);\n  var n = [0, 0, 1];\n  cross(v1, v2, n);\n  normalize(n); // Inflate bounds in order to avoid precision error when cutting cubesource\n\n  var inflatedBounds = _toConsumableArray(bounds);\n  var eps = [].concat(n);\n  multiplyScalar(eps, EPSILON);\n  vtkBoundingBox.addBounds(inflatedBounds, bounds[0] + eps[0], bounds[1] + eps[0], bounds[2] + eps[1], bounds[3] + eps[1], bounds[4] + eps[2], bounds[5] + eps[2]);\n  vtkBoundingBox.addBounds(inflatedBounds, bounds[0] - eps[0], bounds[1] - eps[0], bounds[2] - eps[1], bounds[3] - eps[1], bounds[4] - eps[2], bounds[5] - eps[2]);\n  var plane = vtkPlane.newInstance();\n  plane.setOrigin.apply(plane, _toConsumableArray(origin));\n  plane.setNormal.apply(plane, n);\n  var cubeSource = vtkCubeSource.newInstance();\n  cubeSource.setBounds(inflatedBounds);\n  var cutter = vtkCutter.newInstance();\n  cutter.setCutFunction(plane);\n  cutter.setInputConnection(cubeSource.getOutputPort());\n  var cutBounds = cutter.getOutputData();\n  if (cutBounds.getNumberOfPoints() === 0) {\n    return false;\n  }\n  var localBounds = STATIC.computeLocalBounds(cutBounds.getPoints(), v1, v2, n);\n  for (var i = 0; i < 3; i += 1) {\n    origin[i] = localBounds[0] * v1[i] + localBounds[2] * v2[i] + localBounds[4] * n[i];\n    p1[i] = localBounds[1] * v1[i] + localBounds[2] * v2[i] + localBounds[4] * n[i];\n    p2[i] = localBounds[0] * v1[i] + localBounds[3] * v2[i] + localBounds[4] * n[i];\n  }\n  return true;\n} // Project point (inPoint) to the bounds of the image according to a plane\n// defined by two vectors (v1, v2)\n\nfunction boundPoint(inPoint, v1, v2, bounds) {\n  var absT1 = v1.map(function (val) {\n    return Math.abs(val);\n  });\n  var absT2 = v2.map(function (val) {\n    return Math.abs(val);\n  });\n  var o1 = 0.0;\n  var o2 = 0.0;\n  for (var i = 0; i < 3; i++) {\n    var axisOffset = 0;\n    var useT1 = absT1[i] > absT2[i];\n    var t = useT1 ? v1 : v2;\n    var absT = useT1 ? absT1 : absT2;\n    if (inPoint[i] < bounds[i * 2]) {\n      axisOffset = absT[i] > EPSILON ? (bounds[2 * i] - inPoint[i]) / t[i] : 0;\n    } else if (inPoint[i] > bounds[2 * i + 1]) {\n      axisOffset = absT[i] > EPSILON ? (bounds[2 * i + 1] - inPoint[i]) / t[i] : 0;\n    }\n    if (useT1) {\n      if (Math.abs(axisOffset) > Math.abs(o1)) {\n        o1 = axisOffset;\n      }\n    } else if (Math.abs(axisOffset) > Math.abs(o2)) {\n      o2 = axisOffset;\n    }\n  }\n  var outPoint = [inPoint[0], inPoint[1], inPoint[2]];\n  if (o1 !== 0.0) {\n    multiplyAccumulate(outPoint, v1, o1, outPoint);\n  }\n  if (o2 !== 0.0) {\n    multiplyAccumulate(outPoint, v2, o2, outPoint);\n  }\n  return outPoint;\n} // Compute the intersection between p1 and p2 on bounds\n\nfunction boundPointOnPlane(p1, p2, bounds) {\n  var dir12 = [0, 0, 0];\n  subtract(p2, p1, dir12);\n  var out = [0, 0, 0];\n  var tolerance = [0, 0, 0];\n  vtkBoundingBox.intersectBox(bounds, p1, dir12, out, tolerance);\n  return out;\n}\n/**\n * Rotates a vector around another.\n * @param {vec3} vectorToBeRotated Vector to rate\n * @param {vec3} axis Axis to rotate around\n * @param {Number} angle Angle in radian\n * @returns The rotated vector\n */\n\nfunction rotateVector(vectorToBeRotated, axis, angle) {\n  var rotatedVector = _toConsumableArray(vectorToBeRotated);\n  vtkMatrixBuilder.buildFromRadian().rotate(angle, axis).apply(rotatedVector);\n  return rotatedVector;\n}\n/**\n * Return ['X', 'Y'] if there are only 2 planes defined in the widget state.\n * Return ['X', 'Y', 'Z'] if there are 3 planes defined in the widget state.\n * @param {object} widgetState the state of the widget\n * @returns An array of plane names\n */\n\nfunction getPlaneNames(widgetState) {\n  return Object.keys(widgetState.getPlanes()).map(function (viewType) {\n    return viewTypeToPlaneName[viewType];\n  });\n}\n/**\n * Return X if lineName == XinY|XinZ, Y if lineName == YinX|YinZ and Z otherwise\n * @param {string} lineName name of the line (YinX, ZinX, XinY, ZinY, XinZ, YinZ)\n */\n\nfunction getLinePlaneName(lineName) {\n  return lineName[0];\n}\n/**\n * Return X if lineName == YinX|ZinX, Y if lineName == XinY|ZinY and Z otherwise\n * @param {string} lineName name of the line (YinX, ZinX, XinY, ZinY, XinZ, YinZ)\n */\n\nfunction getLineInPlaneName(lineName) {\n  return lineName[3];\n}\n/**\n * Returns ['XinY', 'YinX'] if planes == ['X', 'Y']\n * ['XinY', 'XinZ', 'YinX', 'YinZ', 'ZinX', 'ZinY'] if planes == ['X', 'Y', 'Z']\n * @param {string} planes name of the planes (e.g. ['X', 'Y'])\n */\n\nfunction getPlanesLineNames() {\n  var planes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : planeNames;\n  var lines = [];\n  planes.forEach(function (plane) {\n    planes.forEach(function (inPlane) {\n      if (plane !== inPlane) {\n        lines.push(\"\".concat(plane, \"in\").concat(inPlane));\n      }\n    });\n  });\n  return lines;\n}\nfunction getLineNames(widgetState) {\n  var planes = Object.keys(widgetState.getPlanes()).map(function (viewType) {\n    return viewTypeToPlaneName[viewType];\n  });\n  return getPlanesLineNames(planes);\n}\n/**\n * Return ZinX if lineName == YinX, YinX if lineName == ZinX, ZinY if lineName == XinY...\n * @param {string} lineName name of the line (YinX, ZinX, XinY, ZinY, XinZ, YinZ)\n */\n\nfunction getOtherLineName(widgetState, lineName) {\n  var linePlaneName = getLinePlaneName(lineName);\n  var lineInPlaneName = getLineInPlaneName(lineName);\n  var otherLineName = getPlaneNames(widgetState).find(function (planeName) {\n    return planeName !== linePlaneName && planeName !== lineInPlaneName;\n  });\n  return \"\".concat(otherLineName, \"in\").concat(lineInPlaneName);\n} // Compute the offset of the rotation handle origin\n\nfunction computeRotationHandleOriginOffset(axis, rotationHandlePosition, volumeDiagonalLength, scaleInPixels) {\n  // FIXME: p1 and p2 could be placed on the exact boundaries of the volume.\n  return multiplyScalar(_toConsumableArray(axis), rotationHandlePosition * (scaleInPixels ? 1 : volumeDiagonalLength) / 2);\n} // Update the reslice cursor state according to the three planes normals and the origin\n\nfunction updateState(widgetState, scaleInPixels, rotationHandlePosition) {\n  var planes = Object.keys(widgetState.getPlanes()).map(function (viewType) {\n    return viewTypeToPlaneName[viewType];\n  }); // Generates an object as such:\n  // axes = {'XY': cross(X, Y), 'YX': cross(X, Y), 'YZ': cross(Y, Z)...}\n\n  var axes = planes.reduce(function (res, plane) {\n    planes.filter(function (otherPlane) {\n      return plane !== otherPlane;\n    }).forEach(function (otherPlane) {\n      var cross$1 = cross(widgetState.getPlanes()[planeNameToViewType[plane]].normal, widgetState.getPlanes()[planeNameToViewType[otherPlane]].normal, []);\n      res[\"\".concat(plane).concat(otherPlane)] = cross$1;\n      res[\"\".concat(otherPlane).concat(plane)] = cross$1;\n    });\n    return res;\n  }, {});\n  var bounds = widgetState.getImage().getBounds();\n  var center = widgetState.getCenter(); // Length of the principal diagonal.\n\n  var pdLength = vtkBoundingBox.getDiagonalLength(bounds);\n  widgetState.getCenterHandle().setOrigin(center);\n  getPlanesLineNames(planes).forEach(function (lineName) {\n    var _widgetState$$getMani, _widgetState$$getMani2, _widgetState$$getMani3, _widgetState$$getMani4, _lineHandle$getManipu, _lineHandle$getManipu2;\n    var planeName = getLinePlaneName(lineName);\n    var inPlaneName = getLineInPlaneName(lineName);\n    var direction = axes[\"\".concat(planeName).concat(inPlaneName)];\n    widgetState[\"getRotationHandle\".concat(lineName, \"0\")]().setOrigin(center);\n    (_widgetState$$getMani = widgetState[\"getRotationHandle\".concat(lineName, \"0\")]().getManipulator()) === null || _widgetState$$getMani === void 0 ? void 0 : _widgetState$$getMani.setHandleOrigin(center);\n    (_widgetState$$getMani2 = widgetState[\"getRotationHandle\".concat(lineName, \"0\")]().getManipulator()) === null || _widgetState$$getMani2 === void 0 ? void 0 : _widgetState$$getMani2.setHandleNormal(widgetState.getPlanes()[planeNameToViewType[planeName]].normal);\n    widgetState[\"getRotationHandle\".concat(lineName, \"0\")]().setOffset(computeRotationHandleOriginOffset(direction, rotationHandlePosition, pdLength, scaleInPixels));\n    widgetState[\"getRotationHandle\".concat(lineName, \"1\")]().setOrigin(center);\n    (_widgetState$$getMani3 = widgetState[\"getRotationHandle\".concat(lineName, \"1\")]().getManipulator()) === null || _widgetState$$getMani3 === void 0 ? void 0 : _widgetState$$getMani3.setHandleOrigin(center);\n    (_widgetState$$getMani4 = widgetState[\"getRotationHandle\".concat(lineName, \"1\")]().getManipulator()) === null || _widgetState$$getMani4 === void 0 ? void 0 : _widgetState$$getMani4.setHandleNormal(widgetState.getPlanes()[planeNameToViewType[planeName]].normal);\n    widgetState[\"getRotationHandle\".concat(lineName, \"1\")]().setOffset(computeRotationHandleOriginOffset(direction, -rotationHandlePosition, pdLength, scaleInPixels));\n    var lineHandle = widgetState[\"getAxis\".concat(lineName)]();\n    lineHandle.setOrigin(center);\n    (_lineHandle$getManipu = lineHandle.getManipulator()) === null || _lineHandle$getManipu === void 0 ? void 0 : _lineHandle$getManipu.setHandleOrigin(center);\n    (_lineHandle$getManipu2 = lineHandle.getManipulator()) === null || _lineHandle$getManipu2 === void 0 ? void 0 : _lineHandle$getManipu2.setHandleNormal(widgetState.getPlanes()[planeNameToViewType[planeName]].normal);\n    var scale = normalize(direction);\n    var scale3 = lineHandle.getScale3();\n    scale3[2] = 2 * scale;\n    lineHandle.setScale3(scale3);\n    var right = widgetState.getPlanes()[planeNameToViewType[inPlaneName]].normal;\n    var up = cross(direction, right, []);\n    lineHandle.setRight(right);\n    lineHandle.setUp(up);\n    lineHandle.setDirection(direction);\n  });\n}\n/**\n * First rotate planeToTransform to match targetPlane normal.\n * Then rotate around targetNormal to enforce targetViewUp \"up\" vector (i.e. Origin->p2 ).\n * There is an infinite number of options to rotate a plane normal to another. Here we attempt to\n * preserve Origin, P1 and P2 when rotating around targetPlane.\n * @param {vtkPlaneSource} planeToTransform\n * @param {vec3} targetOrigin Center of the plane\n * @param {vec3} targetNormal Normal to state to the plane\n * @param {vec3} viewType Vector that enforces view up\n */\n\nfunction transformPlane(planeToTransform, targetCenter, targetNormal, targetViewUp) {\n  planeToTransform.setNormal(targetNormal);\n  var viewUp = subtract(planeToTransform.getPoint2(), planeToTransform.getOrigin(), []);\n  var angle = signedAngleBetweenVectors(viewUp, targetViewUp, targetNormal);\n  planeToTransform.rotate(angle, targetNormal);\n  planeToTransform.setCenter(targetCenter);\n}\nexport { boundPlane, boundPoint, boundPointOnPlane, getLineInPlaneName, getLineNames, getLinePlaneName, getOtherLineName, getPlaneNames, getPlanesLineNames, rotateVector, transformPlane, updateState };","map":{"version":3,"names":["_toConsumableArray","vtkBoundingBox","STATIC","vtkCubeSource","vtkCutter","vtkPlane","s","subtract","l","normalize","j","cross","w","multiplyScalar","m","multiplyAccumulate","S","signedAngleBetweenVectors","vtkMatrixBuilder","viewTypeToPlaneName","planeNameToViewType","planeNames","EPSILON","boundPlane","bounds","origin","p1","p2","v1","v2","n","inflatedBounds","eps","concat","addBounds","plane","newInstance","setOrigin","apply","setNormal","cubeSource","setBounds","cutter","setCutFunction","setInputConnection","getOutputPort","cutBounds","getOutputData","getNumberOfPoints","localBounds","computeLocalBounds","getPoints","i","boundPoint","inPoint","absT1","map","val","Math","abs","absT2","o1","o2","axisOffset","useT1","t","absT","outPoint","boundPointOnPlane","dir12","out","tolerance","intersectBox","rotateVector","vectorToBeRotated","axis","angle","rotatedVector","buildFromRadian","rotate","getPlaneNames","widgetState","Object","keys","getPlanes","viewType","getLinePlaneName","lineName","getLineInPlaneName","getPlanesLineNames","planes","arguments","length","undefined","lines","forEach","inPlane","push","getLineNames","getOtherLineName","linePlaneName","lineInPlaneName","otherLineName","find","planeName","computeRotationHandleOriginOffset","rotationHandlePosition","volumeDiagonalLength","scaleInPixels","updateState","axes","reduce","res","filter","otherPlane","cross$1","normal","getImage","getBounds","center","getCenter","pdLength","getDiagonalLength","getCenterHandle","_widgetState$$getMani","_widgetState$$getMani2","_widgetState$$getMani3","_widgetState$$getMani4","_lineHandle$getManipu","_lineHandle$getManipu2","inPlaneName","direction","getManipulator","setHandleOrigin","setHandleNormal","setOffset","lineHandle","scale","scale3","getScale3","setScale3","right","up","setRight","setUp","setDirection","transformPlane","planeToTransform","targetCenter","targetNormal","targetViewUp","viewUp","getPoint2","getOrigin","setCenter"],"sources":["/home/rakshith/Documents/RemoteRendering/vtk-js-react-app/node_modules/@kitware/vtk.js/Widgets/Widgets3D/ResliceCursorWidget/helpers.js"],"sourcesContent":["import _toConsumableArray from '@babel/runtime/helpers/toConsumableArray';\nimport vtkBoundingBox, { STATIC } from '../../../Common/DataModel/BoundingBox.js';\nimport vtkCubeSource from '../../../Filters/Sources/CubeSource.js';\nimport vtkCutter from '../../../Filters/Core/Cutter.js';\nimport vtkPlane from '../../../Common/DataModel/Plane.js';\nimport { s as subtract, l as normalize, j as cross, w as multiplyScalar, m as multiplyAccumulate, S as signedAngleBetweenVectors } from '../../../Common/Core/Math/index.js';\nimport vtkMatrixBuilder from '../../../Common/Core/MatrixBuilder.js';\nimport { viewTypeToPlaneName, planeNameToViewType, planeNames } from './Constants.js';\n\nvar EPSILON = 10e-7;\n/**\n * Fit the plane defined by origin, p1, p2 onto the bounds.\n * Plane is untouched if does not intersect bounds.\n * @param {Array} bounds\n * @param {Array} origin\n * @param {Array} p1\n * @param {Array} p2\n * @return {Boolean} false if no bounds have been found, else true\n */\n\nfunction boundPlane(bounds, origin, p1, p2) {\n  var v1 = [];\n  subtract(p1, origin, v1);\n  normalize(v1);\n  var v2 = [];\n  subtract(p2, origin, v2);\n  normalize(v2);\n  var n = [0, 0, 1];\n  cross(v1, v2, n);\n  normalize(n); // Inflate bounds in order to avoid precision error when cutting cubesource\n\n  var inflatedBounds = _toConsumableArray(bounds);\n\n  var eps = [].concat(n);\n  multiplyScalar(eps, EPSILON);\n  vtkBoundingBox.addBounds(inflatedBounds, bounds[0] + eps[0], bounds[1] + eps[0], bounds[2] + eps[1], bounds[3] + eps[1], bounds[4] + eps[2], bounds[5] + eps[2]);\n  vtkBoundingBox.addBounds(inflatedBounds, bounds[0] - eps[0], bounds[1] - eps[0], bounds[2] - eps[1], bounds[3] - eps[1], bounds[4] - eps[2], bounds[5] - eps[2]);\n  var plane = vtkPlane.newInstance();\n  plane.setOrigin.apply(plane, _toConsumableArray(origin));\n  plane.setNormal.apply(plane, n);\n  var cubeSource = vtkCubeSource.newInstance();\n  cubeSource.setBounds(inflatedBounds);\n  var cutter = vtkCutter.newInstance();\n  cutter.setCutFunction(plane);\n  cutter.setInputConnection(cubeSource.getOutputPort());\n  var cutBounds = cutter.getOutputData();\n\n  if (cutBounds.getNumberOfPoints() === 0) {\n    return false;\n  }\n\n  var localBounds = STATIC.computeLocalBounds(cutBounds.getPoints(), v1, v2, n);\n\n  for (var i = 0; i < 3; i += 1) {\n    origin[i] = localBounds[0] * v1[i] + localBounds[2] * v2[i] + localBounds[4] * n[i];\n    p1[i] = localBounds[1] * v1[i] + localBounds[2] * v2[i] + localBounds[4] * n[i];\n    p2[i] = localBounds[0] * v1[i] + localBounds[3] * v2[i] + localBounds[4] * n[i];\n  }\n\n  return true;\n} // Project point (inPoint) to the bounds of the image according to a plane\n// defined by two vectors (v1, v2)\n\nfunction boundPoint(inPoint, v1, v2, bounds) {\n  var absT1 = v1.map(function (val) {\n    return Math.abs(val);\n  });\n  var absT2 = v2.map(function (val) {\n    return Math.abs(val);\n  });\n  var o1 = 0.0;\n  var o2 = 0.0;\n\n  for (var i = 0; i < 3; i++) {\n    var axisOffset = 0;\n    var useT1 = absT1[i] > absT2[i];\n    var t = useT1 ? v1 : v2;\n    var absT = useT1 ? absT1 : absT2;\n\n    if (inPoint[i] < bounds[i * 2]) {\n      axisOffset = absT[i] > EPSILON ? (bounds[2 * i] - inPoint[i]) / t[i] : 0;\n    } else if (inPoint[i] > bounds[2 * i + 1]) {\n      axisOffset = absT[i] > EPSILON ? (bounds[2 * i + 1] - inPoint[i]) / t[i] : 0;\n    }\n\n    if (useT1) {\n      if (Math.abs(axisOffset) > Math.abs(o1)) {\n        o1 = axisOffset;\n      }\n    } else if (Math.abs(axisOffset) > Math.abs(o2)) {\n      o2 = axisOffset;\n    }\n  }\n\n  var outPoint = [inPoint[0], inPoint[1], inPoint[2]];\n\n  if (o1 !== 0.0) {\n    multiplyAccumulate(outPoint, v1, o1, outPoint);\n  }\n\n  if (o2 !== 0.0) {\n    multiplyAccumulate(outPoint, v2, o2, outPoint);\n  }\n\n  return outPoint;\n} // Compute the intersection between p1 and p2 on bounds\n\nfunction boundPointOnPlane(p1, p2, bounds) {\n  var dir12 = [0, 0, 0];\n  subtract(p2, p1, dir12);\n  var out = [0, 0, 0];\n  var tolerance = [0, 0, 0];\n  vtkBoundingBox.intersectBox(bounds, p1, dir12, out, tolerance);\n  return out;\n}\n/**\n * Rotates a vector around another.\n * @param {vec3} vectorToBeRotated Vector to rate\n * @param {vec3} axis Axis to rotate around\n * @param {Number} angle Angle in radian\n * @returns The rotated vector\n */\n\nfunction rotateVector(vectorToBeRotated, axis, angle) {\n  var rotatedVector = _toConsumableArray(vectorToBeRotated);\n\n  vtkMatrixBuilder.buildFromRadian().rotate(angle, axis).apply(rotatedVector);\n  return rotatedVector;\n}\n/**\n * Return ['X', 'Y'] if there are only 2 planes defined in the widget state.\n * Return ['X', 'Y', 'Z'] if there are 3 planes defined in the widget state.\n * @param {object} widgetState the state of the widget\n * @returns An array of plane names\n */\n\nfunction getPlaneNames(widgetState) {\n  return Object.keys(widgetState.getPlanes()).map(function (viewType) {\n    return viewTypeToPlaneName[viewType];\n  });\n}\n/**\n * Return X if lineName == XinY|XinZ, Y if lineName == YinX|YinZ and Z otherwise\n * @param {string} lineName name of the line (YinX, ZinX, XinY, ZinY, XinZ, YinZ)\n */\n\nfunction getLinePlaneName(lineName) {\n  return lineName[0];\n}\n/**\n * Return X if lineName == YinX|ZinX, Y if lineName == XinY|ZinY and Z otherwise\n * @param {string} lineName name of the line (YinX, ZinX, XinY, ZinY, XinZ, YinZ)\n */\n\nfunction getLineInPlaneName(lineName) {\n  return lineName[3];\n}\n/**\n * Returns ['XinY', 'YinX'] if planes == ['X', 'Y']\n * ['XinY', 'XinZ', 'YinX', 'YinZ', 'ZinX', 'ZinY'] if planes == ['X', 'Y', 'Z']\n * @param {string} planes name of the planes (e.g. ['X', 'Y'])\n */\n\nfunction getPlanesLineNames() {\n  var planes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : planeNames;\n  var lines = [];\n  planes.forEach(function (plane) {\n    planes.forEach(function (inPlane) {\n      if (plane !== inPlane) {\n        lines.push(\"\".concat(plane, \"in\").concat(inPlane));\n      }\n    });\n  });\n  return lines;\n}\nfunction getLineNames(widgetState) {\n  var planes = Object.keys(widgetState.getPlanes()).map(function (viewType) {\n    return viewTypeToPlaneName[viewType];\n  });\n  return getPlanesLineNames(planes);\n}\n/**\n * Return ZinX if lineName == YinX, YinX if lineName == ZinX, ZinY if lineName == XinY...\n * @param {string} lineName name of the line (YinX, ZinX, XinY, ZinY, XinZ, YinZ)\n */\n\nfunction getOtherLineName(widgetState, lineName) {\n  var linePlaneName = getLinePlaneName(lineName);\n  var lineInPlaneName = getLineInPlaneName(lineName);\n  var otherLineName = getPlaneNames(widgetState).find(function (planeName) {\n    return planeName !== linePlaneName && planeName !== lineInPlaneName;\n  });\n  return \"\".concat(otherLineName, \"in\").concat(lineInPlaneName);\n} // Compute the offset of the rotation handle origin\n\nfunction computeRotationHandleOriginOffset(axis, rotationHandlePosition, volumeDiagonalLength, scaleInPixels) {\n  // FIXME: p1 and p2 could be placed on the exact boundaries of the volume.\n  return multiplyScalar(_toConsumableArray(axis), rotationHandlePosition * (scaleInPixels ? 1 : volumeDiagonalLength) / 2);\n} // Update the reslice cursor state according to the three planes normals and the origin\n\n\nfunction updateState(widgetState, scaleInPixels, rotationHandlePosition) {\n  var planes = Object.keys(widgetState.getPlanes()).map(function (viewType) {\n    return viewTypeToPlaneName[viewType];\n  }); // Generates an object as such:\n  // axes = {'XY': cross(X, Y), 'YX': cross(X, Y), 'YZ': cross(Y, Z)...}\n\n  var axes = planes.reduce(function (res, plane) {\n    planes.filter(function (otherPlane) {\n      return plane !== otherPlane;\n    }).forEach(function (otherPlane) {\n      var cross$1 = cross(widgetState.getPlanes()[planeNameToViewType[plane]].normal, widgetState.getPlanes()[planeNameToViewType[otherPlane]].normal, []);\n      res[\"\".concat(plane).concat(otherPlane)] = cross$1;\n      res[\"\".concat(otherPlane).concat(plane)] = cross$1;\n    });\n    return res;\n  }, {});\n  var bounds = widgetState.getImage().getBounds();\n  var center = widgetState.getCenter(); // Length of the principal diagonal.\n\n  var pdLength = vtkBoundingBox.getDiagonalLength(bounds);\n  widgetState.getCenterHandle().setOrigin(center);\n  getPlanesLineNames(planes).forEach(function (lineName) {\n    var _widgetState$$getMani, _widgetState$$getMani2, _widgetState$$getMani3, _widgetState$$getMani4, _lineHandle$getManipu, _lineHandle$getManipu2;\n\n    var planeName = getLinePlaneName(lineName);\n    var inPlaneName = getLineInPlaneName(lineName);\n    var direction = axes[\"\".concat(planeName).concat(inPlaneName)];\n    widgetState[\"getRotationHandle\".concat(lineName, \"0\")]().setOrigin(center);\n    (_widgetState$$getMani = widgetState[\"getRotationHandle\".concat(lineName, \"0\")]().getManipulator()) === null || _widgetState$$getMani === void 0 ? void 0 : _widgetState$$getMani.setHandleOrigin(center);\n    (_widgetState$$getMani2 = widgetState[\"getRotationHandle\".concat(lineName, \"0\")]().getManipulator()) === null || _widgetState$$getMani2 === void 0 ? void 0 : _widgetState$$getMani2.setHandleNormal(widgetState.getPlanes()[planeNameToViewType[planeName]].normal);\n    widgetState[\"getRotationHandle\".concat(lineName, \"0\")]().setOffset(computeRotationHandleOriginOffset(direction, rotationHandlePosition, pdLength, scaleInPixels));\n    widgetState[\"getRotationHandle\".concat(lineName, \"1\")]().setOrigin(center);\n    (_widgetState$$getMani3 = widgetState[\"getRotationHandle\".concat(lineName, \"1\")]().getManipulator()) === null || _widgetState$$getMani3 === void 0 ? void 0 : _widgetState$$getMani3.setHandleOrigin(center);\n    (_widgetState$$getMani4 = widgetState[\"getRotationHandle\".concat(lineName, \"1\")]().getManipulator()) === null || _widgetState$$getMani4 === void 0 ? void 0 : _widgetState$$getMani4.setHandleNormal(widgetState.getPlanes()[planeNameToViewType[planeName]].normal);\n    widgetState[\"getRotationHandle\".concat(lineName, \"1\")]().setOffset(computeRotationHandleOriginOffset(direction, -rotationHandlePosition, pdLength, scaleInPixels));\n    var lineHandle = widgetState[\"getAxis\".concat(lineName)]();\n    lineHandle.setOrigin(center);\n    (_lineHandle$getManipu = lineHandle.getManipulator()) === null || _lineHandle$getManipu === void 0 ? void 0 : _lineHandle$getManipu.setHandleOrigin(center);\n    (_lineHandle$getManipu2 = lineHandle.getManipulator()) === null || _lineHandle$getManipu2 === void 0 ? void 0 : _lineHandle$getManipu2.setHandleNormal(widgetState.getPlanes()[planeNameToViewType[planeName]].normal);\n    var scale = normalize(direction);\n    var scale3 = lineHandle.getScale3();\n    scale3[2] = 2 * scale;\n    lineHandle.setScale3(scale3);\n    var right = widgetState.getPlanes()[planeNameToViewType[inPlaneName]].normal;\n    var up = cross(direction, right, []);\n    lineHandle.setRight(right);\n    lineHandle.setUp(up);\n    lineHandle.setDirection(direction);\n  });\n}\n/**\n * First rotate planeToTransform to match targetPlane normal.\n * Then rotate around targetNormal to enforce targetViewUp \"up\" vector (i.e. Origin->p2 ).\n * There is an infinite number of options to rotate a plane normal to another. Here we attempt to\n * preserve Origin, P1 and P2 when rotating around targetPlane.\n * @param {vtkPlaneSource} planeToTransform\n * @param {vec3} targetOrigin Center of the plane\n * @param {vec3} targetNormal Normal to state to the plane\n * @param {vec3} viewType Vector that enforces view up\n */\n\nfunction transformPlane(planeToTransform, targetCenter, targetNormal, targetViewUp) {\n  planeToTransform.setNormal(targetNormal);\n  var viewUp = subtract(planeToTransform.getPoint2(), planeToTransform.getOrigin(), []);\n  var angle = signedAngleBetweenVectors(viewUp, targetViewUp, targetNormal);\n  planeToTransform.rotate(angle, targetNormal);\n  planeToTransform.setCenter(targetCenter);\n}\n\nexport { boundPlane, boundPoint, boundPointOnPlane, getLineInPlaneName, getLineNames, getLinePlaneName, getOtherLineName, getPlaneNames, getPlanesLineNames, rotateVector, transformPlane, updateState };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}