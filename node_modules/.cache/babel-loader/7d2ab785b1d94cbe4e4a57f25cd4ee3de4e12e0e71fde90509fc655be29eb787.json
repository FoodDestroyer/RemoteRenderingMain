{"ast":null,"code":"import macro from '../../macros.js';\n\n// Global methods\n// ----------------------------------------------------------------------------\n// ----------------------------------------------------------------------------\n// vtkImagePointDataIterator methods\n// ----------------------------------------------------------------------------\n\nfunction vtkImagePointDataIterator(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkImagePointDataIterator');\n  publicAPI.initialize = function (image, inExtent, stencil, algorithm) {\n    var dataExtent = image.getExtent();\n    var extent = inExtent;\n    if (extent == null) {\n      extent = dataExtent;\n    }\n    var emptyExtent = false;\n    for (var i = 0; i < 6; i += 2) {\n      model.extent[i] = Math.max(extent[i], dataExtent[i]);\n      model.extent[i + 1] = Math.min(extent[i + 1], dataExtent[i + 1]);\n      if (model.extent[i] > model.extent[i + 1]) {\n        emptyExtent = true;\n      }\n    }\n    model.rowIncrement = dataExtent[1] - dataExtent[0] + 1;\n    model.sliceIncrement = model.rowIncrement * (dataExtent[3] - dataExtent[2] + 1);\n    var rowSpan;\n    var sliceSpan;\n    var volumeSpan;\n    if (!emptyExtent) {\n      // Compute the span of the image region to be covered.\n      rowSpan = model.extent[1] - model.extent[0] + 1;\n      sliceSpan = model.extent[3] - model.extent[2] + 1;\n      volumeSpan = model.extent[5] - model.extent[4] + 1;\n      model.id = model.extent[0] - dataExtent[0] + (model.extent[2] - dataExtent[2]) * model.rowIncrement + (model.extent[4] - dataExtent[4]) * model.sliceIncrement; // Compute the end increments (continuous increments).\n\n      model.rowEndIncrement = model.rowIncrement - rowSpan;\n      model.sliceEndIncrement = model.rowEndIncrement + model.sliceIncrement - model.rowIncrement * sliceSpan;\n    } else {\n      // Extent is empty, isAtEnd() will immediately return \"true\"\n      rowSpan = 0;\n      sliceSpan = 0;\n      volumeSpan = 0;\n      model.id = 0;\n      model.rowEndIncrement = 0;\n      model.sliceEndIncrement = 0;\n      for (var _i = 0; _i < 6; _i += 2) {\n        model.extent[_i] = dataExtent[_i];\n        model.extent[_i + 1] = dataExtent[_i] - 1;\n      }\n    } // Get the end pointers for row, slice, and volume.\n\n    model.spanEnd = model.id + rowSpan;\n    model.rowEnd = model.id + rowSpan;\n    model.sliceEnd = model.id + (model.rowIncrement * sliceSpan - model.rowEndIncrement);\n    model.end = model.id + (model.sliceIncrement * volumeSpan - model.sliceEndIncrement); // For keeping track of the current x,y,z index.\n\n    model.index[0] = model.extent[0];\n    model.index[1] = model.extent[2];\n    model.index[2] = model.extent[4]; // For resetting the Y index after each slice.\n\n    model.startY = model.index[1]; // Code for when a stencil is provided.\n\n    if (stencil) {\n      model.hasStencil = true;\n      model.inStencil = false;\n      model.spanIndex = 0;\n      var stencilExtent = stencil.getExtent(); // The stencil has a YZ array of span lists, we need increments\n      // to get to the next Z position in the YZ array.\n\n      model.spanSliceIncrement = 0;\n      model.spanSliceEndIncrement = 0;\n      if (stencilExtent[3] >= stencilExtent[2] && stencilExtent[5] >= stencilExtent[4]) {\n        model.spanSliceIncrement = stencilExtent[3] - stencilExtent[2] + 1;\n        var botOffset = model.extent[2] - stencilExtent[2];\n        if (botOffset >= 0) {\n          model.spanSliceEndIncrement += botOffset;\n        }\n        var topOffset = stencilExtent[3] - model.extent[3];\n        if (topOffset >= 0) {\n          model.spanSliceEndIncrement += topOffset;\n        }\n      } // Find the offset to the start position within the YZ array.\n\n      var startOffset = 0;\n      var yOffset = model.extent[2] - stencilExtent[2];\n      if (yOffset < 0) {\n        model.extent[2] = stencilExtent[2]; // starting before start of stencil: subtract the increment that\n        // will be added in NextSpan() upon entry into stencil extent\n\n        startOffset -= 1;\n      } else {\n        // starting partway into the stencil, so add an offset\n        startOffset += yOffset;\n      }\n      if (stencilExtent[3] <= model.extent[3]) {\n        model.extent[3] = stencilExtent[3];\n      }\n      var zOffset = model.extent[4] - stencilExtent[4];\n      if (zOffset < 0) {\n        model.extent[4] = stencilExtent[4]; // starting before start of stencil: subtract the increment that\n        // will be added in NextSpan() upon entry into stencil extent\n\n        if (yOffset >= 0) {\n          startOffset -= 1 + model.spanSliceEndIncrement;\n        }\n      } else {\n        // starting partway into the stencil, so add an offset\n        startOffset += zOffset * model.spanSliceIncrement;\n      }\n      if (stencilExtent[5] <= model.extent[5]) {\n        model.extent[5] = stencilExtent[5];\n      }\n      if (model.extent[2] <= model.extent[3] && model.extent[4] <= model.extent[5]) {\n        model.spanCountPointer = stencil.extentListLengths.subarray(startOffset);\n        model.spanListPointer = stencil.extentLists.subarray(startOffset); // Get the current position within the span list for the current row\n\n        if (yOffset >= 0 && zOffset >= 0) {\n          // If starting within stencil extent, check stencil immediately\n          model.inStencil = true;\n          model.setSpanState(model.extent[0]);\n        }\n      } else {\n        model.spanCountPointer = null;\n        model.spanListPointer = null;\n        model.inStencil = false;\n      }\n    } else {\n      model.hasStencil = false;\n      model.inStencil = true;\n      model.spanSliceEndIncrement = 0;\n      model.spanSliceIncrement = 0;\n      model.spanIndex = 0;\n      model.spanCountPointer = null;\n      model.spanListPointer = null;\n    }\n    if (algorithm) {\n      model.algorithm = algorithm;\n      var maxCount = sliceSpan * volumeSpan;\n      model.target = maxCount / 50 + 1;\n      model.count = model.target * 50 - maxCount / model.target * model.target + 1;\n    } else {\n      model.algorithm = null;\n      model.target = 0;\n      model.count = 0;\n    }\n  };\n  publicAPI.setSpanState = function (idX) {\n    // Find the span that includes idX\n    var inStencil = false;\n    var spans = model.spanListPointer;\n    var n = model.spanCountPointer[0];\n    var i;\n    for (i = 0; i < n; ++i) {\n      if (spans[i] > idX) {\n        break;\n      }\n      inStencil = !inStencil;\n    } // Set the primary span state variables\n\n    model.spanIndex = i;\n    model.inStencil = inStencil; // Clamp the span end to MaxX+1\n\n    var endIdX = model.extent[1] + 1;\n    if (i < n && spans[i] <= model.extent[1]) {\n      endIdX = spans[i];\n    } // Compute the pointers for idX and endIdX\n\n    var rowStart = model.rowEnd - (model.rowIncrement - model.rowEndIncrement);\n    model.id = rowStart + (idX - model.extent[0]);\n    model.spanEnd = rowStart + (endIdX - model.extent[0]);\n  };\n  publicAPI.nextSpan = function () {\n    if (model.spanEnd === model.rowEnd) {\n      var spanIncr = 1;\n      if (model.spanEnd !== model.sliceEnd) {\n        // Move to the next row\n        model.id = model.rowEnd + model.rowEndIncrement;\n        model.rowEnd += model.rowIncrement;\n        model.spanEnd = model.rowEnd;\n        model.index[1]++;\n      } else if (model.spanEnd !== model.end) {\n        // Move to the next slice\n        model.id = model.sliceEnd + model.sliceEndIncrement;\n        model.sliceEnd += model.sliceIncrement;\n        model.rowEnd = model.id + (model.rowIncrement - model.rowEndIncrement);\n        model.spanEnd = model.rowEnd;\n        model.index[1] = model.startY;\n        model.index[2]++;\n        spanIncr += model.spanSliceEndIncrement;\n      } else {\n        // reached End\n        model.id = model.end;\n        return;\n      } // Start of next row\n\n      model.index[0] = model.extent[0];\n      if (model.hasStencil) {\n        if (model.index[1] >= model.extent[2] && model.index[1] <= model.extent[3] && model.index[2] >= model.extent[4] && model.index[2] <= model.extent[5]) {\n          model.spanCountPointer = model.spanCountPointer.subarray(spanIncr);\n          model.spanListPointer = model.spanListPointer.subarray(spanIncr);\n          publicAPI.setSpanState(model.extent[0]);\n        } else {\n          model.inStencil = false;\n        }\n      }\n      if (model.algorithm) {\n        publicAPI.reportProgress();\n      }\n    } else {\n      // Move to the next span in the current row\n      model.id = model.spanEnd;\n      var spanCount = model.spanCountPointer[0];\n      var endIdX = model.extent[1] + 1;\n      model.index[0] = endIdX;\n      if (model.spanIndex < spanCount) {\n        var tmpIdX = model.spanListPointer[model.spanIndex];\n        if (tmpIdX < endIdX) {\n          model.index[0] = tmpIdX;\n        }\n      } // Get the index to the start of the span after the next\n\n      model.spanIndex++;\n      if (model.spanIndex < spanCount) {\n        var _tmpIdX = model.spanListPointer[model.spanIndex];\n        if (_tmpIdX < endIdX) {\n          endIdX = _tmpIdX;\n        }\n      } // Compute the end of the span\n\n      model.spanEnd = model.rowEnd - (model.rowIncrement - model.rowEndIncrement) + (endIdX - model.extent[0]); // Flip the state\n\n      model.inStencil = !model.inStencil;\n    }\n  };\n  publicAPI.isAtEnd = function () {\n    return model.id === model.end;\n  };\n  publicAPI.isInStencil = function () {\n    return model.inStencil;\n  };\n  publicAPI.spanEndId = function () {\n    return model.spanEnd;\n  };\n  publicAPI.reportProgress = function () {};\n  publicAPI.getArray = function (array, i) {\n    return array.getData().subarray(i * array.getNumberOfComponents());\n  };\n  publicAPI.getScalars = function (image) {\n    var i = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    return publicAPI.getArray(image.getPointData().getScalars(), i);\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nvar DEFAULT_VALUES = {\n  spanState: 0,\n  extent: [0, -1, 0, -1, 0, -1],\n  end: 0,\n  spanEnd: 0,\n  rowEnd: 0,\n  sliceEnd: 0,\n  rowIncrement: 0,\n  rowEndIncrement: 0,\n  sliceIncrement: 0,\n  sliceEndIncrement: 0,\n  id: 0,\n  index: [0, 0, 0],\n  startY: 0,\n  hasStencil: false,\n  inStencil: true,\n  spanIndex: 0,\n  spanSliceIncrement: 0,\n  spanSliceEndIncrement: 0,\n  spanCountPointer: null,\n  spanListPointer: null,\n  algorithm: null,\n  target: 0,\n  count: 0\n}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Object methods\n\n  macro.obj(publicAPI, model);\n  macro.get(publicAPI, model, ['id', 'index']); // Object specific methods\n\n  vtkImagePointDataIterator(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = macro.newInstance(extend, 'vtkImagePointDataIterator'); // ----------------------------------------------------------------------------\n\nvar vtkImagePointDataIterator$1 = {\n  newInstance: newInstance,\n  extend: extend\n};\nexport { vtkImagePointDataIterator$1 as default, extend, newInstance };","map":{"version":3,"names":["macro","vtkImagePointDataIterator","publicAPI","model","classHierarchy","push","initialize","image","inExtent","stencil","algorithm","dataExtent","getExtent","extent","emptyExtent","i","Math","max","min","rowIncrement","sliceIncrement","rowSpan","sliceSpan","volumeSpan","id","rowEndIncrement","sliceEndIncrement","_i","spanEnd","rowEnd","sliceEnd","end","index","startY","hasStencil","inStencil","spanIndex","stencilExtent","spanSliceIncrement","spanSliceEndIncrement","botOffset","topOffset","startOffset","yOffset","zOffset","spanCountPointer","extentListLengths","subarray","spanListPointer","extentLists","setSpanState","maxCount","target","count","idX","spans","n","endIdX","rowStart","nextSpan","spanIncr","reportProgress","spanCount","tmpIdX","_tmpIdX","isAtEnd","isInStencil","spanEndId","getArray","array","getData","getNumberOfComponents","getScalars","arguments","length","undefined","getPointData","DEFAULT_VALUES","spanState","extend","initialValues","Object","assign","obj","get","newInstance","vtkImagePointDataIterator$1","default"],"sources":["/home/rakshith/Documents/RemoteRendering/vtk-js-react-app/node_modules/@kitware/vtk.js/Imaging/Core/ImagePointDataIterator.js"],"sourcesContent":["import macro from '../../macros.js';\n\n// Global methods\n// ----------------------------------------------------------------------------\n// ----------------------------------------------------------------------------\n// vtkImagePointDataIterator methods\n// ----------------------------------------------------------------------------\n\nfunction vtkImagePointDataIterator(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkImagePointDataIterator');\n\n  publicAPI.initialize = function (image, inExtent, stencil, algorithm) {\n    var dataExtent = image.getExtent();\n    var extent = inExtent;\n\n    if (extent == null) {\n      extent = dataExtent;\n    }\n\n    var emptyExtent = false;\n\n    for (var i = 0; i < 6; i += 2) {\n      model.extent[i] = Math.max(extent[i], dataExtent[i]);\n      model.extent[i + 1] = Math.min(extent[i + 1], dataExtent[i + 1]);\n\n      if (model.extent[i] > model.extent[i + 1]) {\n        emptyExtent = true;\n      }\n    }\n\n    model.rowIncrement = dataExtent[1] - dataExtent[0] + 1;\n    model.sliceIncrement = model.rowIncrement * (dataExtent[3] - dataExtent[2] + 1);\n    var rowSpan;\n    var sliceSpan;\n    var volumeSpan;\n\n    if (!emptyExtent) {\n      // Compute the span of the image region to be covered.\n      rowSpan = model.extent[1] - model.extent[0] + 1;\n      sliceSpan = model.extent[3] - model.extent[2] + 1;\n      volumeSpan = model.extent[5] - model.extent[4] + 1;\n      model.id = model.extent[0] - dataExtent[0] + (model.extent[2] - dataExtent[2]) * model.rowIncrement + (model.extent[4] - dataExtent[4]) * model.sliceIncrement; // Compute the end increments (continuous increments).\n\n      model.rowEndIncrement = model.rowIncrement - rowSpan;\n      model.sliceEndIncrement = model.rowEndIncrement + model.sliceIncrement - model.rowIncrement * sliceSpan;\n    } else {\n      // Extent is empty, isAtEnd() will immediately return \"true\"\n      rowSpan = 0;\n      sliceSpan = 0;\n      volumeSpan = 0;\n      model.id = 0;\n      model.rowEndIncrement = 0;\n      model.sliceEndIncrement = 0;\n\n      for (var _i = 0; _i < 6; _i += 2) {\n        model.extent[_i] = dataExtent[_i];\n        model.extent[_i + 1] = dataExtent[_i] - 1;\n      }\n    } // Get the end pointers for row, slice, and volume.\n\n\n    model.spanEnd = model.id + rowSpan;\n    model.rowEnd = model.id + rowSpan;\n    model.sliceEnd = model.id + (model.rowIncrement * sliceSpan - model.rowEndIncrement);\n    model.end = model.id + (model.sliceIncrement * volumeSpan - model.sliceEndIncrement); // For keeping track of the current x,y,z index.\n\n    model.index[0] = model.extent[0];\n    model.index[1] = model.extent[2];\n    model.index[2] = model.extent[4]; // For resetting the Y index after each slice.\n\n    model.startY = model.index[1]; // Code for when a stencil is provided.\n\n    if (stencil) {\n      model.hasStencil = true;\n      model.inStencil = false;\n      model.spanIndex = 0;\n      var stencilExtent = stencil.getExtent(); // The stencil has a YZ array of span lists, we need increments\n      // to get to the next Z position in the YZ array.\n\n      model.spanSliceIncrement = 0;\n      model.spanSliceEndIncrement = 0;\n\n      if (stencilExtent[3] >= stencilExtent[2] && stencilExtent[5] >= stencilExtent[4]) {\n        model.spanSliceIncrement = stencilExtent[3] - stencilExtent[2] + 1;\n        var botOffset = model.extent[2] - stencilExtent[2];\n\n        if (botOffset >= 0) {\n          model.spanSliceEndIncrement += botOffset;\n        }\n\n        var topOffset = stencilExtent[3] - model.extent[3];\n\n        if (topOffset >= 0) {\n          model.spanSliceEndIncrement += topOffset;\n        }\n      } // Find the offset to the start position within the YZ array.\n\n\n      var startOffset = 0;\n      var yOffset = model.extent[2] - stencilExtent[2];\n\n      if (yOffset < 0) {\n        model.extent[2] = stencilExtent[2]; // starting before start of stencil: subtract the increment that\n        // will be added in NextSpan() upon entry into stencil extent\n\n        startOffset -= 1;\n      } else {\n        // starting partway into the stencil, so add an offset\n        startOffset += yOffset;\n      }\n\n      if (stencilExtent[3] <= model.extent[3]) {\n        model.extent[3] = stencilExtent[3];\n      }\n\n      var zOffset = model.extent[4] - stencilExtent[4];\n\n      if (zOffset < 0) {\n        model.extent[4] = stencilExtent[4]; // starting before start of stencil: subtract the increment that\n        // will be added in NextSpan() upon entry into stencil extent\n\n        if (yOffset >= 0) {\n          startOffset -= 1 + model.spanSliceEndIncrement;\n        }\n      } else {\n        // starting partway into the stencil, so add an offset\n        startOffset += zOffset * model.spanSliceIncrement;\n      }\n\n      if (stencilExtent[5] <= model.extent[5]) {\n        model.extent[5] = stencilExtent[5];\n      }\n\n      if (model.extent[2] <= model.extent[3] && model.extent[4] <= model.extent[5]) {\n        model.spanCountPointer = stencil.extentListLengths.subarray(startOffset);\n        model.spanListPointer = stencil.extentLists.subarray(startOffset); // Get the current position within the span list for the current row\n\n        if (yOffset >= 0 && zOffset >= 0) {\n          // If starting within stencil extent, check stencil immediately\n          model.inStencil = true;\n          model.setSpanState(model.extent[0]);\n        }\n      } else {\n        model.spanCountPointer = null;\n        model.spanListPointer = null;\n        model.inStencil = false;\n      }\n    } else {\n      model.hasStencil = false;\n      model.inStencil = true;\n      model.spanSliceEndIncrement = 0;\n      model.spanSliceIncrement = 0;\n      model.spanIndex = 0;\n      model.spanCountPointer = null;\n      model.spanListPointer = null;\n    }\n\n    if (algorithm) {\n      model.algorithm = algorithm;\n      var maxCount = sliceSpan * volumeSpan;\n      model.target = maxCount / 50 + 1;\n      model.count = model.target * 50 - maxCount / model.target * model.target + 1;\n    } else {\n      model.algorithm = null;\n      model.target = 0;\n      model.count = 0;\n    }\n  };\n\n  publicAPI.setSpanState = function (idX) {\n    // Find the span that includes idX\n    var inStencil = false;\n    var spans = model.spanListPointer;\n    var n = model.spanCountPointer[0];\n    var i;\n\n    for (i = 0; i < n; ++i) {\n      if (spans[i] > idX) {\n        break;\n      }\n\n      inStencil = !inStencil;\n    } // Set the primary span state variables\n\n\n    model.spanIndex = i;\n    model.inStencil = inStencil; // Clamp the span end to MaxX+1\n\n    var endIdX = model.extent[1] + 1;\n\n    if (i < n && spans[i] <= model.extent[1]) {\n      endIdX = spans[i];\n    } // Compute the pointers for idX and endIdX\n\n\n    var rowStart = model.rowEnd - (model.rowIncrement - model.rowEndIncrement);\n    model.id = rowStart + (idX - model.extent[0]);\n    model.spanEnd = rowStart + (endIdX - model.extent[0]);\n  };\n\n  publicAPI.nextSpan = function () {\n    if (model.spanEnd === model.rowEnd) {\n      var spanIncr = 1;\n\n      if (model.spanEnd !== model.sliceEnd) {\n        // Move to the next row\n        model.id = model.rowEnd + model.rowEndIncrement;\n        model.rowEnd += model.rowIncrement;\n        model.spanEnd = model.rowEnd;\n        model.index[1]++;\n      } else if (model.spanEnd !== model.end) {\n        // Move to the next slice\n        model.id = model.sliceEnd + model.sliceEndIncrement;\n        model.sliceEnd += model.sliceIncrement;\n        model.rowEnd = model.id + (model.rowIncrement - model.rowEndIncrement);\n        model.spanEnd = model.rowEnd;\n        model.index[1] = model.startY;\n        model.index[2]++;\n        spanIncr += model.spanSliceEndIncrement;\n      } else {\n        // reached End\n        model.id = model.end;\n        return;\n      } // Start of next row\n\n\n      model.index[0] = model.extent[0];\n\n      if (model.hasStencil) {\n        if (model.index[1] >= model.extent[2] && model.index[1] <= model.extent[3] && model.index[2] >= model.extent[4] && model.index[2] <= model.extent[5]) {\n          model.spanCountPointer = model.spanCountPointer.subarray(spanIncr);\n          model.spanListPointer = model.spanListPointer.subarray(spanIncr);\n          publicAPI.setSpanState(model.extent[0]);\n        } else {\n          model.inStencil = false;\n        }\n      }\n\n      if (model.algorithm) {\n        publicAPI.reportProgress();\n      }\n    } else {\n      // Move to the next span in the current row\n      model.id = model.spanEnd;\n      var spanCount = model.spanCountPointer[0];\n      var endIdX = model.extent[1] + 1;\n      model.index[0] = endIdX;\n\n      if (model.spanIndex < spanCount) {\n        var tmpIdX = model.spanListPointer[model.spanIndex];\n\n        if (tmpIdX < endIdX) {\n          model.index[0] = tmpIdX;\n        }\n      } // Get the index to the start of the span after the next\n\n\n      model.spanIndex++;\n\n      if (model.spanIndex < spanCount) {\n        var _tmpIdX = model.spanListPointer[model.spanIndex];\n\n        if (_tmpIdX < endIdX) {\n          endIdX = _tmpIdX;\n        }\n      } // Compute the end of the span\n\n\n      model.spanEnd = model.rowEnd - (model.rowIncrement - model.rowEndIncrement) + (endIdX - model.extent[0]); // Flip the state\n\n      model.inStencil = !model.inStencil;\n    }\n  };\n\n  publicAPI.isAtEnd = function () {\n    return model.id === model.end;\n  };\n\n  publicAPI.isInStencil = function () {\n    return model.inStencil;\n  };\n\n  publicAPI.spanEndId = function () {\n    return model.spanEnd;\n  };\n\n  publicAPI.reportProgress = function () {};\n\n  publicAPI.getArray = function (array, i) {\n    return array.getData().subarray(i * array.getNumberOfComponents());\n  };\n\n  publicAPI.getScalars = function (image) {\n    var i = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    return publicAPI.getArray(image.getPointData().getScalars(), i);\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\n\nvar DEFAULT_VALUES = {\n  spanState: 0,\n  extent: [0, -1, 0, -1, 0, -1],\n  end: 0,\n  spanEnd: 0,\n  rowEnd: 0,\n  sliceEnd: 0,\n  rowIncrement: 0,\n  rowEndIncrement: 0,\n  sliceIncrement: 0,\n  sliceEndIncrement: 0,\n  id: 0,\n  index: [0, 0, 0],\n  startY: 0,\n  hasStencil: false,\n  inStencil: true,\n  spanIndex: 0,\n  spanSliceIncrement: 0,\n  spanSliceEndIncrement: 0,\n  spanCountPointer: null,\n  spanListPointer: null,\n  algorithm: null,\n  target: 0,\n  count: 0\n}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Object methods\n\n  macro.obj(publicAPI, model);\n  macro.get(publicAPI, model, ['id', 'index']); // Object specific methods\n\n  vtkImagePointDataIterator(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = macro.newInstance(extend, 'vtkImagePointDataIterator'); // ----------------------------------------------------------------------------\n\nvar vtkImagePointDataIterator$1 = {\n  newInstance: newInstance,\n  extend: extend\n};\n\nexport { vtkImagePointDataIterator$1 as default, extend, newInstance };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}