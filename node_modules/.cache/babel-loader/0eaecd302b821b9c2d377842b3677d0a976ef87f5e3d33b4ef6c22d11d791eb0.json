{"ast":null,"code":"import _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport macro from '../../macros.js';\nimport vtkDataArray from './DataArray.js';\nimport vtkScalarsToColors$2 from './ScalarsToColors/Constants.js';\nimport Constants from '../../Rendering/Core/Mapper/Constants.js';\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n  return target;\n}\nvar ScalarMappingTarget = vtkScalarsToColors$2.ScalarMappingTarget,\n  VectorMode = vtkScalarsToColors$2.VectorMode;\nvar VtkDataTypes = vtkDataArray.VtkDataTypes;\nvar ColorMode = Constants.ColorMode;\nvar vtkErrorMacro = macro.vtkErrorMacro; // ----------------------------------------------------------------------------\n// Global methods\n// ----------------------------------------------------------------------------\n// Add module-level functions or api that you want to expose statically via\n// the next section...\n// ----------------------------------------------------------------------------\n// Static API\n// ----------------------------------------------------------------------------\n\nfunction intColorToUChar(c) {\n  return c;\n}\nfunction floatColorToUChar(c) {\n  return Math.floor(c * 255.0 + 0.5);\n} // ----------------------------------------------------------------------------\n// vtkScalarsToColors methods\n// ----------------------------------------------------------------------------\n\nfunction vtkScalarsToColors(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkScalarsToColors');\n  publicAPI.setVectorModeToMagnitude = function () {\n    return publicAPI.setVectorMode(VectorMode.MAGNITUDE);\n  };\n  publicAPI.setVectorModeToComponent = function () {\n    return publicAPI.setVectorMode(VectorMode.COMPONENT);\n  };\n  publicAPI.setVectorModeToRGBColors = function () {\n    return publicAPI.setVectorMode(VectorMode.RGBCOLORS);\n  };\n  publicAPI.build = function () {};\n  publicAPI.isOpaque = function () {\n    return true;\n  }; //----------------------------------------------------------------------------\n\n  publicAPI.setAnnotations = function (values, annotations) {\n    if (values && !annotations || !values && annotations) {\n      return;\n    }\n    if (values && annotations && values.length !== annotations.length) {\n      vtkErrorMacro('Values and annotations do not have the same number of tuples so ignoring');\n      return;\n    }\n    model.annotationArray = [];\n    if (annotations && values) {\n      var num = annotations.length;\n      for (var i = 0; i < num; i++) {\n        model.annotationArray.push({\n          value: values[i],\n          annotation: String(annotations[i])\n        });\n      }\n    }\n    publicAPI.updateAnnotatedValueMap();\n    publicAPI.modified();\n  }; //----------------------------------------------------------------------------\n\n  publicAPI.setAnnotation = function (value, annotation) {\n    var i = publicAPI.checkForAnnotatedValue(value);\n    var modified = false;\n    if (i >= 0) {\n      if (model.annotationArray[i].annotation !== annotation) {\n        model.annotationArray[i].annotation = annotation;\n        modified = true;\n      }\n    } else {\n      model.annotationArray.push({\n        value: value,\n        annotation: annotation\n      });\n      i = model.annotationArray.length - 1;\n      modified = true;\n    }\n    if (modified) {\n      publicAPI.updateAnnotatedValueMap();\n      publicAPI.modified();\n    }\n    return i;\n  }; //----------------------------------------------------------------------------\n\n  publicAPI.getNumberOfAnnotatedValues = function () {\n    return model.annotationArray.length;\n  }; //----------------------------------------------------------------------------\n\n  publicAPI.getAnnotatedValue = function (idx) {\n    if (idx < 0 || idx >= model.annotationArray.length) {\n      return null;\n    }\n    return model.annotationArray[idx].value;\n  }; //----------------------------------------------------------------------------\n\n  publicAPI.getAnnotation = function (idx) {\n    if (model.annotationArray[idx] === undefined) {\n      return null;\n    }\n    return model.annotationArray[idx].annotation;\n  }; //----------------------------------------------------------------------------\n\n  publicAPI.getAnnotatedValueIndex = function (val) {\n    return model.annotationArray.length ? publicAPI.checkForAnnotatedValue(val) : -1;\n  }; //----------------------------------------------------------------------------\n\n  publicAPI.removeAnnotation = function (value) {\n    var i = publicAPI.checkForAnnotatedValue(value);\n    var needToRemove = i >= 0;\n    if (needToRemove) {\n      model.annotationArray.splice(i, 1);\n      publicAPI.updateAnnotatedValueMap();\n      publicAPI.modified();\n    }\n    return needToRemove;\n  }; //----------------------------------------------------------------------------\n\n  publicAPI.resetAnnotations = function () {\n    model.annotationArray = [];\n    model.annotatedValueMap = [];\n    publicAPI.modified();\n  }; //----------------------------------------------------------------------------\n\n  publicAPI.getAnnotationColor = function (val, rgba) {\n    if (model.indexedLookup) {\n      var i = publicAPI.getAnnotatedValueIndex(val);\n      publicAPI.getIndexedColor(i, rgba);\n    } else {\n      publicAPI.getColor(parseFloat(val), rgba);\n      rgba[3] = 1.0;\n    }\n  }; //----------------------------------------------------------------------------\n\n  publicAPI.checkForAnnotatedValue = function (value) {\n    return publicAPI.getAnnotatedValueIndexInternal(value);\n  }; //----------------------------------------------------------------------------\n  // An unsafe version of vtkScalarsToColors::CheckForAnnotatedValue for\n  // internal use (no pointer checks performed)\n\n  publicAPI.getAnnotatedValueIndexInternal = function (value) {\n    if (model.annotatedValueMap[value] !== undefined) {\n      var na = model.annotationArray.length;\n      return model.annotatedValueMap[value] % na;\n    } // Treat as a NaN\n\n    return -1;\n  }; //----------------------------------------------------------------------------\n\n  publicAPI.getIndexedColor = function (val, rgba) {\n    rgba[0] = 0.0;\n    rgba[1] = 0.0;\n    rgba[2] = 0.0;\n    rgba[3] = 0.0;\n  }; //----------------------------------------------------------------------------\n\n  publicAPI.updateAnnotatedValueMap = function () {\n    model.annotatedValueMap = [];\n    var na = model.annotationArray.length;\n    for (var i = 0; i < na; i++) {\n      model.annotatedValueMap[model.annotationArray[i].value] = i;\n    }\n  }; // Description:\n  // Internal methods that map a data array into a 4-component,\n  // unsigned char RGBA array. The color mode determines the behavior\n  // of mapping. If ColorMode.DEFAULT is set, then unsigned char\n  // data arrays are treated as colors (and converted to RGBA if\n  // necessary); If ColorMode.DIRECT_SCALARS is set, then all arrays\n  // are treated as colors (integer types are clamped in the range 0-255,\n  // floating point arrays are clamped in the range 0.0-1.0. Note 'char' does\n  // not have enough values to represent a color so mapping this type is\n  // considered an error);\n  // otherwise, the data is mapped through this instance\n  // of ScalarsToColors. The component argument is used for data\n  // arrays with more than one component; it indicates which component\n  // to use to do the blending.  When the component argument is -1,\n  // then the this object uses its own selected technique to change a\n  // vector into a scalar to map.\n\n  publicAPI.mapScalars = function (scalars, colorMode, componentIn) {\n    var numberOfComponents = scalars.getNumberOfComponents();\n    var newColors = null; // map scalars through lookup table only if needed\n\n    if (colorMode === ColorMode.DEFAULT && scalars.getDataType() === VtkDataTypes.UNSIGNED_CHAR || colorMode === ColorMode.DIRECT_SCALARS && scalars) {\n      newColors = publicAPI.convertToRGBA(scalars, numberOfComponents, scalars.getNumberOfTuples());\n    } else {\n      var newscalars = {\n        type: 'vtkDataArray',\n        name: 'temp',\n        numberOfComponents: 4,\n        dataType: VtkDataTypes.UNSIGNED_CHAR\n      };\n      var s = macro.newTypedArray(newscalars.dataType, 4 * scalars.getNumberOfTuples());\n      newscalars.values = s;\n      newscalars.size = s.length;\n      newColors = vtkDataArray.newInstance(newscalars);\n      var component = componentIn; // If mapper did not specify a component, use the VectorMode\n\n      if (component < 0 && numberOfComponents > 1) {\n        publicAPI.mapVectorsThroughTable(scalars, newColors, ScalarMappingTarget.RGBA, -1, -1);\n      } else {\n        if (component < 0) {\n          component = 0;\n        }\n        if (component >= numberOfComponents) {\n          component = numberOfComponents - 1;\n        } // Map the scalars to colors\n\n        publicAPI.mapScalarsThroughTable(scalars, newColors, ScalarMappingTarget.RGBA, component);\n      }\n    }\n    return newColors;\n  };\n  publicAPI.mapVectorsToMagnitude = function (input, output, compsToUse) {\n    var length = input.getNumberOfTuples();\n    var inIncr = input.getNumberOfComponents();\n    var outputV = output.getData();\n    var inputV = input.getData();\n    for (var i = 0; i < length; i++) {\n      var sum = 0.0;\n      for (var j = 0; j < compsToUse; j++) {\n        sum += inputV[i * inIncr + j] * inputV[i * inIncr + j];\n      }\n      outputV[i] = Math.sqrt(sum);\n    }\n  }; //----------------------------------------------------------------------------\n  // Map a set of vector values through the table\n\n  publicAPI.mapVectorsThroughTable = function (input, output, outputFormat, vectorComponentIn, vectorSizeIn) {\n    var vectorMode = publicAPI.getVectorMode();\n    var vectorSize = vectorSizeIn;\n    var vectorComponent = vectorComponentIn;\n    var inComponents = input.getNumberOfComponents();\n    if (vectorMode === VectorMode.COMPONENT) {\n      // make sure vectorComponent is within allowed range\n      if (vectorComponent === -1) {\n        // if set to -1, use default value provided by table\n        vectorComponent = publicAPI.getVectorComponent();\n      }\n      if (vectorComponent < 0) {\n        vectorComponent = 0;\n      }\n      if (vectorComponent >= inComponents) {\n        vectorComponent = inComponents - 1;\n      }\n    } else {\n      // make sure vectorSize is within allowed range\n      if (vectorSize === -1) {\n        // if set to -1, use default value provided by table\n        vectorSize = publicAPI.getVectorSize();\n      }\n      if (vectorSize <= 0) {\n        vectorComponent = 0;\n        vectorSize = inComponents;\n      } else {\n        if (vectorComponent < 0) {\n          vectorComponent = 0;\n        }\n        if (vectorComponent >= inComponents) {\n          vectorComponent = inComponents - 1;\n        }\n        if (vectorComponent + vectorSize > inComponents) {\n          vectorSize = inComponents - vectorComponent;\n        }\n      }\n      if (vectorMode === VectorMode.MAGNITUDE && (inComponents === 1 || vectorSize === 1)) {\n        vectorMode = VectorMode.COMPONENT;\n      }\n    } // increment input pointer to the first component to map\n\n    var inputOffset = 0;\n    if (vectorComponent > 0) {\n      inputOffset = vectorComponent;\n    } // map according to the current vector mode\n\n    switch (vectorMode) {\n      case VectorMode.COMPONENT:\n        {\n          publicAPI.mapScalarsThroughTable(input, output, outputFormat, inputOffset);\n          break;\n        }\n      case VectorMode.RGBCOLORS:\n        {\n          // publicAPI.mapColorsToColors(\n          //   input, output, inComponents, vectorSize,\n          //   outputFormat);\n          break;\n        }\n      // MAGNITUDE is considered default\n\n      case VectorMode.MAGNITUDE:\n      default:\n        {\n          var magValues = vtkDataArray.newInstance({\n            numberOfComponents: 1,\n            values: new Float32Array(input.getNumberOfTuples())\n          });\n          publicAPI.mapVectorsToMagnitude(input, magValues, vectorSize);\n          publicAPI.mapScalarsThroughTable(magValues, output, outputFormat, 0);\n          break;\n        }\n    }\n  };\n  publicAPI.luminanceToRGBA = function (newColors, colors, alpha, convtFun) {\n    var a = convtFun(alpha);\n    var values = colors.getData();\n    var newValues = newColors.getData();\n    var size = values.length;\n    var component = 0;\n    var tuple = 1;\n    var count = 0;\n    for (var i = component; i < size; i += tuple) {\n      var l = convtFun(values[i]);\n      newValues[count * 4] = l;\n      newValues[count * 4 + 1] = l;\n      newValues[count * 4 + 2] = l;\n      newValues[count * 4 + 3] = a;\n      count++;\n    }\n  };\n  publicAPI.luminanceAlphaToRGBA = function (newColors, colors, alpha, convtFun) {\n    var values = colors.getData();\n    var newValues = newColors.getData();\n    var size = values.length;\n    var component = 0;\n    var tuple = 2;\n    var count = 0;\n    for (var i = component; i < size; i += tuple) {\n      var l = convtFun(values[i]);\n      newValues[count] = l;\n      newValues[count + 1] = l;\n      newValues[count + 2] = l;\n      newValues[count + 3] = convtFun(values[i + 1]) * alpha;\n      count += 4;\n    }\n  };\n  publicAPI.rGBToRGBA = function (newColors, colors, alpha, convtFun) {\n    var a = floatColorToUChar(alpha);\n    var values = colors.getData();\n    var newValues = newColors.getData();\n    var size = values.length;\n    var component = 0;\n    var tuple = 3;\n    var count = 0;\n    for (var i = component; i < size; i += tuple) {\n      newValues[count * 4] = convtFun(values[i]);\n      newValues[count * 4 + 1] = convtFun(values[i + 1]);\n      newValues[count * 4 + 2] = convtFun(values[i + 2]);\n      newValues[count * 4 + 3] = a;\n      count++;\n    }\n  };\n  publicAPI.rGBAToRGBA = function (newColors, colors, alpha, convtFun) {\n    var values = colors.getData();\n    var newValues = newColors.getData();\n    var size = values.length;\n    var component = 0;\n    var tuple = 4;\n    var count = 0;\n    for (var i = component; i < size; i += tuple) {\n      newValues[count * 4] = convtFun(values[i]);\n      newValues[count * 4 + 1] = convtFun(values[i + 1]);\n      newValues[count * 4 + 2] = convtFun(values[i + 2]);\n      newValues[count * 4 + 3] = convtFun(values[i + 3]) * alpha;\n      count++;\n    }\n  }; //----------------------------------------------------------------------------\n\n  publicAPI.convertToRGBA = function (colors, numComp, numTuples) {\n    var alpha = model.alpha;\n    if (numComp === 4 && alpha >= 1.0 && colors.getDataType() === VtkDataTypes.UNSIGNED_CHAR) {\n      return colors;\n    }\n    var newColors = vtkDataArray.newInstance({\n      numberOfComponents: 4,\n      empty: true,\n      size: 4 * numTuples,\n      dataType: VtkDataTypes.UNSIGNED_CHAR\n    });\n    if (numTuples <= 0) {\n      return newColors;\n    }\n    alpha = alpha > 0 ? alpha : 0;\n    alpha = alpha < 1 ? alpha : 1;\n    var convtFun = intColorToUChar;\n    if (colors.getDataType() === VtkDataTypes.FLOAT || colors.getDataType() === VtkDataTypes.DOUBLE) {\n      convtFun = floatColorToUChar;\n    }\n    switch (numComp) {\n      case 1:\n        publicAPI.luminanceToRGBA(newColors, colors, alpha, convtFun);\n        break;\n      case 2:\n        publicAPI.luminanceAlphaToRGBA(newColors, colors, convtFun);\n        break;\n      case 3:\n        publicAPI.rGBToRGBA(newColors, colors, alpha, convtFun);\n        break;\n      case 4:\n        publicAPI.rGBAToRGBA(newColors, colors, alpha, convtFun);\n        break;\n      default:\n        vtkErrorMacro('Cannot convert colors');\n        return null;\n    }\n    return newColors;\n  };\n  publicAPI.usingLogScale = function () {\n    return false;\n  };\n  publicAPI.getNumberOfAvailableColors = function () {\n    return 256 * 256 * 256;\n  };\n  publicAPI.setRange = function (min, max) {\n    return publicAPI.setMappingRange(min, max);\n  };\n  publicAPI.getRange = function () {\n    return publicAPI.getMappingRange();\n  };\n  publicAPI.areScalarsOpaque = function (scalars, colorMode, componentIn) {\n    if (!scalars) {\n      return publicAPI.isOpaque();\n    }\n    var numberOfComponents = scalars.getNumberOfComponents(); // map scalars through lookup table only if needed\n\n    if (colorMode === ColorMode.DEFAULT && scalars.getDataType() === VtkDataTypes.UNSIGNED_CHAR || colorMode === ColorMode.DIRECT_SCALARS) {\n      // we will be using the scalars directly, so look at the number of\n      // components and the range\n      if (numberOfComponents === 3 || numberOfComponents === 1) {\n        return model.alpha >= 1.0;\n      } // otherwise look at the range of the alpha channel\n\n      var range = scalars.getRange(numberOfComponents - 1);\n      return range[0] === 255;\n    }\n    return true;\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nvar DEFAULT_VALUES = {\n  alpha: 1.0,\n  vectorComponent: 0,\n  vectorSize: -1,\n  vectorMode: VectorMode.COMPONENT,\n  mappingRange: null,\n  annotationArray: null,\n  annotatedValueMap: null,\n  indexedLookup: false\n}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Object methods\n\n  macro.obj(publicAPI, model);\n  model.mappingRange = [0, 255];\n  model.annotationArray = [];\n  model.annotatedValueMap = []; // Create get-set macros\n\n  macro.setGet(publicAPI, model, ['vectorSize', 'vectorComponent', 'vectorMode', 'alpha', 'indexedLookup']); // Create set macros for array (needs to know size)\n\n  macro.setArray(publicAPI, model, ['mappingRange'], 2); // Create get macros for array\n\n  macro.getArray(publicAPI, model, ['mappingRange']); // For more macro methods, see \"Sources/macros.js\"\n  // Object specific methods\n\n  vtkScalarsToColors(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = macro.newInstance(extend, 'vtkScalarsToColors'); // ----------------------------------------------------------------------------\n\nvar vtkScalarsToColors$1 = _objectSpread({\n  newInstance: newInstance,\n  extend: extend\n}, vtkScalarsToColors$2);\nexport { vtkScalarsToColors$1 as default, extend, newInstance };","map":{"version":3,"names":["_defineProperty","macro","vtkDataArray","vtkScalarsToColors$2","Constants","ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","getOwnPropertyDescriptors","defineProperties","defineProperty","ScalarMappingTarget","VectorMode","VtkDataTypes","ColorMode","vtkErrorMacro","intColorToUChar","c","floatColorToUChar","Math","floor","vtkScalarsToColors","publicAPI","model","classHierarchy","setVectorModeToMagnitude","setVectorMode","MAGNITUDE","setVectorModeToComponent","COMPONENT","setVectorModeToRGBColors","RGBCOLORS","build","isOpaque","setAnnotations","values","annotations","annotationArray","num","value","annotation","String","updateAnnotatedValueMap","modified","setAnnotation","checkForAnnotatedValue","getNumberOfAnnotatedValues","getAnnotatedValue","idx","getAnnotation","undefined","getAnnotatedValueIndex","val","removeAnnotation","needToRemove","splice","resetAnnotations","annotatedValueMap","getAnnotationColor","rgba","indexedLookup","getIndexedColor","getColor","parseFloat","getAnnotatedValueIndexInternal","na","mapScalars","scalars","colorMode","componentIn","numberOfComponents","getNumberOfComponents","newColors","DEFAULT","getDataType","UNSIGNED_CHAR","DIRECT_SCALARS","convertToRGBA","getNumberOfTuples","newscalars","type","name","dataType","s","newTypedArray","size","newInstance","component","mapVectorsThroughTable","RGBA","mapScalarsThroughTable","mapVectorsToMagnitude","input","output","compsToUse","inIncr","outputV","getData","inputV","sum","j","sqrt","outputFormat","vectorComponentIn","vectorSizeIn","vectorMode","getVectorMode","vectorSize","vectorComponent","inComponents","getVectorComponent","getVectorSize","inputOffset","magValues","Float32Array","luminanceToRGBA","colors","alpha","convtFun","a","newValues","tuple","count","l","luminanceAlphaToRGBA","rGBToRGBA","rGBAToRGBA","numComp","numTuples","empty","FLOAT","DOUBLE","usingLogScale","getNumberOfAvailableColors","setRange","min","max","setMappingRange","getRange","getMappingRange","areScalarsOpaque","range","DEFAULT_VALUES","mappingRange","extend","initialValues","assign","obj","setGet","setArray","getArray","vtkScalarsToColors$1","default"],"sources":["/home/rakshith/Documents/RemoteRendering/vtk-js-react-app/node_modules/@kitware/vtk.js/Common/Core/ScalarsToColors.js"],"sourcesContent":["import _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport macro from '../../macros.js';\nimport vtkDataArray from './DataArray.js';\nimport vtkScalarsToColors$2 from './ScalarsToColors/Constants.js';\nimport Constants from '../../Rendering/Core/Mapper/Constants.js';\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nvar ScalarMappingTarget = vtkScalarsToColors$2.ScalarMappingTarget,\n    VectorMode = vtkScalarsToColors$2.VectorMode;\nvar VtkDataTypes = vtkDataArray.VtkDataTypes;\nvar ColorMode = Constants.ColorMode;\nvar vtkErrorMacro = macro.vtkErrorMacro; // ----------------------------------------------------------------------------\n// Global methods\n// ----------------------------------------------------------------------------\n// Add module-level functions or api that you want to expose statically via\n// the next section...\n// ----------------------------------------------------------------------------\n// Static API\n// ----------------------------------------------------------------------------\n\nfunction intColorToUChar(c) {\n  return c;\n}\n\nfunction floatColorToUChar(c) {\n  return Math.floor(c * 255.0 + 0.5);\n} // ----------------------------------------------------------------------------\n// vtkScalarsToColors methods\n// ----------------------------------------------------------------------------\n\n\nfunction vtkScalarsToColors(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkScalarsToColors');\n\n  publicAPI.setVectorModeToMagnitude = function () {\n    return publicAPI.setVectorMode(VectorMode.MAGNITUDE);\n  };\n\n  publicAPI.setVectorModeToComponent = function () {\n    return publicAPI.setVectorMode(VectorMode.COMPONENT);\n  };\n\n  publicAPI.setVectorModeToRGBColors = function () {\n    return publicAPI.setVectorMode(VectorMode.RGBCOLORS);\n  };\n\n  publicAPI.build = function () {};\n\n  publicAPI.isOpaque = function () {\n    return true;\n  }; //----------------------------------------------------------------------------\n\n\n  publicAPI.setAnnotations = function (values, annotations) {\n    if (values && !annotations || !values && annotations) {\n      return;\n    }\n\n    if (values && annotations && values.length !== annotations.length) {\n      vtkErrorMacro('Values and annotations do not have the same number of tuples so ignoring');\n      return;\n    }\n\n    model.annotationArray = [];\n\n    if (annotations && values) {\n      var num = annotations.length;\n\n      for (var i = 0; i < num; i++) {\n        model.annotationArray.push({\n          value: values[i],\n          annotation: String(annotations[i])\n        });\n      }\n    }\n\n    publicAPI.updateAnnotatedValueMap();\n    publicAPI.modified();\n  }; //----------------------------------------------------------------------------\n\n\n  publicAPI.setAnnotation = function (value, annotation) {\n    var i = publicAPI.checkForAnnotatedValue(value);\n    var modified = false;\n\n    if (i >= 0) {\n      if (model.annotationArray[i].annotation !== annotation) {\n        model.annotationArray[i].annotation = annotation;\n        modified = true;\n      }\n    } else {\n      model.annotationArray.push({\n        value: value,\n        annotation: annotation\n      });\n      i = model.annotationArray.length - 1;\n      modified = true;\n    }\n\n    if (modified) {\n      publicAPI.updateAnnotatedValueMap();\n      publicAPI.modified();\n    }\n\n    return i;\n  }; //----------------------------------------------------------------------------\n\n\n  publicAPI.getNumberOfAnnotatedValues = function () {\n    return model.annotationArray.length;\n  }; //----------------------------------------------------------------------------\n\n\n  publicAPI.getAnnotatedValue = function (idx) {\n    if (idx < 0 || idx >= model.annotationArray.length) {\n      return null;\n    }\n\n    return model.annotationArray[idx].value;\n  }; //----------------------------------------------------------------------------\n\n\n  publicAPI.getAnnotation = function (idx) {\n    if (model.annotationArray[idx] === undefined) {\n      return null;\n    }\n\n    return model.annotationArray[idx].annotation;\n  }; //----------------------------------------------------------------------------\n\n\n  publicAPI.getAnnotatedValueIndex = function (val) {\n    return model.annotationArray.length ? publicAPI.checkForAnnotatedValue(val) : -1;\n  }; //----------------------------------------------------------------------------\n\n\n  publicAPI.removeAnnotation = function (value) {\n    var i = publicAPI.checkForAnnotatedValue(value);\n    var needToRemove = i >= 0;\n\n    if (needToRemove) {\n      model.annotationArray.splice(i, 1);\n      publicAPI.updateAnnotatedValueMap();\n      publicAPI.modified();\n    }\n\n    return needToRemove;\n  }; //----------------------------------------------------------------------------\n\n\n  publicAPI.resetAnnotations = function () {\n    model.annotationArray = [];\n    model.annotatedValueMap = [];\n    publicAPI.modified();\n  }; //----------------------------------------------------------------------------\n\n\n  publicAPI.getAnnotationColor = function (val, rgba) {\n    if (model.indexedLookup) {\n      var i = publicAPI.getAnnotatedValueIndex(val);\n      publicAPI.getIndexedColor(i, rgba);\n    } else {\n      publicAPI.getColor(parseFloat(val), rgba);\n      rgba[3] = 1.0;\n    }\n  }; //----------------------------------------------------------------------------\n\n\n  publicAPI.checkForAnnotatedValue = function (value) {\n    return publicAPI.getAnnotatedValueIndexInternal(value);\n  }; //----------------------------------------------------------------------------\n  // An unsafe version of vtkScalarsToColors::CheckForAnnotatedValue for\n  // internal use (no pointer checks performed)\n\n\n  publicAPI.getAnnotatedValueIndexInternal = function (value) {\n    if (model.annotatedValueMap[value] !== undefined) {\n      var na = model.annotationArray.length;\n      return model.annotatedValueMap[value] % na;\n    } // Treat as a NaN\n\n\n    return -1;\n  }; //----------------------------------------------------------------------------\n\n\n  publicAPI.getIndexedColor = function (val, rgba) {\n    rgba[0] = 0.0;\n    rgba[1] = 0.0;\n    rgba[2] = 0.0;\n    rgba[3] = 0.0;\n  }; //----------------------------------------------------------------------------\n\n\n  publicAPI.updateAnnotatedValueMap = function () {\n    model.annotatedValueMap = [];\n    var na = model.annotationArray.length;\n\n    for (var i = 0; i < na; i++) {\n      model.annotatedValueMap[model.annotationArray[i].value] = i;\n    }\n  }; // Description:\n  // Internal methods that map a data array into a 4-component,\n  // unsigned char RGBA array. The color mode determines the behavior\n  // of mapping. If ColorMode.DEFAULT is set, then unsigned char\n  // data arrays are treated as colors (and converted to RGBA if\n  // necessary); If ColorMode.DIRECT_SCALARS is set, then all arrays\n  // are treated as colors (integer types are clamped in the range 0-255,\n  // floating point arrays are clamped in the range 0.0-1.0. Note 'char' does\n  // not have enough values to represent a color so mapping this type is\n  // considered an error);\n  // otherwise, the data is mapped through this instance\n  // of ScalarsToColors. The component argument is used for data\n  // arrays with more than one component; it indicates which component\n  // to use to do the blending.  When the component argument is -1,\n  // then the this object uses its own selected technique to change a\n  // vector into a scalar to map.\n\n\n  publicAPI.mapScalars = function (scalars, colorMode, componentIn) {\n    var numberOfComponents = scalars.getNumberOfComponents();\n    var newColors = null; // map scalars through lookup table only if needed\n\n    if (colorMode === ColorMode.DEFAULT && scalars.getDataType() === VtkDataTypes.UNSIGNED_CHAR || colorMode === ColorMode.DIRECT_SCALARS && scalars) {\n      newColors = publicAPI.convertToRGBA(scalars, numberOfComponents, scalars.getNumberOfTuples());\n    } else {\n      var newscalars = {\n        type: 'vtkDataArray',\n        name: 'temp',\n        numberOfComponents: 4,\n        dataType: VtkDataTypes.UNSIGNED_CHAR\n      };\n      var s = macro.newTypedArray(newscalars.dataType, 4 * scalars.getNumberOfTuples());\n      newscalars.values = s;\n      newscalars.size = s.length;\n      newColors = vtkDataArray.newInstance(newscalars);\n      var component = componentIn; // If mapper did not specify a component, use the VectorMode\n\n      if (component < 0 && numberOfComponents > 1) {\n        publicAPI.mapVectorsThroughTable(scalars, newColors, ScalarMappingTarget.RGBA, -1, -1);\n      } else {\n        if (component < 0) {\n          component = 0;\n        }\n\n        if (component >= numberOfComponents) {\n          component = numberOfComponents - 1;\n        } // Map the scalars to colors\n\n\n        publicAPI.mapScalarsThroughTable(scalars, newColors, ScalarMappingTarget.RGBA, component);\n      }\n    }\n\n    return newColors;\n  };\n\n  publicAPI.mapVectorsToMagnitude = function (input, output, compsToUse) {\n    var length = input.getNumberOfTuples();\n    var inIncr = input.getNumberOfComponents();\n    var outputV = output.getData();\n    var inputV = input.getData();\n\n    for (var i = 0; i < length; i++) {\n      var sum = 0.0;\n\n      for (var j = 0; j < compsToUse; j++) {\n        sum += inputV[i * inIncr + j] * inputV[i * inIncr + j];\n      }\n\n      outputV[i] = Math.sqrt(sum);\n    }\n  }; //----------------------------------------------------------------------------\n  // Map a set of vector values through the table\n\n\n  publicAPI.mapVectorsThroughTable = function (input, output, outputFormat, vectorComponentIn, vectorSizeIn) {\n    var vectorMode = publicAPI.getVectorMode();\n    var vectorSize = vectorSizeIn;\n    var vectorComponent = vectorComponentIn;\n    var inComponents = input.getNumberOfComponents();\n\n    if (vectorMode === VectorMode.COMPONENT) {\n      // make sure vectorComponent is within allowed range\n      if (vectorComponent === -1) {\n        // if set to -1, use default value provided by table\n        vectorComponent = publicAPI.getVectorComponent();\n      }\n\n      if (vectorComponent < 0) {\n        vectorComponent = 0;\n      }\n\n      if (vectorComponent >= inComponents) {\n        vectorComponent = inComponents - 1;\n      }\n    } else {\n      // make sure vectorSize is within allowed range\n      if (vectorSize === -1) {\n        // if set to -1, use default value provided by table\n        vectorSize = publicAPI.getVectorSize();\n      }\n\n      if (vectorSize <= 0) {\n        vectorComponent = 0;\n        vectorSize = inComponents;\n      } else {\n        if (vectorComponent < 0) {\n          vectorComponent = 0;\n        }\n\n        if (vectorComponent >= inComponents) {\n          vectorComponent = inComponents - 1;\n        }\n\n        if (vectorComponent + vectorSize > inComponents) {\n          vectorSize = inComponents - vectorComponent;\n        }\n      }\n\n      if (vectorMode === VectorMode.MAGNITUDE && (inComponents === 1 || vectorSize === 1)) {\n        vectorMode = VectorMode.COMPONENT;\n      }\n    } // increment input pointer to the first component to map\n\n\n    var inputOffset = 0;\n\n    if (vectorComponent > 0) {\n      inputOffset = vectorComponent;\n    } // map according to the current vector mode\n\n\n    switch (vectorMode) {\n      case VectorMode.COMPONENT:\n        {\n          publicAPI.mapScalarsThroughTable(input, output, outputFormat, inputOffset);\n          break;\n        }\n\n      case VectorMode.RGBCOLORS:\n        {\n          // publicAPI.mapColorsToColors(\n          //   input, output, inComponents, vectorSize,\n          //   outputFormat);\n          break;\n        }\n      // MAGNITUDE is considered default\n\n      case VectorMode.MAGNITUDE:\n      default:\n        {\n          var magValues = vtkDataArray.newInstance({\n            numberOfComponents: 1,\n            values: new Float32Array(input.getNumberOfTuples())\n          });\n          publicAPI.mapVectorsToMagnitude(input, magValues, vectorSize);\n          publicAPI.mapScalarsThroughTable(magValues, output, outputFormat, 0);\n          break;\n        }\n    }\n  };\n\n  publicAPI.luminanceToRGBA = function (newColors, colors, alpha, convtFun) {\n    var a = convtFun(alpha);\n    var values = colors.getData();\n    var newValues = newColors.getData();\n    var size = values.length;\n    var component = 0;\n    var tuple = 1;\n    var count = 0;\n\n    for (var i = component; i < size; i += tuple) {\n      var l = convtFun(values[i]);\n      newValues[count * 4] = l;\n      newValues[count * 4 + 1] = l;\n      newValues[count * 4 + 2] = l;\n      newValues[count * 4 + 3] = a;\n      count++;\n    }\n  };\n\n  publicAPI.luminanceAlphaToRGBA = function (newColors, colors, alpha, convtFun) {\n    var values = colors.getData();\n    var newValues = newColors.getData();\n    var size = values.length;\n    var component = 0;\n    var tuple = 2;\n    var count = 0;\n\n    for (var i = component; i < size; i += tuple) {\n      var l = convtFun(values[i]);\n      newValues[count] = l;\n      newValues[count + 1] = l;\n      newValues[count + 2] = l;\n      newValues[count + 3] = convtFun(values[i + 1]) * alpha;\n      count += 4;\n    }\n  };\n\n  publicAPI.rGBToRGBA = function (newColors, colors, alpha, convtFun) {\n    var a = floatColorToUChar(alpha);\n    var values = colors.getData();\n    var newValues = newColors.getData();\n    var size = values.length;\n    var component = 0;\n    var tuple = 3;\n    var count = 0;\n\n    for (var i = component; i < size; i += tuple) {\n      newValues[count * 4] = convtFun(values[i]);\n      newValues[count * 4 + 1] = convtFun(values[i + 1]);\n      newValues[count * 4 + 2] = convtFun(values[i + 2]);\n      newValues[count * 4 + 3] = a;\n      count++;\n    }\n  };\n\n  publicAPI.rGBAToRGBA = function (newColors, colors, alpha, convtFun) {\n    var values = colors.getData();\n    var newValues = newColors.getData();\n    var size = values.length;\n    var component = 0;\n    var tuple = 4;\n    var count = 0;\n\n    for (var i = component; i < size; i += tuple) {\n      newValues[count * 4] = convtFun(values[i]);\n      newValues[count * 4 + 1] = convtFun(values[i + 1]);\n      newValues[count * 4 + 2] = convtFun(values[i + 2]);\n      newValues[count * 4 + 3] = convtFun(values[i + 3]) * alpha;\n      count++;\n    }\n  }; //----------------------------------------------------------------------------\n\n\n  publicAPI.convertToRGBA = function (colors, numComp, numTuples) {\n    var alpha = model.alpha;\n\n    if (numComp === 4 && alpha >= 1.0 && colors.getDataType() === VtkDataTypes.UNSIGNED_CHAR) {\n      return colors;\n    }\n\n    var newColors = vtkDataArray.newInstance({\n      numberOfComponents: 4,\n      empty: true,\n      size: 4 * numTuples,\n      dataType: VtkDataTypes.UNSIGNED_CHAR\n    });\n\n    if (numTuples <= 0) {\n      return newColors;\n    }\n\n    alpha = alpha > 0 ? alpha : 0;\n    alpha = alpha < 1 ? alpha : 1;\n    var convtFun = intColorToUChar;\n\n    if (colors.getDataType() === VtkDataTypes.FLOAT || colors.getDataType() === VtkDataTypes.DOUBLE) {\n      convtFun = floatColorToUChar;\n    }\n\n    switch (numComp) {\n      case 1:\n        publicAPI.luminanceToRGBA(newColors, colors, alpha, convtFun);\n        break;\n\n      case 2:\n        publicAPI.luminanceAlphaToRGBA(newColors, colors, convtFun);\n        break;\n\n      case 3:\n        publicAPI.rGBToRGBA(newColors, colors, alpha, convtFun);\n        break;\n\n      case 4:\n        publicAPI.rGBAToRGBA(newColors, colors, alpha, convtFun);\n        break;\n\n      default:\n        vtkErrorMacro('Cannot convert colors');\n        return null;\n    }\n\n    return newColors;\n  };\n\n  publicAPI.usingLogScale = function () {\n    return false;\n  };\n\n  publicAPI.getNumberOfAvailableColors = function () {\n    return 256 * 256 * 256;\n  };\n\n  publicAPI.setRange = function (min, max) {\n    return publicAPI.setMappingRange(min, max);\n  };\n\n  publicAPI.getRange = function () {\n    return publicAPI.getMappingRange();\n  };\n\n  publicAPI.areScalarsOpaque = function (scalars, colorMode, componentIn) {\n    if (!scalars) {\n      return publicAPI.isOpaque();\n    }\n\n    var numberOfComponents = scalars.getNumberOfComponents(); // map scalars through lookup table only if needed\n\n    if (colorMode === ColorMode.DEFAULT && scalars.getDataType() === VtkDataTypes.UNSIGNED_CHAR || colorMode === ColorMode.DIRECT_SCALARS) {\n      // we will be using the scalars directly, so look at the number of\n      // components and the range\n      if (numberOfComponents === 3 || numberOfComponents === 1) {\n        return model.alpha >= 1.0;\n      } // otherwise look at the range of the alpha channel\n\n\n      var range = scalars.getRange(numberOfComponents - 1);\n      return range[0] === 255;\n    }\n\n    return true;\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\n\nvar DEFAULT_VALUES = {\n  alpha: 1.0,\n  vectorComponent: 0,\n  vectorSize: -1,\n  vectorMode: VectorMode.COMPONENT,\n  mappingRange: null,\n  annotationArray: null,\n  annotatedValueMap: null,\n  indexedLookup: false\n}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Object methods\n\n  macro.obj(publicAPI, model);\n  model.mappingRange = [0, 255];\n  model.annotationArray = [];\n  model.annotatedValueMap = []; // Create get-set macros\n\n  macro.setGet(publicAPI, model, ['vectorSize', 'vectorComponent', 'vectorMode', 'alpha', 'indexedLookup']); // Create set macros for array (needs to know size)\n\n  macro.setArray(publicAPI, model, ['mappingRange'], 2); // Create get macros for array\n\n  macro.getArray(publicAPI, model, ['mappingRange']); // For more macro methods, see \"Sources/macros.js\"\n  // Object specific methods\n\n  vtkScalarsToColors(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = macro.newInstance(extend, 'vtkScalarsToColors'); // ----------------------------------------------------------------------------\n\nvar vtkScalarsToColors$1 = _objectSpread({\n  newInstance: newInstance,\n  extend: extend\n}, vtkScalarsToColors$2);\n\nexport { vtkScalarsToColors$1 as default, extend, newInstance };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}