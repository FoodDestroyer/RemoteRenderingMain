{"ast":null,"code":"import _slicedToArray from '@babel/runtime/helpers/slicedToArray';\nimport _toConsumableArray from '@babel/runtime/helpers/toConsumableArray';\nimport { newInstance as newInstance$1, obj, get, vtkErrorMacro as vtkErrorMacro$1 } from '../../macros.js';\nimport { mat4, mat3, vec3 } from 'gl-matrix';\nimport vtkClosedPolyLineToSurfaceFilter from '../../Filters/General/ClosedPolyLineToSurfaceFilter.js';\nimport vtkCutter from '../../Filters/Core/Cutter.js';\nimport vtkDataArray from '../../Common/Core/DataArray.js';\nimport vtkHelper from './Helper.js';\nimport vtkImageDataOutlineFilter from '../../Filters/General/ImageDataOutlineFilter.js';\nimport { f as vtkMath } from '../../Common/Core/Math/index.js';\nimport vtkOpenGLTexture from './Texture.js';\nimport vtkPlane from '../../Common/DataModel/Plane.js';\nimport vtkPolyData from '../../Common/DataModel/PolyData.js';\nimport vtkReplacementShaderMapper from './ReplacementShaderMapper.js';\nimport vtkShaderProgram from './ShaderProgram.js';\nimport vtkTransform from '../../Common/Transform/Transform.js';\nimport vtkViewNode from '../SceneGraph/ViewNode.js';\nimport { v as vtkImageResliceMapperVS } from './glsl/vtkImageResliceMapperVS.glsl.js';\nimport { v as vtkImageResliceMapperFS } from './glsl/vtkImageResliceMapperFS.glsl.js';\nimport { Filter } from './Texture/Constants.js';\nimport { InterpolationType } from '../Core/ImageProperty/Constants.js';\nimport { Representation } from '../Core/Property/Constants.js';\nimport { VtkDataTypes } from '../../Common/Core/DataArray/Constants.js';\nimport { registerOverride } from './ViewNodeFactory.js';\nvar vtkErrorMacro = vtkErrorMacro$1; // ----------------------------------------------------------------------------\n// helper methods\n// ----------------------------------------------------------------------------\n\nfunction computeFnToString(property, fn, numberOfComponents) {\n  var pwfun = fn.apply(property);\n  if (pwfun) {\n    var iComps = property.getIndependentComponents();\n    return \"\".concat(property.getMTime(), \"-\").concat(iComps, \"-\").concat(numberOfComponents);\n  }\n  return '0';\n}\nfunction safeMatrixMultiply(matrixArray, matrixType, tmpMat) {\n  matrixType.identity(tmpMat);\n  return matrixArray.reduce(function (res, matrix, index) {\n    if (index === 0) {\n      return matrix ? matrixType.copy(res, matrix) : matrixType.identity(res);\n    }\n    return matrix ? matrixType.multiply(res, res, matrix) : res;\n  }, tmpMat);\n} // ----------------------------------------------------------------------------\n// vtkOpenGLImageResliceMapper methods\n// ----------------------------------------------------------------------------\n\nfunction vtkOpenGLImageResliceMapper(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkOpenGLImageResliceMapper');\n  publicAPI.buildPass = function (prepass) {\n    if (prepass) {\n      model.currentRenderPass = null;\n      model._openGLImageSlice = publicAPI.getFirstAncestorOfType('vtkOpenGLImageSlice');\n      model._openGLRenderer = publicAPI.getFirstAncestorOfType('vtkOpenGLRenderer');\n      var ren = model._openGLRenderer.getRenderable();\n      model._openGLCamera = model._openGLRenderer.getViewNodeFor(ren.getActiveCamera());\n      model._openGLRenderWindow = model._openGLRenderer.getParent();\n      model.context = model._openGLRenderWindow.getContext();\n      model.tris.setOpenGLRenderWindow(model._openGLRenderWindow);\n      if (!model.openGLTexture) {\n        model.openGLTexture = vtkOpenGLTexture.newInstance();\n      }\n      model.openGLTexture.setOpenGLRenderWindow(model._openGLRenderWindow);\n      model.colorTexture.setOpenGLRenderWindow(model._openGLRenderWindow);\n      model.pwfTexture.setOpenGLRenderWindow(model._openGLRenderWindow);\n    }\n  };\n  publicAPI.translucentPass = function (prepass, renderPass) {\n    if (prepass) {\n      model.currentRenderPass = renderPass;\n      publicAPI.render();\n    }\n  };\n  publicAPI.zBufferPass = function (prepass) {\n    if (prepass) {\n      model.haveSeenDepthRequest = true;\n      model.renderDepth = true;\n      publicAPI.render();\n      model.renderDepth = false;\n    }\n  };\n  publicAPI.opaqueZBufferPass = function (prepass) {\n    return publicAPI.zBufferPass(prepass);\n  };\n  publicAPI.opaquePass = function (prepass) {\n    if (prepass) {\n      publicAPI.render();\n    }\n  };\n  publicAPI.getCoincidentParameters = function (ren, actor) {\n    if (model.renderable.getResolveCoincidentTopology()) {\n      return model.renderable.getCoincidentTopologyPolygonOffsetParameters();\n    }\n    return null;\n  }; // Renders myself\n\n  publicAPI.render = function () {\n    var actor = model._openGLImageSlice.getRenderable();\n    var ren = model._openGLRenderer.getRenderable();\n    publicAPI.renderPiece(ren, actor);\n  };\n  publicAPI.renderPiece = function (ren, actor) {\n    publicAPI.invokeEvent({\n      type: 'StartEvent'\n    });\n    model.renderable.update();\n    model.currentInput = model.renderable.getInputData();\n    if (!model.currentInput) {\n      vtkErrorMacro('No input!');\n      return;\n    }\n    publicAPI.updateResliceGeometry();\n    publicAPI.renderPieceStart(ren, actor);\n    publicAPI.renderPieceDraw(ren, actor);\n    publicAPI.renderPieceFinish(ren, actor);\n    publicAPI.invokeEvent({\n      type: 'EndEvent'\n    });\n  };\n  publicAPI.renderPieceStart = function (ren, actor) {\n    // make sure the BOs are up to date\n    publicAPI.updateBufferObjects(ren, actor);\n    var iType = actor.getProperty().getInterpolationType();\n    if (iType === InterpolationType.NEAREST) {\n      model.openGLTexture.setMinificationFilter(Filter.NEAREST);\n      model.openGLTexture.setMagnificationFilter(Filter.NEAREST);\n      model.colorTexture.setMinificationFilter(Filter.NEAREST);\n      model.colorTexture.setMagnificationFilter(Filter.NEAREST);\n      model.pwfTexture.setMinificationFilter(Filter.NEAREST);\n      model.pwfTexture.setMagnificationFilter(Filter.NEAREST);\n    } else {\n      model.openGLTexture.setMinificationFilter(Filter.LINEAR);\n      model.openGLTexture.setMagnificationFilter(Filter.LINEAR);\n      model.colorTexture.setMinificationFilter(Filter.LINEAR);\n      model.colorTexture.setMagnificationFilter(Filter.LINEAR);\n      model.pwfTexture.setMinificationFilter(Filter.LINEAR);\n      model.pwfTexture.setMagnificationFilter(Filter.LINEAR);\n    } // No buffer objects bound.\n\n    model.lastBoundBO = null;\n  };\n  publicAPI.renderPieceDraw = function (ren, actor) {\n    var gl = model.context; // render the texture\n\n    model.openGLTexture.activate();\n    model.colorTexture.activate();\n    model.pwfTexture.activate(); // update shaders if required\n\n    publicAPI.updateShaders(model.tris, ren, actor); // Finally draw\n\n    gl.drawArrays(gl.TRIANGLES, 0, model.tris.getCABO().getElementCount());\n    model.tris.getVAO().release();\n    model.openGLTexture.deactivate();\n    model.colorTexture.deactivate();\n    model.pwfTexture.deactivate();\n  };\n  publicAPI.renderPieceFinish = function (ren, actor) {};\n  publicAPI.updateBufferObjects = function (ren, actor) {\n    // Rebuild buffer objects if needed\n    if (publicAPI.getNeedToRebuildBufferObjects(ren, actor)) {\n      publicAPI.buildBufferObjects(ren, actor);\n    }\n  };\n  publicAPI.getNeedToRebuildBufferObjects = function (ren, actor) {\n    return model.VBOBuildTime.getMTime() < publicAPI.getMTime() || model.VBOBuildTime.getMTime() < actor.getMTime() || model.VBOBuildTime.getMTime() < model.renderable.getMTime() || model.VBOBuildTime.getMTime() < actor.getProperty().getMTime() || model.VBOBuildTime.getMTime() < model.currentInput.getMTime() || model.VBOBuildTime.getMTime() < model.resliceGeom.getMTime();\n  };\n  publicAPI.buildBufferObjects = function (ren, actor) {\n    var _image$getPointData;\n    var image = model.currentInput;\n    if (!image) {\n      return;\n    }\n    var scalars = (_image$getPointData = image.getPointData()) === null || _image$getPointData === void 0 ? void 0 : _image$getPointData.getScalars();\n    if (!scalars) {\n      return;\n    }\n    var numComp = scalars.getNumberOfComponents();\n    if (!model._externalOpenGLTexture) {\n      var _toString = \"\".concat(image.getMTime(), \"A\").concat(scalars.getMTime());\n      if (model.openGLTextureString !== _toString) {\n        // Build the image scalar texture\n        var dims = image.getDimensions(); // Use norm16 for the 3D texture if the extension is available\n\n        model.openGLTexture.getOglNorm16Ext(model.context.getExtension('EXT_texture_norm16'));\n        model.openGLTexture.releaseGraphicsResources(model._openGLRenderWindow);\n        model.openGLTexture.resetFormatAndType();\n        model.openGLTexture.create3DFilterableFromDataArray(dims[0], dims[1], dims[2], scalars);\n        model.openGLTextureString = _toString;\n      }\n    }\n    var ppty = actor.getProperty();\n    var iComps = ppty.getIndependentComponents();\n    var numIComps = iComps ? numComp : 1;\n    var textureHeight = iComps ? 2 * numIComps : 1;\n    var cfunToString = computeFnToString(ppty, ppty.getRGBTransferFunction, numIComps);\n    if (model.colorTextureString !== cfunToString) {\n      var cWidth = 1024;\n      var cSize = cWidth * textureHeight * 3;\n      var cTable = new Uint8Array(cSize);\n      var cfun = ppty.getRGBTransferFunction();\n      if (cfun) {\n        var tmpTable = new Float32Array(cWidth * 3);\n        for (var c = 0; c < numIComps; c++) {\n          cfun = ppty.getRGBTransferFunction(c);\n          var cRange = cfun.getRange();\n          cfun.getTable(cRange[0], cRange[1], cWidth, tmpTable, 1);\n          if (iComps) {\n            for (var i = 0; i < cWidth * 3; i++) {\n              cTable[c * cWidth * 6 + i] = 255.0 * tmpTable[i];\n              cTable[c * cWidth * 6 + i + cWidth * 3] = 255.0 * tmpTable[i];\n            }\n          } else {\n            for (var _i = 0; _i < cWidth * 3; _i++) {\n              cTable[c * cWidth * 6 + _i] = 255.0 * tmpTable[_i];\n            }\n          }\n        }\n        model.colorTexture.releaseGraphicsResources(model._openGLRenderWindow);\n        model.colorTexture.resetFormatAndType();\n        model.colorTexture.create2DFromRaw(cWidth, textureHeight, 3, VtkDataTypes.UNSIGNED_CHAR, cTable);\n      } else {\n        for (var _i2 = 0; _i2 < cWidth * 3; ++_i2) {\n          cTable[_i2] = 255.0 * _i2 / ((cWidth - 1) * 3);\n          cTable[_i2 + 1] = 255.0 * _i2 / ((cWidth - 1) * 3);\n          cTable[_i2 + 2] = 255.0 * _i2 / ((cWidth - 1) * 3);\n        }\n        model.colorTexture.create2DFromRaw(cWidth, 1, 3, VtkDataTypes.UNSIGNED_CHAR, cTable);\n      }\n      model.colorTextureString = cfunToString;\n    } // Build piecewise function buffer.  This buffer is used either\n    // for component weighting or opacity, depending on whether we're\n    // rendering components independently or not.\n\n    var pwfunToString = computeFnToString(ppty, ppty.getPiecewiseFunction, numIComps);\n    if (model.pwfTextureString !== pwfunToString) {\n      var pwfWidth = 1024;\n      var pwfSize = pwfWidth * textureHeight;\n      var pwfTable = new Uint8Array(pwfSize);\n      var pwfun = ppty.getPiecewiseFunction(); // support case where pwfun is added/removed\n\n      model.pwfTexture.releaseGraphicsResources(model._openGLRenderWindow);\n      model.pwfTexture.resetFormatAndType();\n      if (pwfun) {\n        var pwfFloatTable = new Float32Array(pwfSize);\n        var _tmpTable = new Float32Array(pwfWidth);\n        for (var _c = 0; _c < numIComps; ++_c) {\n          pwfun = ppty.getPiecewiseFunction(_c);\n          if (pwfun === null) {\n            // Piecewise constant max if no function supplied for this component\n            pwfFloatTable.fill(1.0);\n          } else {\n            var pwfRange = pwfun.getRange();\n            pwfun.getTable(pwfRange[0], pwfRange[1], pwfWidth, _tmpTable, 1); // adjust for sample distance etc\n\n            if (iComps) {\n              for (var _i3 = 0; _i3 < pwfWidth; _i3++) {\n                pwfFloatTable[_c * pwfWidth * 2 + _i3] = _tmpTable[_i3];\n                pwfFloatTable[_c * pwfWidth * 2 + _i3 + pwfWidth] = _tmpTable[_i3];\n              }\n            } else {\n              for (var _i4 = 0; _i4 < pwfWidth; _i4++) {\n                pwfFloatTable[_c * pwfWidth * 2 + _i4] = _tmpTable[_i4];\n              }\n            }\n          }\n        }\n        model.pwfTexture.create2DFromRaw(pwfWidth, textureHeight, 1, VtkDataTypes.FLOAT, pwfFloatTable);\n      } else {\n        // default is opaque\n        pwfTable.fill(255.0);\n        model.pwfTexture.create2DFromRaw(pwfWidth, 1, 1, VtkDataTypes.UNSIGNED_CHAR, pwfTable);\n      }\n      model.pwfTextureString = pwfunToString;\n    }\n    var vboString = \"\".concat(model.resliceGeom.getMTime(), \"A\").concat(model.renderable.getSlabThickness());\n    if (!model.tris.getCABO().getElementCount() || model.VBOBuildString !== vboString) {\n      var points = vtkDataArray.newInstance({\n        numberOfComponents: 3,\n        values: model.resliceGeom.getPoints().getData()\n      });\n      points.setName('points');\n      var cells = vtkDataArray.newInstance({\n        numberOfComponents: 1,\n        values: model.resliceGeom.getPolys().getData()\n      });\n      var options = {\n        points: points,\n        cellOffset: 0\n      };\n      if (model.renderable.getSlabThickness() > 0.0) {\n        var n = model.resliceGeom.getPointData().getNormals();\n        if (!n) {\n          vtkErrorMacro('Slab mode requested without normals');\n        } else {\n          options.normals = n;\n        }\n      }\n      model.tris.getCABO().createVBO(cells, 'polys', Representation.SURFACE, options);\n    }\n    model.VBOBuildString = vboString;\n    model.VBOBuildTime.modified();\n  };\n  publicAPI.updateShaders = function (cellBO, ren, actor) {\n    model.lastBoundBO = cellBO; // has something changed that would require us to recreate the shader?\n\n    if (publicAPI.getNeedToRebuildShaders(cellBO, ren, actor)) {\n      var shaders = {\n        Vertex: null,\n        Fragment: null,\n        Geometry: null\n      };\n      publicAPI.buildShaders(shaders, ren, actor); // compile and bind the program if needed\n\n      var newShader = model._openGLRenderWindow.getShaderCache().readyShaderProgramArray(shaders.Vertex, shaders.Fragment, shaders.Geometry); // if the shader changed reinitialize the VAO\n\n      if (newShader !== cellBO.getProgram()) {\n        cellBO.setProgram(newShader); // reset the VAO as the shader has changed\n\n        cellBO.getVAO().releaseGraphicsResources();\n      }\n      cellBO.getShaderSourceTime().modified();\n    } else {\n      model._openGLRenderWindow.getShaderCache().readyShaderProgram(cellBO.getProgram());\n    }\n    cellBO.getVAO().bind();\n    publicAPI.setMapperShaderParameters(cellBO, ren, actor);\n    publicAPI.setCameraShaderParameters(cellBO, ren, actor);\n    publicAPI.setPropertyShaderParameters(cellBO, ren, actor);\n  };\n  publicAPI.setMapperShaderParameters = function (cellBO, ren, actor) {\n    var program = cellBO.getProgram();\n    if (cellBO.getCABO().getElementCount() && (model.VBOBuildTime.getMTime() > cellBO.getAttributeUpdateTime().getMTime() || cellBO.getShaderSourceTime().getMTime() > cellBO.getAttributeUpdateTime().getMTime())) {\n      // Set the 3D texture\n      if (program.isUniformUsed('texture1')) {\n        program.setUniformi('texture1', model.openGLTexture.getTextureUnit());\n      } // Set the plane vertex attributes\n\n      if (program.isAttributeUsed('vertexWC')) {\n        if (!cellBO.getVAO().addAttributeArray(program, cellBO.getCABO(), 'vertexWC', cellBO.getCABO().getVertexOffset(), cellBO.getCABO().getStride(), model.context.FLOAT, 3, model.context.FALSE)) {\n          vtkErrorMacro('Error setting vertexWC in shader VAO.');\n        }\n      } // If we are doing slab mode, we need normals\n\n      if (program.isAttributeUsed('normalWC')) {\n        if (!cellBO.getVAO().addAttributeArray(program, cellBO.getCABO(), 'normalWC', cellBO.getCABO().getNormalOffset(), cellBO.getCABO().getStride(), model.context.FLOAT, 3, model.context.FALSE)) {\n          vtkErrorMacro('Error setting normalWC in shader VAO.');\n        }\n      }\n      if (program.isUniformUsed('slabThickness')) {\n        program.setUniformf('slabThickness', model.renderable.getSlabThickness());\n      }\n      if (program.isUniformUsed('spacing')) {\n        program.setUniform3fv('spacing', model.currentInput.getSpacing());\n      }\n      if (program.isUniformUsed('slabType')) {\n        program.setUniformi('slabType', model.renderable.getSlabType());\n      }\n      if (program.isUniformUsed('slabType')) {\n        program.setUniformi('slabType', model.renderable.getSlabType());\n      }\n      if (program.isUniformUsed('slabTrapezoid')) {\n        program.setUniformi('slabTrapezoid', model.renderable.getSlabTrapezoidIntegration());\n      }\n      var shiftScaleEnabled = cellBO.getCABO().getCoordShiftAndScaleEnabled();\n      var inverseShiftScaleMatrix = shiftScaleEnabled ? cellBO.getCABO().getInverseShiftAndScaleMatrix() : null; // Set the world->texture matrix\n\n      if (program.isUniformUsed('WCTCMatrix')) {\n        var image = model.currentInput;\n        var dim = image.getDimensions();\n        mat4.copy(model.tmpMat4, image.getIndexToWorld());\n        mat4.scale(model.tmpMat4, model.tmpMat4, dim);\n        mat4.invert(model.tmpMat4, model.tmpMat4);\n        if (inverseShiftScaleMatrix) {\n          mat4.multiply(model.tmpMat4, model.tmpMat4, inverseShiftScaleMatrix);\n        }\n        program.setUniformMatrix('WCTCMatrix', model.tmpMat4);\n      }\n      if (program.isUniformUsed('vboScaling')) {\n        program.setUniform3fv('vboScaling', cellBO.getCABO().getCoordScale());\n      }\n      cellBO.getAttributeUpdateTime().modified();\n    } // Depth request\n\n    if (model.haveSeenDepthRequest) {\n      cellBO.getProgram().setUniformi('depthRequest', model.renderDepth ? 1 : 0);\n    } // handle coincident\n\n    if (cellBO.getProgram().isUniformUsed('coffset')) {\n      var cp = publicAPI.getCoincidentParameters(ren, actor);\n      cellBO.getProgram().setUniformf('coffset', cp.offset); // cfactor isn't always used when coffset is.\n\n      if (cellBO.getProgram().isUniformUsed('cfactor')) {\n        cellBO.getProgram().setUniformf('cfactor', cp.factor);\n      }\n    }\n  };\n  publicAPI.setCameraShaderParameters = function (cellBO, ren, actor) {\n    // [WMVP]C == {world, model, view, projection} coordinates\n    // e.g. WCPC == world to projection coordinate transformation\n    var keyMats = model._openGLCamera.getKeyMatrices(ren);\n    var actMats = model._openGLImageSlice.getKeyMatrices();\n    var shiftScaleEnabled = cellBO.getCABO().getCoordShiftAndScaleEnabled();\n    var inverseShiftScaleMatrix = shiftScaleEnabled ? cellBO.getCABO().getInverseShiftAndScaleMatrix() : null;\n    var program = cellBO.getProgram();\n    if (program.isUniformUsed('MCPCMatrix')) {\n      mat4.identity(model.tmpMat4);\n      program.setUniformMatrix('MCPCMatrix', safeMatrixMultiply([keyMats.wcpc, actMats.mcwc, inverseShiftScaleMatrix], mat4, model.tmpMat4));\n    }\n    if (program.isUniformUsed('MCVCMatrix')) {\n      mat4.identity(model.tmpMat4);\n      program.setUniformMatrix('MCVCMatrix', safeMatrixMultiply([keyMats.wcvc, actMats.mcwc, inverseShiftScaleMatrix], mat4, model.tmpMat4));\n    }\n  };\n  publicAPI.setPropertyShaderParameters = function (cellBO, ren, actor) {\n    var program = cellBO.getProgram();\n    var ppty = actor.getProperty();\n    var opacity = ppty.getOpacity();\n    program.setUniformf('opacity', opacity); // Component mix\n    // Independent components: Mixed according to component weights\n    // Dependent components: Mixed using the following logic:\n    //    - 2 comps => LA\n    //    - 3 comps => RGB + opacity from pwf\n    //    - 4 comps => RGBA\n\n    var numComp = model.openGLTexture.getComponents();\n    var iComps = ppty.getIndependentComponents();\n    if (iComps) {\n      for (var i = 0; i < numComp; ++i) {\n        program.setUniformf(\"mix\".concat(i), ppty.getComponentWeight(i));\n      }\n    } // Color opacity map\n\n    var volInfo = model.openGLTexture.getVolumeInfo(); // three levels of shift scale combined into one\n    // for performance in the fragment shader\n\n    for (var _i5 = 0; _i5 < numComp; _i5++) {\n      var cw = ppty.getColorWindow();\n      var cl = ppty.getColorLevel();\n      var target = iComps ? _i5 : 0;\n      var cfun = ppty.getRGBTransferFunction(target);\n      if (cfun && ppty.getUseLookupTableScalarRange()) {\n        var cRange = cfun.getRange();\n        cw = cRange[1] - cRange[0];\n        cl = 0.5 * (cRange[1] + cRange[0]);\n      }\n      var scale = volInfo.scale[_i5] / cw;\n      var shift = (volInfo.offset[_i5] - cl) / cw + 0.5;\n      program.setUniformf(\"cshift\".concat(_i5), shift);\n      program.setUniformf(\"cscale\".concat(_i5), scale);\n    }\n    var texColorUnit = model.colorTexture.getTextureUnit();\n    program.setUniformi('colorTexture1', texColorUnit); // pwf shift/scale\n\n    for (var _i6 = 0; _i6 < numComp; _i6++) {\n      var pwfScale = 1.0;\n      var pwfShift = 0.0;\n      var _target = iComps ? _i6 : 0;\n      var pwfun = ppty.getPiecewiseFunction(_target);\n      if (pwfun) {\n        var pwfRange = pwfun.getRange();\n        var length = pwfRange[1] - pwfRange[0];\n        var mid = 0.5 * (pwfRange[0] + pwfRange[1]);\n        pwfScale = volInfo.scale[_i6] / length;\n        pwfShift = (volInfo.offset[_i6] - mid) / length + 0.5;\n      }\n      program.setUniformf(\"pwfshift\".concat(_i6), pwfShift);\n      program.setUniformf(\"pwfscale\".concat(_i6), pwfScale);\n    }\n    var texOpacityUnit = model.pwfTexture.getTextureUnit();\n    program.setUniformi('pwfTexture1', texOpacityUnit); // Background color\n\n    program.setUniform4fv('backgroundColor', model.renderable.getBackgroundColor());\n  };\n  publicAPI.getNeedToRebuildShaders = function (cellBO, ren, actor) {\n    // has something changed that would require us to recreate the shader?\n    // candidates are\n    // property modified (representation interpolation and lighting)\n    // input modified\n    // light complexity changed\n    // render pass shader replacement changed\n    var tNumComp = model.openGLTexture.getComponents();\n    var iComp = actor.getProperty().getIndependentComponents();\n    var slabTh = model.renderable.getSlabThickness();\n    var slabType = model.renderable.getSlabType();\n    var slabTrap = model.renderable.getSlabTrapezoidIntegration(); // has the render pass shader replacement changed? Two options\n\n    var needRebuild = false;\n    if (!model.currentRenderPass && model.lastRenderPassShaderReplacement || model.currentRenderPass && model.currentRenderPass.getShaderReplacement() !== model.lastRenderPassShaderReplacement) {\n      needRebuild = true;\n    }\n    if (needRebuild || model.lastHaveSeenDepthRequest !== model.haveSeenDepthRequest || cellBO.getProgram() === 0 || model.lastTextureComponents !== tNumComp || model.lastIndependentComponents !== iComp || model.lastSlabThickness !== slabTh || model.lastSlabType !== slabType || model.lastSlabTrapezoidIntegration !== slabTrap) {\n      model.lastHaveSeenDepthRequest = model.haveSeenDepthRequest;\n      model.lastTextureComponents = tNumComp;\n      model.lastIndependentComponents = iComp;\n      model.lastSlabThickness = slabTh;\n      model.lastSlabType = slabType;\n      model.lastSlabTrapezoidIntegration = slabTrap;\n      return true;\n    }\n    return false;\n  };\n  publicAPI.getShaderTemplate = function (shaders, ren, actor) {\n    shaders.Vertex = vtkImageResliceMapperVS;\n    shaders.Fragment = vtkImageResliceMapperFS;\n    shaders.Geometry = '';\n  };\n  publicAPI.replaceShaderValues = function (shaders, ren, actor) {\n    publicAPI.replaceShaderTCoord(shaders, ren, actor);\n    publicAPI.replaceShaderPositionVC(shaders, ren, actor);\n    if (model.haveSeenDepthRequest) {\n      var FSSource = shaders.Fragment;\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::ZBuffer::Dec', 'uniform int depthRequest;').result;\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::ZBuffer::Impl', ['if (depthRequest == 1) {', 'float iz = floor(gl_FragCoord.z*65535.0 + 0.1);', 'float rf = floor(iz/256.0)/255.0;', 'float gf = mod(iz,256.0)/255.0;', 'gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }']).result;\n      shaders.Fragment = FSSource;\n    }\n    publicAPI.replaceShaderCoincidentOffset(shaders, ren, actor);\n  };\n  publicAPI.replaceShaderTCoord = function (shaders, ren, actor) {\n    var VSSource = shaders.Vertex;\n    var GSSource = shaders.Geometry;\n    var FSSource = shaders.Fragment;\n    var tcoordVSDec = ['uniform mat4 WCTCMatrix;', 'out vec3 fragTexCoord;'];\n    var slabThickness = model.renderable.getSlabThickness();\n    VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::TCoord::Dec', tcoordVSDec).result;\n    var tcoordVSImpl = ['fragTexCoord = (WCTCMatrix * vertexWC).xyz;'];\n    VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::TCoord::Impl', tcoordVSImpl).result;\n    var tNumComp = model.openGLTexture.getComponents();\n    var iComps = actor.getProperty().getIndependentComponents();\n    var tcoordFSDec = ['in vec3 fragTexCoord;', 'uniform highp sampler3D texture1;', 'uniform mat4 WCTCMatrix;',\n    // color shift and scale\n    'uniform float cshift0;', 'uniform float cscale0;',\n    // pwf shift and scale\n    'uniform float pwfshift0;', 'uniform float pwfscale0;',\n    // color and pwf textures\n    'uniform sampler2D colorTexture1;', 'uniform sampler2D pwfTexture1;',\n    // opacity\n    'uniform float opacity;',\n    // background color\n    'uniform vec4 backgroundColor;'];\n    if (iComps) {\n      for (var comp = 1; comp < tNumComp; comp++) {\n        tcoordFSDec = tcoordFSDec.concat([\n        // color shift and scale\n        \"uniform float cshift\".concat(comp, \";\"), \"uniform float cscale\".concat(comp, \";\"),\n        // weighting shift and scale\n        \"uniform float pwfshift\".concat(comp, \";\"), \"uniform float pwfscale\".concat(comp, \";\")]);\n      } // the heights defined below are the locations\n      // for the up to four components of the tfuns\n      // the tfuns have a height of 2XnumComps pixels so the\n      // values are computed to hit the middle of the two rows\n      // for that component\n\n      switch (tNumComp) {\n        case 1:\n          tcoordFSDec = tcoordFSDec.concat(['uniform float mix0;', '#define height0 0.5']);\n          break;\n        case 2:\n          tcoordFSDec = tcoordFSDec.concat(['uniform float mix0;', 'uniform float mix1;', '#define height0 0.25', '#define height1 0.75']);\n          break;\n        case 3:\n          tcoordFSDec = tcoordFSDec.concat(['uniform float mix0;', 'uniform float mix1;', 'uniform float mix2;', '#define height0 0.17', '#define height1 0.5', '#define height2 0.83']);\n          break;\n        case 4:\n          tcoordFSDec = tcoordFSDec.concat(['uniform float mix0;', 'uniform float mix1;', 'uniform float mix2;', 'uniform float mix3;', '#define height0 0.125', '#define height1 0.375', '#define height2 0.625', '#define height3 0.875']);\n          break;\n        default:\n          vtkErrorMacro('Unsupported number of independent coordinates.');\n      }\n    }\n    if (slabThickness > 0.0) {\n      tcoordFSDec = tcoordFSDec.concat(['uniform vec3 spacing;', 'uniform float slabThickness;', 'uniform int slabType;', 'uniform int slabTrapezoid;', 'uniform vec3 vboScaling;']);\n      tcoordFSDec = tcoordFSDec.concat(['vec4 compositeValue(vec4 currVal, vec4 valToComp, int trapezoid)', '{', '  vec4 retVal = vec4(1.0);', '  if (slabType == 0) // min', '  {', '    retVal = min(currVal, valToComp);', '  }', '  else if (slabType == 1) // max', '  {', '    retVal = max(currVal, valToComp);', '  }', '  else if (slabType == 3) // sum', '  {', '    retVal = currVal + (trapezoid > 0 ? 0.5 * valToComp : valToComp); ', '  }', '  else // mean', '  {', '    retVal = currVal + (trapezoid > 0 ? 0.5 * valToComp : valToComp); ', '  }', '  return retVal;', '}']);\n    }\n    FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::TCoord::Dec', tcoordFSDec).result;\n    var tcoordFSImpl = ['if (any(greaterThan(fragTexCoord, vec3(1.0))) || any(lessThan(fragTexCoord, vec3(0.0))))', '{', '  // set the background color and exit', '  gl_FragData[0] = backgroundColor;', '  return;', '}', 'vec4 tvalue = texture(texture1, fragTexCoord);'];\n    if (slabThickness > 0.0) {\n      tcoordFSImpl = tcoordFSImpl.concat(['// Get the first and last samples', 'int numSlices = 1;', 'float scaling = min(min(spacing.x, spacing.y), spacing.z) * 0.5;', 'vec3 normalxspacing = scaling * normalWCVSOutput;', 'float distTraveled = length(normalxspacing);', 'int trapezoid = 0;', 'while (distTraveled < slabThickness * 0.5)', '{', '  distTraveled += length(normalxspacing);', '  float fnumSlices = float(numSlices);', '  if (distTraveled > slabThickness * 0.5)', '  {', '    // Before stepping outside the slab, sample at the boundaries', '    normalxspacing = normalWCVSOutput * slabThickness * 0.5 / fnumSlices;', '    trapezoid = slabTrapezoid;', '  }', '  vec3 fragTCoordNeg = (WCTCMatrix * vec4(vertexWCVSOutput.xyz - fnumSlices * normalxspacing * vboScaling, 1.0)).xyz;', '  if (!any(greaterThan(fragTCoordNeg, vec3(1.0))) && !any(lessThan(fragTCoordNeg, vec3(0.0))))', '  {', '    vec4 newVal = texture(texture1, fragTCoordNeg);', '    tvalue = compositeValue(tvalue, newVal, trapezoid);', '    numSlices += 1;', '  }', '  vec3 fragTCoordPos = (WCTCMatrix * vec4(vertexWCVSOutput.xyz + fnumSlices * normalxspacing * vboScaling, 1.0)).xyz;', '  if (!any(greaterThan(fragTCoordNeg, vec3(1.0))) && !any(lessThan(fragTCoordNeg, vec3(0.0))))', '  {', '    vec4 newVal = texture(texture1, fragTCoordPos);', '    tvalue = compositeValue(tvalue, newVal, trapezoid);', '    numSlices += 1;', '  }', '}', '// Finally, if slab type is *mean*, divide the sum by the numSlices', 'if (slabType == 2)', '{', '  tvalue = tvalue / float(numSlices);', '}']);\n    }\n    if (iComps) {\n      var rgba = ['r', 'g', 'b', 'a'];\n      for (var _comp = 0; _comp < tNumComp; ++_comp) {\n        tcoordFSImpl = tcoordFSImpl.concat([\"vec3 tcolor\".concat(_comp, \" = mix\").concat(_comp, \" * texture2D(colorTexture1, vec2(tvalue.\").concat(rgba[_comp], \" * cscale\").concat(_comp, \" + cshift\").concat(_comp, \", height\").concat(_comp, \")).rgb;\"), \"float compWeight\".concat(_comp, \" = mix\").concat(_comp, \" * texture2D(pwfTexture1, vec2(tvalue.\").concat(rgba[_comp], \" * pwfscale\").concat(_comp, \" + pwfshift\").concat(_comp, \", height\").concat(_comp, \")).r;\")]);\n      }\n      switch (tNumComp) {\n        case 1:\n          tcoordFSImpl = tcoordFSImpl.concat(['gl_FragData[0] = vec4(tcolor0.rgb, compWeight0 * opacity);']);\n          break;\n        case 2:\n          tcoordFSImpl = tcoordFSImpl.concat(['float weightSum = compWeight0 + compWeight1;', 'gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum))), opacity);']);\n          break;\n        case 3:\n          tcoordFSImpl = tcoordFSImpl.concat(['float weightSum = compWeight0 + compWeight1 + compWeight2;', 'gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum))), opacity);']);\n          break;\n        case 4:\n          tcoordFSImpl = tcoordFSImpl.concat(['float weightSum = compWeight0 + compWeight1 + compWeight2 + compWeight3;', 'gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum)) + (tcolor3.rgb * (compWeight3 / weightSum))), opacity);']);\n          break;\n        default:\n          vtkErrorMacro('Unsupported number of independent coordinates.');\n      }\n    } else {\n      // dependent components\n      switch (tNumComp) {\n        case 1:\n          tcoordFSImpl = tcoordFSImpl.concat(['// Dependent components', 'float intensity = tvalue.r;', 'vec3 tcolor = texture2D(colorTexture1, vec2(intensity * cscale0 + cshift0, 0.5)).rgb;', 'float scalarOpacity = texture2D(pwfTexture1, vec2(intensity * pwfscale0 + pwfshift0, 0.5)).r;', 'gl_FragData[0] = vec4(tcolor, scalarOpacity * opacity);']);\n          break;\n        case 2:\n          tcoordFSImpl = tcoordFSImpl.concat(['float intensity = tvalue.r*cscale0 + cshift0;', 'gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(intensity, 0.5)).rgb, pwfscale0*tvalue.g + pwfshift0);']);\n          break;\n        case 3:\n          tcoordFSImpl = tcoordFSImpl.concat(['vec4 tcolor = cscale0*tvalue + cshift0;', 'gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,', '  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,', '  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, opacity);']);\n          break;\n        default:\n          tcoordFSImpl = tcoordFSImpl.concat(['vec4 tcolor = cscale0*tvalue + cshift0;', 'gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,', '  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,', '  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, tcolor.a);']);\n      }\n    }\n    FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::TCoord::Impl', tcoordFSImpl).result;\n    shaders.Vertex = VSSource;\n    shaders.Fragment = FSSource;\n    shaders.Geometry = GSSource;\n  };\n  publicAPI.replaceShaderPositionVC = function (shaders, ren, actor) {\n    var VSSource = shaders.Vertex;\n    var GSSource = shaders.Geometry;\n    var FSSource = shaders.Fragment;\n    var slabThickness = model.renderable.getSlabThickness();\n    var posVCVSDec = ['attribute vec4 vertexWC;']; // Add a unique hash to the shader to ensure that the shader program is unique to this mapper.\n\n    posVCVSDec = posVCVSDec.concat([\"//\".concat(publicAPI.getMTime()).concat(model.resliceGeomUpdateString)]);\n    if (slabThickness > 0.0) {\n      posVCVSDec = posVCVSDec.concat(['attribute vec3 normalWC;', 'varying vec3 normalWCVSOutput;', 'varying vec4 vertexWCVSOutput;']);\n    }\n    VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::PositionVC::Dec', posVCVSDec).result;\n    var posVCVSImpl = ['gl_Position = MCPCMatrix * vertexWC;'];\n    if (slabThickness > 0.0) {\n      posVCVSImpl = posVCVSImpl.concat(['normalWCVSOutput = normalWC;', 'vertexWCVSOutput = vertexWC;']);\n    }\n    VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::PositionVC::Impl', posVCVSImpl).result;\n    VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::Camera::Dec', ['uniform mat4 MCPCMatrix;', 'uniform mat4 MCVCMatrix;']).result;\n    var posVCFSDec = [];\n    if (slabThickness > 0.0) {\n      posVCFSDec = posVCFSDec.concat(['varying vec3 normalWCVSOutput;', 'varying vec4 vertexWCVSOutput;']);\n    }\n    FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::PositionVC::Dec', posVCFSDec).result;\n    shaders.Vertex = VSSource;\n    shaders.Geometry = GSSource;\n    shaders.Fragment = FSSource;\n  };\n  function isVectorAxisAligned(n) {\n    vtkMath.normalize(n);\n    var tmpN = [0, 0, 0];\n    for (var i = 0; i < 3; ++i) {\n      vec3.zero(tmpN);\n      tmpN[i] = 1.0;\n      var dotP = vtkMath.dot(n, tmpN);\n      if (dotP < -0.999 || dotP > 0.999) {\n        return [true, i];\n      }\n    }\n    return [false, 2];\n  }\n  publicAPI.updateResliceGeometry = function () {\n    var resGeomString = '';\n    var image = model.currentInput;\n    var imageBounds = image === null || image === void 0 ? void 0 : image.getBounds(); // Orthogonal slicing by default\n\n    var orthoSlicing = true;\n    var orthoAxis = 2;\n    var slicePD = model.renderable.getSlicePolyData();\n    var slicePlane = model.renderable.getSlicePlane();\n    if (slicePD) {\n      resGeomString = resGeomString.concat(\"PolyData\".concat(slicePD.getMTime()));\n    } else if (slicePlane) {\n      resGeomString = resGeomString.concat(\"Plane\".concat(slicePlane.getMTime()));\n      if (image) {\n        resGeomString = resGeomString.concat(\"Image\".concat(image.getMTime()));\n      } // Check to see if we can bypass oblique slicing related bounds computation\n      // Compute a world-to-image-orientation matrix.\n      // Ignore the translation component since we are\n      // using it on vectors rather than positions.\n\n      var w2io = mat3.fromValues(image === null || image === void 0 ? void 0 : image.getDirection());\n      mat3.invert(w2io, w2io); // transform the cutting plane normal to image local coords\n\n      var imageLocalNormal = _toConsumableArray(slicePlane.getNormal());\n      vec3.transformMat3(imageLocalNormal, imageLocalNormal, w2io);\n      var _isVectorAxisAligned = isVectorAxisAligned(imageLocalNormal);\n      var _isVectorAxisAligned2 = _slicedToArray(_isVectorAxisAligned, 2);\n      orthoSlicing = _isVectorAxisAligned2[0];\n      orthoAxis = _isVectorAxisAligned2[1];\n    } else {\n      // Create a default slice plane here\n      var plane = vtkPlane.newInstance();\n      plane.setNormal(0, 0, 1);\n      var bds = [0, 1, 0, 1, 0, 1];\n      if (image) {\n        bds = imageBounds;\n      }\n      plane.setOrigin(bds[0], bds[2], 0.5 * (bds[5] + bds[4]));\n      model.renderable.setSlicePlane(plane);\n      resGeomString = resGeomString.concat(\"Plane\".concat(slicePlane === null || slicePlane === void 0 ? void 0 : slicePlane.getMTime()));\n      if (image) {\n        resGeomString = resGeomString.concat(\"Image\".concat(image.getMTime()));\n      }\n    }\n    if (!model.resliceGeom || model.resliceGeomUpdateString !== resGeomString) {\n      var _model$resliceGeom;\n      if (slicePD) {\n        if (!model.resliceGeom) {\n          model.resliceGeom = vtkPolyData.newInstance();\n        }\n        model.resliceGeom.getPoints().setData(slicePD.getPoints().getData(), 3);\n        model.resliceGeom.getPolys().setData(slicePD.getPolys().getData(), 1);\n        model.resliceGeom.getPointData().setNormals(slicePD.getPointData().getNormals());\n      } else if (slicePlane) {\n        if (!orthoSlicing) {\n          model.outlineFilter.setInputData(image);\n          model.cutter.setInputConnection(model.outlineFilter.getOutputPort());\n          model.cutter.setCutFunction(slicePlane);\n          model.lineToSurfaceFilter.setInputConnection(model.cutter.getOutputPort());\n          model.lineToSurfaceFilter.update();\n          if (!model.resliceGeom) {\n            model.resliceGeom = vtkPolyData.newInstance();\n          }\n          var planePD = model.lineToSurfaceFilter.getOutputData();\n          model.resliceGeom.getPoints().setData(planePD.getPoints().getData(), 3);\n          model.resliceGeom.getPolys().setData(planePD.getPolys().getData(), 1);\n          model.resliceGeom.getPointData().setNormals(planePD.getPointData().getNormals()); // The above method does not generate point normals\n          // Set it manually here.\n\n          var n = slicePlane.getNormal();\n          var npts = model.resliceGeom.getNumberOfPoints();\n          vtkMath.normalize(n);\n          var normalsData = new Float32Array(npts * 3);\n          for (var i = 0; i < npts; ++i) {\n            normalsData[3 * i] = n[0];\n            normalsData[3 * i + 1] = n[1];\n            normalsData[3 * i + 2] = n[2];\n          }\n          var normals = vtkDataArray.newInstance({\n            numberOfComponents: 3,\n            values: normalsData,\n            name: 'Normals'\n          });\n          model.resliceGeom.getPointData().setNormals(normals);\n        } else {\n          // Since the image-local normal is axis-aligned, we\n          // can quickly construct the cutting plane using indexToWorld transforms.\n          var ptsArray = new Float32Array(12);\n          var indexSpacePlaneOrigin = image.worldToIndex(slicePlane.getOrigin(), [0, 0, 0]);\n          var otherAxes = [(orthoAxis + 1) % 3, (orthoAxis + 2) % 3].sort();\n          var dim = image.getDimensions();\n          var ext = [0, dim[0] - 1, 0, dim[1] - 1, 0, dim[2] - 1];\n          var ptIdx = 0;\n          for (var _i7 = 0; _i7 < 2; ++_i7) {\n            for (var j = 0; j < 2; ++j) {\n              ptsArray[ptIdx + orthoAxis] = indexSpacePlaneOrigin[orthoAxis];\n              ptsArray[ptIdx + otherAxes[0]] = ext[2 * otherAxes[0] + j];\n              ptsArray[ptIdx + otherAxes[1]] = ext[2 * otherAxes[1] + _i7];\n              ptIdx += 3;\n            }\n          }\n          model.transform.setMatrix(image.getIndexToWorld());\n          model.transform.transformPoints(ptsArray, ptsArray);\n          var cellArray = new Uint16Array(8);\n          cellArray[0] = 3;\n          cellArray[1] = 0;\n          cellArray[2] = 1;\n          cellArray[3] = 3;\n          cellArray[4] = 3;\n          cellArray[5] = 0;\n          cellArray[6] = 3;\n          cellArray[7] = 2;\n          var _n = slicePlane.getNormal();\n          vtkMath.normalize(_n);\n          var _normalsData = new Float32Array(12);\n          for (var _i8 = 0; _i8 < 4; ++_i8) {\n            _normalsData[3 * _i8] = _n[0];\n            _normalsData[3 * _i8 + 1] = _n[1];\n            _normalsData[3 * _i8 + 2] = _n[2];\n          }\n          if (!model.resliceGeom) {\n            model.resliceGeom = vtkPolyData.newInstance();\n          }\n          model.resliceGeom.getPoints().setData(ptsArray, 3);\n          model.resliceGeom.getPolys().setData(cellArray, 1);\n          var _normals = vtkDataArray.newInstance({\n            numberOfComponents: 3,\n            values: _normalsData,\n            name: 'Normals'\n          });\n          model.resliceGeom.getPointData().setNormals(_normals);\n        }\n      } else {\n        vtkErrorMacro('Something went wrong.', 'A default slice plane should have been created in the beginning of', 'updateResliceGeometry.');\n      }\n      model.resliceGeomUpdateString = resGeomString;\n      (_model$resliceGeom = model.resliceGeom) === null || _model$resliceGeom === void 0 ? void 0 : _model$resliceGeom.modified();\n    }\n  };\n  publicAPI.setOpenGLTexture = function (oglTex) {\n    if (oglTex) {\n      model.openGLTexture = oglTex;\n      model._externalOpenGLTexture = true;\n    }\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nvar DEFAULT_VALUES = {\n  VBOBuildTime: {},\n  VBOBuildString: null,\n  haveSeenDepthRequest: false,\n  lastHaveSeenDepthRequest: false,\n  lastIndependentComponents: false,\n  lastTextureComponents: 0,\n  lastSlabThickness: 0,\n  lastSlabTrapezoidIntegration: 0,\n  lastSlabType: -1,\n  openGLTexture: null,\n  openGLTextureString: null,\n  colorTextureString: null,\n  pwfTextureString: null,\n  resliceGeom: null,\n  resliceGeomUpdateString: null,\n  tris: null,\n  colorTexture: null,\n  pwfTexture: null,\n  _externalOpenGLTexture: false\n}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Inheritance\n\n  vtkViewNode.extend(publicAPI, model, initialValues);\n  vtkReplacementShaderMapper.implementReplaceShaderCoincidentOffset(publicAPI, model, initialValues);\n  vtkReplacementShaderMapper.implementBuildShadersWithReplacements(publicAPI, model, initialValues);\n  model.tris = vtkHelper.newInstance();\n  model.openGLTexture = vtkOpenGLTexture.newInstance();\n  model.colorTexture = vtkOpenGLTexture.newInstance();\n  model.pwfTexture = vtkOpenGLTexture.newInstance();\n  model.VBOBuildTime = {};\n  obj(model.VBOBuildTime);\n  model.tmpMat4 = mat4.identity(new Float64Array(16)); // Implicit plane to polydata related cache:\n\n  model.outlineFilter = vtkImageDataOutlineFilter.newInstance();\n  model.outlineFilter.setGenerateFaces(true);\n  model.outlineFilter.setGenerateLines(false);\n  model.cubePolyData = vtkPolyData.newInstance();\n  model.cutter = vtkCutter.newInstance();\n  model.lineToSurfaceFilter = vtkClosedPolyLineToSurfaceFilter.newInstance();\n  model.transform = vtkTransform.newInstance();\n  get(publicAPI, model, ['openGLTexture']); // Object methods\n\n  vtkOpenGLImageResliceMapper(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = newInstance$1(extend, 'vtkOpenGLImageResliceMapper'); // ----------------------------------------------------------------------------\n\nvar vtkImageResliceMapper = {\n  newInstance: newInstance,\n  extend: extend\n}; // Register ourself to OpenGL backend if imported\n\nregisterOverride('vtkImageResliceMapper', newInstance);\nexport { vtkImageResliceMapper as default, extend, newInstance };","map":{"version":3,"names":["_slicedToArray","_toConsumableArray","newInstance","newInstance$1","obj","get","vtkErrorMacro","vtkErrorMacro$1","mat4","mat3","vec3","vtkClosedPolyLineToSurfaceFilter","vtkCutter","vtkDataArray","vtkHelper","vtkImageDataOutlineFilter","f","vtkMath","vtkOpenGLTexture","vtkPlane","vtkPolyData","vtkReplacementShaderMapper","vtkShaderProgram","vtkTransform","vtkViewNode","v","vtkImageResliceMapperVS","vtkImageResliceMapperFS","Filter","InterpolationType","Representation","VtkDataTypes","registerOverride","computeFnToString","property","fn","numberOfComponents","pwfun","apply","iComps","getIndependentComponents","concat","getMTime","safeMatrixMultiply","matrixArray","matrixType","tmpMat","identity","reduce","res","matrix","index","copy","multiply","vtkOpenGLImageResliceMapper","publicAPI","model","classHierarchy","push","buildPass","prepass","currentRenderPass","_openGLImageSlice","getFirstAncestorOfType","_openGLRenderer","ren","getRenderable","_openGLCamera","getViewNodeFor","getActiveCamera","_openGLRenderWindow","getParent","context","getContext","tris","setOpenGLRenderWindow","openGLTexture","colorTexture","pwfTexture","translucentPass","renderPass","render","zBufferPass","haveSeenDepthRequest","renderDepth","opaqueZBufferPass","opaquePass","getCoincidentParameters","actor","renderable","getResolveCoincidentTopology","getCoincidentTopologyPolygonOffsetParameters","renderPiece","invokeEvent","type","update","currentInput","getInputData","updateResliceGeometry","renderPieceStart","renderPieceDraw","renderPieceFinish","updateBufferObjects","iType","getProperty","getInterpolationType","NEAREST","setMinificationFilter","setMagnificationFilter","LINEAR","lastBoundBO","gl","activate","updateShaders","drawArrays","TRIANGLES","getCABO","getElementCount","getVAO","release","deactivate","getNeedToRebuildBufferObjects","buildBufferObjects","VBOBuildTime","resliceGeom","_image$getPointData","image","scalars","getPointData","getScalars","numComp","getNumberOfComponents","_externalOpenGLTexture","_toString","openGLTextureString","dims","getDimensions","getOglNorm16Ext","getExtension","releaseGraphicsResources","resetFormatAndType","create3DFilterableFromDataArray","ppty","numIComps","textureHeight","cfunToString","getRGBTransferFunction","colorTextureString","cWidth","cSize","cTable","Uint8Array","cfun","tmpTable","Float32Array","c","cRange","getRange","getTable","i","_i","create2DFromRaw","UNSIGNED_CHAR","_i2","pwfunToString","getPiecewiseFunction","pwfTextureString","pwfWidth","pwfSize","pwfTable","pwfFloatTable","_tmpTable","_c","fill","pwfRange","_i3","_i4","FLOAT","vboString","getSlabThickness","VBOBuildString","points","values","getPoints","getData","setName","cells","getPolys","options","cellOffset","n","getNormals","normals","createVBO","SURFACE","modified","cellBO","getNeedToRebuildShaders","shaders","Vertex","Fragment","Geometry","buildShaders","newShader","getShaderCache","readyShaderProgramArray","getProgram","setProgram","getShaderSourceTime","readyShaderProgram","bind","setMapperShaderParameters","setCameraShaderParameters","setPropertyShaderParameters","program","getAttributeUpdateTime","isUniformUsed","setUniformi","getTextureUnit","isAttributeUsed","addAttributeArray","getVertexOffset","getStride","FALSE","getNormalOffset","setUniformf","setUniform3fv","getSpacing","getSlabType","getSlabTrapezoidIntegration","shiftScaleEnabled","getCoordShiftAndScaleEnabled","inverseShiftScaleMatrix","getInverseShiftAndScaleMatrix","dim","tmpMat4","getIndexToWorld","scale","invert","setUniformMatrix","getCoordScale","cp","offset","factor","keyMats","getKeyMatrices","actMats","wcpc","mcwc","wcvc","opacity","getOpacity","getComponents","getComponentWeight","volInfo","getVolumeInfo","_i5","cw","getColorWindow","cl","getColorLevel","target","getUseLookupTableScalarRange","shift","texColorUnit","_i6","pwfScale","pwfShift","_target","length","mid","texOpacityUnit","setUniform4fv","getBackgroundColor","tNumComp","iComp","slabTh","slabType","slabTrap","needRebuild","lastRenderPassShaderReplacement","getShaderReplacement","lastHaveSeenDepthRequest","lastTextureComponents","lastIndependentComponents","lastSlabThickness","lastSlabType","lastSlabTrapezoidIntegration","getShaderTemplate","replaceShaderValues","replaceShaderTCoord","replaceShaderPositionVC","FSSource","substitute","result","replaceShaderCoincidentOffset","VSSource","GSSource","tcoordVSDec","slabThickness","tcoordVSImpl","tcoordFSDec","comp","tcoordFSImpl","rgba","_comp","posVCVSDec","resliceGeomUpdateString","posVCVSImpl","posVCFSDec","isVectorAxisAligned","normalize","tmpN","zero","dotP","dot","resGeomString","imageBounds","getBounds","orthoSlicing","orthoAxis","slicePD","getSlicePolyData","slicePlane","getSlicePlane","w2io","fromValues","getDirection","imageLocalNormal","getNormal","transformMat3","_isVectorAxisAligned","_isVectorAxisAligned2","plane","setNormal","bds","setOrigin","setSlicePlane","_model$resliceGeom","setData","setNormals","outlineFilter","setInputData","cutter","setInputConnection","getOutputPort","setCutFunction","lineToSurfaceFilter","planePD","getOutputData","npts","getNumberOfPoints","normalsData","name","ptsArray","indexSpacePlaneOrigin","worldToIndex","getOrigin","otherAxes","sort","ext","ptIdx","_i7","j","transform","setMatrix","transformPoints","cellArray","Uint16Array","_n","_normalsData","_i8","_normals","setOpenGLTexture","oglTex","DEFAULT_VALUES","extend","initialValues","arguments","undefined","Object","assign","implementReplaceShaderCoincidentOffset","implementBuildShadersWithReplacements","Float64Array","setGenerateFaces","setGenerateLines","cubePolyData","vtkImageResliceMapper","default"],"sources":["/home/rakshith/Documents/RemoteRendering/vtk-js-react-app/node_modules/@kitware/vtk.js/Rendering/OpenGL/ImageResliceMapper.js"],"sourcesContent":["import _slicedToArray from '@babel/runtime/helpers/slicedToArray';\nimport _toConsumableArray from '@babel/runtime/helpers/toConsumableArray';\nimport { newInstance as newInstance$1, obj, get, vtkErrorMacro as vtkErrorMacro$1 } from '../../macros.js';\nimport { mat4, mat3, vec3 } from 'gl-matrix';\nimport vtkClosedPolyLineToSurfaceFilter from '../../Filters/General/ClosedPolyLineToSurfaceFilter.js';\nimport vtkCutter from '../../Filters/Core/Cutter.js';\nimport vtkDataArray from '../../Common/Core/DataArray.js';\nimport vtkHelper from './Helper.js';\nimport vtkImageDataOutlineFilter from '../../Filters/General/ImageDataOutlineFilter.js';\nimport { f as vtkMath } from '../../Common/Core/Math/index.js';\nimport vtkOpenGLTexture from './Texture.js';\nimport vtkPlane from '../../Common/DataModel/Plane.js';\nimport vtkPolyData from '../../Common/DataModel/PolyData.js';\nimport vtkReplacementShaderMapper from './ReplacementShaderMapper.js';\nimport vtkShaderProgram from './ShaderProgram.js';\nimport vtkTransform from '../../Common/Transform/Transform.js';\nimport vtkViewNode from '../SceneGraph/ViewNode.js';\nimport { v as vtkImageResliceMapperVS } from './glsl/vtkImageResliceMapperVS.glsl.js';\nimport { v as vtkImageResliceMapperFS } from './glsl/vtkImageResliceMapperFS.glsl.js';\nimport { Filter } from './Texture/Constants.js';\nimport { InterpolationType } from '../Core/ImageProperty/Constants.js';\nimport { Representation } from '../Core/Property/Constants.js';\nimport { VtkDataTypes } from '../../Common/Core/DataArray/Constants.js';\nimport { registerOverride } from './ViewNodeFactory.js';\n\nvar vtkErrorMacro = vtkErrorMacro$1; // ----------------------------------------------------------------------------\n// helper methods\n// ----------------------------------------------------------------------------\n\nfunction computeFnToString(property, fn, numberOfComponents) {\n  var pwfun = fn.apply(property);\n\n  if (pwfun) {\n    var iComps = property.getIndependentComponents();\n    return \"\".concat(property.getMTime(), \"-\").concat(iComps, \"-\").concat(numberOfComponents);\n  }\n\n  return '0';\n}\n\nfunction safeMatrixMultiply(matrixArray, matrixType, tmpMat) {\n  matrixType.identity(tmpMat);\n  return matrixArray.reduce(function (res, matrix, index) {\n    if (index === 0) {\n      return matrix ? matrixType.copy(res, matrix) : matrixType.identity(res);\n    }\n\n    return matrix ? matrixType.multiply(res, res, matrix) : res;\n  }, tmpMat);\n} // ----------------------------------------------------------------------------\n// vtkOpenGLImageResliceMapper methods\n// ----------------------------------------------------------------------------\n\n\nfunction vtkOpenGLImageResliceMapper(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkOpenGLImageResliceMapper');\n\n  publicAPI.buildPass = function (prepass) {\n    if (prepass) {\n      model.currentRenderPass = null;\n      model._openGLImageSlice = publicAPI.getFirstAncestorOfType('vtkOpenGLImageSlice');\n      model._openGLRenderer = publicAPI.getFirstAncestorOfType('vtkOpenGLRenderer');\n\n      var ren = model._openGLRenderer.getRenderable();\n\n      model._openGLCamera = model._openGLRenderer.getViewNodeFor(ren.getActiveCamera());\n      model._openGLRenderWindow = model._openGLRenderer.getParent();\n      model.context = model._openGLRenderWindow.getContext();\n      model.tris.setOpenGLRenderWindow(model._openGLRenderWindow);\n\n      if (!model.openGLTexture) {\n        model.openGLTexture = vtkOpenGLTexture.newInstance();\n      }\n\n      model.openGLTexture.setOpenGLRenderWindow(model._openGLRenderWindow);\n      model.colorTexture.setOpenGLRenderWindow(model._openGLRenderWindow);\n      model.pwfTexture.setOpenGLRenderWindow(model._openGLRenderWindow);\n    }\n  };\n\n  publicAPI.translucentPass = function (prepass, renderPass) {\n    if (prepass) {\n      model.currentRenderPass = renderPass;\n      publicAPI.render();\n    }\n  };\n\n  publicAPI.zBufferPass = function (prepass) {\n    if (prepass) {\n      model.haveSeenDepthRequest = true;\n      model.renderDepth = true;\n      publicAPI.render();\n      model.renderDepth = false;\n    }\n  };\n\n  publicAPI.opaqueZBufferPass = function (prepass) {\n    return publicAPI.zBufferPass(prepass);\n  };\n\n  publicAPI.opaquePass = function (prepass) {\n    if (prepass) {\n      publicAPI.render();\n    }\n  };\n\n  publicAPI.getCoincidentParameters = function (ren, actor) {\n    if (model.renderable.getResolveCoincidentTopology()) {\n      return model.renderable.getCoincidentTopologyPolygonOffsetParameters();\n    }\n\n    return null;\n  }; // Renders myself\n\n\n  publicAPI.render = function () {\n    var actor = model._openGLImageSlice.getRenderable();\n\n    var ren = model._openGLRenderer.getRenderable();\n\n    publicAPI.renderPiece(ren, actor);\n  };\n\n  publicAPI.renderPiece = function (ren, actor) {\n    publicAPI.invokeEvent({\n      type: 'StartEvent'\n    });\n    model.renderable.update();\n    model.currentInput = model.renderable.getInputData();\n\n    if (!model.currentInput) {\n      vtkErrorMacro('No input!');\n      return;\n    }\n\n    publicAPI.updateResliceGeometry();\n    publicAPI.renderPieceStart(ren, actor);\n    publicAPI.renderPieceDraw(ren, actor);\n    publicAPI.renderPieceFinish(ren, actor);\n    publicAPI.invokeEvent({\n      type: 'EndEvent'\n    });\n  };\n\n  publicAPI.renderPieceStart = function (ren, actor) {\n    // make sure the BOs are up to date\n    publicAPI.updateBufferObjects(ren, actor);\n    var iType = actor.getProperty().getInterpolationType();\n\n    if (iType === InterpolationType.NEAREST) {\n      model.openGLTexture.setMinificationFilter(Filter.NEAREST);\n      model.openGLTexture.setMagnificationFilter(Filter.NEAREST);\n      model.colorTexture.setMinificationFilter(Filter.NEAREST);\n      model.colorTexture.setMagnificationFilter(Filter.NEAREST);\n      model.pwfTexture.setMinificationFilter(Filter.NEAREST);\n      model.pwfTexture.setMagnificationFilter(Filter.NEAREST);\n    } else {\n      model.openGLTexture.setMinificationFilter(Filter.LINEAR);\n      model.openGLTexture.setMagnificationFilter(Filter.LINEAR);\n      model.colorTexture.setMinificationFilter(Filter.LINEAR);\n      model.colorTexture.setMagnificationFilter(Filter.LINEAR);\n      model.pwfTexture.setMinificationFilter(Filter.LINEAR);\n      model.pwfTexture.setMagnificationFilter(Filter.LINEAR);\n    } // No buffer objects bound.\n\n\n    model.lastBoundBO = null;\n  };\n\n  publicAPI.renderPieceDraw = function (ren, actor) {\n    var gl = model.context; // render the texture\n\n    model.openGLTexture.activate();\n    model.colorTexture.activate();\n    model.pwfTexture.activate(); // update shaders if required\n\n    publicAPI.updateShaders(model.tris, ren, actor); // Finally draw\n\n    gl.drawArrays(gl.TRIANGLES, 0, model.tris.getCABO().getElementCount());\n    model.tris.getVAO().release();\n    model.openGLTexture.deactivate();\n    model.colorTexture.deactivate();\n    model.pwfTexture.deactivate();\n  };\n\n  publicAPI.renderPieceFinish = function (ren, actor) {};\n\n  publicAPI.updateBufferObjects = function (ren, actor) {\n    // Rebuild buffer objects if needed\n    if (publicAPI.getNeedToRebuildBufferObjects(ren, actor)) {\n      publicAPI.buildBufferObjects(ren, actor);\n    }\n  };\n\n  publicAPI.getNeedToRebuildBufferObjects = function (ren, actor) {\n    return model.VBOBuildTime.getMTime() < publicAPI.getMTime() || model.VBOBuildTime.getMTime() < actor.getMTime() || model.VBOBuildTime.getMTime() < model.renderable.getMTime() || model.VBOBuildTime.getMTime() < actor.getProperty().getMTime() || model.VBOBuildTime.getMTime() < model.currentInput.getMTime() || model.VBOBuildTime.getMTime() < model.resliceGeom.getMTime();\n  };\n\n  publicAPI.buildBufferObjects = function (ren, actor) {\n    var _image$getPointData;\n\n    var image = model.currentInput;\n\n    if (!image) {\n      return;\n    }\n\n    var scalars = (_image$getPointData = image.getPointData()) === null || _image$getPointData === void 0 ? void 0 : _image$getPointData.getScalars();\n\n    if (!scalars) {\n      return;\n    }\n\n    var numComp = scalars.getNumberOfComponents();\n\n    if (!model._externalOpenGLTexture) {\n      var _toString = \"\".concat(image.getMTime(), \"A\").concat(scalars.getMTime());\n\n      if (model.openGLTextureString !== _toString) {\n        // Build the image scalar texture\n        var dims = image.getDimensions(); // Use norm16 for the 3D texture if the extension is available\n\n        model.openGLTexture.getOglNorm16Ext(model.context.getExtension('EXT_texture_norm16'));\n        model.openGLTexture.releaseGraphicsResources(model._openGLRenderWindow);\n        model.openGLTexture.resetFormatAndType();\n        model.openGLTexture.create3DFilterableFromDataArray(dims[0], dims[1], dims[2], scalars);\n        model.openGLTextureString = _toString;\n      }\n    }\n\n    var ppty = actor.getProperty();\n    var iComps = ppty.getIndependentComponents();\n    var numIComps = iComps ? numComp : 1;\n    var textureHeight = iComps ? 2 * numIComps : 1;\n    var cfunToString = computeFnToString(ppty, ppty.getRGBTransferFunction, numIComps);\n\n    if (model.colorTextureString !== cfunToString) {\n      var cWidth = 1024;\n      var cSize = cWidth * textureHeight * 3;\n      var cTable = new Uint8Array(cSize);\n      var cfun = ppty.getRGBTransferFunction();\n\n      if (cfun) {\n        var tmpTable = new Float32Array(cWidth * 3);\n\n        for (var c = 0; c < numIComps; c++) {\n          cfun = ppty.getRGBTransferFunction(c);\n          var cRange = cfun.getRange();\n          cfun.getTable(cRange[0], cRange[1], cWidth, tmpTable, 1);\n\n          if (iComps) {\n            for (var i = 0; i < cWidth * 3; i++) {\n              cTable[c * cWidth * 6 + i] = 255.0 * tmpTable[i];\n              cTable[c * cWidth * 6 + i + cWidth * 3] = 255.0 * tmpTable[i];\n            }\n          } else {\n            for (var _i = 0; _i < cWidth * 3; _i++) {\n              cTable[c * cWidth * 6 + _i] = 255.0 * tmpTable[_i];\n            }\n          }\n        }\n\n        model.colorTexture.releaseGraphicsResources(model._openGLRenderWindow);\n        model.colorTexture.resetFormatAndType();\n        model.colorTexture.create2DFromRaw(cWidth, textureHeight, 3, VtkDataTypes.UNSIGNED_CHAR, cTable);\n      } else {\n        for (var _i2 = 0; _i2 < cWidth * 3; ++_i2) {\n          cTable[_i2] = 255.0 * _i2 / ((cWidth - 1) * 3);\n          cTable[_i2 + 1] = 255.0 * _i2 / ((cWidth - 1) * 3);\n          cTable[_i2 + 2] = 255.0 * _i2 / ((cWidth - 1) * 3);\n        }\n\n        model.colorTexture.create2DFromRaw(cWidth, 1, 3, VtkDataTypes.UNSIGNED_CHAR, cTable);\n      }\n\n      model.colorTextureString = cfunToString;\n    } // Build piecewise function buffer.  This buffer is used either\n    // for component weighting or opacity, depending on whether we're\n    // rendering components independently or not.\n\n\n    var pwfunToString = computeFnToString(ppty, ppty.getPiecewiseFunction, numIComps);\n\n    if (model.pwfTextureString !== pwfunToString) {\n      var pwfWidth = 1024;\n      var pwfSize = pwfWidth * textureHeight;\n      var pwfTable = new Uint8Array(pwfSize);\n      var pwfun = ppty.getPiecewiseFunction(); // support case where pwfun is added/removed\n\n      model.pwfTexture.releaseGraphicsResources(model._openGLRenderWindow);\n      model.pwfTexture.resetFormatAndType();\n\n      if (pwfun) {\n        var pwfFloatTable = new Float32Array(pwfSize);\n\n        var _tmpTable = new Float32Array(pwfWidth);\n\n        for (var _c = 0; _c < numIComps; ++_c) {\n          pwfun = ppty.getPiecewiseFunction(_c);\n\n          if (pwfun === null) {\n            // Piecewise constant max if no function supplied for this component\n            pwfFloatTable.fill(1.0);\n          } else {\n            var pwfRange = pwfun.getRange();\n            pwfun.getTable(pwfRange[0], pwfRange[1], pwfWidth, _tmpTable, 1); // adjust for sample distance etc\n\n            if (iComps) {\n              for (var _i3 = 0; _i3 < pwfWidth; _i3++) {\n                pwfFloatTable[_c * pwfWidth * 2 + _i3] = _tmpTable[_i3];\n                pwfFloatTable[_c * pwfWidth * 2 + _i3 + pwfWidth] = _tmpTable[_i3];\n              }\n            } else {\n              for (var _i4 = 0; _i4 < pwfWidth; _i4++) {\n                pwfFloatTable[_c * pwfWidth * 2 + _i4] = _tmpTable[_i4];\n              }\n            }\n          }\n        }\n\n        model.pwfTexture.create2DFromRaw(pwfWidth, textureHeight, 1, VtkDataTypes.FLOAT, pwfFloatTable);\n      } else {\n        // default is opaque\n        pwfTable.fill(255.0);\n        model.pwfTexture.create2DFromRaw(pwfWidth, 1, 1, VtkDataTypes.UNSIGNED_CHAR, pwfTable);\n      }\n\n      model.pwfTextureString = pwfunToString;\n    }\n\n    var vboString = \"\".concat(model.resliceGeom.getMTime(), \"A\").concat(model.renderable.getSlabThickness());\n\n    if (!model.tris.getCABO().getElementCount() || model.VBOBuildString !== vboString) {\n      var points = vtkDataArray.newInstance({\n        numberOfComponents: 3,\n        values: model.resliceGeom.getPoints().getData()\n      });\n      points.setName('points');\n      var cells = vtkDataArray.newInstance({\n        numberOfComponents: 1,\n        values: model.resliceGeom.getPolys().getData()\n      });\n      var options = {\n        points: points,\n        cellOffset: 0\n      };\n\n      if (model.renderable.getSlabThickness() > 0.0) {\n        var n = model.resliceGeom.getPointData().getNormals();\n\n        if (!n) {\n          vtkErrorMacro('Slab mode requested without normals');\n        } else {\n          options.normals = n;\n        }\n      }\n\n      model.tris.getCABO().createVBO(cells, 'polys', Representation.SURFACE, options);\n    }\n\n    model.VBOBuildString = vboString;\n    model.VBOBuildTime.modified();\n  };\n\n  publicAPI.updateShaders = function (cellBO, ren, actor) {\n    model.lastBoundBO = cellBO; // has something changed that would require us to recreate the shader?\n\n    if (publicAPI.getNeedToRebuildShaders(cellBO, ren, actor)) {\n      var shaders = {\n        Vertex: null,\n        Fragment: null,\n        Geometry: null\n      };\n      publicAPI.buildShaders(shaders, ren, actor); // compile and bind the program if needed\n\n      var newShader = model._openGLRenderWindow.getShaderCache().readyShaderProgramArray(shaders.Vertex, shaders.Fragment, shaders.Geometry); // if the shader changed reinitialize the VAO\n\n\n      if (newShader !== cellBO.getProgram()) {\n        cellBO.setProgram(newShader); // reset the VAO as the shader has changed\n\n        cellBO.getVAO().releaseGraphicsResources();\n      }\n\n      cellBO.getShaderSourceTime().modified();\n    } else {\n      model._openGLRenderWindow.getShaderCache().readyShaderProgram(cellBO.getProgram());\n    }\n\n    cellBO.getVAO().bind();\n    publicAPI.setMapperShaderParameters(cellBO, ren, actor);\n    publicAPI.setCameraShaderParameters(cellBO, ren, actor);\n    publicAPI.setPropertyShaderParameters(cellBO, ren, actor);\n  };\n\n  publicAPI.setMapperShaderParameters = function (cellBO, ren, actor) {\n    var program = cellBO.getProgram();\n\n    if (cellBO.getCABO().getElementCount() && (model.VBOBuildTime.getMTime() > cellBO.getAttributeUpdateTime().getMTime() || cellBO.getShaderSourceTime().getMTime() > cellBO.getAttributeUpdateTime().getMTime())) {\n      // Set the 3D texture\n      if (program.isUniformUsed('texture1')) {\n        program.setUniformi('texture1', model.openGLTexture.getTextureUnit());\n      } // Set the plane vertex attributes\n\n\n      if (program.isAttributeUsed('vertexWC')) {\n        if (!cellBO.getVAO().addAttributeArray(program, cellBO.getCABO(), 'vertexWC', cellBO.getCABO().getVertexOffset(), cellBO.getCABO().getStride(), model.context.FLOAT, 3, model.context.FALSE)) {\n          vtkErrorMacro('Error setting vertexWC in shader VAO.');\n        }\n      } // If we are doing slab mode, we need normals\n\n\n      if (program.isAttributeUsed('normalWC')) {\n        if (!cellBO.getVAO().addAttributeArray(program, cellBO.getCABO(), 'normalWC', cellBO.getCABO().getNormalOffset(), cellBO.getCABO().getStride(), model.context.FLOAT, 3, model.context.FALSE)) {\n          vtkErrorMacro('Error setting normalWC in shader VAO.');\n        }\n      }\n\n      if (program.isUniformUsed('slabThickness')) {\n        program.setUniformf('slabThickness', model.renderable.getSlabThickness());\n      }\n\n      if (program.isUniformUsed('spacing')) {\n        program.setUniform3fv('spacing', model.currentInput.getSpacing());\n      }\n\n      if (program.isUniformUsed('slabType')) {\n        program.setUniformi('slabType', model.renderable.getSlabType());\n      }\n\n      if (program.isUniformUsed('slabType')) {\n        program.setUniformi('slabType', model.renderable.getSlabType());\n      }\n\n      if (program.isUniformUsed('slabTrapezoid')) {\n        program.setUniformi('slabTrapezoid', model.renderable.getSlabTrapezoidIntegration());\n      }\n\n      var shiftScaleEnabled = cellBO.getCABO().getCoordShiftAndScaleEnabled();\n      var inverseShiftScaleMatrix = shiftScaleEnabled ? cellBO.getCABO().getInverseShiftAndScaleMatrix() : null; // Set the world->texture matrix\n\n      if (program.isUniformUsed('WCTCMatrix')) {\n        var image = model.currentInput;\n        var dim = image.getDimensions();\n        mat4.copy(model.tmpMat4, image.getIndexToWorld());\n        mat4.scale(model.tmpMat4, model.tmpMat4, dim);\n        mat4.invert(model.tmpMat4, model.tmpMat4);\n\n        if (inverseShiftScaleMatrix) {\n          mat4.multiply(model.tmpMat4, model.tmpMat4, inverseShiftScaleMatrix);\n        }\n\n        program.setUniformMatrix('WCTCMatrix', model.tmpMat4);\n      }\n\n      if (program.isUniformUsed('vboScaling')) {\n        program.setUniform3fv('vboScaling', cellBO.getCABO().getCoordScale());\n      }\n\n      cellBO.getAttributeUpdateTime().modified();\n    } // Depth request\n\n\n    if (model.haveSeenDepthRequest) {\n      cellBO.getProgram().setUniformi('depthRequest', model.renderDepth ? 1 : 0);\n    } // handle coincident\n\n\n    if (cellBO.getProgram().isUniformUsed('coffset')) {\n      var cp = publicAPI.getCoincidentParameters(ren, actor);\n      cellBO.getProgram().setUniformf('coffset', cp.offset); // cfactor isn't always used when coffset is.\n\n      if (cellBO.getProgram().isUniformUsed('cfactor')) {\n        cellBO.getProgram().setUniformf('cfactor', cp.factor);\n      }\n    }\n  };\n\n  publicAPI.setCameraShaderParameters = function (cellBO, ren, actor) {\n    // [WMVP]C == {world, model, view, projection} coordinates\n    // e.g. WCPC == world to projection coordinate transformation\n    var keyMats = model._openGLCamera.getKeyMatrices(ren);\n\n    var actMats = model._openGLImageSlice.getKeyMatrices();\n\n    var shiftScaleEnabled = cellBO.getCABO().getCoordShiftAndScaleEnabled();\n    var inverseShiftScaleMatrix = shiftScaleEnabled ? cellBO.getCABO().getInverseShiftAndScaleMatrix() : null;\n    var program = cellBO.getProgram();\n\n    if (program.isUniformUsed('MCPCMatrix')) {\n      mat4.identity(model.tmpMat4);\n      program.setUniformMatrix('MCPCMatrix', safeMatrixMultiply([keyMats.wcpc, actMats.mcwc, inverseShiftScaleMatrix], mat4, model.tmpMat4));\n    }\n\n    if (program.isUniformUsed('MCVCMatrix')) {\n      mat4.identity(model.tmpMat4);\n      program.setUniformMatrix('MCVCMatrix', safeMatrixMultiply([keyMats.wcvc, actMats.mcwc, inverseShiftScaleMatrix], mat4, model.tmpMat4));\n    }\n  };\n\n  publicAPI.setPropertyShaderParameters = function (cellBO, ren, actor) {\n    var program = cellBO.getProgram();\n    var ppty = actor.getProperty();\n    var opacity = ppty.getOpacity();\n    program.setUniformf('opacity', opacity); // Component mix\n    // Independent components: Mixed according to component weights\n    // Dependent components: Mixed using the following logic:\n    //    - 2 comps => LA\n    //    - 3 comps => RGB + opacity from pwf\n    //    - 4 comps => RGBA\n\n    var numComp = model.openGLTexture.getComponents();\n    var iComps = ppty.getIndependentComponents();\n\n    if (iComps) {\n      for (var i = 0; i < numComp; ++i) {\n        program.setUniformf(\"mix\".concat(i), ppty.getComponentWeight(i));\n      }\n    } // Color opacity map\n\n\n    var volInfo = model.openGLTexture.getVolumeInfo(); // three levels of shift scale combined into one\n    // for performance in the fragment shader\n\n    for (var _i5 = 0; _i5 < numComp; _i5++) {\n      var cw = ppty.getColorWindow();\n      var cl = ppty.getColorLevel();\n      var target = iComps ? _i5 : 0;\n      var cfun = ppty.getRGBTransferFunction(target);\n\n      if (cfun && ppty.getUseLookupTableScalarRange()) {\n        var cRange = cfun.getRange();\n        cw = cRange[1] - cRange[0];\n        cl = 0.5 * (cRange[1] + cRange[0]);\n      }\n\n      var scale = volInfo.scale[_i5] / cw;\n      var shift = (volInfo.offset[_i5] - cl) / cw + 0.5;\n      program.setUniformf(\"cshift\".concat(_i5), shift);\n      program.setUniformf(\"cscale\".concat(_i5), scale);\n    }\n\n    var texColorUnit = model.colorTexture.getTextureUnit();\n    program.setUniformi('colorTexture1', texColorUnit); // pwf shift/scale\n\n    for (var _i6 = 0; _i6 < numComp; _i6++) {\n      var pwfScale = 1.0;\n      var pwfShift = 0.0;\n\n      var _target = iComps ? _i6 : 0;\n\n      var pwfun = ppty.getPiecewiseFunction(_target);\n\n      if (pwfun) {\n        var pwfRange = pwfun.getRange();\n        var length = pwfRange[1] - pwfRange[0];\n        var mid = 0.5 * (pwfRange[0] + pwfRange[1]);\n        pwfScale = volInfo.scale[_i6] / length;\n        pwfShift = (volInfo.offset[_i6] - mid) / length + 0.5;\n      }\n\n      program.setUniformf(\"pwfshift\".concat(_i6), pwfShift);\n      program.setUniformf(\"pwfscale\".concat(_i6), pwfScale);\n    }\n\n    var texOpacityUnit = model.pwfTexture.getTextureUnit();\n    program.setUniformi('pwfTexture1', texOpacityUnit); // Background color\n\n    program.setUniform4fv('backgroundColor', model.renderable.getBackgroundColor());\n  };\n\n  publicAPI.getNeedToRebuildShaders = function (cellBO, ren, actor) {\n    // has something changed that would require us to recreate the shader?\n    // candidates are\n    // property modified (representation interpolation and lighting)\n    // input modified\n    // light complexity changed\n    // render pass shader replacement changed\n    var tNumComp = model.openGLTexture.getComponents();\n    var iComp = actor.getProperty().getIndependentComponents();\n    var slabTh = model.renderable.getSlabThickness();\n    var slabType = model.renderable.getSlabType();\n    var slabTrap = model.renderable.getSlabTrapezoidIntegration(); // has the render pass shader replacement changed? Two options\n\n    var needRebuild = false;\n\n    if (!model.currentRenderPass && model.lastRenderPassShaderReplacement || model.currentRenderPass && model.currentRenderPass.getShaderReplacement() !== model.lastRenderPassShaderReplacement) {\n      needRebuild = true;\n    }\n\n    if (needRebuild || model.lastHaveSeenDepthRequest !== model.haveSeenDepthRequest || cellBO.getProgram() === 0 || model.lastTextureComponents !== tNumComp || model.lastIndependentComponents !== iComp || model.lastSlabThickness !== slabTh || model.lastSlabType !== slabType || model.lastSlabTrapezoidIntegration !== slabTrap) {\n      model.lastHaveSeenDepthRequest = model.haveSeenDepthRequest;\n      model.lastTextureComponents = tNumComp;\n      model.lastIndependentComponents = iComp;\n      model.lastSlabThickness = slabTh;\n      model.lastSlabType = slabType;\n      model.lastSlabTrapezoidIntegration = slabTrap;\n      return true;\n    }\n\n    return false;\n  };\n\n  publicAPI.getShaderTemplate = function (shaders, ren, actor) {\n    shaders.Vertex = vtkImageResliceMapperVS;\n    shaders.Fragment = vtkImageResliceMapperFS;\n    shaders.Geometry = '';\n  };\n\n  publicAPI.replaceShaderValues = function (shaders, ren, actor) {\n    publicAPI.replaceShaderTCoord(shaders, ren, actor);\n    publicAPI.replaceShaderPositionVC(shaders, ren, actor);\n\n    if (model.haveSeenDepthRequest) {\n      var FSSource = shaders.Fragment;\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::ZBuffer::Dec', 'uniform int depthRequest;').result;\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::ZBuffer::Impl', ['if (depthRequest == 1) {', 'float iz = floor(gl_FragCoord.z*65535.0 + 0.1);', 'float rf = floor(iz/256.0)/255.0;', 'float gf = mod(iz,256.0)/255.0;', 'gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }']).result;\n      shaders.Fragment = FSSource;\n    }\n\n    publicAPI.replaceShaderCoincidentOffset(shaders, ren, actor);\n  };\n\n  publicAPI.replaceShaderTCoord = function (shaders, ren, actor) {\n    var VSSource = shaders.Vertex;\n    var GSSource = shaders.Geometry;\n    var FSSource = shaders.Fragment;\n    var tcoordVSDec = ['uniform mat4 WCTCMatrix;', 'out vec3 fragTexCoord;'];\n    var slabThickness = model.renderable.getSlabThickness();\n    VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::TCoord::Dec', tcoordVSDec).result;\n    var tcoordVSImpl = ['fragTexCoord = (WCTCMatrix * vertexWC).xyz;'];\n    VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::TCoord::Impl', tcoordVSImpl).result;\n    var tNumComp = model.openGLTexture.getComponents();\n    var iComps = actor.getProperty().getIndependentComponents();\n    var tcoordFSDec = ['in vec3 fragTexCoord;', 'uniform highp sampler3D texture1;', 'uniform mat4 WCTCMatrix;', // color shift and scale\n    'uniform float cshift0;', 'uniform float cscale0;', // pwf shift and scale\n    'uniform float pwfshift0;', 'uniform float pwfscale0;', // color and pwf textures\n    'uniform sampler2D colorTexture1;', 'uniform sampler2D pwfTexture1;', // opacity\n    'uniform float opacity;', // background color\n    'uniform vec4 backgroundColor;'];\n\n    if (iComps) {\n      for (var comp = 1; comp < tNumComp; comp++) {\n        tcoordFSDec = tcoordFSDec.concat([// color shift and scale\n        \"uniform float cshift\".concat(comp, \";\"), \"uniform float cscale\".concat(comp, \";\"), // weighting shift and scale\n        \"uniform float pwfshift\".concat(comp, \";\"), \"uniform float pwfscale\".concat(comp, \";\")]);\n      } // the heights defined below are the locations\n      // for the up to four components of the tfuns\n      // the tfuns have a height of 2XnumComps pixels so the\n      // values are computed to hit the middle of the two rows\n      // for that component\n\n\n      switch (tNumComp) {\n        case 1:\n          tcoordFSDec = tcoordFSDec.concat(['uniform float mix0;', '#define height0 0.5']);\n          break;\n\n        case 2:\n          tcoordFSDec = tcoordFSDec.concat(['uniform float mix0;', 'uniform float mix1;', '#define height0 0.25', '#define height1 0.75']);\n          break;\n\n        case 3:\n          tcoordFSDec = tcoordFSDec.concat(['uniform float mix0;', 'uniform float mix1;', 'uniform float mix2;', '#define height0 0.17', '#define height1 0.5', '#define height2 0.83']);\n          break;\n\n        case 4:\n          tcoordFSDec = tcoordFSDec.concat(['uniform float mix0;', 'uniform float mix1;', 'uniform float mix2;', 'uniform float mix3;', '#define height0 0.125', '#define height1 0.375', '#define height2 0.625', '#define height3 0.875']);\n          break;\n\n        default:\n          vtkErrorMacro('Unsupported number of independent coordinates.');\n      }\n    }\n\n    if (slabThickness > 0.0) {\n      tcoordFSDec = tcoordFSDec.concat(['uniform vec3 spacing;', 'uniform float slabThickness;', 'uniform int slabType;', 'uniform int slabTrapezoid;', 'uniform vec3 vboScaling;']);\n      tcoordFSDec = tcoordFSDec.concat(['vec4 compositeValue(vec4 currVal, vec4 valToComp, int trapezoid)', '{', '  vec4 retVal = vec4(1.0);', '  if (slabType == 0) // min', '  {', '    retVal = min(currVal, valToComp);', '  }', '  else if (slabType == 1) // max', '  {', '    retVal = max(currVal, valToComp);', '  }', '  else if (slabType == 3) // sum', '  {', '    retVal = currVal + (trapezoid > 0 ? 0.5 * valToComp : valToComp); ', '  }', '  else // mean', '  {', '    retVal = currVal + (trapezoid > 0 ? 0.5 * valToComp : valToComp); ', '  }', '  return retVal;', '}']);\n    }\n\n    FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::TCoord::Dec', tcoordFSDec).result;\n    var tcoordFSImpl = ['if (any(greaterThan(fragTexCoord, vec3(1.0))) || any(lessThan(fragTexCoord, vec3(0.0))))', '{', '  // set the background color and exit', '  gl_FragData[0] = backgroundColor;', '  return;', '}', 'vec4 tvalue = texture(texture1, fragTexCoord);'];\n\n    if (slabThickness > 0.0) {\n      tcoordFSImpl = tcoordFSImpl.concat(['// Get the first and last samples', 'int numSlices = 1;', 'float scaling = min(min(spacing.x, spacing.y), spacing.z) * 0.5;', 'vec3 normalxspacing = scaling * normalWCVSOutput;', 'float distTraveled = length(normalxspacing);', 'int trapezoid = 0;', 'while (distTraveled < slabThickness * 0.5)', '{', '  distTraveled += length(normalxspacing);', '  float fnumSlices = float(numSlices);', '  if (distTraveled > slabThickness * 0.5)', '  {', '    // Before stepping outside the slab, sample at the boundaries', '    normalxspacing = normalWCVSOutput * slabThickness * 0.5 / fnumSlices;', '    trapezoid = slabTrapezoid;', '  }', '  vec3 fragTCoordNeg = (WCTCMatrix * vec4(vertexWCVSOutput.xyz - fnumSlices * normalxspacing * vboScaling, 1.0)).xyz;', '  if (!any(greaterThan(fragTCoordNeg, vec3(1.0))) && !any(lessThan(fragTCoordNeg, vec3(0.0))))', '  {', '    vec4 newVal = texture(texture1, fragTCoordNeg);', '    tvalue = compositeValue(tvalue, newVal, trapezoid);', '    numSlices += 1;', '  }', '  vec3 fragTCoordPos = (WCTCMatrix * vec4(vertexWCVSOutput.xyz + fnumSlices * normalxspacing * vboScaling, 1.0)).xyz;', '  if (!any(greaterThan(fragTCoordNeg, vec3(1.0))) && !any(lessThan(fragTCoordNeg, vec3(0.0))))', '  {', '    vec4 newVal = texture(texture1, fragTCoordPos);', '    tvalue = compositeValue(tvalue, newVal, trapezoid);', '    numSlices += 1;', '  }', '}', '// Finally, if slab type is *mean*, divide the sum by the numSlices', 'if (slabType == 2)', '{', '  tvalue = tvalue / float(numSlices);', '}']);\n    }\n\n    if (iComps) {\n      var rgba = ['r', 'g', 'b', 'a'];\n\n      for (var _comp = 0; _comp < tNumComp; ++_comp) {\n        tcoordFSImpl = tcoordFSImpl.concat([\"vec3 tcolor\".concat(_comp, \" = mix\").concat(_comp, \" * texture2D(colorTexture1, vec2(tvalue.\").concat(rgba[_comp], \" * cscale\").concat(_comp, \" + cshift\").concat(_comp, \", height\").concat(_comp, \")).rgb;\"), \"float compWeight\".concat(_comp, \" = mix\").concat(_comp, \" * texture2D(pwfTexture1, vec2(tvalue.\").concat(rgba[_comp], \" * pwfscale\").concat(_comp, \" + pwfshift\").concat(_comp, \", height\").concat(_comp, \")).r;\")]);\n      }\n\n      switch (tNumComp) {\n        case 1:\n          tcoordFSImpl = tcoordFSImpl.concat(['gl_FragData[0] = vec4(tcolor0.rgb, compWeight0 * opacity);']);\n          break;\n\n        case 2:\n          tcoordFSImpl = tcoordFSImpl.concat(['float weightSum = compWeight0 + compWeight1;', 'gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum))), opacity);']);\n          break;\n\n        case 3:\n          tcoordFSImpl = tcoordFSImpl.concat(['float weightSum = compWeight0 + compWeight1 + compWeight2;', 'gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum))), opacity);']);\n          break;\n\n        case 4:\n          tcoordFSImpl = tcoordFSImpl.concat(['float weightSum = compWeight0 + compWeight1 + compWeight2 + compWeight3;', 'gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum)) + (tcolor3.rgb * (compWeight3 / weightSum))), opacity);']);\n          break;\n\n        default:\n          vtkErrorMacro('Unsupported number of independent coordinates.');\n      }\n    } else {\n      // dependent components\n      switch (tNumComp) {\n        case 1:\n          tcoordFSImpl = tcoordFSImpl.concat(['// Dependent components', 'float intensity = tvalue.r;', 'vec3 tcolor = texture2D(colorTexture1, vec2(intensity * cscale0 + cshift0, 0.5)).rgb;', 'float scalarOpacity = texture2D(pwfTexture1, vec2(intensity * pwfscale0 + pwfshift0, 0.5)).r;', 'gl_FragData[0] = vec4(tcolor, scalarOpacity * opacity);']);\n          break;\n\n        case 2:\n          tcoordFSImpl = tcoordFSImpl.concat(['float intensity = tvalue.r*cscale0 + cshift0;', 'gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(intensity, 0.5)).rgb, pwfscale0*tvalue.g + pwfshift0);']);\n          break;\n\n        case 3:\n          tcoordFSImpl = tcoordFSImpl.concat(['vec4 tcolor = cscale0*tvalue + cshift0;', 'gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,', '  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,', '  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, opacity);']);\n          break;\n\n        default:\n          tcoordFSImpl = tcoordFSImpl.concat(['vec4 tcolor = cscale0*tvalue + cshift0;', 'gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,', '  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,', '  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, tcolor.a);']);\n      }\n    }\n\n    FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::TCoord::Impl', tcoordFSImpl).result;\n    shaders.Vertex = VSSource;\n    shaders.Fragment = FSSource;\n    shaders.Geometry = GSSource;\n  };\n\n  publicAPI.replaceShaderPositionVC = function (shaders, ren, actor) {\n    var VSSource = shaders.Vertex;\n    var GSSource = shaders.Geometry;\n    var FSSource = shaders.Fragment;\n    var slabThickness = model.renderable.getSlabThickness();\n    var posVCVSDec = ['attribute vec4 vertexWC;']; // Add a unique hash to the shader to ensure that the shader program is unique to this mapper.\n\n    posVCVSDec = posVCVSDec.concat([\"//\".concat(publicAPI.getMTime()).concat(model.resliceGeomUpdateString)]);\n\n    if (slabThickness > 0.0) {\n      posVCVSDec = posVCVSDec.concat(['attribute vec3 normalWC;', 'varying vec3 normalWCVSOutput;', 'varying vec4 vertexWCVSOutput;']);\n    }\n\n    VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::PositionVC::Dec', posVCVSDec).result;\n    var posVCVSImpl = ['gl_Position = MCPCMatrix * vertexWC;'];\n\n    if (slabThickness > 0.0) {\n      posVCVSImpl = posVCVSImpl.concat(['normalWCVSOutput = normalWC;', 'vertexWCVSOutput = vertexWC;']);\n    }\n\n    VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::PositionVC::Impl', posVCVSImpl).result;\n    VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::Camera::Dec', ['uniform mat4 MCPCMatrix;', 'uniform mat4 MCVCMatrix;']).result;\n    var posVCFSDec = [];\n\n    if (slabThickness > 0.0) {\n      posVCFSDec = posVCFSDec.concat(['varying vec3 normalWCVSOutput;', 'varying vec4 vertexWCVSOutput;']);\n    }\n\n    FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::PositionVC::Dec', posVCFSDec).result;\n    shaders.Vertex = VSSource;\n    shaders.Geometry = GSSource;\n    shaders.Fragment = FSSource;\n  };\n\n  function isVectorAxisAligned(n) {\n    vtkMath.normalize(n);\n    var tmpN = [0, 0, 0];\n\n    for (var i = 0; i < 3; ++i) {\n      vec3.zero(tmpN);\n      tmpN[i] = 1.0;\n      var dotP = vtkMath.dot(n, tmpN);\n\n      if (dotP < -0.999 || dotP > 0.999) {\n        return [true, i];\n      }\n    }\n\n    return [false, 2];\n  }\n\n  publicAPI.updateResliceGeometry = function () {\n    var resGeomString = '';\n    var image = model.currentInput;\n    var imageBounds = image === null || image === void 0 ? void 0 : image.getBounds(); // Orthogonal slicing by default\n\n    var orthoSlicing = true;\n    var orthoAxis = 2;\n    var slicePD = model.renderable.getSlicePolyData();\n    var slicePlane = model.renderable.getSlicePlane();\n\n    if (slicePD) {\n      resGeomString = resGeomString.concat(\"PolyData\".concat(slicePD.getMTime()));\n    } else if (slicePlane) {\n      resGeomString = resGeomString.concat(\"Plane\".concat(slicePlane.getMTime()));\n\n      if (image) {\n        resGeomString = resGeomString.concat(\"Image\".concat(image.getMTime()));\n      } // Check to see if we can bypass oblique slicing related bounds computation\n      // Compute a world-to-image-orientation matrix.\n      // Ignore the translation component since we are\n      // using it on vectors rather than positions.\n\n\n      var w2io = mat3.fromValues(image === null || image === void 0 ? void 0 : image.getDirection());\n      mat3.invert(w2io, w2io); // transform the cutting plane normal to image local coords\n\n      var imageLocalNormal = _toConsumableArray(slicePlane.getNormal());\n\n      vec3.transformMat3(imageLocalNormal, imageLocalNormal, w2io);\n\n      var _isVectorAxisAligned = isVectorAxisAligned(imageLocalNormal);\n\n      var _isVectorAxisAligned2 = _slicedToArray(_isVectorAxisAligned, 2);\n\n      orthoSlicing = _isVectorAxisAligned2[0];\n      orthoAxis = _isVectorAxisAligned2[1];\n    } else {\n      // Create a default slice plane here\n      var plane = vtkPlane.newInstance();\n      plane.setNormal(0, 0, 1);\n      var bds = [0, 1, 0, 1, 0, 1];\n\n      if (image) {\n        bds = imageBounds;\n      }\n\n      plane.setOrigin(bds[0], bds[2], 0.5 * (bds[5] + bds[4]));\n      model.renderable.setSlicePlane(plane);\n      resGeomString = resGeomString.concat(\"Plane\".concat(slicePlane === null || slicePlane === void 0 ? void 0 : slicePlane.getMTime()));\n\n      if (image) {\n        resGeomString = resGeomString.concat(\"Image\".concat(image.getMTime()));\n      }\n    }\n\n    if (!model.resliceGeom || model.resliceGeomUpdateString !== resGeomString) {\n      var _model$resliceGeom;\n\n      if (slicePD) {\n        if (!model.resliceGeom) {\n          model.resliceGeom = vtkPolyData.newInstance();\n        }\n\n        model.resliceGeom.getPoints().setData(slicePD.getPoints().getData(), 3);\n        model.resliceGeom.getPolys().setData(slicePD.getPolys().getData(), 1);\n        model.resliceGeom.getPointData().setNormals(slicePD.getPointData().getNormals());\n      } else if (slicePlane) {\n        if (!orthoSlicing) {\n          model.outlineFilter.setInputData(image);\n          model.cutter.setInputConnection(model.outlineFilter.getOutputPort());\n          model.cutter.setCutFunction(slicePlane);\n          model.lineToSurfaceFilter.setInputConnection(model.cutter.getOutputPort());\n          model.lineToSurfaceFilter.update();\n\n          if (!model.resliceGeom) {\n            model.resliceGeom = vtkPolyData.newInstance();\n          }\n\n          var planePD = model.lineToSurfaceFilter.getOutputData();\n          model.resliceGeom.getPoints().setData(planePD.getPoints().getData(), 3);\n          model.resliceGeom.getPolys().setData(planePD.getPolys().getData(), 1);\n          model.resliceGeom.getPointData().setNormals(planePD.getPointData().getNormals()); // The above method does not generate point normals\n          // Set it manually here.\n\n          var n = slicePlane.getNormal();\n          var npts = model.resliceGeom.getNumberOfPoints();\n          vtkMath.normalize(n);\n          var normalsData = new Float32Array(npts * 3);\n\n          for (var i = 0; i < npts; ++i) {\n            normalsData[3 * i] = n[0];\n            normalsData[3 * i + 1] = n[1];\n            normalsData[3 * i + 2] = n[2];\n          }\n\n          var normals = vtkDataArray.newInstance({\n            numberOfComponents: 3,\n            values: normalsData,\n            name: 'Normals'\n          });\n          model.resliceGeom.getPointData().setNormals(normals);\n        } else {\n          // Since the image-local normal is axis-aligned, we\n          // can quickly construct the cutting plane using indexToWorld transforms.\n          var ptsArray = new Float32Array(12);\n          var indexSpacePlaneOrigin = image.worldToIndex(slicePlane.getOrigin(), [0, 0, 0]);\n          var otherAxes = [(orthoAxis + 1) % 3, (orthoAxis + 2) % 3].sort();\n          var dim = image.getDimensions();\n          var ext = [0, dim[0] - 1, 0, dim[1] - 1, 0, dim[2] - 1];\n          var ptIdx = 0;\n\n          for (var _i7 = 0; _i7 < 2; ++_i7) {\n            for (var j = 0; j < 2; ++j) {\n              ptsArray[ptIdx + orthoAxis] = indexSpacePlaneOrigin[orthoAxis];\n              ptsArray[ptIdx + otherAxes[0]] = ext[2 * otherAxes[0] + j];\n              ptsArray[ptIdx + otherAxes[1]] = ext[2 * otherAxes[1] + _i7];\n              ptIdx += 3;\n            }\n          }\n\n          model.transform.setMatrix(image.getIndexToWorld());\n          model.transform.transformPoints(ptsArray, ptsArray);\n          var cellArray = new Uint16Array(8);\n          cellArray[0] = 3;\n          cellArray[1] = 0;\n          cellArray[2] = 1;\n          cellArray[3] = 3;\n          cellArray[4] = 3;\n          cellArray[5] = 0;\n          cellArray[6] = 3;\n          cellArray[7] = 2;\n\n          var _n = slicePlane.getNormal();\n\n          vtkMath.normalize(_n);\n\n          var _normalsData = new Float32Array(12);\n\n          for (var _i8 = 0; _i8 < 4; ++_i8) {\n            _normalsData[3 * _i8] = _n[0];\n            _normalsData[3 * _i8 + 1] = _n[1];\n            _normalsData[3 * _i8 + 2] = _n[2];\n          }\n\n          if (!model.resliceGeom) {\n            model.resliceGeom = vtkPolyData.newInstance();\n          }\n\n          model.resliceGeom.getPoints().setData(ptsArray, 3);\n          model.resliceGeom.getPolys().setData(cellArray, 1);\n\n          var _normals = vtkDataArray.newInstance({\n            numberOfComponents: 3,\n            values: _normalsData,\n            name: 'Normals'\n          });\n\n          model.resliceGeom.getPointData().setNormals(_normals);\n        }\n      } else {\n        vtkErrorMacro('Something went wrong.', 'A default slice plane should have been created in the beginning of', 'updateResliceGeometry.');\n      }\n\n      model.resliceGeomUpdateString = resGeomString;\n      (_model$resliceGeom = model.resliceGeom) === null || _model$resliceGeom === void 0 ? void 0 : _model$resliceGeom.modified();\n    }\n  };\n\n  publicAPI.setOpenGLTexture = function (oglTex) {\n    if (oglTex) {\n      model.openGLTexture = oglTex;\n      model._externalOpenGLTexture = true;\n    }\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\n\nvar DEFAULT_VALUES = {\n  VBOBuildTime: {},\n  VBOBuildString: null,\n  haveSeenDepthRequest: false,\n  lastHaveSeenDepthRequest: false,\n  lastIndependentComponents: false,\n  lastTextureComponents: 0,\n  lastSlabThickness: 0,\n  lastSlabTrapezoidIntegration: 0,\n  lastSlabType: -1,\n  openGLTexture: null,\n  openGLTextureString: null,\n  colorTextureString: null,\n  pwfTextureString: null,\n  resliceGeom: null,\n  resliceGeomUpdateString: null,\n  tris: null,\n  colorTexture: null,\n  pwfTexture: null,\n  _externalOpenGLTexture: false\n}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Inheritance\n\n  vtkViewNode.extend(publicAPI, model, initialValues);\n  vtkReplacementShaderMapper.implementReplaceShaderCoincidentOffset(publicAPI, model, initialValues);\n  vtkReplacementShaderMapper.implementBuildShadersWithReplacements(publicAPI, model, initialValues);\n  model.tris = vtkHelper.newInstance();\n  model.openGLTexture = vtkOpenGLTexture.newInstance();\n  model.colorTexture = vtkOpenGLTexture.newInstance();\n  model.pwfTexture = vtkOpenGLTexture.newInstance();\n  model.VBOBuildTime = {};\n  obj(model.VBOBuildTime);\n  model.tmpMat4 = mat4.identity(new Float64Array(16)); // Implicit plane to polydata related cache:\n\n  model.outlineFilter = vtkImageDataOutlineFilter.newInstance();\n  model.outlineFilter.setGenerateFaces(true);\n  model.outlineFilter.setGenerateLines(false);\n  model.cubePolyData = vtkPolyData.newInstance();\n  model.cutter = vtkCutter.newInstance();\n  model.lineToSurfaceFilter = vtkClosedPolyLineToSurfaceFilter.newInstance();\n  model.transform = vtkTransform.newInstance();\n  get(publicAPI, model, ['openGLTexture']); // Object methods\n\n  vtkOpenGLImageResliceMapper(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = newInstance$1(extend, 'vtkOpenGLImageResliceMapper'); // ----------------------------------------------------------------------------\n\nvar vtkImageResliceMapper = {\n  newInstance: newInstance,\n  extend: extend\n}; // Register ourself to OpenGL backend if imported\n\nregisterOverride('vtkImageResliceMapper', newInstance);\n\nexport { vtkImageResliceMapper as default, extend, newInstance };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}