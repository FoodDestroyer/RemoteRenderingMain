{"ast":null,"code":"import _toConsumableArray from '@babel/runtime/helpers/toConsumableArray';\nimport macro from '../../macros.js';\nimport vtkCell from './Cell.js';\nimport { e as distance2BetweenPoints } from '../Core/Math/index.js';\nimport { CellType } from './CellTypes/Constants.js';\nimport vtkTriangle from './Triangle.js';\nimport vtkPoints from '../Core/Points.js';\nfunction intersectionStruct() {\n  return {\n    intersected: false,\n    subId: -1,\n    x: [0.0, 0.0, 0.0],\n    pCoords: [0.0, 0.0, 0.0],\n    t: -1\n  };\n}\nfunction vtkQuad(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkQuad');\n  publicAPI.getCellDimension = function () {\n    return 2;\n  };\n  publicAPI.getCellType = function () {\n    return CellType.VTK_QUAD;\n  };\n  publicAPI.getNumberOfEdges = function () {\n    return 4;\n  };\n  publicAPI.getNumberOfFaces = function () {\n    return 0;\n  };\n  publicAPI.intersectWithLine = function (p1, p2, tol, x, pcoords) {\n    var _points, _points2, _points3, _points4, _points5, _points6, _points7, _points8, _points9, _points10, _points11, _points12;\n    var outObj = {\n      subId: 0,\n      t: Number.MAX_VALUE,\n      intersect: 0,\n      betweenPoints: false\n    };\n    var diagonalCase;\n    var point0 = model.points.getPoint(0, []);\n    var point1 = model.points.getPoint(1, []);\n    var point2 = model.points.getPoint(2, []);\n    var point3 = model.points.getPoint(3, []);\n    var d1 = distance2BetweenPoints(point0, point2);\n    var d2 = distance2BetweenPoints(point1, point3);\n    /* Figure out how to uniquely tessellate the quad. Watch out for\n     * equivalent triangulations (i.e., the triangulation is equivalent\n     * no matter where the diagonal). In this case use the point ids as\n     * a tie breaker to ensure unique triangulation across the quad.\n     */\n    // rare case; discriminate based on point id\n\n    if (d1 === d2) {\n      // find the maximum id\n      var id;\n      var maxId = 0;\n      var maxIdx = 0;\n      for (var i = 0; i < 4; i++) {\n        id = model.pointsIds[i];\n        if (id > maxId) {\n          maxId = id;\n          maxIdx = i;\n        }\n      }\n      if (maxIdx === 0 || maxIdx === 2) {\n        diagonalCase = 0;\n      } else {\n        diagonalCase = 1;\n      }\n    } else if (d1 < d2) {\n      diagonalCase = 0;\n    } else {\n      diagonalCase = 1;\n    }\n    var points = null;\n    if (!model.triangle) {\n      model.triangle = vtkTriangle.newInstance();\n      points = vtkPoints.newInstance();\n      points.setNumberOfPoints(3);\n      model.triangle.initialize(points);\n    } else {\n      points = model.triangle.getPoints();\n    }\n    var firstIntersect;\n    var firstIntersectTmpObj = intersectionStruct();\n    var secondIntersect;\n    var secondIntersectTmpObj = intersectionStruct();\n    var useFirstIntersection;\n    var useSecondIntersection;\n    switch (diagonalCase) {\n      case 0:\n        (_points = points).setPoint.apply(_points, [0].concat(_toConsumableArray(point0)));\n        (_points2 = points).setPoint.apply(_points2, [1].concat(_toConsumableArray(point1)));\n        (_points3 = points).setPoint.apply(_points3, [2].concat(_toConsumableArray(point2)));\n        firstIntersect = model.triangle.intersectWithLine(p1, p2, tol, firstIntersectTmpObj.x, firstIntersectTmpObj.pCoords);\n        (_points4 = points).setPoint.apply(_points4, [0].concat(_toConsumableArray(point2)));\n        (_points5 = points).setPoint.apply(_points5, [1].concat(_toConsumableArray(point3)));\n        (_points6 = points).setPoint.apply(_points6, [2].concat(_toConsumableArray(point0)));\n        secondIntersect = model.triangle.intersectWithLine(p1, p2, tol, secondIntersectTmpObj.x, secondIntersectTmpObj.pCoords);\n        useFirstIntersection = firstIntersect.intersect && secondIntersect.intersect ? firstIntersect.t <= secondIntersect.t : firstIntersect.intersect;\n        useSecondIntersection = firstIntersect.intersect && secondIntersect.intersect ? secondIntersect.t < firstIntersect.t : secondIntersect.intersect;\n        if (useFirstIntersection) {\n          outObj = firstIntersect;\n          x[0] = firstIntersectTmpObj.x[0];\n          x[1] = firstIntersectTmpObj.x[1];\n          x[2] = firstIntersectTmpObj.x[2];\n          pcoords[0] = firstIntersectTmpObj.pCoords[0] + firstIntersectTmpObj.pCoords[1];\n          pcoords[1] = firstIntersectTmpObj.pCoords[1];\n          pcoords[2] = firstIntersectTmpObj.pCoords[2];\n        } else if (useSecondIntersection) {\n          outObj = secondIntersect;\n          x[0] = secondIntersectTmpObj.x[0];\n          x[1] = secondIntersectTmpObj.x[1];\n          x[2] = secondIntersectTmpObj.x[2];\n          pcoords[0] = 1.0 - (secondIntersectTmpObj.pCoords[0] + secondIntersectTmpObj.pCoords[1]);\n          pcoords[1] = 1 - secondIntersectTmpObj.pCoords[1];\n          pcoords[2] = secondIntersectTmpObj.pCoords[2];\n        }\n        break;\n      case 1:\n        (_points7 = points).setPoint.apply(_points7, [0].concat(_toConsumableArray(point0)));\n        (_points8 = points).setPoint.apply(_points8, [1].concat(_toConsumableArray(point1)));\n        (_points9 = points).setPoint.apply(_points9, [2].concat(_toConsumableArray(point3)));\n        firstIntersect = model.triangle.intersectWithLine(p1, p2, tol, firstIntersectTmpObj.x, firstIntersectTmpObj.pCoords);\n        (_points10 = points).setPoint.apply(_points10, [0].concat(_toConsumableArray(point2)));\n        (_points11 = points).setPoint.apply(_points11, [1].concat(_toConsumableArray(point3)));\n        (_points12 = points).setPoint.apply(_points12, [2].concat(_toConsumableArray(point1)));\n        secondIntersect = model.triangle.intersectWithLine(p1, p2, tol, secondIntersectTmpObj.x, secondIntersectTmpObj.pCoords);\n        useFirstIntersection = firstIntersect.intersect && secondIntersect.intersect ? firstIntersect.t <= secondIntersect.t : firstIntersect.intersect;\n        useSecondIntersection = firstIntersect.intersect && secondIntersect.intersect ? secondIntersect.t < firstIntersect.t : secondIntersect.intersect;\n        if (useFirstIntersection) {\n          outObj = firstIntersect;\n          x[0] = firstIntersectTmpObj.x[0];\n          x[1] = firstIntersectTmpObj.x[1];\n          x[2] = firstIntersectTmpObj.x[2];\n          pcoords[0] = firstIntersectTmpObj.pCoords[0];\n          pcoords[1] = firstIntersectTmpObj.pCoords[1];\n          pcoords[2] = firstIntersectTmpObj.pCoords[2];\n        } else if (useSecondIntersection) {\n          outObj = secondIntersect;\n          x[0] = secondIntersectTmpObj.x[0];\n          x[1] = secondIntersectTmpObj.x[1];\n          x[2] = secondIntersectTmpObj.x[2];\n          pcoords[0] = 1 - secondIntersectTmpObj.pCoords[0];\n          pcoords[1] = 1 - secondIntersectTmpObj.pCoords[1];\n          pcoords[2] = secondIntersectTmpObj.pCoords[2];\n        }\n        break;\n    }\n    return outObj;\n  };\n  publicAPI.interpolationFunctions = function (pcoords, weights) {\n    var rm = 1 - pcoords[0];\n    var sm = 1 - pcoords[1];\n    weights[0] = rm * sm;\n    weights[1] = pcoords[0] * sm;\n    weights[2] = pcoords[0] * pcoords[1];\n    weights[3] = rm * pcoords[1];\n  };\n  publicAPI.evaluateLocation = function (pcoords, x, weights) {\n    var point = []; // Calculate the weights\n\n    publicAPI.interpolationFunctions(pcoords, weights);\n    x[0] = 0.0;\n    x[1] = 0.0;\n    x[2] = 0.0;\n    for (var i = 0; i < 4; i++) {\n      model.points.getPoint(i, point);\n      for (var j = 0; j < 3; j++) {\n        x[j] += point[j] * weights[i];\n      }\n    }\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nvar DEFAULT_VALUES = {}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n  vtkCell.extend(publicAPI, model, initialValues);\n  vtkQuad(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = macro.newInstance(extend, 'vtkQuad'); // ----------------------------------------------------------------------------\n\nvar vtkQuad$1 = {\n  newInstance: newInstance,\n  extend: extend\n};\nexport { vtkQuad$1 as default, extend, newInstance };","map":{"version":3,"names":["_toConsumableArray","macro","vtkCell","e","distance2BetweenPoints","CellType","vtkTriangle","vtkPoints","intersectionStruct","intersected","subId","x","pCoords","t","vtkQuad","publicAPI","model","classHierarchy","push","getCellDimension","getCellType","VTK_QUAD","getNumberOfEdges","getNumberOfFaces","intersectWithLine","p1","p2","tol","pcoords","_points","_points2","_points3","_points4","_points5","_points6","_points7","_points8","_points9","_points10","_points11","_points12","outObj","Number","MAX_VALUE","intersect","betweenPoints","diagonalCase","point0","points","getPoint","point1","point2","point3","d1","d2","id","maxId","maxIdx","i","pointsIds","triangle","newInstance","setNumberOfPoints","initialize","getPoints","firstIntersect","firstIntersectTmpObj","secondIntersect","secondIntersectTmpObj","useFirstIntersection","useSecondIntersection","setPoint","apply","concat","interpolationFunctions","weights","rm","sm","evaluateLocation","point","j","DEFAULT_VALUES","extend","initialValues","arguments","length","undefined","Object","assign","vtkQuad$1","default"],"sources":["/home/rakshith/Documents/RemoteRendering/vtk-js-react-app/node_modules/@kitware/vtk.js/Common/DataModel/Quad.js"],"sourcesContent":["import _toConsumableArray from '@babel/runtime/helpers/toConsumableArray';\nimport macro from '../../macros.js';\nimport vtkCell from './Cell.js';\nimport { e as distance2BetweenPoints } from '../Core/Math/index.js';\nimport { CellType } from './CellTypes/Constants.js';\nimport vtkTriangle from './Triangle.js';\nimport vtkPoints from '../Core/Points.js';\n\nfunction intersectionStruct() {\n  return {\n    intersected: false,\n    subId: -1,\n    x: [0.0, 0.0, 0.0],\n    pCoords: [0.0, 0.0, 0.0],\n    t: -1\n  };\n}\n\nfunction vtkQuad(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkQuad');\n\n  publicAPI.getCellDimension = function () {\n    return 2;\n  };\n\n  publicAPI.getCellType = function () {\n    return CellType.VTK_QUAD;\n  };\n\n  publicAPI.getNumberOfEdges = function () {\n    return 4;\n  };\n\n  publicAPI.getNumberOfFaces = function () {\n    return 0;\n  };\n\n  publicAPI.intersectWithLine = function (p1, p2, tol, x, pcoords) {\n    var _points, _points2, _points3, _points4, _points5, _points6, _points7, _points8, _points9, _points10, _points11, _points12;\n\n    var outObj = {\n      subId: 0,\n      t: Number.MAX_VALUE,\n      intersect: 0,\n      betweenPoints: false\n    };\n    var diagonalCase;\n    var point0 = model.points.getPoint(0, []);\n    var point1 = model.points.getPoint(1, []);\n    var point2 = model.points.getPoint(2, []);\n    var point3 = model.points.getPoint(3, []);\n    var d1 = distance2BetweenPoints(point0, point2);\n    var d2 = distance2BetweenPoints(point1, point3);\n    /* Figure out how to uniquely tessellate the quad. Watch out for\n     * equivalent triangulations (i.e., the triangulation is equivalent\n     * no matter where the diagonal). In this case use the point ids as\n     * a tie breaker to ensure unique triangulation across the quad.\n     */\n    // rare case; discriminate based on point id\n\n    if (d1 === d2) {\n      // find the maximum id\n      var id;\n      var maxId = 0;\n      var maxIdx = 0;\n\n      for (var i = 0; i < 4; i++) {\n        id = model.pointsIds[i];\n\n        if (id > maxId) {\n          maxId = id;\n          maxIdx = i;\n        }\n      }\n\n      if (maxIdx === 0 || maxIdx === 2) {\n        diagonalCase = 0;\n      } else {\n        diagonalCase = 1;\n      }\n    } else if (d1 < d2) {\n      diagonalCase = 0;\n    } else {\n      diagonalCase = 1;\n    }\n\n    var points = null;\n\n    if (!model.triangle) {\n      model.triangle = vtkTriangle.newInstance();\n      points = vtkPoints.newInstance();\n      points.setNumberOfPoints(3);\n      model.triangle.initialize(points);\n    } else {\n      points = model.triangle.getPoints();\n    }\n\n    var firstIntersect;\n    var firstIntersectTmpObj = intersectionStruct();\n    var secondIntersect;\n    var secondIntersectTmpObj = intersectionStruct();\n    var useFirstIntersection;\n    var useSecondIntersection;\n\n    switch (diagonalCase) {\n      case 0:\n        (_points = points).setPoint.apply(_points, [0].concat(_toConsumableArray(point0)));\n\n        (_points2 = points).setPoint.apply(_points2, [1].concat(_toConsumableArray(point1)));\n\n        (_points3 = points).setPoint.apply(_points3, [2].concat(_toConsumableArray(point2)));\n\n        firstIntersect = model.triangle.intersectWithLine(p1, p2, tol, firstIntersectTmpObj.x, firstIntersectTmpObj.pCoords);\n\n        (_points4 = points).setPoint.apply(_points4, [0].concat(_toConsumableArray(point2)));\n\n        (_points5 = points).setPoint.apply(_points5, [1].concat(_toConsumableArray(point3)));\n\n        (_points6 = points).setPoint.apply(_points6, [2].concat(_toConsumableArray(point0)));\n\n        secondIntersect = model.triangle.intersectWithLine(p1, p2, tol, secondIntersectTmpObj.x, secondIntersectTmpObj.pCoords);\n        useFirstIntersection = firstIntersect.intersect && secondIntersect.intersect ? firstIntersect.t <= secondIntersect.t : firstIntersect.intersect;\n        useSecondIntersection = firstIntersect.intersect && secondIntersect.intersect ? secondIntersect.t < firstIntersect.t : secondIntersect.intersect;\n\n        if (useFirstIntersection) {\n          outObj = firstIntersect;\n          x[0] = firstIntersectTmpObj.x[0];\n          x[1] = firstIntersectTmpObj.x[1];\n          x[2] = firstIntersectTmpObj.x[2];\n          pcoords[0] = firstIntersectTmpObj.pCoords[0] + firstIntersectTmpObj.pCoords[1];\n          pcoords[1] = firstIntersectTmpObj.pCoords[1];\n          pcoords[2] = firstIntersectTmpObj.pCoords[2];\n        } else if (useSecondIntersection) {\n          outObj = secondIntersect;\n          x[0] = secondIntersectTmpObj.x[0];\n          x[1] = secondIntersectTmpObj.x[1];\n          x[2] = secondIntersectTmpObj.x[2];\n          pcoords[0] = 1.0 - (secondIntersectTmpObj.pCoords[0] + secondIntersectTmpObj.pCoords[1]);\n          pcoords[1] = 1 - secondIntersectTmpObj.pCoords[1];\n          pcoords[2] = secondIntersectTmpObj.pCoords[2];\n        }\n\n        break;\n\n      case 1:\n        (_points7 = points).setPoint.apply(_points7, [0].concat(_toConsumableArray(point0)));\n\n        (_points8 = points).setPoint.apply(_points8, [1].concat(_toConsumableArray(point1)));\n\n        (_points9 = points).setPoint.apply(_points9, [2].concat(_toConsumableArray(point3)));\n\n        firstIntersect = model.triangle.intersectWithLine(p1, p2, tol, firstIntersectTmpObj.x, firstIntersectTmpObj.pCoords);\n\n        (_points10 = points).setPoint.apply(_points10, [0].concat(_toConsumableArray(point2)));\n\n        (_points11 = points).setPoint.apply(_points11, [1].concat(_toConsumableArray(point3)));\n\n        (_points12 = points).setPoint.apply(_points12, [2].concat(_toConsumableArray(point1)));\n\n        secondIntersect = model.triangle.intersectWithLine(p1, p2, tol, secondIntersectTmpObj.x, secondIntersectTmpObj.pCoords);\n        useFirstIntersection = firstIntersect.intersect && secondIntersect.intersect ? firstIntersect.t <= secondIntersect.t : firstIntersect.intersect;\n        useSecondIntersection = firstIntersect.intersect && secondIntersect.intersect ? secondIntersect.t < firstIntersect.t : secondIntersect.intersect;\n\n        if (useFirstIntersection) {\n          outObj = firstIntersect;\n          x[0] = firstIntersectTmpObj.x[0];\n          x[1] = firstIntersectTmpObj.x[1];\n          x[2] = firstIntersectTmpObj.x[2];\n          pcoords[0] = firstIntersectTmpObj.pCoords[0];\n          pcoords[1] = firstIntersectTmpObj.pCoords[1];\n          pcoords[2] = firstIntersectTmpObj.pCoords[2];\n        } else if (useSecondIntersection) {\n          outObj = secondIntersect;\n          x[0] = secondIntersectTmpObj.x[0];\n          x[1] = secondIntersectTmpObj.x[1];\n          x[2] = secondIntersectTmpObj.x[2];\n          pcoords[0] = 1 - secondIntersectTmpObj.pCoords[0];\n          pcoords[1] = 1 - secondIntersectTmpObj.pCoords[1];\n          pcoords[2] = secondIntersectTmpObj.pCoords[2];\n        }\n\n        break;\n    }\n\n    return outObj;\n  };\n\n  publicAPI.interpolationFunctions = function (pcoords, weights) {\n    var rm = 1 - pcoords[0];\n    var sm = 1 - pcoords[1];\n    weights[0] = rm * sm;\n    weights[1] = pcoords[0] * sm;\n    weights[2] = pcoords[0] * pcoords[1];\n    weights[3] = rm * pcoords[1];\n  };\n\n  publicAPI.evaluateLocation = function (pcoords, x, weights) {\n    var point = []; // Calculate the weights\n\n    publicAPI.interpolationFunctions(pcoords, weights);\n    x[0] = 0.0;\n    x[1] = 0.0;\n    x[2] = 0.0;\n\n    for (var i = 0; i < 4; i++) {\n      model.points.getPoint(i, point);\n\n      for (var j = 0; j < 3; j++) {\n        x[j] += point[j] * weights[i];\n      }\n    }\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\n\nvar DEFAULT_VALUES = {}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n  vtkCell.extend(publicAPI, model, initialValues);\n  vtkQuad(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = macro.newInstance(extend, 'vtkQuad'); // ----------------------------------------------------------------------------\n\nvar vtkQuad$1 = {\n  newInstance: newInstance,\n  extend: extend\n};\n\nexport { vtkQuad$1 as default, extend, newInstance };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}