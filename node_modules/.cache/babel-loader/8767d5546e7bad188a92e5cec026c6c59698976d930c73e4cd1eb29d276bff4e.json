{"ast":null,"code":"import _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport _toConsumableArray from '@babel/runtime/helpers/toConsumableArray';\nimport { mat4, vec3, mat3 } from 'gl-matrix';\nimport Constants from './Glyph3DMapper/Constants.js';\nimport macro from '../../macros.js';\nimport vtkMapper from './Mapper.js';\nimport { F as createUninitializedBounds, n as norm } from '../../Common/Core/Math/index.js';\nimport vtkBoundingBox from '../../Common/DataModel/BoundingBox.js';\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n  return target;\n}\nvar OrientationModes = Constants.OrientationModes,\n  ScaleModes = Constants.ScaleModes;\nvar vtkErrorMacro = macro.vtkErrorMacro; // ----------------------------------------------------------------------------\n// class methods\n// ----------------------------------------------------------------------------\n\nfunction vtkGlyph3DMapper(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkGlyph3DMapper');\n  /**\n   * An orientation array is a vtkDataArray with 3 components. The first\n   * component is the angle of rotation along the X axis. The second\n   * component is the angle of rotation along the Y axis. The third\n   * component is the angle of rotation along the Z axis. Orientation is\n   * specified in X,Y,Z order but the rotations are performed in Z,X an Y.\n   * This definition is compliant with SetOrientation method on vtkProp3D.\n   * By using vector or normal there is a degree of freedom or rotation\n   * left (underconstrained). With the orientation array, there is no degree of\n   * freedom left.\n   */\n\n  publicAPI.getOrientationModeAsString = function () {\n    return macro.enumToString(OrientationModes, model.orientationMode);\n  };\n  publicAPI.setOrientationModeToDirection = function () {\n    return publicAPI.setOrientationMode(OrientationModes.DIRECTION);\n  };\n  publicAPI.setOrientationModeToRotation = function () {\n    return publicAPI.setOrientationMode(OrientationModes.ROTATION);\n  };\n  publicAPI.setOrientationModeToMatrix = function () {\n    return publicAPI.setOrientationMode(OrientationModes.MATRIX);\n  };\n  publicAPI.getOrientationArrayData = function () {\n    var idata = publicAPI.getInputData(0);\n    if (!idata || !idata.getPointData()) {\n      return null;\n    }\n    if (!model.orientationArray) {\n      return idata.getPointData().getVectors();\n    }\n    return idata.getPointData().getArray(model.orientationArray);\n  };\n  publicAPI.getScaleModeAsString = function () {\n    return macro.enumToString(ScaleModes, model.scaleMode);\n  };\n  publicAPI.setScaleModeToScaleByMagnitude = function () {\n    return publicAPI.setScaleMode(ScaleModes.SCALE_BY_MAGNITUDE);\n  };\n  publicAPI.setScaleModeToScaleByComponents = function () {\n    return publicAPI.setScaleMode(ScaleModes.SCALE_BY_COMPONENTS);\n  };\n  publicAPI.setScaleModeToScaleByConstant = function () {\n    return publicAPI.setScaleMode(ScaleModes.SCALE_BY_CONSTANT);\n  };\n  publicAPI.getScaleArrayData = function () {\n    var idata = publicAPI.getInputData(0);\n    if (!idata || !idata.getPointData()) {\n      return null;\n    }\n    if (!model.scaleArray) {\n      return idata.getPointData().getScalars();\n    }\n    return idata.getPointData().getArray(model.scaleArray);\n  };\n  publicAPI.getBounds = function () {\n    var idata = publicAPI.getInputData(0);\n    var gdata = publicAPI.getInputData(1);\n    if (!idata || !gdata) {\n      return createUninitializedBounds();\n    } // first we build the arrays used for the glyphing\n\n    publicAPI.buildArrays();\n    return model.bounds;\n  };\n  publicAPI.buildArrays = function () {\n    // if the mtgime requires it, rebuild\n    var idata = publicAPI.getInputData(0);\n    var gdata = publicAPI.getInputData(1);\n    if (model.buildTime.getMTime() < gdata.getMTime() || model.buildTime.getMTime() < idata.getMTime() || model.buildTime.getMTime() < publicAPI.getMTime()) {\n      var pts = idata.getPoints().getData();\n      var sArray = publicAPI.getScaleArrayData();\n      var sData = null;\n      var numSComp = 0;\n      if (sArray) {\n        sData = sArray.getData();\n        numSComp = sArray.getNumberOfComponents();\n      }\n      if (model.scaling && sArray && model.scaleMode === ScaleModes.SCALE_BY_COMPONENTS && sArray.getNumberOfComponents() !== 3) {\n        vtkErrorMacro('Cannot scale by components since scale array does not have 3 components.');\n        sArray = null;\n      } // get the glyph bounds\n\n      var gbounds = gdata.getBounds(); // convert them to 8 points so we can compute the\n      // overall bounds while building the arrays\n\n      var corners = [];\n      vtkBoundingBox.getCorners(gbounds, corners);\n      model.bounds[0] = vtkBoundingBox.INIT_BOUNDS[0];\n      model.bounds[1] = vtkBoundingBox.INIT_BOUNDS[1];\n      model.bounds[2] = vtkBoundingBox.INIT_BOUNDS[2];\n      model.bounds[3] = vtkBoundingBox.INIT_BOUNDS[3];\n      model.bounds[4] = vtkBoundingBox.INIT_BOUNDS[4];\n      model.bounds[5] = vtkBoundingBox.INIT_BOUNDS[5];\n      var tcorner = new Float64Array(3);\n      var oArray = publicAPI.getOrientationArrayData();\n      var identity = mat4.identity(new Float64Array(16));\n      var trans = [];\n      var scale = [];\n      var numPts = pts.length / 3;\n      model.matrixArray = new Float32Array(16 * numPts);\n      var mbuff = model.matrixArray.buffer;\n      model.normalArray = new Float32Array(9 * numPts);\n      var nbuff = model.normalArray.buffer;\n      var tuple = [];\n      for (var i = 0; i < numPts; ++i) {\n        var z = new Float32Array(mbuff, i * 64, 16);\n        trans[0] = pts[i * 3];\n        trans[1] = pts[i * 3 + 1];\n        trans[2] = pts[i * 3 + 2];\n        mat4.translate(z, identity, trans);\n        if (oArray) {\n          var orientation = [];\n          oArray.getTuple(i, orientation);\n          switch (model.orientationMode) {\n            case OrientationModes.MATRIX:\n              {\n                // prettier-ignore\n                var rotMat4 = [].concat(_toConsumableArray(orientation.slice(0, 3)), [0], _toConsumableArray(orientation.slice(3, 6)), [0], _toConsumableArray(orientation.slice(6, 9)), [0, 0, 0, 0, 1]);\n                mat4.multiply(z, z, rotMat4);\n                break;\n              }\n            case OrientationModes.ROTATION:\n              mat4.rotateZ(z, z, orientation[2]);\n              mat4.rotateX(z, z, orientation[0]);\n              mat4.rotateY(z, z, orientation[1]);\n              break;\n            case OrientationModes.DIRECTION:\n              if (orientation[1] === 0.0 && orientation[2] === 0.0) {\n                if (orientation[0] < 0) {\n                  mat4.rotateY(z, z, 3.1415926);\n                }\n              } else {\n                var vMag = norm(orientation);\n                var vNew = [];\n                vNew[0] = (orientation[0] + vMag) / 2.0;\n                vNew[1] = orientation[1] / 2.0;\n                vNew[2] = orientation[2] / 2.0;\n                mat4.rotate(z, z, 3.1415926, vNew);\n              }\n              break;\n          }\n        } // scale data if appropriate\n\n        if (model.scaling) {\n          scale[0] = model.scaleFactor;\n          scale[1] = model.scaleFactor;\n          scale[2] = model.scaleFactor; // Get the scalar and vector data\n\n          if (sArray) {\n            switch (model.scaleMode) {\n              case ScaleModes.SCALE_BY_MAGNITUDE:\n                for (var t = 0; t < numSComp; ++t) {\n                  tuple[t] = sData[i * numSComp + t];\n                }\n                scale[0] *= norm(tuple, numSComp);\n                scale[1] = scale[0];\n                scale[2] = scale[0];\n                break;\n              case ScaleModes.SCALE_BY_COMPONENTS:\n                for (var _t = 0; _t < numSComp; ++_t) {\n                  tuple[_t] = sData[i * numSComp + _t];\n                }\n                scale[0] *= tuple[0];\n                scale[1] *= tuple[1];\n                scale[2] *= tuple[2];\n                break;\n              case ScaleModes.SCALE_BY_CONSTANT:\n            }\n          }\n          if (scale[0] === 0.0) {\n            scale[0] = 1.0e-10;\n          }\n          if (scale[1] === 0.0) {\n            scale[1] = 1.0e-10;\n          }\n          if (scale[2] === 0.0) {\n            scale[2] = 1.0e-10;\n          }\n          mat4.scale(z, z, scale);\n        } // update bounds\n\n        for (var p = 0; p < 8; ++p) {\n          vec3.transformMat4(tcorner, corners[p], z);\n          if (tcorner[0] < model.bounds[0]) {\n            model.bounds[0] = tcorner[0];\n          }\n          if (tcorner[1] < model.bounds[2]) {\n            model.bounds[2] = tcorner[1];\n          }\n          if (tcorner[2] < model.bounds[4]) {\n            model.bounds[4] = tcorner[2];\n          }\n          if (tcorner[0] > model.bounds[1]) {\n            model.bounds[1] = tcorner[0];\n          }\n          if (tcorner[1] > model.bounds[3]) {\n            model.bounds[3] = tcorner[1];\n          }\n          if (tcorner[2] > model.bounds[5]) {\n            model.bounds[5] = tcorner[2];\n          }\n        }\n        var n = new Float32Array(nbuff, i * 36, 9);\n        mat3.fromMat4(n, z);\n        mat3.invert(n, n);\n        mat3.transpose(n, n);\n      } // map scalars as well\n\n      var scalars = publicAPI.getAbstractScalars(idata, model.scalarMode, model.arrayAccessMode, model.arrayId, model.colorByArrayName).scalars;\n      if (!model.useLookupTableScalarRange) {\n        publicAPI.getLookupTable().setRange(model.scalarRange[0], model.scalarRange[1]);\n      }\n      model.colorArray = null;\n      var lut = publicAPI.getLookupTable();\n      if (lut && scalars) {\n        // Ensure that the lookup table is built\n        lut.build();\n        model.colorArray = lut.mapScalars(scalars, model.colorMode, 0);\n      }\n      model.buildTime.modified();\n    }\n  };\n  publicAPI.getPrimitiveCount = function () {\n    var glyph = publicAPI.getInputData(1);\n    var mult = publicAPI.getInputData().getPoints().getNumberOfValues() / 3;\n    var pcount = {\n      points: mult * glyph.getPoints().getNumberOfValues() / 3,\n      verts: mult * (glyph.getVerts().getNumberOfValues() - glyph.getVerts().getNumberOfCells()),\n      lines: mult * (glyph.getLines().getNumberOfValues() - 2 * glyph.getLines().getNumberOfCells()),\n      triangles: mult * (glyph.getPolys().getNumberOfValues() - 3 * glyph.getLines().getNumberOfCells())\n    };\n    return pcount;\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nvar DEFAULT_VALUES = {\n  orient: true,\n  orientationMode: OrientationModes.DIRECTION,\n  orientationArray: null,\n  scaling: true,\n  scaleFactor: 1.0,\n  scaleMode: ScaleModes.SCALE_BY_MAGNITUDE,\n  scaleArray: null,\n  matrixArray: null,\n  normalArray: null,\n  colorArray: null\n}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Inheritance\n\n  vtkMapper.extend(publicAPI, model, initialValues);\n  macro.algo(publicAPI, model, 2, 0);\n  model.buildTime = {};\n  macro.obj(model.buildTime, {\n    mtime: 0\n  });\n  model.boundsTime = {};\n  macro.obj(model.boundsTime, {\n    mtime: 0\n  });\n  macro.setGet(publicAPI, model, ['orient', 'orientationMode', 'orientationArray', 'scaleArray', 'scaleFactor', 'scaleMode', 'scaling']);\n  macro.get(publicAPI, model, ['colorArray', 'matrixArray', 'normalArray', 'buildTime']); // Object methods\n\n  vtkGlyph3DMapper(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = macro.newInstance(extend, 'vtkGlyph3DMapper'); // ----------------------------------------------------------------------------\n\nvar vtkGlyph3DMapper$1 = _objectSpread({\n  newInstance: newInstance,\n  extend: extend\n}, Constants);\nexport { vtkGlyph3DMapper$1 as default, extend, newInstance };","map":{"version":3,"names":["_defineProperty","_toConsumableArray","mat4","vec3","mat3","Constants","macro","vtkMapper","F","createUninitializedBounds","n","norm","vtkBoundingBox","ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","getOwnPropertyDescriptors","defineProperties","defineProperty","OrientationModes","ScaleModes","vtkErrorMacro","vtkGlyph3DMapper","publicAPI","model","classHierarchy","getOrientationModeAsString","enumToString","orientationMode","setOrientationModeToDirection","setOrientationMode","DIRECTION","setOrientationModeToRotation","ROTATION","setOrientationModeToMatrix","MATRIX","getOrientationArrayData","idata","getInputData","getPointData","orientationArray","getVectors","getArray","getScaleModeAsString","scaleMode","setScaleModeToScaleByMagnitude","setScaleMode","SCALE_BY_MAGNITUDE","setScaleModeToScaleByComponents","SCALE_BY_COMPONENTS","setScaleModeToScaleByConstant","SCALE_BY_CONSTANT","getScaleArrayData","scaleArray","getScalars","getBounds","gdata","buildArrays","bounds","buildTime","getMTime","pts","getPoints","getData","sArray","sData","numSComp","getNumberOfComponents","scaling","gbounds","corners","getCorners","INIT_BOUNDS","tcorner","Float64Array","oArray","identity","trans","scale","numPts","matrixArray","Float32Array","mbuff","buffer","normalArray","nbuff","tuple","z","translate","orientation","getTuple","rotMat4","concat","slice","multiply","rotateZ","rotateX","rotateY","vMag","vNew","rotate","scaleFactor","t","_t","p","transformMat4","fromMat4","invert","transpose","scalars","getAbstractScalars","scalarMode","arrayAccessMode","arrayId","colorByArrayName","useLookupTableScalarRange","getLookupTable","setRange","scalarRange","colorArray","lut","build","mapScalars","colorMode","modified","getPrimitiveCount","glyph","mult","getNumberOfValues","pcount","points","verts","getVerts","getNumberOfCells","lines","getLines","triangles","getPolys","DEFAULT_VALUES","orient","extend","initialValues","undefined","assign","algo","obj","mtime","boundsTime","setGet","get","newInstance","vtkGlyph3DMapper$1","default"],"sources":["/home/rakshith/Documents/RemoteRendering/vtk-js-react-app/node_modules/@kitware/vtk.js/Rendering/Core/Glyph3DMapper.js"],"sourcesContent":["import _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport _toConsumableArray from '@babel/runtime/helpers/toConsumableArray';\nimport { mat4, vec3, mat3 } from 'gl-matrix';\nimport Constants from './Glyph3DMapper/Constants.js';\nimport macro from '../../macros.js';\nimport vtkMapper from './Mapper.js';\nimport { F as createUninitializedBounds, n as norm } from '../../Common/Core/Math/index.js';\nimport vtkBoundingBox from '../../Common/DataModel/BoundingBox.js';\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nvar OrientationModes = Constants.OrientationModes,\n    ScaleModes = Constants.ScaleModes;\nvar vtkErrorMacro = macro.vtkErrorMacro; // ----------------------------------------------------------------------------\n// class methods\n// ----------------------------------------------------------------------------\n\nfunction vtkGlyph3DMapper(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkGlyph3DMapper');\n  /**\n   * An orientation array is a vtkDataArray with 3 components. The first\n   * component is the angle of rotation along the X axis. The second\n   * component is the angle of rotation along the Y axis. The third\n   * component is the angle of rotation along the Z axis. Orientation is\n   * specified in X,Y,Z order but the rotations are performed in Z,X an Y.\n   * This definition is compliant with SetOrientation method on vtkProp3D.\n   * By using vector or normal there is a degree of freedom or rotation\n   * left (underconstrained). With the orientation array, there is no degree of\n   * freedom left.\n   */\n\n  publicAPI.getOrientationModeAsString = function () {\n    return macro.enumToString(OrientationModes, model.orientationMode);\n  };\n\n  publicAPI.setOrientationModeToDirection = function () {\n    return publicAPI.setOrientationMode(OrientationModes.DIRECTION);\n  };\n\n  publicAPI.setOrientationModeToRotation = function () {\n    return publicAPI.setOrientationMode(OrientationModes.ROTATION);\n  };\n\n  publicAPI.setOrientationModeToMatrix = function () {\n    return publicAPI.setOrientationMode(OrientationModes.MATRIX);\n  };\n\n  publicAPI.getOrientationArrayData = function () {\n    var idata = publicAPI.getInputData(0);\n\n    if (!idata || !idata.getPointData()) {\n      return null;\n    }\n\n    if (!model.orientationArray) {\n      return idata.getPointData().getVectors();\n    }\n\n    return idata.getPointData().getArray(model.orientationArray);\n  };\n\n  publicAPI.getScaleModeAsString = function () {\n    return macro.enumToString(ScaleModes, model.scaleMode);\n  };\n\n  publicAPI.setScaleModeToScaleByMagnitude = function () {\n    return publicAPI.setScaleMode(ScaleModes.SCALE_BY_MAGNITUDE);\n  };\n\n  publicAPI.setScaleModeToScaleByComponents = function () {\n    return publicAPI.setScaleMode(ScaleModes.SCALE_BY_COMPONENTS);\n  };\n\n  publicAPI.setScaleModeToScaleByConstant = function () {\n    return publicAPI.setScaleMode(ScaleModes.SCALE_BY_CONSTANT);\n  };\n\n  publicAPI.getScaleArrayData = function () {\n    var idata = publicAPI.getInputData(0);\n\n    if (!idata || !idata.getPointData()) {\n      return null;\n    }\n\n    if (!model.scaleArray) {\n      return idata.getPointData().getScalars();\n    }\n\n    return idata.getPointData().getArray(model.scaleArray);\n  };\n\n  publicAPI.getBounds = function () {\n    var idata = publicAPI.getInputData(0);\n    var gdata = publicAPI.getInputData(1);\n\n    if (!idata || !gdata) {\n      return createUninitializedBounds();\n    } // first we build the arrays used for the glyphing\n\n\n    publicAPI.buildArrays();\n    return model.bounds;\n  };\n\n  publicAPI.buildArrays = function () {\n    // if the mtgime requires it, rebuild\n    var idata = publicAPI.getInputData(0);\n    var gdata = publicAPI.getInputData(1);\n\n    if (model.buildTime.getMTime() < gdata.getMTime() || model.buildTime.getMTime() < idata.getMTime() || model.buildTime.getMTime() < publicAPI.getMTime()) {\n      var pts = idata.getPoints().getData();\n      var sArray = publicAPI.getScaleArrayData();\n      var sData = null;\n      var numSComp = 0;\n\n      if (sArray) {\n        sData = sArray.getData();\n        numSComp = sArray.getNumberOfComponents();\n      }\n\n      if (model.scaling && sArray && model.scaleMode === ScaleModes.SCALE_BY_COMPONENTS && sArray.getNumberOfComponents() !== 3) {\n        vtkErrorMacro('Cannot scale by components since scale array does not have 3 components.');\n        sArray = null;\n      } // get the glyph bounds\n\n\n      var gbounds = gdata.getBounds(); // convert them to 8 points so we can compute the\n      // overall bounds while building the arrays\n\n      var corners = [];\n      vtkBoundingBox.getCorners(gbounds, corners);\n      model.bounds[0] = vtkBoundingBox.INIT_BOUNDS[0];\n      model.bounds[1] = vtkBoundingBox.INIT_BOUNDS[1];\n      model.bounds[2] = vtkBoundingBox.INIT_BOUNDS[2];\n      model.bounds[3] = vtkBoundingBox.INIT_BOUNDS[3];\n      model.bounds[4] = vtkBoundingBox.INIT_BOUNDS[4];\n      model.bounds[5] = vtkBoundingBox.INIT_BOUNDS[5];\n      var tcorner = new Float64Array(3);\n      var oArray = publicAPI.getOrientationArrayData();\n      var identity = mat4.identity(new Float64Array(16));\n      var trans = [];\n      var scale = [];\n      var numPts = pts.length / 3;\n      model.matrixArray = new Float32Array(16 * numPts);\n      var mbuff = model.matrixArray.buffer;\n      model.normalArray = new Float32Array(9 * numPts);\n      var nbuff = model.normalArray.buffer;\n      var tuple = [];\n\n      for (var i = 0; i < numPts; ++i) {\n        var z = new Float32Array(mbuff, i * 64, 16);\n        trans[0] = pts[i * 3];\n        trans[1] = pts[i * 3 + 1];\n        trans[2] = pts[i * 3 + 2];\n        mat4.translate(z, identity, trans);\n\n        if (oArray) {\n          var orientation = [];\n          oArray.getTuple(i, orientation);\n\n          switch (model.orientationMode) {\n            case OrientationModes.MATRIX:\n              {\n                // prettier-ignore\n                var rotMat4 = [].concat(_toConsumableArray(orientation.slice(0, 3)), [0], _toConsumableArray(orientation.slice(3, 6)), [0], _toConsumableArray(orientation.slice(6, 9)), [0, 0, 0, 0, 1]);\n                mat4.multiply(z, z, rotMat4);\n                break;\n              }\n\n            case OrientationModes.ROTATION:\n              mat4.rotateZ(z, z, orientation[2]);\n              mat4.rotateX(z, z, orientation[0]);\n              mat4.rotateY(z, z, orientation[1]);\n              break;\n\n            case OrientationModes.DIRECTION:\n              if (orientation[1] === 0.0 && orientation[2] === 0.0) {\n                if (orientation[0] < 0) {\n                  mat4.rotateY(z, z, 3.1415926);\n                }\n              } else {\n                var vMag = norm(orientation);\n                var vNew = [];\n                vNew[0] = (orientation[0] + vMag) / 2.0;\n                vNew[1] = orientation[1] / 2.0;\n                vNew[2] = orientation[2] / 2.0;\n                mat4.rotate(z, z, 3.1415926, vNew);\n              }\n\n              break;\n          }\n        } // scale data if appropriate\n\n\n        if (model.scaling) {\n          scale[0] = model.scaleFactor;\n          scale[1] = model.scaleFactor;\n          scale[2] = model.scaleFactor; // Get the scalar and vector data\n\n          if (sArray) {\n            switch (model.scaleMode) {\n              case ScaleModes.SCALE_BY_MAGNITUDE:\n                for (var t = 0; t < numSComp; ++t) {\n                  tuple[t] = sData[i * numSComp + t];\n                }\n\n                scale[0] *= norm(tuple, numSComp);\n                scale[1] = scale[0];\n                scale[2] = scale[0];\n                break;\n\n              case ScaleModes.SCALE_BY_COMPONENTS:\n                for (var _t = 0; _t < numSComp; ++_t) {\n                  tuple[_t] = sData[i * numSComp + _t];\n                }\n\n                scale[0] *= tuple[0];\n                scale[1] *= tuple[1];\n                scale[2] *= tuple[2];\n                break;\n\n              case ScaleModes.SCALE_BY_CONSTANT:\n            }\n          }\n\n          if (scale[0] === 0.0) {\n            scale[0] = 1.0e-10;\n          }\n\n          if (scale[1] === 0.0) {\n            scale[1] = 1.0e-10;\n          }\n\n          if (scale[2] === 0.0) {\n            scale[2] = 1.0e-10;\n          }\n\n          mat4.scale(z, z, scale);\n        } // update bounds\n\n\n        for (var p = 0; p < 8; ++p) {\n          vec3.transformMat4(tcorner, corners[p], z);\n\n          if (tcorner[0] < model.bounds[0]) {\n            model.bounds[0] = tcorner[0];\n          }\n\n          if (tcorner[1] < model.bounds[2]) {\n            model.bounds[2] = tcorner[1];\n          }\n\n          if (tcorner[2] < model.bounds[4]) {\n            model.bounds[4] = tcorner[2];\n          }\n\n          if (tcorner[0] > model.bounds[1]) {\n            model.bounds[1] = tcorner[0];\n          }\n\n          if (tcorner[1] > model.bounds[3]) {\n            model.bounds[3] = tcorner[1];\n          }\n\n          if (tcorner[2] > model.bounds[5]) {\n            model.bounds[5] = tcorner[2];\n          }\n        }\n\n        var n = new Float32Array(nbuff, i * 36, 9);\n        mat3.fromMat4(n, z);\n        mat3.invert(n, n);\n        mat3.transpose(n, n);\n      } // map scalars as well\n\n\n      var scalars = publicAPI.getAbstractScalars(idata, model.scalarMode, model.arrayAccessMode, model.arrayId, model.colorByArrayName).scalars;\n\n      if (!model.useLookupTableScalarRange) {\n        publicAPI.getLookupTable().setRange(model.scalarRange[0], model.scalarRange[1]);\n      }\n\n      model.colorArray = null;\n      var lut = publicAPI.getLookupTable();\n\n      if (lut && scalars) {\n        // Ensure that the lookup table is built\n        lut.build();\n        model.colorArray = lut.mapScalars(scalars, model.colorMode, 0);\n      }\n\n      model.buildTime.modified();\n    }\n  };\n\n  publicAPI.getPrimitiveCount = function () {\n    var glyph = publicAPI.getInputData(1);\n    var mult = publicAPI.getInputData().getPoints().getNumberOfValues() / 3;\n    var pcount = {\n      points: mult * glyph.getPoints().getNumberOfValues() / 3,\n      verts: mult * (glyph.getVerts().getNumberOfValues() - glyph.getVerts().getNumberOfCells()),\n      lines: mult * (glyph.getLines().getNumberOfValues() - 2 * glyph.getLines().getNumberOfCells()),\n      triangles: mult * (glyph.getPolys().getNumberOfValues() - 3 * glyph.getLines().getNumberOfCells())\n    };\n    return pcount;\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\n\nvar DEFAULT_VALUES = {\n  orient: true,\n  orientationMode: OrientationModes.DIRECTION,\n  orientationArray: null,\n  scaling: true,\n  scaleFactor: 1.0,\n  scaleMode: ScaleModes.SCALE_BY_MAGNITUDE,\n  scaleArray: null,\n  matrixArray: null,\n  normalArray: null,\n  colorArray: null\n}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Inheritance\n\n  vtkMapper.extend(publicAPI, model, initialValues);\n  macro.algo(publicAPI, model, 2, 0);\n  model.buildTime = {};\n  macro.obj(model.buildTime, {\n    mtime: 0\n  });\n  model.boundsTime = {};\n  macro.obj(model.boundsTime, {\n    mtime: 0\n  });\n  macro.setGet(publicAPI, model, ['orient', 'orientationMode', 'orientationArray', 'scaleArray', 'scaleFactor', 'scaleMode', 'scaling']);\n  macro.get(publicAPI, model, ['colorArray', 'matrixArray', 'normalArray', 'buildTime']); // Object methods\n\n  vtkGlyph3DMapper(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = macro.newInstance(extend, 'vtkGlyph3DMapper'); // ----------------------------------------------------------------------------\n\nvar vtkGlyph3DMapper$1 = _objectSpread({\n  newInstance: newInstance,\n  extend: extend\n}, Constants);\n\nexport { vtkGlyph3DMapper$1 as default, extend, newInstance };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}