{"ast":null,"code":"import _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport Constants from './ImageMapper/Constants.js';\nimport macro from '../../macros.js';\nimport vtkAbstractImageMapper from './AbstractImageMapper.js';\nimport { intersectWithLineForPointPicking, intersectWithLineForCellPicking } from './AbstractImageMapper/helper.js';\nimport { C as clampValue, O as multiply3x3_vect3, F as createUninitializedBounds } from '../../Common/Core/Math/index.js';\nimport CoincidentTopologyHelper from './Mapper/CoincidentTopologyHelper.js';\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n  return target;\n}\nvar staticOffsetAPI = CoincidentTopologyHelper.staticOffsetAPI,\n  otherStaticMethods = CoincidentTopologyHelper.otherStaticMethods;\nvar vtkWarningMacro = macro.vtkWarningMacro;\nvar SlicingMode = Constants.SlicingMode; // ----------------------------------------------------------------------------\n// vtkImageMapper methods\n// ----------------------------------------------------------------------------\n\nfunction vtkImageMapper(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkImageMapper');\n  publicAPI.getSliceAtPosition = function (pos) {\n    var image = publicAPI.getCurrentImage();\n    var pos3;\n    if (pos.length === 3) {\n      pos3 = pos;\n    } else if (Number.isFinite(pos)) {\n      var bds = image.getBounds();\n      switch (model.slicingMode) {\n        case SlicingMode.X:\n          pos3 = [pos, (bds[3] + bds[2]) / 2, (bds[5] + bds[4]) / 2];\n          break;\n        case SlicingMode.Y:\n          pos3 = [(bds[1] + bds[0]) / 2, pos, (bds[5] + bds[4]) / 2];\n          break;\n        case SlicingMode.Z:\n          pos3 = [(bds[1] + bds[0]) / 2, (bds[3] + bds[2]) / 2, pos];\n          break;\n      }\n    }\n    var ijk = [0, 0, 0];\n    image.worldToIndex(pos3, ijk);\n    var ex = image.getExtent();\n    var _publicAPI$getClosest = publicAPI.getClosestIJKAxis(),\n      ijkMode = _publicAPI$getClosest.ijkMode;\n    var slice = 0;\n    switch (ijkMode) {\n      case SlicingMode.I:\n        slice = clampValue(ijk[0], ex[0], ex[1]);\n        break;\n      case SlicingMode.J:\n        slice = clampValue(ijk[1], ex[2], ex[3]);\n        break;\n      case SlicingMode.K:\n        slice = clampValue(ijk[2], ex[4], ex[5]);\n        break;\n      default:\n        return 0;\n    }\n    return slice;\n  };\n  publicAPI.setSliceFromCamera = function (cam) {\n    var fp = cam.getFocalPoint();\n    switch (model.slicingMode) {\n      case SlicingMode.I:\n      case SlicingMode.J:\n      case SlicingMode.K:\n        {\n          var slice = publicAPI.getSliceAtPosition(fp);\n          publicAPI.setSlice(slice);\n        }\n        break;\n      case SlicingMode.X:\n        publicAPI.setSlice(fp[0]);\n        break;\n      case SlicingMode.Y:\n        publicAPI.setSlice(fp[1]);\n        break;\n      case SlicingMode.Z:\n        publicAPI.setSlice(fp[2]);\n        break;\n    }\n  };\n  publicAPI.setXSlice = function (id) {\n    publicAPI.setSlicingMode(SlicingMode.X);\n    publicAPI.setSlice(id);\n  };\n  publicAPI.setYSlice = function (id) {\n    publicAPI.setSlicingMode(SlicingMode.Y);\n    publicAPI.setSlice(id);\n  };\n  publicAPI.setZSlice = function (id) {\n    publicAPI.setSlicingMode(SlicingMode.Z);\n    publicAPI.setSlice(id);\n  };\n  publicAPI.setISlice = function (id) {\n    publicAPI.setSlicingMode(SlicingMode.I);\n    publicAPI.setSlice(id);\n  };\n  publicAPI.setJSlice = function (id) {\n    publicAPI.setSlicingMode(SlicingMode.J);\n    publicAPI.setSlice(id);\n  };\n  publicAPI.setKSlice = function (id) {\n    publicAPI.setSlicingMode(SlicingMode.K);\n    publicAPI.setSlice(id);\n  };\n  publicAPI.getSlicingModeNormal = function () {\n    var out = [0, 0, 0];\n    var mat3 = publicAPI.getCurrentImage().getDirection();\n    switch (model.slicingMode) {\n      case SlicingMode.X:\n        out[0] = 1;\n        break;\n      case SlicingMode.Y:\n        out[1] = 1;\n        break;\n      case SlicingMode.Z:\n        out[2] = 1;\n        break;\n      case SlicingMode.I:\n        multiply3x3_vect3(mat3, [1, 0, 0], out);\n        break;\n      case SlicingMode.J:\n        multiply3x3_vect3(mat3, [0, 1, 0], out);\n        break;\n      case SlicingMode.K:\n        multiply3x3_vect3(mat3, [0, 0, 1], out);\n        break;\n    }\n    return out;\n  };\n  function computeClosestIJKAxis() {\n    var inVec3;\n    switch (model.slicingMode) {\n      case SlicingMode.X:\n        inVec3 = [1, 0, 0];\n        break;\n      case SlicingMode.Y:\n        inVec3 = [0, 1, 0];\n        break;\n      case SlicingMode.Z:\n        inVec3 = [0, 0, 1];\n        break;\n      default:\n        model.closestIJKAxis = {\n          ijkMode: model.slicingMode,\n          flip: false\n        };\n        return;\n    } // Project vec3 onto direction cosines\n\n    var out = [0, 0, 0]; // The direction matrix in vtkImageData is the indexToWorld rotation matrix\n    // with a column-major data layout since it is stored as a WebGL matrix.\n    // We need the worldToIndex rotation matrix for the projection, and it needs\n    // to be in a row-major data layout to use vtkMath for operations.\n    // To go from the indexToWorld column-major matrix to the worldToIndex\n    // row-major matrix, we need to transpose it (column -> row) then inverse it.\n    // However, that 3x3 matrix is a rotation matrix which is orthonormal, meaning\n    // that its inverse is equal to its transpose. We therefore need to apply two\n    // transpositions resulting in a no-op.\n\n    var a = publicAPI.getCurrentImage().getDirection();\n    multiply3x3_vect3(a, inVec3, out);\n    var maxAbs = 0.0;\n    var ijkMode = -1;\n    var flip = false;\n    for (var axis = 0; axis < out.length; ++axis) {\n      var absValue = Math.abs(out[axis]);\n      if (absValue > maxAbs) {\n        maxAbs = absValue;\n        flip = out[axis] < 0.0;\n        ijkMode = axis;\n      }\n    }\n    if (maxAbs !== 1.0) {\n      var xyzLabel = 'IJKXYZ'[model.slicingMode];\n      var ijkLabel = 'IJKXYZ'[ijkMode];\n      vtkWarningMacro(\"Unaccurate slicing along \".concat(xyzLabel, \" axis which \") + \"is not aligned with any IJK axis of the image data. \" + \"Using \".concat(ijkLabel, \" axis  as a fallback (\").concat(maxAbs, \"% aligned). \") + \"Necessitates slice reformat that is not yet implemented.  \" + \"You can switch the slicing mode on your mapper to do IJK slicing instead.\");\n    }\n    model.closestIJKAxis = {\n      ijkMode: ijkMode,\n      flip: flip\n    };\n  }\n  publicAPI.setSlicingMode = function (mode) {\n    if (model.slicingMode === mode) {\n      return;\n    }\n    model.slicingMode = mode;\n    if (publicAPI.getCurrentImage()) {\n      computeClosestIJKAxis();\n    }\n    publicAPI.modified();\n  };\n  publicAPI.getClosestIJKAxis = function () {\n    if ((model.closestIJKAxis === undefined || model.closestIJKAxis.ijkMode === SlicingMode.NONE) && publicAPI.getCurrentImage()) {\n      computeClosestIJKAxis();\n    }\n    return model.closestIJKAxis;\n  };\n  publicAPI.getBounds = function () {\n    var image = publicAPI.getCurrentImage();\n    if (!image) {\n      return createUninitializedBounds();\n    }\n    if (!model.useCustomExtents) {\n      return image.getBounds();\n    }\n    var ex = model.customDisplayExtent.slice();\n    var _publicAPI$getClosest2 = publicAPI.getClosestIJKAxis(),\n      ijkMode = _publicAPI$getClosest2.ijkMode;\n    var nSlice = model.slice;\n    if (ijkMode !== model.slicingMode) {\n      // If not IJK slicing, get the IJK slice from the XYZ position/slice\n      nSlice = publicAPI.getSliceAtPosition(model.slice);\n    }\n    switch (ijkMode) {\n      case SlicingMode.I:\n        ex[0] = nSlice;\n        ex[1] = nSlice;\n        break;\n      case SlicingMode.J:\n        ex[2] = nSlice;\n        ex[3] = nSlice;\n        break;\n      case SlicingMode.K:\n        ex[4] = nSlice;\n        ex[5] = nSlice;\n        break;\n    }\n    return image.extentToBounds(ex);\n  };\n  publicAPI.getBoundsForSlice = function () {\n    var slice = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : model.slice;\n    var halfThickness = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    var image = publicAPI.getCurrentImage();\n    if (!image) {\n      return createUninitializedBounds();\n    }\n    var extent = image.getSpatialExtent();\n    var _publicAPI$getClosest3 = publicAPI.getClosestIJKAxis(),\n      ijkMode = _publicAPI$getClosest3.ijkMode;\n    var nSlice = slice;\n    if (ijkMode !== model.slicingMode) {\n      // If not IJK slicing, get the IJK slice from the XYZ position/slice\n      nSlice = publicAPI.getSliceAtPosition(slice);\n    }\n    switch (ijkMode) {\n      case SlicingMode.I:\n        extent[0] = nSlice - halfThickness;\n        extent[1] = nSlice + halfThickness;\n        break;\n      case SlicingMode.J:\n        extent[2] = nSlice - halfThickness;\n        extent[3] = nSlice + halfThickness;\n        break;\n      case SlicingMode.K:\n        extent[4] = nSlice - halfThickness;\n        extent[5] = nSlice + halfThickness;\n        break;\n    }\n    return image.extentToBounds(extent);\n  };\n  publicAPI.intersectWithLineForPointPicking = function (p1, p2) {\n    return intersectWithLineForPointPicking(p1, p2, publicAPI);\n  };\n  publicAPI.intersectWithLineForCellPicking = function (p1, p2) {\n    return intersectWithLineForCellPicking(p1, p2, publicAPI);\n  };\n  publicAPI.getCurrentImage = function () {\n    return publicAPI.getInputData();\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nvar DEFAULT_VALUES = {\n  slicingMode: SlicingMode.NONE,\n  closestIJKAxis: {\n    ijkMode: SlicingMode.NONE,\n    flip: false\n  },\n  renderToRectangle: false,\n  sliceAtFocalPoint: false,\n  preferSizeOverAccuracy: false // Whether to use halfFloat representation of float, when it is inaccurate\n}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Build VTK API\n\n  vtkAbstractImageMapper.extend(publicAPI, model, initialValues);\n  macro.get(publicAPI, model, ['slicingMode']);\n  macro.setGet(publicAPI, model, ['closestIJKAxis', 'renderToRectangle', 'sliceAtFocalPoint', 'preferSizeOverAccuracy']);\n  CoincidentTopologyHelper.implementCoincidentTopologyMethods(publicAPI, model); // Object methods\n\n  vtkImageMapper(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = macro.newInstance(extend, 'vtkImageMapper'); // ----------------------------------------------------------------------------\n\nvar vtkImageMapper$1 = _objectSpread(_objectSpread(_objectSpread({\n  newInstance: newInstance,\n  extend: extend\n}, staticOffsetAPI), otherStaticMethods), Constants);\nexport { vtkImageMapper$1 as default, extend, newInstance };","map":{"version":3,"names":["_defineProperty","Constants","macro","vtkAbstractImageMapper","intersectWithLineForPointPicking","intersectWithLineForCellPicking","C","clampValue","O","multiply3x3_vect3","F","createUninitializedBounds","CoincidentTopologyHelper","ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","getOwnPropertyDescriptors","defineProperties","defineProperty","staticOffsetAPI","otherStaticMethods","vtkWarningMacro","SlicingMode","vtkImageMapper","publicAPI","model","classHierarchy","getSliceAtPosition","pos","image","getCurrentImage","pos3","Number","isFinite","bds","getBounds","slicingMode","X","Y","Z","ijk","worldToIndex","ex","getExtent","_publicAPI$getClosest","getClosestIJKAxis","ijkMode","slice","I","J","K","setSliceFromCamera","cam","fp","getFocalPoint","setSlice","setXSlice","id","setSlicingMode","setYSlice","setZSlice","setISlice","setJSlice","setKSlice","getSlicingModeNormal","out","mat3","getDirection","computeClosestIJKAxis","inVec3","closestIJKAxis","flip","a","maxAbs","axis","absValue","Math","abs","xyzLabel","ijkLabel","concat","mode","modified","undefined","NONE","useCustomExtents","customDisplayExtent","_publicAPI$getClosest2","nSlice","extentToBounds","getBoundsForSlice","halfThickness","extent","getSpatialExtent","_publicAPI$getClosest3","p1","p2","getInputData","DEFAULT_VALUES","renderToRectangle","sliceAtFocalPoint","preferSizeOverAccuracy","extend","initialValues","assign","get","setGet","implementCoincidentTopologyMethods","newInstance","vtkImageMapper$1","default"],"sources":["/home/rakshith/Documents/RemoteRendering/vtk-js-react-app/node_modules/@kitware/vtk.js/Rendering/Core/ImageMapper.js"],"sourcesContent":["import _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport Constants from './ImageMapper/Constants.js';\nimport macro from '../../macros.js';\nimport vtkAbstractImageMapper from './AbstractImageMapper.js';\nimport { intersectWithLineForPointPicking, intersectWithLineForCellPicking } from './AbstractImageMapper/helper.js';\nimport { C as clampValue, O as multiply3x3_vect3, F as createUninitializedBounds } from '../../Common/Core/Math/index.js';\nimport CoincidentTopologyHelper from './Mapper/CoincidentTopologyHelper.js';\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nvar staticOffsetAPI = CoincidentTopologyHelper.staticOffsetAPI,\n    otherStaticMethods = CoincidentTopologyHelper.otherStaticMethods;\nvar vtkWarningMacro = macro.vtkWarningMacro;\nvar SlicingMode = Constants.SlicingMode; // ----------------------------------------------------------------------------\n// vtkImageMapper methods\n// ----------------------------------------------------------------------------\n\nfunction vtkImageMapper(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkImageMapper');\n\n  publicAPI.getSliceAtPosition = function (pos) {\n    var image = publicAPI.getCurrentImage();\n    var pos3;\n\n    if (pos.length === 3) {\n      pos3 = pos;\n    } else if (Number.isFinite(pos)) {\n      var bds = image.getBounds();\n\n      switch (model.slicingMode) {\n        case SlicingMode.X:\n          pos3 = [pos, (bds[3] + bds[2]) / 2, (bds[5] + bds[4]) / 2];\n          break;\n\n        case SlicingMode.Y:\n          pos3 = [(bds[1] + bds[0]) / 2, pos, (bds[5] + bds[4]) / 2];\n          break;\n\n        case SlicingMode.Z:\n          pos3 = [(bds[1] + bds[0]) / 2, (bds[3] + bds[2]) / 2, pos];\n          break;\n      }\n    }\n\n    var ijk = [0, 0, 0];\n    image.worldToIndex(pos3, ijk);\n    var ex = image.getExtent();\n\n    var _publicAPI$getClosest = publicAPI.getClosestIJKAxis(),\n        ijkMode = _publicAPI$getClosest.ijkMode;\n\n    var slice = 0;\n\n    switch (ijkMode) {\n      case SlicingMode.I:\n        slice = clampValue(ijk[0], ex[0], ex[1]);\n        break;\n\n      case SlicingMode.J:\n        slice = clampValue(ijk[1], ex[2], ex[3]);\n        break;\n\n      case SlicingMode.K:\n        slice = clampValue(ijk[2], ex[4], ex[5]);\n        break;\n\n      default:\n        return 0;\n    }\n\n    return slice;\n  };\n\n  publicAPI.setSliceFromCamera = function (cam) {\n    var fp = cam.getFocalPoint();\n\n    switch (model.slicingMode) {\n      case SlicingMode.I:\n      case SlicingMode.J:\n      case SlicingMode.K:\n        {\n          var slice = publicAPI.getSliceAtPosition(fp);\n          publicAPI.setSlice(slice);\n        }\n        break;\n\n      case SlicingMode.X:\n        publicAPI.setSlice(fp[0]);\n        break;\n\n      case SlicingMode.Y:\n        publicAPI.setSlice(fp[1]);\n        break;\n\n      case SlicingMode.Z:\n        publicAPI.setSlice(fp[2]);\n        break;\n    }\n  };\n\n  publicAPI.setXSlice = function (id) {\n    publicAPI.setSlicingMode(SlicingMode.X);\n    publicAPI.setSlice(id);\n  };\n\n  publicAPI.setYSlice = function (id) {\n    publicAPI.setSlicingMode(SlicingMode.Y);\n    publicAPI.setSlice(id);\n  };\n\n  publicAPI.setZSlice = function (id) {\n    publicAPI.setSlicingMode(SlicingMode.Z);\n    publicAPI.setSlice(id);\n  };\n\n  publicAPI.setISlice = function (id) {\n    publicAPI.setSlicingMode(SlicingMode.I);\n    publicAPI.setSlice(id);\n  };\n\n  publicAPI.setJSlice = function (id) {\n    publicAPI.setSlicingMode(SlicingMode.J);\n    publicAPI.setSlice(id);\n  };\n\n  publicAPI.setKSlice = function (id) {\n    publicAPI.setSlicingMode(SlicingMode.K);\n    publicAPI.setSlice(id);\n  };\n\n  publicAPI.getSlicingModeNormal = function () {\n    var out = [0, 0, 0];\n    var mat3 = publicAPI.getCurrentImage().getDirection();\n\n    switch (model.slicingMode) {\n      case SlicingMode.X:\n        out[0] = 1;\n        break;\n\n      case SlicingMode.Y:\n        out[1] = 1;\n        break;\n\n      case SlicingMode.Z:\n        out[2] = 1;\n        break;\n\n      case SlicingMode.I:\n        multiply3x3_vect3(mat3, [1, 0, 0], out);\n        break;\n\n      case SlicingMode.J:\n        multiply3x3_vect3(mat3, [0, 1, 0], out);\n        break;\n\n      case SlicingMode.K:\n        multiply3x3_vect3(mat3, [0, 0, 1], out);\n        break;\n    }\n\n    return out;\n  };\n\n  function computeClosestIJKAxis() {\n    var inVec3;\n\n    switch (model.slicingMode) {\n      case SlicingMode.X:\n        inVec3 = [1, 0, 0];\n        break;\n\n      case SlicingMode.Y:\n        inVec3 = [0, 1, 0];\n        break;\n\n      case SlicingMode.Z:\n        inVec3 = [0, 0, 1];\n        break;\n\n      default:\n        model.closestIJKAxis = {\n          ijkMode: model.slicingMode,\n          flip: false\n        };\n        return;\n    } // Project vec3 onto direction cosines\n\n\n    var out = [0, 0, 0]; // The direction matrix in vtkImageData is the indexToWorld rotation matrix\n    // with a column-major data layout since it is stored as a WebGL matrix.\n    // We need the worldToIndex rotation matrix for the projection, and it needs\n    // to be in a row-major data layout to use vtkMath for operations.\n    // To go from the indexToWorld column-major matrix to the worldToIndex\n    // row-major matrix, we need to transpose it (column -> row) then inverse it.\n    // However, that 3x3 matrix is a rotation matrix which is orthonormal, meaning\n    // that its inverse is equal to its transpose. We therefore need to apply two\n    // transpositions resulting in a no-op.\n\n    var a = publicAPI.getCurrentImage().getDirection();\n    multiply3x3_vect3(a, inVec3, out);\n    var maxAbs = 0.0;\n    var ijkMode = -1;\n    var flip = false;\n\n    for (var axis = 0; axis < out.length; ++axis) {\n      var absValue = Math.abs(out[axis]);\n\n      if (absValue > maxAbs) {\n        maxAbs = absValue;\n        flip = out[axis] < 0.0;\n        ijkMode = axis;\n      }\n    }\n\n    if (maxAbs !== 1.0) {\n      var xyzLabel = 'IJKXYZ'[model.slicingMode];\n      var ijkLabel = 'IJKXYZ'[ijkMode];\n      vtkWarningMacro(\"Unaccurate slicing along \".concat(xyzLabel, \" axis which \") + \"is not aligned with any IJK axis of the image data. \" + \"Using \".concat(ijkLabel, \" axis  as a fallback (\").concat(maxAbs, \"% aligned). \") + \"Necessitates slice reformat that is not yet implemented.  \" + \"You can switch the slicing mode on your mapper to do IJK slicing instead.\");\n    }\n\n    model.closestIJKAxis = {\n      ijkMode: ijkMode,\n      flip: flip\n    };\n  }\n\n  publicAPI.setSlicingMode = function (mode) {\n    if (model.slicingMode === mode) {\n      return;\n    }\n\n    model.slicingMode = mode;\n\n    if (publicAPI.getCurrentImage()) {\n      computeClosestIJKAxis();\n    }\n\n    publicAPI.modified();\n  };\n\n  publicAPI.getClosestIJKAxis = function () {\n    if ((model.closestIJKAxis === undefined || model.closestIJKAxis.ijkMode === SlicingMode.NONE) && publicAPI.getCurrentImage()) {\n      computeClosestIJKAxis();\n    }\n\n    return model.closestIJKAxis;\n  };\n\n  publicAPI.getBounds = function () {\n    var image = publicAPI.getCurrentImage();\n\n    if (!image) {\n      return createUninitializedBounds();\n    }\n\n    if (!model.useCustomExtents) {\n      return image.getBounds();\n    }\n\n    var ex = model.customDisplayExtent.slice();\n\n    var _publicAPI$getClosest2 = publicAPI.getClosestIJKAxis(),\n        ijkMode = _publicAPI$getClosest2.ijkMode;\n\n    var nSlice = model.slice;\n\n    if (ijkMode !== model.slicingMode) {\n      // If not IJK slicing, get the IJK slice from the XYZ position/slice\n      nSlice = publicAPI.getSliceAtPosition(model.slice);\n    }\n\n    switch (ijkMode) {\n      case SlicingMode.I:\n        ex[0] = nSlice;\n        ex[1] = nSlice;\n        break;\n\n      case SlicingMode.J:\n        ex[2] = nSlice;\n        ex[3] = nSlice;\n        break;\n\n      case SlicingMode.K:\n        ex[4] = nSlice;\n        ex[5] = nSlice;\n        break;\n    }\n\n    return image.extentToBounds(ex);\n  };\n\n  publicAPI.getBoundsForSlice = function () {\n    var slice = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : model.slice;\n    var halfThickness = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    var image = publicAPI.getCurrentImage();\n\n    if (!image) {\n      return createUninitializedBounds();\n    }\n\n    var extent = image.getSpatialExtent();\n\n    var _publicAPI$getClosest3 = publicAPI.getClosestIJKAxis(),\n        ijkMode = _publicAPI$getClosest3.ijkMode;\n\n    var nSlice = slice;\n\n    if (ijkMode !== model.slicingMode) {\n      // If not IJK slicing, get the IJK slice from the XYZ position/slice\n      nSlice = publicAPI.getSliceAtPosition(slice);\n    }\n\n    switch (ijkMode) {\n      case SlicingMode.I:\n        extent[0] = nSlice - halfThickness;\n        extent[1] = nSlice + halfThickness;\n        break;\n\n      case SlicingMode.J:\n        extent[2] = nSlice - halfThickness;\n        extent[3] = nSlice + halfThickness;\n        break;\n\n      case SlicingMode.K:\n        extent[4] = nSlice - halfThickness;\n        extent[5] = nSlice + halfThickness;\n        break;\n    }\n\n    return image.extentToBounds(extent);\n  };\n\n  publicAPI.intersectWithLineForPointPicking = function (p1, p2) {\n    return intersectWithLineForPointPicking(p1, p2, publicAPI);\n  };\n\n  publicAPI.intersectWithLineForCellPicking = function (p1, p2) {\n    return intersectWithLineForCellPicking(p1, p2, publicAPI);\n  };\n\n  publicAPI.getCurrentImage = function () {\n    return publicAPI.getInputData();\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\n\nvar DEFAULT_VALUES = {\n  slicingMode: SlicingMode.NONE,\n  closestIJKAxis: {\n    ijkMode: SlicingMode.NONE,\n    flip: false\n  },\n  renderToRectangle: false,\n  sliceAtFocalPoint: false,\n  preferSizeOverAccuracy: false // Whether to use halfFloat representation of float, when it is inaccurate\n\n}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Build VTK API\n\n  vtkAbstractImageMapper.extend(publicAPI, model, initialValues);\n  macro.get(publicAPI, model, ['slicingMode']);\n  macro.setGet(publicAPI, model, ['closestIJKAxis', 'renderToRectangle', 'sliceAtFocalPoint', 'preferSizeOverAccuracy']);\n  CoincidentTopologyHelper.implementCoincidentTopologyMethods(publicAPI, model); // Object methods\n\n  vtkImageMapper(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = macro.newInstance(extend, 'vtkImageMapper'); // ----------------------------------------------------------------------------\n\nvar vtkImageMapper$1 = _objectSpread(_objectSpread(_objectSpread({\n  newInstance: newInstance,\n  extend: extend\n}, staticOffsetAPI), otherStaticMethods), Constants);\n\nexport { vtkImageMapper$1 as default, extend, newInstance };\n"],"mappings":"AAAA,OAAOA,eAAe,MAAM,uCAAuC;AACnE,OAAOC,SAAS,MAAM,4BAA4B;AAClD,OAAOC,KAAK,MAAM,iBAAiB;AACnC,OAAOC,sBAAsB,MAAM,0BAA0B;AAC7D,SAASC,gCAAgC,EAAEC,+BAA+B,QAAQ,iCAAiC;AACnH,SAASC,CAAC,IAAIC,UAAU,EAAEC,CAAC,IAAIC,iBAAiB,EAAEC,CAAC,IAAIC,yBAAyB,QAAQ,iCAAiC;AACzH,OAAOC,wBAAwB,MAAM,sCAAsC;AAE3E,SAASC,OAAOA,CAACC,MAAM,EAAEC,cAAc,EAAE;EAAE,IAAIC,IAAI,GAAGC,MAAM,CAACD,IAAI,CAACF,MAAM,CAAC;EAAE,IAAIG,MAAM,CAACC,qBAAqB,EAAE;IAAE,IAAIC,OAAO,GAAGF,MAAM,CAACC,qBAAqB,CAACJ,MAAM,CAAC;IAAEC,cAAc,KAAKI,OAAO,GAAGA,OAAO,CAACC,MAAM,CAAC,UAAUC,GAAG,EAAE;MAAE,OAAOJ,MAAM,CAACK,wBAAwB,CAACR,MAAM,EAAEO,GAAG,CAAC,CAACE,UAAU;IAAE,CAAC,CAAC,CAAC,EAAEP,IAAI,CAACQ,IAAI,CAACC,KAAK,CAACT,IAAI,EAAEG,OAAO,CAAC;EAAE;EAAE,OAAOH,IAAI;AAAE;AAEpV,SAASU,aAAaA,CAACC,MAAM,EAAE;EAAE,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGC,SAAS,CAACC,MAAM,EAAEF,CAAC,EAAE,EAAE;IAAE,IAAIG,MAAM,GAAG,IAAI,IAAIF,SAAS,CAACD,CAAC,CAAC,GAAGC,SAAS,CAACD,CAAC,CAAC,GAAG,CAAC,CAAC;IAAEA,CAAC,GAAG,CAAC,GAAGf,OAAO,CAACI,MAAM,CAACc,MAAM,CAAC,EAAE,CAAC,CAAC,CAAC,CAACC,OAAO,CAAC,UAAUC,GAAG,EAAE;MAAEjC,eAAe,CAAC2B,MAAM,EAAEM,GAAG,EAAEF,MAAM,CAACE,GAAG,CAAC,CAAC;IAAE,CAAC,CAAC,GAAGhB,MAAM,CAACiB,yBAAyB,GAAGjB,MAAM,CAACkB,gBAAgB,CAACR,MAAM,EAAEV,MAAM,CAACiB,yBAAyB,CAACH,MAAM,CAAC,CAAC,GAAGlB,OAAO,CAACI,MAAM,CAACc,MAAM,CAAC,CAAC,CAACC,OAAO,CAAC,UAAUC,GAAG,EAAE;MAAEhB,MAAM,CAACmB,cAAc,CAACT,MAAM,EAAEM,GAAG,EAAEhB,MAAM,CAACK,wBAAwB,CAACS,MAAM,EAAEE,GAAG,CAAC,CAAC;IAAE,CAAC,CAAC;EAAE;EAAE,OAAON,MAAM;AAAE;AACzf,IAAIU,eAAe,GAAGzB,wBAAwB,CAACyB,eAAe;EAC1DC,kBAAkB,GAAG1B,wBAAwB,CAAC0B,kBAAkB;AACpE,IAAIC,eAAe,GAAGrC,KAAK,CAACqC,eAAe;AAC3C,IAAIC,WAAW,GAAGvC,SAAS,CAACuC,WAAW,CAAC,CAAC;AACzC;AACA;;AAEA,SAASC,cAAcA,CAACC,SAAS,EAAEC,KAAK,EAAE;EACxC;EACAA,KAAK,CAACC,cAAc,CAACpB,IAAI,CAAC,gBAAgB,CAAC;EAE3CkB,SAAS,CAACG,kBAAkB,GAAG,UAAUC,GAAG,EAAE;IAC5C,IAAIC,KAAK,GAAGL,SAAS,CAACM,eAAe,CAAC,CAAC;IACvC,IAAIC,IAAI;IAER,IAAIH,GAAG,CAAChB,MAAM,KAAK,CAAC,EAAE;MACpBmB,IAAI,GAAGH,GAAG;IACZ,CAAC,MAAM,IAAII,MAAM,CAACC,QAAQ,CAACL,GAAG,CAAC,EAAE;MAC/B,IAAIM,GAAG,GAAGL,KAAK,CAACM,SAAS,CAAC,CAAC;MAE3B,QAAQV,KAAK,CAACW,WAAW;QACvB,KAAKd,WAAW,CAACe,CAAC;UAChBN,IAAI,GAAG,CAACH,GAAG,EAAE,CAACM,GAAG,CAAC,CAAC,CAAC,GAAGA,GAAG,CAAC,CAAC,CAAC,IAAI,CAAC,EAAE,CAACA,GAAG,CAAC,CAAC,CAAC,GAAGA,GAAG,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC;UAC1D;QAEF,KAAKZ,WAAW,CAACgB,CAAC;UAChBP,IAAI,GAAG,CAAC,CAACG,GAAG,CAAC,CAAC,CAAC,GAAGA,GAAG,CAAC,CAAC,CAAC,IAAI,CAAC,EAAEN,GAAG,EAAE,CAACM,GAAG,CAAC,CAAC,CAAC,GAAGA,GAAG,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC;UAC1D;QAEF,KAAKZ,WAAW,CAACiB,CAAC;UAChBR,IAAI,GAAG,CAAC,CAACG,GAAG,CAAC,CAAC,CAAC,GAAGA,GAAG,CAAC,CAAC,CAAC,IAAI,CAAC,EAAE,CAACA,GAAG,CAAC,CAAC,CAAC,GAAGA,GAAG,CAAC,CAAC,CAAC,IAAI,CAAC,EAAEN,GAAG,CAAC;UAC1D;MACJ;IACF;IAEA,IAAIY,GAAG,GAAG,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;IACnBX,KAAK,CAACY,YAAY,CAACV,IAAI,EAAES,GAAG,CAAC;IAC7B,IAAIE,EAAE,GAAGb,KAAK,CAACc,SAAS,CAAC,CAAC;IAE1B,IAAIC,qBAAqB,GAAGpB,SAAS,CAACqB,iBAAiB,CAAC,CAAC;MACrDC,OAAO,GAAGF,qBAAqB,CAACE,OAAO;IAE3C,IAAIC,KAAK,GAAG,CAAC;IAEb,QAAQD,OAAO;MACb,KAAKxB,WAAW,CAAC0B,CAAC;QAChBD,KAAK,GAAG1D,UAAU,CAACmD,GAAG,CAAC,CAAC,CAAC,EAAEE,EAAE,CAAC,CAAC,CAAC,EAAEA,EAAE,CAAC,CAAC,CAAC,CAAC;QACxC;MAEF,KAAKpB,WAAW,CAAC2B,CAAC;QAChBF,KAAK,GAAG1D,UAAU,CAACmD,GAAG,CAAC,CAAC,CAAC,EAAEE,EAAE,CAAC,CAAC,CAAC,EAAEA,EAAE,CAAC,CAAC,CAAC,CAAC;QACxC;MAEF,KAAKpB,WAAW,CAAC4B,CAAC;QAChBH,KAAK,GAAG1D,UAAU,CAACmD,GAAG,CAAC,CAAC,CAAC,EAAEE,EAAE,CAAC,CAAC,CAAC,EAAEA,EAAE,CAAC,CAAC,CAAC,CAAC;QACxC;MAEF;QACE,OAAO,CAAC;IACZ;IAEA,OAAOK,KAAK;EACd,CAAC;EAEDvB,SAAS,CAAC2B,kBAAkB,GAAG,UAAUC,GAAG,EAAE;IAC5C,IAAIC,EAAE,GAAGD,GAAG,CAACE,aAAa,CAAC,CAAC;IAE5B,QAAQ7B,KAAK,CAACW,WAAW;MACvB,KAAKd,WAAW,CAAC0B,CAAC;MAClB,KAAK1B,WAAW,CAAC2B,CAAC;MAClB,KAAK3B,WAAW,CAAC4B,CAAC;QAChB;UACE,IAAIH,KAAK,GAAGvB,SAAS,CAACG,kBAAkB,CAAC0B,EAAE,CAAC;UAC5C7B,SAAS,CAAC+B,QAAQ,CAACR,KAAK,CAAC;QAC3B;QACA;MAEF,KAAKzB,WAAW,CAACe,CAAC;QAChBb,SAAS,CAAC+B,QAAQ,CAACF,EAAE,CAAC,CAAC,CAAC,CAAC;QACzB;MAEF,KAAK/B,WAAW,CAACgB,CAAC;QAChBd,SAAS,CAAC+B,QAAQ,CAACF,EAAE,CAAC,CAAC,CAAC,CAAC;QACzB;MAEF,KAAK/B,WAAW,CAACiB,CAAC;QAChBf,SAAS,CAAC+B,QAAQ,CAACF,EAAE,CAAC,CAAC,CAAC,CAAC;QACzB;IACJ;EACF,CAAC;EAED7B,SAAS,CAACgC,SAAS,GAAG,UAAUC,EAAE,EAAE;IAClCjC,SAAS,CAACkC,cAAc,CAACpC,WAAW,CAACe,CAAC,CAAC;IACvCb,SAAS,CAAC+B,QAAQ,CAACE,EAAE,CAAC;EACxB,CAAC;EAEDjC,SAAS,CAACmC,SAAS,GAAG,UAAUF,EAAE,EAAE;IAClCjC,SAAS,CAACkC,cAAc,CAACpC,WAAW,CAACgB,CAAC,CAAC;IACvCd,SAAS,CAAC+B,QAAQ,CAACE,EAAE,CAAC;EACxB,CAAC;EAEDjC,SAAS,CAACoC,SAAS,GAAG,UAAUH,EAAE,EAAE;IAClCjC,SAAS,CAACkC,cAAc,CAACpC,WAAW,CAACiB,CAAC,CAAC;IACvCf,SAAS,CAAC+B,QAAQ,CAACE,EAAE,CAAC;EACxB,CAAC;EAEDjC,SAAS,CAACqC,SAAS,GAAG,UAAUJ,EAAE,EAAE;IAClCjC,SAAS,CAACkC,cAAc,CAACpC,WAAW,CAAC0B,CAAC,CAAC;IACvCxB,SAAS,CAAC+B,QAAQ,CAACE,EAAE,CAAC;EACxB,CAAC;EAEDjC,SAAS,CAACsC,SAAS,GAAG,UAAUL,EAAE,EAAE;IAClCjC,SAAS,CAACkC,cAAc,CAACpC,WAAW,CAAC2B,CAAC,CAAC;IACvCzB,SAAS,CAAC+B,QAAQ,CAACE,EAAE,CAAC;EACxB,CAAC;EAEDjC,SAAS,CAACuC,SAAS,GAAG,UAAUN,EAAE,EAAE;IAClCjC,SAAS,CAACkC,cAAc,CAACpC,WAAW,CAAC4B,CAAC,CAAC;IACvC1B,SAAS,CAAC+B,QAAQ,CAACE,EAAE,CAAC;EACxB,CAAC;EAEDjC,SAAS,CAACwC,oBAAoB,GAAG,YAAY;IAC3C,IAAIC,GAAG,GAAG,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;IACnB,IAAIC,IAAI,GAAG1C,SAAS,CAACM,eAAe,CAAC,CAAC,CAACqC,YAAY,CAAC,CAAC;IAErD,QAAQ1C,KAAK,CAACW,WAAW;MACvB,KAAKd,WAAW,CAACe,CAAC;QAChB4B,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC;QACV;MAEF,KAAK3C,WAAW,CAACgB,CAAC;QAChB2B,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC;QACV;MAEF,KAAK3C,WAAW,CAACiB,CAAC;QAChB0B,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC;QACV;MAEF,KAAK3C,WAAW,CAAC0B,CAAC;QAChBzD,iBAAiB,CAAC2E,IAAI,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EAAED,GAAG,CAAC;QACvC;MAEF,KAAK3C,WAAW,CAAC2B,CAAC;QAChB1D,iBAAiB,CAAC2E,IAAI,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EAAED,GAAG,CAAC;QACvC;MAEF,KAAK3C,WAAW,CAAC4B,CAAC;QAChB3D,iBAAiB,CAAC2E,IAAI,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EAAED,GAAG,CAAC;QACvC;IACJ;IAEA,OAAOA,GAAG;EACZ,CAAC;EAED,SAASG,qBAAqBA,CAAA,EAAG;IAC/B,IAAIC,MAAM;IAEV,QAAQ5C,KAAK,CAACW,WAAW;MACvB,KAAKd,WAAW,CAACe,CAAC;QAChBgC,MAAM,GAAG,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;QAClB;MAEF,KAAK/C,WAAW,CAACgB,CAAC;QAChB+B,MAAM,GAAG,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;QAClB;MAEF,KAAK/C,WAAW,CAACiB,CAAC;QAChB8B,MAAM,GAAG,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;QAClB;MAEF;QACE5C,KAAK,CAAC6C,cAAc,GAAG;UACrBxB,OAAO,EAAErB,KAAK,CAACW,WAAW;UAC1BmC,IAAI,EAAE;QACR,CAAC;QACD;IACJ,CAAC,CAAC;;IAGF,IAAIN,GAAG,GAAG,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;IACrB;IACA;IACA;IACA;IACA;IACA;IACA;IACA;;IAEA,IAAIO,CAAC,GAAGhD,SAAS,CAACM,eAAe,CAAC,CAAC,CAACqC,YAAY,CAAC,CAAC;IAClD5E,iBAAiB,CAACiF,CAAC,EAAEH,MAAM,EAAEJ,GAAG,CAAC;IACjC,IAAIQ,MAAM,GAAG,GAAG;IAChB,IAAI3B,OAAO,GAAG,CAAC,CAAC;IAChB,IAAIyB,IAAI,GAAG,KAAK;IAEhB,KAAK,IAAIG,IAAI,GAAG,CAAC,EAAEA,IAAI,GAAGT,GAAG,CAACrD,MAAM,EAAE,EAAE8D,IAAI,EAAE;MAC5C,IAAIC,QAAQ,GAAGC,IAAI,CAACC,GAAG,CAACZ,GAAG,CAACS,IAAI,CAAC,CAAC;MAElC,IAAIC,QAAQ,GAAGF,MAAM,EAAE;QACrBA,MAAM,GAAGE,QAAQ;QACjBJ,IAAI,GAAGN,GAAG,CAACS,IAAI,CAAC,GAAG,GAAG;QACtB5B,OAAO,GAAG4B,IAAI;MAChB;IACF;IAEA,IAAID,MAAM,KAAK,GAAG,EAAE;MAClB,IAAIK,QAAQ,GAAG,QAAQ,CAACrD,KAAK,CAACW,WAAW,CAAC;MAC1C,IAAI2C,QAAQ,GAAG,QAAQ,CAACjC,OAAO,CAAC;MAChCzB,eAAe,CAAC,2BAA2B,CAAC2D,MAAM,CAACF,QAAQ,EAAE,cAAc,CAAC,GAAG,sDAAsD,GAAG,QAAQ,CAACE,MAAM,CAACD,QAAQ,EAAE,wBAAwB,CAAC,CAACC,MAAM,CAACP,MAAM,EAAE,cAAc,CAAC,GAAG,4DAA4D,GAAG,2EAA2E,CAAC;IAC1W;IAEAhD,KAAK,CAAC6C,cAAc,GAAG;MACrBxB,OAAO,EAAEA,OAAO;MAChByB,IAAI,EAAEA;IACR,CAAC;EACH;EAEA/C,SAAS,CAACkC,cAAc,GAAG,UAAUuB,IAAI,EAAE;IACzC,IAAIxD,KAAK,CAACW,WAAW,KAAK6C,IAAI,EAAE;MAC9B;IACF;IAEAxD,KAAK,CAACW,WAAW,GAAG6C,IAAI;IAExB,IAAIzD,SAAS,CAACM,eAAe,CAAC,CAAC,EAAE;MAC/BsC,qBAAqB,CAAC,CAAC;IACzB;IAEA5C,SAAS,CAAC0D,QAAQ,CAAC,CAAC;EACtB,CAAC;EAED1D,SAAS,CAACqB,iBAAiB,GAAG,YAAY;IACxC,IAAI,CAACpB,KAAK,CAAC6C,cAAc,KAAKa,SAAS,IAAI1D,KAAK,CAAC6C,cAAc,CAACxB,OAAO,KAAKxB,WAAW,CAAC8D,IAAI,KAAK5D,SAAS,CAACM,eAAe,CAAC,CAAC,EAAE;MAC5HsC,qBAAqB,CAAC,CAAC;IACzB;IAEA,OAAO3C,KAAK,CAAC6C,cAAc;EAC7B,CAAC;EAED9C,SAAS,CAACW,SAAS,GAAG,YAAY;IAChC,IAAIN,KAAK,GAAGL,SAAS,CAACM,eAAe,CAAC,CAAC;IAEvC,IAAI,CAACD,KAAK,EAAE;MACV,OAAOpC,yBAAyB,CAAC,CAAC;IACpC;IAEA,IAAI,CAACgC,KAAK,CAAC4D,gBAAgB,EAAE;MAC3B,OAAOxD,KAAK,CAACM,SAAS,CAAC,CAAC;IAC1B;IAEA,IAAIO,EAAE,GAAGjB,KAAK,CAAC6D,mBAAmB,CAACvC,KAAK,CAAC,CAAC;IAE1C,IAAIwC,sBAAsB,GAAG/D,SAAS,CAACqB,iBAAiB,CAAC,CAAC;MACtDC,OAAO,GAAGyC,sBAAsB,CAACzC,OAAO;IAE5C,IAAI0C,MAAM,GAAG/D,KAAK,CAACsB,KAAK;IAExB,IAAID,OAAO,KAAKrB,KAAK,CAACW,WAAW,EAAE;MACjC;MACAoD,MAAM,GAAGhE,SAAS,CAACG,kBAAkB,CAACF,KAAK,CAACsB,KAAK,CAAC;IACpD;IAEA,QAAQD,OAAO;MACb,KAAKxB,WAAW,CAAC0B,CAAC;QAChBN,EAAE,CAAC,CAAC,CAAC,GAAG8C,MAAM;QACd9C,EAAE,CAAC,CAAC,CAAC,GAAG8C,MAAM;QACd;MAEF,KAAKlE,WAAW,CAAC2B,CAAC;QAChBP,EAAE,CAAC,CAAC,CAAC,GAAG8C,MAAM;QACd9C,EAAE,CAAC,CAAC,CAAC,GAAG8C,MAAM;QACd;MAEF,KAAKlE,WAAW,CAAC4B,CAAC;QAChBR,EAAE,CAAC,CAAC,CAAC,GAAG8C,MAAM;QACd9C,EAAE,CAAC,CAAC,CAAC,GAAG8C,MAAM;QACd;IACJ;IAEA,OAAO3D,KAAK,CAAC4D,cAAc,CAAC/C,EAAE,CAAC;EACjC,CAAC;EAEDlB,SAAS,CAACkE,iBAAiB,GAAG,YAAY;IACxC,IAAI3C,KAAK,GAAGpC,SAAS,CAACC,MAAM,GAAG,CAAC,IAAID,SAAS,CAAC,CAAC,CAAC,KAAKwE,SAAS,GAAGxE,SAAS,CAAC,CAAC,CAAC,GAAGc,KAAK,CAACsB,KAAK;IAC3F,IAAI4C,aAAa,GAAGhF,SAAS,CAACC,MAAM,GAAG,CAAC,IAAID,SAAS,CAAC,CAAC,CAAC,KAAKwE,SAAS,GAAGxE,SAAS,CAAC,CAAC,CAAC,GAAG,CAAC;IACzF,IAAIkB,KAAK,GAAGL,SAAS,CAACM,eAAe,CAAC,CAAC;IAEvC,IAAI,CAACD,KAAK,EAAE;MACV,OAAOpC,yBAAyB,CAAC,CAAC;IACpC;IAEA,IAAImG,MAAM,GAAG/D,KAAK,CAACgE,gBAAgB,CAAC,CAAC;IAErC,IAAIC,sBAAsB,GAAGtE,SAAS,CAACqB,iBAAiB,CAAC,CAAC;MACtDC,OAAO,GAAGgD,sBAAsB,CAAChD,OAAO;IAE5C,IAAI0C,MAAM,GAAGzC,KAAK;IAElB,IAAID,OAAO,KAAKrB,KAAK,CAACW,WAAW,EAAE;MACjC;MACAoD,MAAM,GAAGhE,SAAS,CAACG,kBAAkB,CAACoB,KAAK,CAAC;IAC9C;IAEA,QAAQD,OAAO;MACb,KAAKxB,WAAW,CAAC0B,CAAC;QAChB4C,MAAM,CAAC,CAAC,CAAC,GAAGJ,MAAM,GAAGG,aAAa;QAClCC,MAAM,CAAC,CAAC,CAAC,GAAGJ,MAAM,GAAGG,aAAa;QAClC;MAEF,KAAKrE,WAAW,CAAC2B,CAAC;QAChB2C,MAAM,CAAC,CAAC,CAAC,GAAGJ,MAAM,GAAGG,aAAa;QAClCC,MAAM,CAAC,CAAC,CAAC,GAAGJ,MAAM,GAAGG,aAAa;QAClC;MAEF,KAAKrE,WAAW,CAAC4B,CAAC;QAChB0C,MAAM,CAAC,CAAC,CAAC,GAAGJ,MAAM,GAAGG,aAAa;QAClCC,MAAM,CAAC,CAAC,CAAC,GAAGJ,MAAM,GAAGG,aAAa;QAClC;IACJ;IAEA,OAAO9D,KAAK,CAAC4D,cAAc,CAACG,MAAM,CAAC;EACrC,CAAC;EAEDpE,SAAS,CAACtC,gCAAgC,GAAG,UAAU6G,EAAE,EAAEC,EAAE,EAAE;IAC7D,OAAO9G,gCAAgC,CAAC6G,EAAE,EAAEC,EAAE,EAAExE,SAAS,CAAC;EAC5D,CAAC;EAEDA,SAAS,CAACrC,+BAA+B,GAAG,UAAU4G,EAAE,EAAEC,EAAE,EAAE;IAC5D,OAAO7G,+BAA+B,CAAC4G,EAAE,EAAEC,EAAE,EAAExE,SAAS,CAAC;EAC3D,CAAC;EAEDA,SAAS,CAACM,eAAe,GAAG,YAAY;IACtC,OAAON,SAAS,CAACyE,YAAY,CAAC,CAAC;EACjC,CAAC;AACH,CAAC,CAAC;AACF;AACA;;AAGA,IAAIC,cAAc,GAAG;EACnB9D,WAAW,EAAEd,WAAW,CAAC8D,IAAI;EAC7Bd,cAAc,EAAE;IACdxB,OAAO,EAAExB,WAAW,CAAC8D,IAAI;IACzBb,IAAI,EAAE;EACR,CAAC;EACD4B,iBAAiB,EAAE,KAAK;EACxBC,iBAAiB,EAAE,KAAK;EACxBC,sBAAsB,EAAE,KAAK,CAAC;AAEhC,CAAC,CAAC,CAAC;;AAEH,SAASC,MAAMA,CAAC9E,SAAS,EAAEC,KAAK,EAAE;EAChC,IAAI8E,aAAa,GAAG5F,SAAS,CAACC,MAAM,GAAG,CAAC,IAAID,SAAS,CAAC,CAAC,CAAC,KAAKwE,SAAS,GAAGxE,SAAS,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC;EAC1FZ,MAAM,CAACyG,MAAM,CAAC/E,KAAK,EAAEyE,cAAc,EAAEK,aAAa,CAAC,CAAC,CAAC;;EAErDtH,sBAAsB,CAACqH,MAAM,CAAC9E,SAAS,EAAEC,KAAK,EAAE8E,aAAa,CAAC;EAC9DvH,KAAK,CAACyH,GAAG,CAACjF,SAAS,EAAEC,KAAK,EAAE,CAAC,aAAa,CAAC,CAAC;EAC5CzC,KAAK,CAAC0H,MAAM,CAAClF,SAAS,EAAEC,KAAK,EAAE,CAAC,gBAAgB,EAAE,mBAAmB,EAAE,mBAAmB,EAAE,wBAAwB,CAAC,CAAC;EACtH/B,wBAAwB,CAACiH,kCAAkC,CAACnF,SAAS,EAAEC,KAAK,CAAC,CAAC,CAAC;;EAE/EF,cAAc,CAACC,SAAS,EAAEC,KAAK,CAAC;AAClC,CAAC,CAAC;;AAEF,IAAImF,WAAW,GAAG5H,KAAK,CAAC4H,WAAW,CAACN,MAAM,EAAE,gBAAgB,CAAC,CAAC,CAAC;;AAE/D,IAAIO,gBAAgB,GAAGrG,aAAa,CAACA,aAAa,CAACA,aAAa,CAAC;EAC/DoG,WAAW,EAAEA,WAAW;EACxBN,MAAM,EAAEA;AACV,CAAC,EAAEnF,eAAe,CAAC,EAAEC,kBAAkB,CAAC,EAAErC,SAAS,CAAC;AAEpD,SAAS8H,gBAAgB,IAAIC,OAAO,EAAER,MAAM,EAAEM,WAAW"},"metadata":{},"sourceType":"module","externalDependencies":[]}