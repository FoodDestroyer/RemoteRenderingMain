{"ast":null,"code":"import { strToU8, unzipSync, strFromU8, decompressSync } from 'fflate';\nimport macro from '../../../macros.js';\nimport Endian from '../../../Common/Core/Endian.js';\nimport { DataTypeByteSize } from '../../../Common/Core/DataArray/Constants.js';\nimport { registerType } from '../DataAccessHelper.js';\nimport { fromArrayBuffer } from '../../../Common/Core/Base64.js';\nvar vtkErrorMacro = macro.vtkErrorMacro,\n  vtkDebugMacro = macro.vtkDebugMacro;\nfunction toMimeType(url) {\n  var ext = url.split('.').pop().toLowerCase();\n  if (ext === 'jpg') {\n    return 'jpeg';\n  }\n  return ext;\n}\nfunction handleUint8Array(array, compression, done) {\n  return function (uint8array) {\n    array.buffer = new ArrayBuffer(uint8array.length); // copy uint8array to buffer\n\n    var view = new Uint8Array(array.buffer);\n    view.set(uint8array);\n    if (compression) {\n      if (array.dataType === 'string' || array.dataType === 'JSON') {\n        array.buffer = strFromU8(decompressSync(new Uint8Array(array.buffer)));\n      } else {\n        array.buffer = decompressSync(new Uint8Array(array.buffer)).buffer;\n      }\n    }\n    if (array.ref.encode === 'JSON') {\n      array.values = JSON.parse(array.buffer);\n    } else {\n      if (Endian.ENDIANNESS !== array.ref.encode && Endian.ENDIANNESS) {\n        // Need to swap bytes\n        vtkDebugMacro(\"Swap bytes of \".concat(array.name));\n        Endian.swapBytes(array.buffer, DataTypeByteSize[array.dataType]);\n      }\n      array.values = macro.newTypedArray(array.dataType, array.buffer);\n    }\n    if (array.values.length !== array.size) {\n      vtkErrorMacro(\"Error in FetchArray: \".concat(array.name, \" does not have the proper array size. Got \").concat(array.values.length, \", instead of \").concat(array.size));\n    }\n    done();\n  };\n}\nfunction handleString(array, compression, done) {\n  return function (string) {\n    if (compression) {\n      array.values = JSON.parse(strFromU8(decompressSync(string)));\n    } else {\n      array.values = JSON.parse(string);\n    }\n    done();\n  };\n}\nfunction removeLeadingSlash(str) {\n  return str[0] === '/' ? str.substr(1) : str;\n}\nfunction normalizePath(str) {\n  return new URL(str, 'http://any').pathname;\n}\nfunction cleanUpPath(str) {\n  return removeLeadingSlash(normalizePath(str));\n}\nfunction unpack(zipContent) {\n  return new Promise(function (resolve, reject) {\n    if (typeof zipContent === 'string') {\n      resolve(strToU8(zipContent));\n    } else if (zipContent instanceof Blob) {\n      resolve(zipContent.arrayBuffer().then(function (ab) {\n        return new Uint8Array(ab);\n      }));\n    } else if (zipContent instanceof ArrayBuffer) {\n      resolve(new Uint8Array(zipContent));\n    } else if ((zipContent === null || zipContent === void 0 ? void 0 : zipContent.buffer) instanceof ArrayBuffer) {\n      resolve(new Uint8Array(zipContent.buffer));\n    } else {\n      reject(new Error('Invalid datatype to unpack.'));\n    }\n  });\n}\nfunction create(createOptions) {\n  var ready = false;\n  var requestCount = 0;\n  var decompressedFiles = null;\n  var fullRootPath = '';\n  unpack(createOptions.zipContent).then(function (zipFileData) {\n    decompressedFiles = unzipSync(zipFileData);\n    ready = true; // Find root index.json\n\n    var metaFiles = [];\n    Object.keys(decompressedFiles).forEach(function (relativePath) {\n      if (relativePath.endsWith('index.json')) {\n        metaFiles.push(relativePath);\n      }\n    });\n    metaFiles.sort(function (a, b) {\n      return a.length - b.length;\n    }); // if not empty, then fullRootPath will have a forward slash suffix\n\n    fullRootPath = metaFiles[0].replace(/index\\.json$/, '');\n    if (createOptions.callback) {\n      createOptions.callback(decompressedFiles);\n    }\n  });\n  return {\n    fetchArray: function fetchArray(instance, baseURL, array) {\n      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n      return new Promise(function (resolve, reject) {\n        if (!ready) {\n          vtkErrorMacro('ERROR!!! zip not ready...');\n        }\n        var url = cleanUpPath([baseURL, array.ref.basepath, options.compression ? \"\".concat(array.ref.id, \".gz\") : array.ref.id].join('/'));\n        if (++requestCount === 1 && instance !== null && instance !== void 0 && instance.invokeBusy) {\n          instance.invokeBusy(true);\n        }\n        function doneCleanUp() {\n          // Done with the ref and work\n          delete array.ref;\n          if (--requestCount === 0 && instance !== null && instance !== void 0 && instance.invokeBusy) {\n            instance.invokeBusy(false);\n          }\n          if (instance !== null && instance !== void 0 && instance.modified) {\n            instance.modified();\n          }\n          resolve(array);\n        }\n        var fileData = decompressedFiles[\"\".concat(fullRootPath).concat(url)];\n        if (array.dataType === 'string' && !options.compression) {\n          // string\n          var handler = handleString(array, options.compression, doneCleanUp);\n          handler(strFromU8(fileData));\n        } else {\n          // uint8array\n          var _handler = handleUint8Array(array, options.compression, doneCleanUp);\n          _handler(fileData);\n        }\n      });\n    },\n    fetchJSON: function fetchJSON(instance, url) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var path = cleanUpPath(url);\n      if (!ready) {\n        vtkErrorMacro('ERROR!!! zip not ready...');\n      }\n      var fileData = decompressedFiles[\"\".concat(fullRootPath).concat(path)];\n      if (options.compression) {\n        if (options.compression === 'gz') {\n          var str = strFromU8(decompressSync(fileData));\n          return Promise.resolve(JSON.parse(str));\n        }\n        return Promise.reject(new Error('Invalid compression'));\n      }\n      return Promise.resolve(JSON.parse(strFromU8(fileData)));\n    },\n    fetchText: function fetchText(instance, url) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var path = cleanUpPath(url);\n      if (!ready) {\n        vtkErrorMacro('ERROR!!! zip not ready...');\n      }\n      var fileData = decompressedFiles[\"\".concat(fullRootPath).concat(path)];\n      if (options.compression) {\n        if (options.compression === 'gz') {\n          return Promise.resolve(strFromU8(unzipSync(fileData)));\n        }\n        return Promise.reject(new Error('Invalid compression'));\n      }\n      return Promise.resolve(strFromU8(fileData));\n    },\n    fetchImage: function fetchImage(instance, url) {\n      var path = cleanUpPath(url);\n      if (!ready) {\n        vtkErrorMacro('ERROR!!! zip not ready...');\n      }\n      var fileData = decompressedFiles[\"\".concat(fullRootPath).concat(path)];\n      return new Promise(function (resolve, reject) {\n        var img = new Image();\n        img.onload = function () {\n          return resolve(img);\n        };\n        img.onerror = reject;\n        var str = fromArrayBuffer(fileData.buffer);\n        img.src = \"data:image/\".concat(toMimeType(path), \";base64,\").concat(str);\n      });\n    },\n    fetchBinary: function fetchBinary(instance, url) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var path = cleanUpPath(url);\n      if (!ready) {\n        vtkErrorMacro('ERROR!!! zip not ready...');\n      }\n      var fileData = decompressedFiles[\"\".concat(fullRootPath).concat(path)];\n      if (options.compression) {\n        if (options.compression === 'gz') {\n          return Promise.resolve(decompressSync(fileData).buffer);\n        }\n        return Promise.reject(new Error('Invalid compression'));\n      }\n      return Promise.resolve(fileData.buffer);\n    }\n  };\n}\nvar JSZipDataAccessHelper = {\n  create: create\n};\nregisterType('zip', function (options) {\n  return JSZipDataAccessHelper.create(options);\n});\nexport { JSZipDataAccessHelper as default };","map":{"version":3,"names":["strToU8","unzipSync","strFromU8","decompressSync","macro","Endian","DataTypeByteSize","registerType","fromArrayBuffer","vtkErrorMacro","vtkDebugMacro","toMimeType","url","ext","split","pop","toLowerCase","handleUint8Array","array","compression","done","uint8array","buffer","ArrayBuffer","length","view","Uint8Array","set","dataType","ref","encode","values","JSON","parse","ENDIANNESS","concat","name","swapBytes","newTypedArray","size","handleString","string","removeLeadingSlash","str","substr","normalizePath","URL","pathname","cleanUpPath","unpack","zipContent","Promise","resolve","reject","Blob","arrayBuffer","then","ab","Error","create","createOptions","ready","requestCount","decompressedFiles","fullRootPath","zipFileData","metaFiles","Object","keys","forEach","relativePath","endsWith","push","sort","a","b","replace","callback","fetchArray","instance","baseURL","options","arguments","undefined","basepath","id","join","invokeBusy","doneCleanUp","modified","fileData","handler","_handler","fetchJSON","path","fetchText","fetchImage","img","Image","onload","onerror","src","fetchBinary","JSZipDataAccessHelper","default"],"sources":["/home/rakshith/Documents/RemoteRendering/vtk-js-react-app/node_modules/@kitware/vtk.js/IO/Core/DataAccessHelper/JSZipDataAccessHelper.js"],"sourcesContent":["import { strToU8, unzipSync, strFromU8, decompressSync } from 'fflate';\nimport macro from '../../../macros.js';\nimport Endian from '../../../Common/Core/Endian.js';\nimport { DataTypeByteSize } from '../../../Common/Core/DataArray/Constants.js';\nimport { registerType } from '../DataAccessHelper.js';\nimport { fromArrayBuffer } from '../../../Common/Core/Base64.js';\n\nvar vtkErrorMacro = macro.vtkErrorMacro,\n    vtkDebugMacro = macro.vtkDebugMacro;\n\nfunction toMimeType(url) {\n  var ext = url.split('.').pop().toLowerCase();\n\n  if (ext === 'jpg') {\n    return 'jpeg';\n  }\n\n  return ext;\n}\n\nfunction handleUint8Array(array, compression, done) {\n  return function (uint8array) {\n    array.buffer = new ArrayBuffer(uint8array.length); // copy uint8array to buffer\n\n    var view = new Uint8Array(array.buffer);\n    view.set(uint8array);\n\n    if (compression) {\n      if (array.dataType === 'string' || array.dataType === 'JSON') {\n        array.buffer = strFromU8(decompressSync(new Uint8Array(array.buffer)));\n      } else {\n        array.buffer = decompressSync(new Uint8Array(array.buffer)).buffer;\n      }\n    }\n\n    if (array.ref.encode === 'JSON') {\n      array.values = JSON.parse(array.buffer);\n    } else {\n      if (Endian.ENDIANNESS !== array.ref.encode && Endian.ENDIANNESS) {\n        // Need to swap bytes\n        vtkDebugMacro(\"Swap bytes of \".concat(array.name));\n        Endian.swapBytes(array.buffer, DataTypeByteSize[array.dataType]);\n      }\n\n      array.values = macro.newTypedArray(array.dataType, array.buffer);\n    }\n\n    if (array.values.length !== array.size) {\n      vtkErrorMacro(\"Error in FetchArray: \".concat(array.name, \" does not have the proper array size. Got \").concat(array.values.length, \", instead of \").concat(array.size));\n    }\n\n    done();\n  };\n}\n\nfunction handleString(array, compression, done) {\n  return function (string) {\n    if (compression) {\n      array.values = JSON.parse(strFromU8(decompressSync(string)));\n    } else {\n      array.values = JSON.parse(string);\n    }\n\n    done();\n  };\n}\n\nfunction removeLeadingSlash(str) {\n  return str[0] === '/' ? str.substr(1) : str;\n}\n\nfunction normalizePath(str) {\n  return new URL(str, 'http://any').pathname;\n}\n\nfunction cleanUpPath(str) {\n  return removeLeadingSlash(normalizePath(str));\n}\n\nfunction unpack(zipContent) {\n  return new Promise(function (resolve, reject) {\n    if (typeof zipContent === 'string') {\n      resolve(strToU8(zipContent));\n    } else if (zipContent instanceof Blob) {\n      resolve(zipContent.arrayBuffer().then(function (ab) {\n        return new Uint8Array(ab);\n      }));\n    } else if (zipContent instanceof ArrayBuffer) {\n      resolve(new Uint8Array(zipContent));\n    } else if ((zipContent === null || zipContent === void 0 ? void 0 : zipContent.buffer) instanceof ArrayBuffer) {\n      resolve(new Uint8Array(zipContent.buffer));\n    } else {\n      reject(new Error('Invalid datatype to unpack.'));\n    }\n  });\n}\n\nfunction create(createOptions) {\n  var ready = false;\n  var requestCount = 0;\n  var decompressedFiles = null;\n  var fullRootPath = '';\n  unpack(createOptions.zipContent).then(function (zipFileData) {\n    decompressedFiles = unzipSync(zipFileData);\n    ready = true; // Find root index.json\n\n    var metaFiles = [];\n    Object.keys(decompressedFiles).forEach(function (relativePath) {\n      if (relativePath.endsWith('index.json')) {\n        metaFiles.push(relativePath);\n      }\n    });\n    metaFiles.sort(function (a, b) {\n      return a.length - b.length;\n    }); // if not empty, then fullRootPath will have a forward slash suffix\n\n    fullRootPath = metaFiles[0].replace(/index\\.json$/, '');\n\n    if (createOptions.callback) {\n      createOptions.callback(decompressedFiles);\n    }\n  });\n  return {\n    fetchArray: function fetchArray(instance, baseURL, array) {\n      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n      return new Promise(function (resolve, reject) {\n        if (!ready) {\n          vtkErrorMacro('ERROR!!! zip not ready...');\n        }\n\n        var url = cleanUpPath([baseURL, array.ref.basepath, options.compression ? \"\".concat(array.ref.id, \".gz\") : array.ref.id].join('/'));\n\n        if (++requestCount === 1 && instance !== null && instance !== void 0 && instance.invokeBusy) {\n          instance.invokeBusy(true);\n        }\n\n        function doneCleanUp() {\n          // Done with the ref and work\n          delete array.ref;\n\n          if (--requestCount === 0 && instance !== null && instance !== void 0 && instance.invokeBusy) {\n            instance.invokeBusy(false);\n          }\n\n          if (instance !== null && instance !== void 0 && instance.modified) {\n            instance.modified();\n          }\n\n          resolve(array);\n        }\n\n        var fileData = decompressedFiles[\"\".concat(fullRootPath).concat(url)];\n\n        if (array.dataType === 'string' && !options.compression) {\n          // string\n          var handler = handleString(array, options.compression, doneCleanUp);\n          handler(strFromU8(fileData));\n        } else {\n          // uint8array\n          var _handler = handleUint8Array(array, options.compression, doneCleanUp);\n\n          _handler(fileData);\n        }\n      });\n    },\n    fetchJSON: function fetchJSON(instance, url) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var path = cleanUpPath(url);\n\n      if (!ready) {\n        vtkErrorMacro('ERROR!!! zip not ready...');\n      }\n\n      var fileData = decompressedFiles[\"\".concat(fullRootPath).concat(path)];\n\n      if (options.compression) {\n        if (options.compression === 'gz') {\n          var str = strFromU8(decompressSync(fileData));\n          return Promise.resolve(JSON.parse(str));\n        }\n\n        return Promise.reject(new Error('Invalid compression'));\n      }\n\n      return Promise.resolve(JSON.parse(strFromU8(fileData)));\n    },\n    fetchText: function fetchText(instance, url) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var path = cleanUpPath(url);\n\n      if (!ready) {\n        vtkErrorMacro('ERROR!!! zip not ready...');\n      }\n\n      var fileData = decompressedFiles[\"\".concat(fullRootPath).concat(path)];\n\n      if (options.compression) {\n        if (options.compression === 'gz') {\n          return Promise.resolve(strFromU8(unzipSync(fileData)));\n        }\n\n        return Promise.reject(new Error('Invalid compression'));\n      }\n\n      return Promise.resolve(strFromU8(fileData));\n    },\n    fetchImage: function fetchImage(instance, url) {\n      var path = cleanUpPath(url);\n\n      if (!ready) {\n        vtkErrorMacro('ERROR!!! zip not ready...');\n      }\n\n      var fileData = decompressedFiles[\"\".concat(fullRootPath).concat(path)];\n      return new Promise(function (resolve, reject) {\n        var img = new Image();\n\n        img.onload = function () {\n          return resolve(img);\n        };\n\n        img.onerror = reject;\n        var str = fromArrayBuffer(fileData.buffer);\n        img.src = \"data:image/\".concat(toMimeType(path), \";base64,\").concat(str);\n      });\n    },\n    fetchBinary: function fetchBinary(instance, url) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var path = cleanUpPath(url);\n\n      if (!ready) {\n        vtkErrorMacro('ERROR!!! zip not ready...');\n      }\n\n      var fileData = decompressedFiles[\"\".concat(fullRootPath).concat(path)];\n\n      if (options.compression) {\n        if (options.compression === 'gz') {\n          return Promise.resolve(decompressSync(fileData).buffer);\n        }\n\n        return Promise.reject(new Error('Invalid compression'));\n      }\n\n      return Promise.resolve(fileData.buffer);\n    }\n  };\n}\n\nvar JSZipDataAccessHelper = {\n  create: create\n};\nregisterType('zip', function (options) {\n  return JSZipDataAccessHelper.create(options);\n});\n\nexport { JSZipDataAccessHelper as default };\n"],"mappings":"AAAA,SAASA,OAAO,EAAEC,SAAS,EAAEC,SAAS,EAAEC,cAAc,QAAQ,QAAQ;AACtE,OAAOC,KAAK,MAAM,oBAAoB;AACtC,OAAOC,MAAM,MAAM,gCAAgC;AACnD,SAASC,gBAAgB,QAAQ,6CAA6C;AAC9E,SAASC,YAAY,QAAQ,wBAAwB;AACrD,SAASC,eAAe,QAAQ,gCAAgC;AAEhE,IAAIC,aAAa,GAAGL,KAAK,CAACK,aAAa;EACnCC,aAAa,GAAGN,KAAK,CAACM,aAAa;AAEvC,SAASC,UAAUA,CAACC,GAAG,EAAE;EACvB,IAAIC,GAAG,GAAGD,GAAG,CAACE,KAAK,CAAC,GAAG,CAAC,CAACC,GAAG,CAAC,CAAC,CAACC,WAAW,CAAC,CAAC;EAE5C,IAAIH,GAAG,KAAK,KAAK,EAAE;IACjB,OAAO,MAAM;EACf;EAEA,OAAOA,GAAG;AACZ;AAEA,SAASI,gBAAgBA,CAACC,KAAK,EAAEC,WAAW,EAAEC,IAAI,EAAE;EAClD,OAAO,UAAUC,UAAU,EAAE;IAC3BH,KAAK,CAACI,MAAM,GAAG,IAAIC,WAAW,CAACF,UAAU,CAACG,MAAM,CAAC,CAAC,CAAC;;IAEnD,IAAIC,IAAI,GAAG,IAAIC,UAAU,CAACR,KAAK,CAACI,MAAM,CAAC;IACvCG,IAAI,CAACE,GAAG,CAACN,UAAU,CAAC;IAEpB,IAAIF,WAAW,EAAE;MACf,IAAID,KAAK,CAACU,QAAQ,KAAK,QAAQ,IAAIV,KAAK,CAACU,QAAQ,KAAK,MAAM,EAAE;QAC5DV,KAAK,CAACI,MAAM,GAAGpB,SAAS,CAACC,cAAc,CAAC,IAAIuB,UAAU,CAACR,KAAK,CAACI,MAAM,CAAC,CAAC,CAAC;MACxE,CAAC,MAAM;QACLJ,KAAK,CAACI,MAAM,GAAGnB,cAAc,CAAC,IAAIuB,UAAU,CAACR,KAAK,CAACI,MAAM,CAAC,CAAC,CAACA,MAAM;MACpE;IACF;IAEA,IAAIJ,KAAK,CAACW,GAAG,CAACC,MAAM,KAAK,MAAM,EAAE;MAC/BZ,KAAK,CAACa,MAAM,GAAGC,IAAI,CAACC,KAAK,CAACf,KAAK,CAACI,MAAM,CAAC;IACzC,CAAC,MAAM;MACL,IAAIjB,MAAM,CAAC6B,UAAU,KAAKhB,KAAK,CAACW,GAAG,CAACC,MAAM,IAAIzB,MAAM,CAAC6B,UAAU,EAAE;QAC/D;QACAxB,aAAa,CAAC,gBAAgB,CAACyB,MAAM,CAACjB,KAAK,CAACkB,IAAI,CAAC,CAAC;QAClD/B,MAAM,CAACgC,SAAS,CAACnB,KAAK,CAACI,MAAM,EAAEhB,gBAAgB,CAACY,KAAK,CAACU,QAAQ,CAAC,CAAC;MAClE;MAEAV,KAAK,CAACa,MAAM,GAAG3B,KAAK,CAACkC,aAAa,CAACpB,KAAK,CAACU,QAAQ,EAAEV,KAAK,CAACI,MAAM,CAAC;IAClE;IAEA,IAAIJ,KAAK,CAACa,MAAM,CAACP,MAAM,KAAKN,KAAK,CAACqB,IAAI,EAAE;MACtC9B,aAAa,CAAC,uBAAuB,CAAC0B,MAAM,CAACjB,KAAK,CAACkB,IAAI,EAAE,4CAA4C,CAAC,CAACD,MAAM,CAACjB,KAAK,CAACa,MAAM,CAACP,MAAM,EAAE,eAAe,CAAC,CAACW,MAAM,CAACjB,KAAK,CAACqB,IAAI,CAAC,CAAC;IACzK;IAEAnB,IAAI,CAAC,CAAC;EACR,CAAC;AACH;AAEA,SAASoB,YAAYA,CAACtB,KAAK,EAAEC,WAAW,EAAEC,IAAI,EAAE;EAC9C,OAAO,UAAUqB,MAAM,EAAE;IACvB,IAAItB,WAAW,EAAE;MACfD,KAAK,CAACa,MAAM,GAAGC,IAAI,CAACC,KAAK,CAAC/B,SAAS,CAACC,cAAc,CAACsC,MAAM,CAAC,CAAC,CAAC;IAC9D,CAAC,MAAM;MACLvB,KAAK,CAACa,MAAM,GAAGC,IAAI,CAACC,KAAK,CAACQ,MAAM,CAAC;IACnC;IAEArB,IAAI,CAAC,CAAC;EACR,CAAC;AACH;AAEA,SAASsB,kBAAkBA,CAACC,GAAG,EAAE;EAC/B,OAAOA,GAAG,CAAC,CAAC,CAAC,KAAK,GAAG,GAAGA,GAAG,CAACC,MAAM,CAAC,CAAC,CAAC,GAAGD,GAAG;AAC7C;AAEA,SAASE,aAAaA,CAACF,GAAG,EAAE;EAC1B,OAAO,IAAIG,GAAG,CAACH,GAAG,EAAE,YAAY,CAAC,CAACI,QAAQ;AAC5C;AAEA,SAASC,WAAWA,CAACL,GAAG,EAAE;EACxB,OAAOD,kBAAkB,CAACG,aAAa,CAACF,GAAG,CAAC,CAAC;AAC/C;AAEA,SAASM,MAAMA,CAACC,UAAU,EAAE;EAC1B,OAAO,IAAIC,OAAO,CAAC,UAAUC,OAAO,EAAEC,MAAM,EAAE;IAC5C,IAAI,OAAOH,UAAU,KAAK,QAAQ,EAAE;MAClCE,OAAO,CAACpD,OAAO,CAACkD,UAAU,CAAC,CAAC;IAC9B,CAAC,MAAM,IAAIA,UAAU,YAAYI,IAAI,EAAE;MACrCF,OAAO,CAACF,UAAU,CAACK,WAAW,CAAC,CAAC,CAACC,IAAI,CAAC,UAAUC,EAAE,EAAE;QAClD,OAAO,IAAI/B,UAAU,CAAC+B,EAAE,CAAC;MAC3B,CAAC,CAAC,CAAC;IACL,CAAC,MAAM,IAAIP,UAAU,YAAY3B,WAAW,EAAE;MAC5C6B,OAAO,CAAC,IAAI1B,UAAU,CAACwB,UAAU,CAAC,CAAC;IACrC,CAAC,MAAM,IAAI,CAACA,UAAU,KAAK,IAAI,IAAIA,UAAU,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,UAAU,CAAC5B,MAAM,aAAaC,WAAW,EAAE;MAC7G6B,OAAO,CAAC,IAAI1B,UAAU,CAACwB,UAAU,CAAC5B,MAAM,CAAC,CAAC;IAC5C,CAAC,MAAM;MACL+B,MAAM,CAAC,IAAIK,KAAK,CAAC,6BAA6B,CAAC,CAAC;IAClD;EACF,CAAC,CAAC;AACJ;AAEA,SAASC,MAAMA,CAACC,aAAa,EAAE;EAC7B,IAAIC,KAAK,GAAG,KAAK;EACjB,IAAIC,YAAY,GAAG,CAAC;EACpB,IAAIC,iBAAiB,GAAG,IAAI;EAC5B,IAAIC,YAAY,GAAG,EAAE;EACrBf,MAAM,CAACW,aAAa,CAACV,UAAU,CAAC,CAACM,IAAI,CAAC,UAAUS,WAAW,EAAE;IAC3DF,iBAAiB,GAAG9D,SAAS,CAACgE,WAAW,CAAC;IAC1CJ,KAAK,GAAG,IAAI,CAAC,CAAC;;IAEd,IAAIK,SAAS,GAAG,EAAE;IAClBC,MAAM,CAACC,IAAI,CAACL,iBAAiB,CAAC,CAACM,OAAO,CAAC,UAAUC,YAAY,EAAE;MAC7D,IAAIA,YAAY,CAACC,QAAQ,CAAC,YAAY,CAAC,EAAE;QACvCL,SAAS,CAACM,IAAI,CAACF,YAAY,CAAC;MAC9B;IACF,CAAC,CAAC;IACFJ,SAAS,CAACO,IAAI,CAAC,UAAUC,CAAC,EAAEC,CAAC,EAAE;MAC7B,OAAOD,CAAC,CAAClD,MAAM,GAAGmD,CAAC,CAACnD,MAAM;IAC5B,CAAC,CAAC,CAAC,CAAC;;IAEJwC,YAAY,GAAGE,SAAS,CAAC,CAAC,CAAC,CAACU,OAAO,CAAC,cAAc,EAAE,EAAE,CAAC;IAEvD,IAAIhB,aAAa,CAACiB,QAAQ,EAAE;MAC1BjB,aAAa,CAACiB,QAAQ,CAACd,iBAAiB,CAAC;IAC3C;EACF,CAAC,CAAC;EACF,OAAO;IACLe,UAAU,EAAE,SAASA,UAAUA,CAACC,QAAQ,EAAEC,OAAO,EAAE9D,KAAK,EAAE;MACxD,IAAI+D,OAAO,GAAGC,SAAS,CAAC1D,MAAM,GAAG,CAAC,IAAI0D,SAAS,CAAC,CAAC,CAAC,KAAKC,SAAS,GAAGD,SAAS,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC;MACpF,OAAO,IAAI/B,OAAO,CAAC,UAAUC,OAAO,EAAEC,MAAM,EAAE;QAC5C,IAAI,CAACQ,KAAK,EAAE;UACVpD,aAAa,CAAC,2BAA2B,CAAC;QAC5C;QAEA,IAAIG,GAAG,GAAGoC,WAAW,CAAC,CAACgC,OAAO,EAAE9D,KAAK,CAACW,GAAG,CAACuD,QAAQ,EAAEH,OAAO,CAAC9D,WAAW,GAAG,EAAE,CAACgB,MAAM,CAACjB,KAAK,CAACW,GAAG,CAACwD,EAAE,EAAE,KAAK,CAAC,GAAGnE,KAAK,CAACW,GAAG,CAACwD,EAAE,CAAC,CAACC,IAAI,CAAC,GAAG,CAAC,CAAC;QAEnI,IAAI,EAAExB,YAAY,KAAK,CAAC,IAAIiB,QAAQ,KAAK,IAAI,IAAIA,QAAQ,KAAK,KAAK,CAAC,IAAIA,QAAQ,CAACQ,UAAU,EAAE;UAC3FR,QAAQ,CAACQ,UAAU,CAAC,IAAI,CAAC;QAC3B;QAEA,SAASC,WAAWA,CAAA,EAAG;UACrB;UACA,OAAOtE,KAAK,CAACW,GAAG;UAEhB,IAAI,EAAEiC,YAAY,KAAK,CAAC,IAAIiB,QAAQ,KAAK,IAAI,IAAIA,QAAQ,KAAK,KAAK,CAAC,IAAIA,QAAQ,CAACQ,UAAU,EAAE;YAC3FR,QAAQ,CAACQ,UAAU,CAAC,KAAK,CAAC;UAC5B;UAEA,IAAIR,QAAQ,KAAK,IAAI,IAAIA,QAAQ,KAAK,KAAK,CAAC,IAAIA,QAAQ,CAACU,QAAQ,EAAE;YACjEV,QAAQ,CAACU,QAAQ,CAAC,CAAC;UACrB;UAEArC,OAAO,CAAClC,KAAK,CAAC;QAChB;QAEA,IAAIwE,QAAQ,GAAG3B,iBAAiB,CAAC,EAAE,CAAC5B,MAAM,CAAC6B,YAAY,CAAC,CAAC7B,MAAM,CAACvB,GAAG,CAAC,CAAC;QAErE,IAAIM,KAAK,CAACU,QAAQ,KAAK,QAAQ,IAAI,CAACqD,OAAO,CAAC9D,WAAW,EAAE;UACvD;UACA,IAAIwE,OAAO,GAAGnD,YAAY,CAACtB,KAAK,EAAE+D,OAAO,CAAC9D,WAAW,EAAEqE,WAAW,CAAC;UACnEG,OAAO,CAACzF,SAAS,CAACwF,QAAQ,CAAC,CAAC;QAC9B,CAAC,MAAM;UACL;UACA,IAAIE,QAAQ,GAAG3E,gBAAgB,CAACC,KAAK,EAAE+D,OAAO,CAAC9D,WAAW,EAAEqE,WAAW,CAAC;UAExEI,QAAQ,CAACF,QAAQ,CAAC;QACpB;MACF,CAAC,CAAC;IACJ,CAAC;IACDG,SAAS,EAAE,SAASA,SAASA,CAACd,QAAQ,EAAEnE,GAAG,EAAE;MAC3C,IAAIqE,OAAO,GAAGC,SAAS,CAAC1D,MAAM,GAAG,CAAC,IAAI0D,SAAS,CAAC,CAAC,CAAC,KAAKC,SAAS,GAAGD,SAAS,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC;MACpF,IAAIY,IAAI,GAAG9C,WAAW,CAACpC,GAAG,CAAC;MAE3B,IAAI,CAACiD,KAAK,EAAE;QACVpD,aAAa,CAAC,2BAA2B,CAAC;MAC5C;MAEA,IAAIiF,QAAQ,GAAG3B,iBAAiB,CAAC,EAAE,CAAC5B,MAAM,CAAC6B,YAAY,CAAC,CAAC7B,MAAM,CAAC2D,IAAI,CAAC,CAAC;MAEtE,IAAIb,OAAO,CAAC9D,WAAW,EAAE;QACvB,IAAI8D,OAAO,CAAC9D,WAAW,KAAK,IAAI,EAAE;UAChC,IAAIwB,GAAG,GAAGzC,SAAS,CAACC,cAAc,CAACuF,QAAQ,CAAC,CAAC;UAC7C,OAAOvC,OAAO,CAACC,OAAO,CAACpB,IAAI,CAACC,KAAK,CAACU,GAAG,CAAC,CAAC;QACzC;QAEA,OAAOQ,OAAO,CAACE,MAAM,CAAC,IAAIK,KAAK,CAAC,qBAAqB,CAAC,CAAC;MACzD;MAEA,OAAOP,OAAO,CAACC,OAAO,CAACpB,IAAI,CAACC,KAAK,CAAC/B,SAAS,CAACwF,QAAQ,CAAC,CAAC,CAAC;IACzD,CAAC;IACDK,SAAS,EAAE,SAASA,SAASA,CAAChB,QAAQ,EAAEnE,GAAG,EAAE;MAC3C,IAAIqE,OAAO,GAAGC,SAAS,CAAC1D,MAAM,GAAG,CAAC,IAAI0D,SAAS,CAAC,CAAC,CAAC,KAAKC,SAAS,GAAGD,SAAS,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC;MACpF,IAAIY,IAAI,GAAG9C,WAAW,CAACpC,GAAG,CAAC;MAE3B,IAAI,CAACiD,KAAK,EAAE;QACVpD,aAAa,CAAC,2BAA2B,CAAC;MAC5C;MAEA,IAAIiF,QAAQ,GAAG3B,iBAAiB,CAAC,EAAE,CAAC5B,MAAM,CAAC6B,YAAY,CAAC,CAAC7B,MAAM,CAAC2D,IAAI,CAAC,CAAC;MAEtE,IAAIb,OAAO,CAAC9D,WAAW,EAAE;QACvB,IAAI8D,OAAO,CAAC9D,WAAW,KAAK,IAAI,EAAE;UAChC,OAAOgC,OAAO,CAACC,OAAO,CAAClD,SAAS,CAACD,SAAS,CAACyF,QAAQ,CAAC,CAAC,CAAC;QACxD;QAEA,OAAOvC,OAAO,CAACE,MAAM,CAAC,IAAIK,KAAK,CAAC,qBAAqB,CAAC,CAAC;MACzD;MAEA,OAAOP,OAAO,CAACC,OAAO,CAAClD,SAAS,CAACwF,QAAQ,CAAC,CAAC;IAC7C,CAAC;IACDM,UAAU,EAAE,SAASA,UAAUA,CAACjB,QAAQ,EAAEnE,GAAG,EAAE;MAC7C,IAAIkF,IAAI,GAAG9C,WAAW,CAACpC,GAAG,CAAC;MAE3B,IAAI,CAACiD,KAAK,EAAE;QACVpD,aAAa,CAAC,2BAA2B,CAAC;MAC5C;MAEA,IAAIiF,QAAQ,GAAG3B,iBAAiB,CAAC,EAAE,CAAC5B,MAAM,CAAC6B,YAAY,CAAC,CAAC7B,MAAM,CAAC2D,IAAI,CAAC,CAAC;MACtE,OAAO,IAAI3C,OAAO,CAAC,UAAUC,OAAO,EAAEC,MAAM,EAAE;QAC5C,IAAI4C,GAAG,GAAG,IAAIC,KAAK,CAAC,CAAC;QAErBD,GAAG,CAACE,MAAM,GAAG,YAAY;UACvB,OAAO/C,OAAO,CAAC6C,GAAG,CAAC;QACrB,CAAC;QAEDA,GAAG,CAACG,OAAO,GAAG/C,MAAM;QACpB,IAAIV,GAAG,GAAGnC,eAAe,CAACkF,QAAQ,CAACpE,MAAM,CAAC;QAC1C2E,GAAG,CAACI,GAAG,GAAG,aAAa,CAAClE,MAAM,CAACxB,UAAU,CAACmF,IAAI,CAAC,EAAE,UAAU,CAAC,CAAC3D,MAAM,CAACQ,GAAG,CAAC;MAC1E,CAAC,CAAC;IACJ,CAAC;IACD2D,WAAW,EAAE,SAASA,WAAWA,CAACvB,QAAQ,EAAEnE,GAAG,EAAE;MAC/C,IAAIqE,OAAO,GAAGC,SAAS,CAAC1D,MAAM,GAAG,CAAC,IAAI0D,SAAS,CAAC,CAAC,CAAC,KAAKC,SAAS,GAAGD,SAAS,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC;MACpF,IAAIY,IAAI,GAAG9C,WAAW,CAACpC,GAAG,CAAC;MAE3B,IAAI,CAACiD,KAAK,EAAE;QACVpD,aAAa,CAAC,2BAA2B,CAAC;MAC5C;MAEA,IAAIiF,QAAQ,GAAG3B,iBAAiB,CAAC,EAAE,CAAC5B,MAAM,CAAC6B,YAAY,CAAC,CAAC7B,MAAM,CAAC2D,IAAI,CAAC,CAAC;MAEtE,IAAIb,OAAO,CAAC9D,WAAW,EAAE;QACvB,IAAI8D,OAAO,CAAC9D,WAAW,KAAK,IAAI,EAAE;UAChC,OAAOgC,OAAO,CAACC,OAAO,CAACjD,cAAc,CAACuF,QAAQ,CAAC,CAACpE,MAAM,CAAC;QACzD;QAEA,OAAO6B,OAAO,CAACE,MAAM,CAAC,IAAIK,KAAK,CAAC,qBAAqB,CAAC,CAAC;MACzD;MAEA,OAAOP,OAAO,CAACC,OAAO,CAACsC,QAAQ,CAACpE,MAAM,CAAC;IACzC;EACF,CAAC;AACH;AAEA,IAAIiF,qBAAqB,GAAG;EAC1B5C,MAAM,EAAEA;AACV,CAAC;AACDpD,YAAY,CAAC,KAAK,EAAE,UAAU0E,OAAO,EAAE;EACrC,OAAOsB,qBAAqB,CAAC5C,MAAM,CAACsB,OAAO,CAAC;AAC9C,CAAC,CAAC;AAEF,SAASsB,qBAAqB,IAAIC,OAAO"},"metadata":{},"sourceType":"module","externalDependencies":[]}