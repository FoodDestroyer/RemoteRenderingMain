{"ast":null,"code":"import macro from '../../macros.js';\nimport vtkPolyData from '../../Common/DataModel/PolyData.js';\nimport vtkEdgeLocator from '../../Common/DataModel/EdgeLocator.js';\nimport vtkCaseTable from './ImageMarchingSquares/caseTable.js';\nvar vtkErrorMacro = macro.vtkErrorMacro,\n  vtkDebugMacro = macro.vtkDebugMacro; // ----------------------------------------------------------------------------\n// vtkImageMarchingSquares methods\n// ----------------------------------------------------------------------------\n\nfunction vtkImageMarchingSquares(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkImageMarchingSquares');\n  publicAPI.getContourValues = function () {\n    return model.contourValues;\n  };\n  publicAPI.setContourValues = function (cValues) {\n    model.contourValues = cValues;\n    publicAPI.modified();\n  };\n  var ids = [];\n  var pixelScalars = [];\n  var pixelPts = [];\n  var edgeLocator = vtkEdgeLocator.newInstance(); // Retrieve scalars and pixel coordinates. i-j-k is origin of pixel.\n\n  publicAPI.getPixelScalars = function (i, j, k, slice, dims, origin, spacing, s) {\n    // First get the indices for the pixel\n    ids[0] = k * slice + j * dims[0] + i; // i, j, k\n\n    ids[1] = ids[0] + 1; // i+1, j, k\n\n    ids[2] = ids[0] + dims[0]; // i, j+1, k\n\n    ids[3] = ids[2] + 1; // i+1, j+1, k\n    // Now retrieve the scalars\n\n    for (var ii = 0; ii < 4; ++ii) {\n      pixelScalars[ii] = s[ids[ii]];\n    }\n  }; // Retrieve pixel coordinates. i-j-k is origin of pixel.\n\n  publicAPI.getPixelPoints = function (i, j, k, dims, origin, spacing) {\n    // (i,i+1),(j,j+1),(k,k+1) - i varies fastest; then j; then k\n    pixelPts[0] = origin[0] + i * spacing[0]; // 0\n\n    pixelPts[1] = origin[1] + j * spacing[1];\n    pixelPts[2] = pixelPts[0] + spacing[0]; // 1\n\n    pixelPts[3] = pixelPts[1];\n    pixelPts[4] = pixelPts[0]; // 2\n\n    pixelPts[5] = pixelPts[1] + spacing[1];\n    pixelPts[6] = pixelPts[2]; // 3\n\n    pixelPts[7] = pixelPts[5];\n  };\n  publicAPI.produceLines = function (cVal, i, j, k, slice, dims, origin, spacing, scalars, points, lines) {\n    var CASE_MASK = [1, 2, 8, 4]; // case table is actually for quad\n\n    var xyz = [];\n    var pId;\n    publicAPI.getPixelScalars(i, j, k, slice, dims, origin, spacing, scalars);\n    var index = 0;\n    for (var idx = 0; idx < 4; idx++) {\n      if (pixelScalars[idx] >= cVal) {\n        index |= CASE_MASK[idx]; // eslint-disable-line no-bitwise\n      }\n    }\n\n    var pixelLines = vtkCaseTable.getCase(index);\n    if (pixelLines[0] < 0) {\n      return; // don't get the pixel coordinates, nothing to do\n    }\n\n    publicAPI.getPixelPoints(i, j, k, dims, origin, spacing);\n    var z = origin[2] + k * spacing[2];\n    for (var _idx = 0; pixelLines[_idx] >= 0; _idx += 2) {\n      lines.push(2);\n      for (var eid = 0; eid < 2; eid++) {\n        var edgeVerts = vtkCaseTable.getEdge(pixelLines[_idx + eid]);\n        pId = undefined;\n        if (model.mergePoints) {\n          var _edgeLocator$isInsert;\n          pId = (_edgeLocator$isInsert = edgeLocator.isInsertedEdge(ids[edgeVerts[0]], ids[edgeVerts[1]])) === null || _edgeLocator$isInsert === void 0 ? void 0 : _edgeLocator$isInsert.value;\n        }\n        if (pId === undefined) {\n          var t = (cVal - pixelScalars[edgeVerts[0]]) / (pixelScalars[edgeVerts[1]] - pixelScalars[edgeVerts[0]]);\n          var x0 = pixelPts.slice(edgeVerts[0] * 2, (edgeVerts[0] + 1) * 2);\n          var x1 = pixelPts.slice(edgeVerts[1] * 2, (edgeVerts[1] + 1) * 2);\n          xyz[0] = x0[0] + t * (x1[0] - x0[0]);\n          xyz[1] = x0[1] + t * (x1[1] - x0[1]);\n          pId = points.length / 3;\n          points.push(xyz[0], xyz[1], z);\n          if (model.mergePoints) {\n            edgeLocator.insertEdge(ids[edgeVerts[0]], ids[edgeVerts[1]], pId);\n          }\n        }\n        lines.push(pId);\n      }\n    }\n  };\n  publicAPI.requestData = function (inData, outData) {\n    // implement requestData\n    var input = inData[0];\n    if (!input) {\n      vtkErrorMacro('Invalid or missing input');\n      return;\n    }\n    console.time('msquares'); // Retrieve output and volume data\n\n    var origin = input.getOrigin();\n    var spacing = input.getSpacing();\n    var dims = input.getDimensions();\n    var s = input.getPointData().getScalars().getData(); // Points - dynamic array\n\n    var pBuffer = []; // Cells - dynamic array\n\n    var lBuffer = []; // Ensure slice is valid\n\n    var slice = dims[0] * dims[1];\n    var k = Math.round(model.slice);\n    if (k >= dims[2]) {\n      k = 0;\n    } // Loop over all contour values, and then pixels, determine case and process\n\n    for (var cv = 0; cv < model.contourValues.length; ++cv) {\n      for (var j = 0; j < dims[1] - 1; ++j) {\n        for (var i = 0; i < dims[0] - 1; ++i) {\n          publicAPI.produceLines(model.contourValues[cv], i, j, k, slice, dims, origin, spacing, s, pBuffer, lBuffer);\n        }\n      }\n      edgeLocator.initialize();\n    } // Update output\n\n    var polydata = vtkPolyData.newInstance();\n    polydata.getPoints().setData(new Float32Array(pBuffer), 3);\n    polydata.getLines().setData(new Uint32Array(lBuffer));\n    outData[0] = polydata;\n    vtkDebugMacro('Produced output');\n    console.timeEnd('msquares');\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nvar DEFAULT_VALUES = {\n  contourValues: [],\n  slice: 0,\n  mergePoints: false\n}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Make this a VTK object\n\n  macro.obj(publicAPI, model); // Also make it an algorithm with one input and one output\n\n  macro.algo(publicAPI, model, 1, 1);\n  macro.setGet(publicAPI, model, ['slice', 'mergePoints']); // Object specific methods\n\n  macro.algo(publicAPI, model, 1, 1);\n  vtkImageMarchingSquares(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = macro.newInstance(extend, 'vtkImageMarchingSquares'); // ----------------------------------------------------------------------------\n\nvar vtkImageMarchingSquares$1 = {\n  newInstance: newInstance,\n  extend: extend\n};\nexport { vtkImageMarchingSquares$1 as default, extend, newInstance };","map":{"version":3,"names":["macro","vtkPolyData","vtkEdgeLocator","vtkCaseTable","vtkErrorMacro","vtkDebugMacro","vtkImageMarchingSquares","publicAPI","model","classHierarchy","push","getContourValues","contourValues","setContourValues","cValues","modified","ids","pixelScalars","pixelPts","edgeLocator","newInstance","getPixelScalars","i","j","k","slice","dims","origin","spacing","s","ii","getPixelPoints","produceLines","cVal","scalars","points","lines","CASE_MASK","xyz","pId","index","idx","pixelLines","getCase","z","_idx","eid","edgeVerts","getEdge","undefined","mergePoints","_edgeLocator$isInsert","isInsertedEdge","value","t","x0","x1","length","insertEdge","requestData","inData","outData","input","console","time","getOrigin","getSpacing","getDimensions","getPointData","getScalars","getData","pBuffer","lBuffer","Math","round","cv","initialize","polydata","getPoints","setData","Float32Array","getLines","Uint32Array","timeEnd","DEFAULT_VALUES","extend","initialValues","arguments","Object","assign","obj","algo","setGet","vtkImageMarchingSquares$1","default"],"sources":["/home/rakshith/Documents/RemoteRendering/vtk-js-react-app/node_modules/@kitware/vtk.js/Filters/General/ImageMarchingSquares.js"],"sourcesContent":["import macro from '../../macros.js';\nimport vtkPolyData from '../../Common/DataModel/PolyData.js';\nimport vtkEdgeLocator from '../../Common/DataModel/EdgeLocator.js';\nimport vtkCaseTable from './ImageMarchingSquares/caseTable.js';\n\nvar vtkErrorMacro = macro.vtkErrorMacro,\n    vtkDebugMacro = macro.vtkDebugMacro; // ----------------------------------------------------------------------------\n// vtkImageMarchingSquares methods\n// ----------------------------------------------------------------------------\n\nfunction vtkImageMarchingSquares(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkImageMarchingSquares');\n\n  publicAPI.getContourValues = function () {\n    return model.contourValues;\n  };\n\n  publicAPI.setContourValues = function (cValues) {\n    model.contourValues = cValues;\n    publicAPI.modified();\n  };\n\n  var ids = [];\n  var pixelScalars = [];\n  var pixelPts = [];\n  var edgeLocator = vtkEdgeLocator.newInstance(); // Retrieve scalars and pixel coordinates. i-j-k is origin of pixel.\n\n  publicAPI.getPixelScalars = function (i, j, k, slice, dims, origin, spacing, s) {\n    // First get the indices for the pixel\n    ids[0] = k * slice + j * dims[0] + i; // i, j, k\n\n    ids[1] = ids[0] + 1; // i+1, j, k\n\n    ids[2] = ids[0] + dims[0]; // i, j+1, k\n\n    ids[3] = ids[2] + 1; // i+1, j+1, k\n    // Now retrieve the scalars\n\n    for (var ii = 0; ii < 4; ++ii) {\n      pixelScalars[ii] = s[ids[ii]];\n    }\n  }; // Retrieve pixel coordinates. i-j-k is origin of pixel.\n\n\n  publicAPI.getPixelPoints = function (i, j, k, dims, origin, spacing) {\n    // (i,i+1),(j,j+1),(k,k+1) - i varies fastest; then j; then k\n    pixelPts[0] = origin[0] + i * spacing[0]; // 0\n\n    pixelPts[1] = origin[1] + j * spacing[1];\n    pixelPts[2] = pixelPts[0] + spacing[0]; // 1\n\n    pixelPts[3] = pixelPts[1];\n    pixelPts[4] = pixelPts[0]; // 2\n\n    pixelPts[5] = pixelPts[1] + spacing[1];\n    pixelPts[6] = pixelPts[2]; // 3\n\n    pixelPts[7] = pixelPts[5];\n  };\n\n  publicAPI.produceLines = function (cVal, i, j, k, slice, dims, origin, spacing, scalars, points, lines) {\n    var CASE_MASK = [1, 2, 8, 4]; // case table is actually for quad\n\n    var xyz = [];\n    var pId;\n    publicAPI.getPixelScalars(i, j, k, slice, dims, origin, spacing, scalars);\n    var index = 0;\n\n    for (var idx = 0; idx < 4; idx++) {\n      if (pixelScalars[idx] >= cVal) {\n        index |= CASE_MASK[idx]; // eslint-disable-line no-bitwise\n      }\n    }\n\n    var pixelLines = vtkCaseTable.getCase(index);\n\n    if (pixelLines[0] < 0) {\n      return; // don't get the pixel coordinates, nothing to do\n    }\n\n    publicAPI.getPixelPoints(i, j, k, dims, origin, spacing);\n    var z = origin[2] + k * spacing[2];\n\n    for (var _idx = 0; pixelLines[_idx] >= 0; _idx += 2) {\n      lines.push(2);\n\n      for (var eid = 0; eid < 2; eid++) {\n        var edgeVerts = vtkCaseTable.getEdge(pixelLines[_idx + eid]);\n        pId = undefined;\n\n        if (model.mergePoints) {\n          var _edgeLocator$isInsert;\n\n          pId = (_edgeLocator$isInsert = edgeLocator.isInsertedEdge(ids[edgeVerts[0]], ids[edgeVerts[1]])) === null || _edgeLocator$isInsert === void 0 ? void 0 : _edgeLocator$isInsert.value;\n        }\n\n        if (pId === undefined) {\n          var t = (cVal - pixelScalars[edgeVerts[0]]) / (pixelScalars[edgeVerts[1]] - pixelScalars[edgeVerts[0]]);\n          var x0 = pixelPts.slice(edgeVerts[0] * 2, (edgeVerts[0] + 1) * 2);\n          var x1 = pixelPts.slice(edgeVerts[1] * 2, (edgeVerts[1] + 1) * 2);\n          xyz[0] = x0[0] + t * (x1[0] - x0[0]);\n          xyz[1] = x0[1] + t * (x1[1] - x0[1]);\n          pId = points.length / 3;\n          points.push(xyz[0], xyz[1], z);\n\n          if (model.mergePoints) {\n            edgeLocator.insertEdge(ids[edgeVerts[0]], ids[edgeVerts[1]], pId);\n          }\n        }\n\n        lines.push(pId);\n      }\n    }\n  };\n\n  publicAPI.requestData = function (inData, outData) {\n    // implement requestData\n    var input = inData[0];\n\n    if (!input) {\n      vtkErrorMacro('Invalid or missing input');\n      return;\n    }\n\n    console.time('msquares'); // Retrieve output and volume data\n\n    var origin = input.getOrigin();\n    var spacing = input.getSpacing();\n    var dims = input.getDimensions();\n    var s = input.getPointData().getScalars().getData(); // Points - dynamic array\n\n    var pBuffer = []; // Cells - dynamic array\n\n    var lBuffer = []; // Ensure slice is valid\n\n    var slice = dims[0] * dims[1];\n    var k = Math.round(model.slice);\n\n    if (k >= dims[2]) {\n      k = 0;\n    } // Loop over all contour values, and then pixels, determine case and process\n\n\n    for (var cv = 0; cv < model.contourValues.length; ++cv) {\n      for (var j = 0; j < dims[1] - 1; ++j) {\n        for (var i = 0; i < dims[0] - 1; ++i) {\n          publicAPI.produceLines(model.contourValues[cv], i, j, k, slice, dims, origin, spacing, s, pBuffer, lBuffer);\n        }\n      }\n\n      edgeLocator.initialize();\n    } // Update output\n\n\n    var polydata = vtkPolyData.newInstance();\n    polydata.getPoints().setData(new Float32Array(pBuffer), 3);\n    polydata.getLines().setData(new Uint32Array(lBuffer));\n    outData[0] = polydata;\n    vtkDebugMacro('Produced output');\n    console.timeEnd('msquares');\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\n\nvar DEFAULT_VALUES = {\n  contourValues: [],\n  slice: 0,\n  mergePoints: false\n}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Make this a VTK object\n\n  macro.obj(publicAPI, model); // Also make it an algorithm with one input and one output\n\n  macro.algo(publicAPI, model, 1, 1);\n  macro.setGet(publicAPI, model, ['slice', 'mergePoints']); // Object specific methods\n\n  macro.algo(publicAPI, model, 1, 1);\n  vtkImageMarchingSquares(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = macro.newInstance(extend, 'vtkImageMarchingSquares'); // ----------------------------------------------------------------------------\n\nvar vtkImageMarchingSquares$1 = {\n  newInstance: newInstance,\n  extend: extend\n};\n\nexport { vtkImageMarchingSquares$1 as default, extend, newInstance };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}