import widgetBehavior$1 from './behavior.js';
import { InteractionMethodsName } from './Constants.js';
import { updateState } from './helpers.js';
import { ViewTypes } from '../../Core/WidgetManager/Constants.js';
import { vec3 } from 'gl-matrix';

function widgetBehavior(publicAPI, model) {
  // We inherit resliceCursorBehavior
  widgetBehavior$1(publicAPI, model);
  var stretchPlaneName = 'Y';
  var crossPlaneName = 'Z';

  publicAPI.getActiveInteraction = function () {
    if (model.widgetState.getStatesWithLabel("lineIn".concat(stretchPlaneName)).includes(model.activeState)) {
      return InteractionMethodsName.TranslateCenterAndUpdatePlanes;
    }

    if (model.widgetState.getStatesWithLabel("lineIn".concat(crossPlaneName)).includes(model.activeState) || model.widgetState.getStatesWithLabel("rotationIn".concat(crossPlaneName)).includes(model.activeState)) {
      return InteractionMethodsName.RotateLine;
    }

    return null;
  };

  publicAPI[InteractionMethodsName.TranslateCenterAndUpdatePlanes] = function (calldata) {
    var _model$activeState$ge, _model$activeState, _model$activeState$ge2;

    var manipulator = (_model$activeState$ge = (_model$activeState = model.activeState) === null || _model$activeState === void 0 ? void 0 : (_model$activeState$ge2 = _model$activeState.getManipulator) === null || _model$activeState$ge2 === void 0 ? void 0 : _model$activeState$ge2.call(_model$activeState)) !== null && _model$activeState$ge !== void 0 ? _model$activeState$ge : model.manipulator;

    var _manipulator$handleEv = manipulator.handleEvent(calldata, model._apiSpecificRenderWindow),
        worldCoords = _manipulator$handleEv.worldCoords,
        worldDirection = _manipulator$handleEv.worldDirection;

    publicAPI.updateCenterAndPlanes(worldCoords, worldDirection);
  };

  publicAPI.updateCenterAndPlanes = function (worldCoords, worldDirection) {
    // Update center
    var newBoundedCenter = publicAPI.getBoundedCenter(worldCoords);
    model.widgetState.setCenter(newBoundedCenter); // Update planes if axes are given

    if (worldDirection) {
      var getAxis = function getAxis(idx) {
        return vec3.normalize([], worldDirection.slice(3 * idx, 3 * idx + 3));
      };

      var planes = model.widgetState.getPlanes();
      Object.keys(planes).forEach(function (viewType) {
        switch (Number.parseInt(viewType, 10)) {
          case ViewTypes.YZ_PLANE:
            planes[viewType] = {
              normal: getAxis(0),
              viewUp: getAxis(2)
            };
            break;

          case ViewTypes.XZ_PLANE:
            planes[viewType] = {
              normal: getAxis(1),
              viewUp: getAxis(2)
            };
            break;

          case ViewTypes.XY_PLANE:
            planes[viewType] = {
              normal: getAxis(2),
              viewUp: getAxis(1)
            };
            break;
        }
      });
    }

    updateState(model.widgetState, model._factory.getScaleInPixels(), model._factory.getRotationHandlePosition());
  };

  publicAPI.translateCenterOnPlaneDirection = function (nbSteps) {
    var _model$_factory$getMa;

    var handleScroll = (_model$_factory$getMa = model._factory.getManipulator()) === null || _model$_factory$getMa === void 0 ? void 0 : _model$_factory$getMa.handleScroll;

    if (handleScroll) {
      var _handleScroll = handleScroll(nbSteps),
          worldCoords = _handleScroll.worldCoords,
          worldDirection = _handleScroll.worldDirection;

      publicAPI.updateCenterAndPlanes(worldCoords, worldDirection);
    }
  };
}

export { widgetBehavior as default };
