{"ast":null,"code":"import { newInstance as newInstance$1, vtkErrorMacro as vtkErrorMacro$1 } from '../../macros.js';\nimport { r as radiansFromDegrees } from '../../Common/Core/Math/index.js';\nimport vtkWebGPUCellArrayMapper from './CellArrayMapper.js';\nimport vtkWebGPUBufferManager from './BufferManager.js';\nimport vtkWebGPUShaderCache from './ShaderCache.js';\nimport { registerOverride } from './ViewNodeFactory.js';\nvar BufferUsage = vtkWebGPUBufferManager.BufferUsage;\nvar vtkErrorMacro = vtkErrorMacro$1;\nvar vtkWebGPUSphereMapperVS = \"\\n//VTK::Renderer::Dec\\n\\n//VTK::Mapper::Dec\\n\\n//VTK::Color::Dec\\n\\n//VTK::IOStructs::Dec\\n\\n@vertex\\nfn main(\\n//VTK::IOStructs::Input\\n)\\n//VTK::IOStructs::Output\\n{\\n  var output : vertexOutput;\\n\\n  var vertexVC: vec4<f32> = rendererUBO.SCVCMatrix * mapperUBO.BCSCMatrix * vec4<f32>(vertexBC.xyz, 1.0);\\n\\n  //VTK::Color::Impl\\n\\n  // compute the projected vertex position\\n  output.centerVC = vertexVC.xyz;\\n  output.radiusVC = length(offsetMC)*0.5;\\n\\n  // make the triangle face the camera\\n  if (rendererUBO.cameraParallel == 0u)\\n    {\\n    var dir: vec3<f32> = normalize(-vertexVC.xyz);\\n    var base2: vec3<f32> = normalize(cross(dir,vec3<f32>(1.0,0.0,0.0)));\\n    var base1: vec3<f32> = cross(base2,dir);\\n    dir = vertexVC.xyz + offsetMC.x*base1 + offsetMC.y*base2;\\n    vertexVC = vec4<f32>(dir, 1.0);\\n    }\\n  else\\n    {\\n    // add in the offset\\n    var tmp2: vec2<f32> = vertexVC.xy + offsetMC;\\n    vertexVC = vec4<f32>(tmp2, vertexVC.zw);\\n    }\\n\\n  output.vertexVC = vec4<f32>(vertexVC.xyz, 0.0);\\n\\n  //VTK::Position::Impl\\n\\n  return output;\\n}\\n\"; // ----------------------------------------------------------------------------\n// vtkWebGPUSphereMapper methods\n// ----------------------------------------------------------------------------\n\nfunction vtkWebGPUSphereMapper(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkWebGPUSphereMapper');\n  var cellMapperBuildPass = publicAPI.buildPass;\n  publicAPI.buildPass = function (prepass) {\n    if (prepass) {\n      if (!model.renderable.getStatic()) {\n        model.renderable.update();\n      }\n      var poly = model.renderable.getInputData();\n      publicAPI.setCellArray(poly.getVerts());\n      publicAPI.setCurrentInput(poly);\n    }\n    cellMapperBuildPass(prepass);\n  };\n  publicAPI.replaceShaderNormal = function (hash, pipeline, vertexInput) {\n    var vDesc = pipeline.getShaderDescription('vertex');\n    if (!vDesc.hasOutput('vertexVC')) vDesc.addOutput('vec4<f32>', 'vertexVC');\n    vDesc.addOutput('vec3<f32>', 'centerVC');\n    vDesc.addOutput('f32', 'radiusVC');\n    var fDesc = pipeline.getShaderDescription('fragment');\n    fDesc.addBuiltinOutput('f32', '@builtin(frag_depth) fragDepth');\n    var sphereFrag = \"\\n    // compute the eye position and unit direction\\n    var vertexVC: vec4<f32>;\\n    var EyePos: vec3<f32>;\\n    var EyeDir: vec3<f32>;\\n    var invertedDepth: f32 = 1.0;\\n    if (rendererUBO.cameraParallel != 0u) {\\n      EyePos = vec3<f32>(input.vertexVC.x, input.vertexVC.y, input.vertexVC.z + 3.0*input.radiusVC);\\n      EyeDir = vec3<f32>(0.0, 0.0, -1.0);\\n    }\\n    else {\\n      EyeDir = input.vertexVC.xyz;\\n      EyePos = vec3<f32>(0.0,0.0,0.0);\\n      var lengthED: f32 = length(EyeDir);\\n      EyeDir = normalize(EyeDir);\\n      // we adjust the EyePos to be closer if it is too far away\\n      // to prevent floating point precision noise\\n      if (lengthED > input.radiusVC*3.0) {\\n        EyePos = input.vertexVC.xyz - EyeDir*3.0*input.radiusVC;\\n      }\\n    }\\n\\n    // translate to Sphere center\\n    EyePos = EyePos - input.centerVC;\\n    // scale to radius 1.0\\n    EyePos = EyePos * (1.0 / input.radiusVC);\\n    // find the intersection\\n    var b: f32 = 2.0*dot(EyePos,EyeDir);\\n    var c: f32 = dot(EyePos,EyePos) - 1.0;\\n    var d: f32 = b*b - 4.0*c;\\n    var normal: vec3<f32> = vec3<f32>(0.0,0.0,1.0);\\n    if (d < 0.0) { discard; }\\n    else {\\n      var t: f32 = (-b - invertedDepth*sqrt(d))*0.5;\\n\\n      // compute the normal, for unit sphere this is just\\n      // the intersection point\\n      normal = invertedDepth*normalize(EyePos + t*EyeDir);\\n      // compute the intersection point in VC\\n      vertexVC = vec4<f32>(normal * input.radiusVC + input.centerVC, 1.0);\\n    }\\n    // compute the pixel's depth\\n    var pos: vec4<f32> = rendererUBO.VCPCMatrix * vertexVC;\\n    output.fragDepth = pos.z / pos.w;\\n    \";\n    var code = fDesc.getCode();\n    code = vtkWebGPUShaderCache.substitute(code, '//VTK::Normal::Impl', [sphereFrag]).result;\n    fDesc.setCode(code);\n  };\n  publicAPI.replaceShaderPosition = function (hash, pipeline, vertexInput) {\n    var vDesc = pipeline.getShaderDescription('vertex');\n    vDesc.addBuiltinOutput('vec4<f32>', '@builtin(position) Position');\n    var code = vDesc.getCode();\n    code = vtkWebGPUShaderCache.substitute(code, '//VTK::Position::Impl', ['  output.Position = rendererUBO.VCPCMatrix*vertexVC;']).result;\n    vDesc.setCode(code);\n  }; // compute a unique hash for a pipeline, this needs to be unique enough to\n  // capture any pipeline code changes (which includes shader changes)\n  // or vertex input changes/ bind groups/ etc\n\n  publicAPI.computePipelineHash = function () {\n    model.pipelineHash = 'spm';\n    if (model.vertexInput.hasAttribute(\"colorVI\")) {\n      model.pipelineHash += \"c\";\n    }\n    model.pipelineHash += model.renderEncoder.getPipelineHash();\n  };\n  publicAPI.updateBuffers = function () {\n    var poly = model.currentInput;\n    model.renderable.mapScalars(poly, 1.0);\n    var points = poly.getPoints();\n    var numPoints = points.getNumberOfPoints();\n    var pointArray = points.getData(); // default to one instance and computed number of verts\n\n    publicAPI.setNumberOfInstances(1);\n    publicAPI.setNumberOfVertices(3 * numPoints);\n    var vertexInput = model.vertexInput;\n    var hash = \"spm\".concat(points.getMTime(), \"float32x3\");\n    if (!model.device.getBufferManager().hasBuffer(hash)) {\n      var buffRequest = {\n        hash: hash,\n        usage: BufferUsage.RawVertex,\n        format: 'float32x3'\n      }; // xyz v1 v2 v3\n\n      var tmpVBO = new Float32Array(3 * numPoints * 3);\n      var pointIdx = 0;\n      var vboIdx = 0;\n      for (var id = 0; id < numPoints; ++id) {\n        pointIdx = id * 3;\n        tmpVBO[vboIdx++] = pointArray[pointIdx];\n        tmpVBO[vboIdx++] = pointArray[pointIdx + 1];\n        tmpVBO[vboIdx++] = pointArray[pointIdx + 2];\n        tmpVBO[vboIdx++] = pointArray[pointIdx];\n        tmpVBO[vboIdx++] = pointArray[pointIdx + 1];\n        tmpVBO[vboIdx++] = pointArray[pointIdx + 2];\n        tmpVBO[vboIdx++] = pointArray[pointIdx];\n        tmpVBO[vboIdx++] = pointArray[pointIdx + 1];\n        tmpVBO[vboIdx++] = pointArray[pointIdx + 2];\n      }\n      buffRequest.nativeArray = tmpVBO;\n      var buff = model.device.getBufferManager().getBuffer(buffRequest);\n      vertexInput.addBuffer(buff, ['vertexBC']);\n    } // compute offset VBO\n\n    var pointData = poly.getPointData();\n    var scales = null;\n    if (model.renderable.getScaleArray() != null && pointData.hasArray(model.renderable.getScaleArray())) {\n      scales = pointData.getArray(model.renderable.getScaleArray()).getData();\n    }\n    var defaultRadius = model.renderable.getRadius();\n    if (scales || defaultRadius !== model._lastRadius) {\n      hash = \"spm\".concat(scales ? pointData.getArray(model.renderable.getScaleArray()).getMTime() : defaultRadius, \"float32x2\");\n      if (!model.device.getBufferManager().hasBuffer(hash)) {\n        var _buffRequest = {\n          hash: hash,\n          usage: BufferUsage.RawVertex,\n          format: 'float32x2'\n        };\n        var _tmpVBO = new Float32Array(3 * numPoints * 2);\n        var cos30 = Math.cos(radiansFromDegrees(30.0));\n        var _vboIdx = 0;\n        for (var _id = 0; _id < numPoints; ++_id) {\n          var radius = model.renderable.getRadius();\n          if (scales) {\n            radius = scales[_id] * model.renderable.getScaleFactor();\n          }\n          _tmpVBO[_vboIdx++] = -2.0 * radius * cos30;\n          _tmpVBO[_vboIdx++] = -radius;\n          _tmpVBO[_vboIdx++] = 2.0 * radius * cos30;\n          _tmpVBO[_vboIdx++] = -radius;\n          _tmpVBO[_vboIdx++] = 0.0;\n          _tmpVBO[_vboIdx++] = 2.0 * radius;\n        }\n        _buffRequest.nativeArray = _tmpVBO;\n        var _buff = model.device.getBufferManager().getBuffer(_buffRequest);\n        vertexInput.addBuffer(_buff, ['offsetMC']);\n      }\n      model._lastRadius = defaultRadius;\n    } // deal with colors but only if modified\n\n    var haveColors = false;\n    if (model.renderable.getScalarVisibility()) {\n      var c = model.renderable.getColorMapColors();\n      if (c) {\n        hash = \"spm\".concat(c.getMTime(), \"unorm8x4\");\n        if (!model.device.getBufferManager().hasBuffer(hash)) {\n          var _buffRequest2 = {\n            hash: hash,\n            usage: BufferUsage.RawVertex,\n            format: 'unorm8x4'\n          };\n          var colorComponents = c.getNumberOfComponents();\n          if (colorComponents !== 4) {\n            vtkErrorMacro('this should be 4');\n          }\n          var _tmpVBO2 = new Uint8Array(3 * numPoints * 4);\n          var _vboIdx2 = 0;\n          var colorData = c.getData();\n          for (var _id2 = 0; _id2 < numPoints; ++_id2) {\n            var colorIdx = _id2 * colorComponents;\n            for (var v = 0; v < 3; v++) {\n              _tmpVBO2[_vboIdx2++] = colorData[colorIdx];\n              _tmpVBO2[_vboIdx2++] = colorData[colorIdx + 1];\n              _tmpVBO2[_vboIdx2++] = colorData[colorIdx + 2];\n              _tmpVBO2[_vboIdx2++] = colorData[colorIdx + 3];\n            }\n          }\n          _buffRequest2.nativeArray = _tmpVBO2;\n          var _buff2 = model.device.getBufferManager().getBuffer(_buffRequest2);\n          vertexInput.addBuffer(_buff2, ['colorVI']);\n        }\n        haveColors = true;\n      }\n    }\n    if (!haveColors) {\n      vertexInput.removeBufferIfPresent('colorVI');\n    }\n    publicAPI.setTopology('triangle-list');\n    publicAPI.updateUBO();\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nvar DEFAULT_VALUES = {}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Inheritance\n\n  vtkWebGPUCellArrayMapper.extend(publicAPI, model, initialValues);\n  publicAPI.setVertexShaderTemplate(vtkWebGPUSphereMapperVS); // Object methods\n\n  vtkWebGPUSphereMapper(publicAPI, model);\n  var sr = model.shaderReplacements;\n  sr.set('replaceShaderPosition', publicAPI.replaceShaderPosition);\n  sr.set('replaceShaderNormal', publicAPI.replaceShaderNormal);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = newInstance$1(extend, 'vtkWebGPUSphereMapper'); // ----------------------------------------------------------------------------\n\nvar index = {\n  newInstance: newInstance,\n  extend: extend\n}; // Register ourself to WebGPU backend if imported\n\nregisterOverride('vtkSphereMapper', newInstance);\nexport { index as default, extend, newInstance };","map":{"version":3,"names":["newInstance","newInstance$1","vtkErrorMacro","vtkErrorMacro$1","r","radiansFromDegrees","vtkWebGPUCellArrayMapper","vtkWebGPUBufferManager","vtkWebGPUShaderCache","registerOverride","BufferUsage","vtkWebGPUSphereMapperVS","vtkWebGPUSphereMapper","publicAPI","model","classHierarchy","push","cellMapperBuildPass","buildPass","prepass","renderable","getStatic","update","poly","getInputData","setCellArray","getVerts","setCurrentInput","replaceShaderNormal","hash","pipeline","vertexInput","vDesc","getShaderDescription","hasOutput","addOutput","fDesc","addBuiltinOutput","sphereFrag","code","getCode","substitute","result","setCode","replaceShaderPosition","computePipelineHash","pipelineHash","hasAttribute","renderEncoder","getPipelineHash","updateBuffers","currentInput","mapScalars","points","getPoints","numPoints","getNumberOfPoints","pointArray","getData","setNumberOfInstances","setNumberOfVertices","concat","getMTime","device","getBufferManager","hasBuffer","buffRequest","usage","RawVertex","format","tmpVBO","Float32Array","pointIdx","vboIdx","id","nativeArray","buff","getBuffer","addBuffer","pointData","getPointData","scales","getScaleArray","hasArray","getArray","defaultRadius","getRadius","_lastRadius","_buffRequest","_tmpVBO","cos30","Math","cos","_vboIdx","_id","radius","getScaleFactor","_buff","haveColors","getScalarVisibility","c","getColorMapColors","_buffRequest2","colorComponents","getNumberOfComponents","_tmpVBO2","Uint8Array","_vboIdx2","colorData","_id2","colorIdx","v","_buff2","removeBufferIfPresent","setTopology","updateUBO","DEFAULT_VALUES","extend","initialValues","arguments","length","undefined","Object","assign","setVertexShaderTemplate","sr","shaderReplacements","set","index","default"],"sources":["/home/rakshith/Documents/RemoteRendering/vtk-js-react-app/node_modules/@kitware/vtk.js/Rendering/WebGPU/SphereMapper.js"],"sourcesContent":["import { newInstance as newInstance$1, vtkErrorMacro as vtkErrorMacro$1 } from '../../macros.js';\nimport { r as radiansFromDegrees } from '../../Common/Core/Math/index.js';\nimport vtkWebGPUCellArrayMapper from './CellArrayMapper.js';\nimport vtkWebGPUBufferManager from './BufferManager.js';\nimport vtkWebGPUShaderCache from './ShaderCache.js';\nimport { registerOverride } from './ViewNodeFactory.js';\n\nvar BufferUsage = vtkWebGPUBufferManager.BufferUsage;\nvar vtkErrorMacro = vtkErrorMacro$1;\nvar vtkWebGPUSphereMapperVS = \"\\n//VTK::Renderer::Dec\\n\\n//VTK::Mapper::Dec\\n\\n//VTK::Color::Dec\\n\\n//VTK::IOStructs::Dec\\n\\n@vertex\\nfn main(\\n//VTK::IOStructs::Input\\n)\\n//VTK::IOStructs::Output\\n{\\n  var output : vertexOutput;\\n\\n  var vertexVC: vec4<f32> = rendererUBO.SCVCMatrix * mapperUBO.BCSCMatrix * vec4<f32>(vertexBC.xyz, 1.0);\\n\\n  //VTK::Color::Impl\\n\\n  // compute the projected vertex position\\n  output.centerVC = vertexVC.xyz;\\n  output.radiusVC = length(offsetMC)*0.5;\\n\\n  // make the triangle face the camera\\n  if (rendererUBO.cameraParallel == 0u)\\n    {\\n    var dir: vec3<f32> = normalize(-vertexVC.xyz);\\n    var base2: vec3<f32> = normalize(cross(dir,vec3<f32>(1.0,0.0,0.0)));\\n    var base1: vec3<f32> = cross(base2,dir);\\n    dir = vertexVC.xyz + offsetMC.x*base1 + offsetMC.y*base2;\\n    vertexVC = vec4<f32>(dir, 1.0);\\n    }\\n  else\\n    {\\n    // add in the offset\\n    var tmp2: vec2<f32> = vertexVC.xy + offsetMC;\\n    vertexVC = vec4<f32>(tmp2, vertexVC.zw);\\n    }\\n\\n  output.vertexVC = vec4<f32>(vertexVC.xyz, 0.0);\\n\\n  //VTK::Position::Impl\\n\\n  return output;\\n}\\n\"; // ----------------------------------------------------------------------------\n// vtkWebGPUSphereMapper methods\n// ----------------------------------------------------------------------------\n\nfunction vtkWebGPUSphereMapper(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkWebGPUSphereMapper');\n  var cellMapperBuildPass = publicAPI.buildPass;\n\n  publicAPI.buildPass = function (prepass) {\n    if (prepass) {\n      if (!model.renderable.getStatic()) {\n        model.renderable.update();\n      }\n\n      var poly = model.renderable.getInputData();\n      publicAPI.setCellArray(poly.getVerts());\n      publicAPI.setCurrentInput(poly);\n    }\n\n    cellMapperBuildPass(prepass);\n  };\n\n  publicAPI.replaceShaderNormal = function (hash, pipeline, vertexInput) {\n    var vDesc = pipeline.getShaderDescription('vertex');\n    if (!vDesc.hasOutput('vertexVC')) vDesc.addOutput('vec4<f32>', 'vertexVC');\n    vDesc.addOutput('vec3<f32>', 'centerVC');\n    vDesc.addOutput('f32', 'radiusVC');\n    var fDesc = pipeline.getShaderDescription('fragment');\n    fDesc.addBuiltinOutput('f32', '@builtin(frag_depth) fragDepth');\n    var sphereFrag = \"\\n    // compute the eye position and unit direction\\n    var vertexVC: vec4<f32>;\\n    var EyePos: vec3<f32>;\\n    var EyeDir: vec3<f32>;\\n    var invertedDepth: f32 = 1.0;\\n    if (rendererUBO.cameraParallel != 0u) {\\n      EyePos = vec3<f32>(input.vertexVC.x, input.vertexVC.y, input.vertexVC.z + 3.0*input.radiusVC);\\n      EyeDir = vec3<f32>(0.0, 0.0, -1.0);\\n    }\\n    else {\\n      EyeDir = input.vertexVC.xyz;\\n      EyePos = vec3<f32>(0.0,0.0,0.0);\\n      var lengthED: f32 = length(EyeDir);\\n      EyeDir = normalize(EyeDir);\\n      // we adjust the EyePos to be closer if it is too far away\\n      // to prevent floating point precision noise\\n      if (lengthED > input.radiusVC*3.0) {\\n        EyePos = input.vertexVC.xyz - EyeDir*3.0*input.radiusVC;\\n      }\\n    }\\n\\n    // translate to Sphere center\\n    EyePos = EyePos - input.centerVC;\\n    // scale to radius 1.0\\n    EyePos = EyePos * (1.0 / input.radiusVC);\\n    // find the intersection\\n    var b: f32 = 2.0*dot(EyePos,EyeDir);\\n    var c: f32 = dot(EyePos,EyePos) - 1.0;\\n    var d: f32 = b*b - 4.0*c;\\n    var normal: vec3<f32> = vec3<f32>(0.0,0.0,1.0);\\n    if (d < 0.0) { discard; }\\n    else {\\n      var t: f32 = (-b - invertedDepth*sqrt(d))*0.5;\\n\\n      // compute the normal, for unit sphere this is just\\n      // the intersection point\\n      normal = invertedDepth*normalize(EyePos + t*EyeDir);\\n      // compute the intersection point in VC\\n      vertexVC = vec4<f32>(normal * input.radiusVC + input.centerVC, 1.0);\\n    }\\n    // compute the pixel's depth\\n    var pos: vec4<f32> = rendererUBO.VCPCMatrix * vertexVC;\\n    output.fragDepth = pos.z / pos.w;\\n    \";\n    var code = fDesc.getCode();\n    code = vtkWebGPUShaderCache.substitute(code, '//VTK::Normal::Impl', [sphereFrag]).result;\n    fDesc.setCode(code);\n  };\n\n  publicAPI.replaceShaderPosition = function (hash, pipeline, vertexInput) {\n    var vDesc = pipeline.getShaderDescription('vertex');\n    vDesc.addBuiltinOutput('vec4<f32>', '@builtin(position) Position');\n    var code = vDesc.getCode();\n    code = vtkWebGPUShaderCache.substitute(code, '//VTK::Position::Impl', ['  output.Position = rendererUBO.VCPCMatrix*vertexVC;']).result;\n    vDesc.setCode(code);\n  }; // compute a unique hash for a pipeline, this needs to be unique enough to\n  // capture any pipeline code changes (which includes shader changes)\n  // or vertex input changes/ bind groups/ etc\n\n\n  publicAPI.computePipelineHash = function () {\n    model.pipelineHash = 'spm';\n\n    if (model.vertexInput.hasAttribute(\"colorVI\")) {\n      model.pipelineHash += \"c\";\n    }\n\n    model.pipelineHash += model.renderEncoder.getPipelineHash();\n  };\n\n  publicAPI.updateBuffers = function () {\n    var poly = model.currentInput;\n    model.renderable.mapScalars(poly, 1.0);\n    var points = poly.getPoints();\n    var numPoints = points.getNumberOfPoints();\n    var pointArray = points.getData(); // default to one instance and computed number of verts\n\n    publicAPI.setNumberOfInstances(1);\n    publicAPI.setNumberOfVertices(3 * numPoints);\n    var vertexInput = model.vertexInput;\n    var hash = \"spm\".concat(points.getMTime(), \"float32x3\");\n\n    if (!model.device.getBufferManager().hasBuffer(hash)) {\n      var buffRequest = {\n        hash: hash,\n        usage: BufferUsage.RawVertex,\n        format: 'float32x3'\n      }; // xyz v1 v2 v3\n\n      var tmpVBO = new Float32Array(3 * numPoints * 3);\n      var pointIdx = 0;\n      var vboIdx = 0;\n\n      for (var id = 0; id < numPoints; ++id) {\n        pointIdx = id * 3;\n        tmpVBO[vboIdx++] = pointArray[pointIdx];\n        tmpVBO[vboIdx++] = pointArray[pointIdx + 1];\n        tmpVBO[vboIdx++] = pointArray[pointIdx + 2];\n        tmpVBO[vboIdx++] = pointArray[pointIdx];\n        tmpVBO[vboIdx++] = pointArray[pointIdx + 1];\n        tmpVBO[vboIdx++] = pointArray[pointIdx + 2];\n        tmpVBO[vboIdx++] = pointArray[pointIdx];\n        tmpVBO[vboIdx++] = pointArray[pointIdx + 1];\n        tmpVBO[vboIdx++] = pointArray[pointIdx + 2];\n      }\n\n      buffRequest.nativeArray = tmpVBO;\n      var buff = model.device.getBufferManager().getBuffer(buffRequest);\n      vertexInput.addBuffer(buff, ['vertexBC']);\n    } // compute offset VBO\n\n\n    var pointData = poly.getPointData();\n    var scales = null;\n\n    if (model.renderable.getScaleArray() != null && pointData.hasArray(model.renderable.getScaleArray())) {\n      scales = pointData.getArray(model.renderable.getScaleArray()).getData();\n    }\n\n    var defaultRadius = model.renderable.getRadius();\n\n    if (scales || defaultRadius !== model._lastRadius) {\n      hash = \"spm\".concat(scales ? pointData.getArray(model.renderable.getScaleArray()).getMTime() : defaultRadius, \"float32x2\");\n\n      if (!model.device.getBufferManager().hasBuffer(hash)) {\n        var _buffRequest = {\n          hash: hash,\n          usage: BufferUsage.RawVertex,\n          format: 'float32x2'\n        };\n\n        var _tmpVBO = new Float32Array(3 * numPoints * 2);\n\n        var cos30 = Math.cos(radiansFromDegrees(30.0));\n        var _vboIdx = 0;\n\n        for (var _id = 0; _id < numPoints; ++_id) {\n          var radius = model.renderable.getRadius();\n\n          if (scales) {\n            radius = scales[_id] * model.renderable.getScaleFactor();\n          }\n\n          _tmpVBO[_vboIdx++] = -2.0 * radius * cos30;\n          _tmpVBO[_vboIdx++] = -radius;\n          _tmpVBO[_vboIdx++] = 2.0 * radius * cos30;\n          _tmpVBO[_vboIdx++] = -radius;\n          _tmpVBO[_vboIdx++] = 0.0;\n          _tmpVBO[_vboIdx++] = 2.0 * radius;\n        }\n\n        _buffRequest.nativeArray = _tmpVBO;\n\n        var _buff = model.device.getBufferManager().getBuffer(_buffRequest);\n\n        vertexInput.addBuffer(_buff, ['offsetMC']);\n      }\n\n      model._lastRadius = defaultRadius;\n    } // deal with colors but only if modified\n\n\n    var haveColors = false;\n\n    if (model.renderable.getScalarVisibility()) {\n      var c = model.renderable.getColorMapColors();\n\n      if (c) {\n        hash = \"spm\".concat(c.getMTime(), \"unorm8x4\");\n\n        if (!model.device.getBufferManager().hasBuffer(hash)) {\n          var _buffRequest2 = {\n            hash: hash,\n            usage: BufferUsage.RawVertex,\n            format: 'unorm8x4'\n          };\n          var colorComponents = c.getNumberOfComponents();\n\n          if (colorComponents !== 4) {\n            vtkErrorMacro('this should be 4');\n          }\n\n          var _tmpVBO2 = new Uint8Array(3 * numPoints * 4);\n\n          var _vboIdx2 = 0;\n          var colorData = c.getData();\n\n          for (var _id2 = 0; _id2 < numPoints; ++_id2) {\n            var colorIdx = _id2 * colorComponents;\n\n            for (var v = 0; v < 3; v++) {\n              _tmpVBO2[_vboIdx2++] = colorData[colorIdx];\n              _tmpVBO2[_vboIdx2++] = colorData[colorIdx + 1];\n              _tmpVBO2[_vboIdx2++] = colorData[colorIdx + 2];\n              _tmpVBO2[_vboIdx2++] = colorData[colorIdx + 3];\n            }\n          }\n\n          _buffRequest2.nativeArray = _tmpVBO2;\n\n          var _buff2 = model.device.getBufferManager().getBuffer(_buffRequest2);\n\n          vertexInput.addBuffer(_buff2, ['colorVI']);\n        }\n\n        haveColors = true;\n      }\n    }\n\n    if (!haveColors) {\n      vertexInput.removeBufferIfPresent('colorVI');\n    }\n\n    publicAPI.setTopology('triangle-list');\n    publicAPI.updateUBO();\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\n\nvar DEFAULT_VALUES = {}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Inheritance\n\n  vtkWebGPUCellArrayMapper.extend(publicAPI, model, initialValues);\n  publicAPI.setVertexShaderTemplate(vtkWebGPUSphereMapperVS); // Object methods\n\n  vtkWebGPUSphereMapper(publicAPI, model);\n  var sr = model.shaderReplacements;\n  sr.set('replaceShaderPosition', publicAPI.replaceShaderPosition);\n  sr.set('replaceShaderNormal', publicAPI.replaceShaderNormal);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = newInstance$1(extend, 'vtkWebGPUSphereMapper'); // ----------------------------------------------------------------------------\n\nvar index = {\n  newInstance: newInstance,\n  extend: extend\n}; // Register ourself to WebGPU backend if imported\n\nregisterOverride('vtkSphereMapper', newInstance);\n\nexport { index as default, extend, newInstance };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}