{"ast":null,"code":"import { create } from 'xmlbuilder2';\nimport { zlibSync } from 'fflate';\nimport macro from '../../macros.js';\nimport { fromArrayBuffer } from '../../Common/Core/Base64.js';\nimport { FormatTypes, TYPED_ARRAY } from './XMLWriter/Constants.js';\n\n// Global methods\n// ----------------------------------------------------------------------------\n\nfunction compressBlock(uncompressed) {\n  return zlibSync(uncompressed);\n}\nfunction processDataArray(dataArray, format, blockSize) {\n  var compressor = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'vtkZLibDataCompressor';\n  if (format === FormatTypes.ASCII) {\n    return dataArray.getData().join(' ');\n  }\n  if (format === FormatTypes.BINARY) {\n    if (compressor === 'vtkZLibDataCompressor') {\n      // ----------------------------------------------------------------------\n      // Layout of the data\n      // header[N, s1, s1, blockSize1, ..., blockSizeN], [padding???], block[compressedData], ..., block[compressedData]\n      // [header] N, s1 and s2 are uint 32 or 64 (defined by header_type=\"UInt64\" attribute on the root node)\n      // [header] s1: uncompress size of each block except the last one\n      // [header] s2: uncompress size of the last blocks\n      // [header] blockSize: size of the block in compressed space that represent to bloc to inflate in zlib. (This also give the offset to the next block)\n      // ----------------------------------------------------------------------\n      var componentUint8Size = dataArray.getElementComponentSize();\n      var uncompressedUint8Size = dataArray.getNumberOfValues() * componentUint8Size;\n      var blockUint8Size = blockSize;\n      var nbFullBlocks = Math.trunc(uncompressedUint8Size / blockUint8Size);\n      var lastBlockUint8Size = uncompressedUint8Size % blockUint8Size;\n      var nbBlocks = nbFullBlocks + (lastBlockUint8Size ? 1 : 0);\n      var header = new Uint32Array(3 + nbBlocks);\n      header[0] = nbBlocks; // N\n\n      header[1] = blockUint8Size; // s1\n\n      header[2] = lastBlockUint8Size; // s2\n\n      var totalUint8Length = 0;\n      var blocks = [];\n      var dataOffset = 0;\n      var lastBlockId = nbBlocks - 1;\n      for (var blockId = 0; blockId < nbBlocks; ++blockId) {\n        var currentBlockUint8Size = lastBlockUint8Size === 0 || blockId < lastBlockId ? blockUint8Size : header[2];\n        var uncompressedBlock = new Uint8Array(dataArray.getData().buffer, dataOffset, currentBlockUint8Size);\n        dataOffset += blockUint8Size;\n        var compressedUint8Block = compressBlock(uncompressedBlock);\n        blocks.push(compressedUint8Block);\n        header[3 + blockId] = compressedUint8Block.length;\n        totalUint8Length += compressedUint8Block.length;\n      }\n      var uint8 = new Uint8Array(totalUint8Length);\n      var uint8Offset = 0;\n      var headerUint8 = new Uint8Array(header.buffer);\n      for (var _blockId = 0; _blockId < nbBlocks; ++_blockId) {\n        uint8.set(blocks[_blockId], uint8Offset);\n        uint8Offset += header[3 + _blockId];\n      }\n      return fromArrayBuffer(headerUint8.buffer) + fromArrayBuffer(uint8.buffer);\n    }\n    throw new Error('Only vtkZLibDataCompressor is supported');\n  }\n  if (format === FormatTypes.APPENDED) {\n    throw new Error('Appended format is not supported');\n  }\n  throw new Error('Format is not supported');\n} // ----------------------------------------------------------------------------\n// vtkXMLWriter methods\n// ----------------------------------------------------------------------------\n\nfunction vtkXMLWriter(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkXMLWriter'); // Can be overridden in subclass\n\n  publicAPI.create = function (dataObject) {\n    return create().ele('VTKFile').att('type', model.dataType).att('version', '0.1').att('byte_order', 'LittleEndian').att('header_type', 'UInt32').att('compressor', model.format === FormatTypes.ASCII ? '' : 'vtkZLibDataCompressor');\n  };\n  publicAPI.write = function (object) {\n    return publicAPI.create(object).end({\n      pretty: true\n    });\n  };\n  publicAPI.processDataSetAttributes = function (parentElement, name, datasetAttributes) {\n    var activeAttributes = {};\n    var attrTypes = ['Scalars', 'Vectors', 'Normals', 'TCoords', 'Tensors', 'GlobalIds', 'PedigreeIds'];\n    attrTypes.forEach(function (attrType) {\n      var activeAttribute = datasetAttributes.getActiveAttribute(attrType);\n      if (activeAttribute) {\n        activeAttributes[attrType] = activeAttribute.getName();\n      }\n    });\n    var datasetAttributesEle = parentElement.ele(name, activeAttributes);\n    for (var i = 0; i < datasetAttributes.getNumberOfArrays(); ++i) {\n      publicAPI.processDataArray(datasetAttributesEle, datasetAttributes.getArrayByIndex(i));\n    }\n    return datasetAttributesEle;\n  };\n  publicAPI.processDataArray = function (parentEle, scalars) {\n    return parentEle.ele('DataArray', {\n      type: TYPED_ARRAY[scalars.getDataType()],\n      Name: scalars.getName(),\n      format: publicAPI.getFormat(),\n      RangeMin: scalars.getRange()[0],\n      RangeMax: scalars.getRange()[1],\n      NumberOfComponents: scalars.getNumberOfComponents()\n    }).txt(processDataArray(scalars, publicAPI.getFormat(), publicAPI.getBlockSize()));\n  };\n  publicAPI.requestData = function (inData, outData) {\n    model.file = publicAPI.write(inData);\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nvar DEFAULT_VALUES = {\n  blockSize: 1024,\n  // file: null,\n  format: FormatTypes.BINARY\n}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Build VTK API\n\n  macro.obj(publicAPI, model);\n  macro.setGet(publicAPI, model, ['blockSize', 'format']);\n  macro.get(publicAPI, model, ['file']);\n  macro.algo(publicAPI, model, 1, 0); // vtkXMLWriter methods\n\n  vtkXMLWriter(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar vtkXMLWriter$1 = {\n  extend: extend,\n  compressBlock: compressBlock,\n  processDataArray: processDataArray,\n  FormatTypes: FormatTypes\n};\nexport { vtkXMLWriter$1 as default, extend };","map":{"version":3,"names":["create","zlibSync","macro","fromArrayBuffer","FormatTypes","TYPED_ARRAY","compressBlock","uncompressed","processDataArray","dataArray","format","blockSize","compressor","arguments","length","undefined","ASCII","getData","join","BINARY","componentUint8Size","getElementComponentSize","uncompressedUint8Size","getNumberOfValues","blockUint8Size","nbFullBlocks","Math","trunc","lastBlockUint8Size","nbBlocks","header","Uint32Array","totalUint8Length","blocks","dataOffset","lastBlockId","blockId","currentBlockUint8Size","uncompressedBlock","Uint8Array","buffer","compressedUint8Block","push","uint8","uint8Offset","headerUint8","_blockId","set","Error","APPENDED","vtkXMLWriter","publicAPI","model","classHierarchy","dataObject","ele","att","dataType","write","object","end","pretty","processDataSetAttributes","parentElement","name","datasetAttributes","activeAttributes","attrTypes","forEach","attrType","activeAttribute","getActiveAttribute","getName","datasetAttributesEle","i","getNumberOfArrays","getArrayByIndex","parentEle","scalars","type","getDataType","Name","getFormat","RangeMin","getRange","RangeMax","NumberOfComponents","getNumberOfComponents","txt","getBlockSize","requestData","inData","outData","file","DEFAULT_VALUES","extend","initialValues","Object","assign","obj","setGet","get","algo","vtkXMLWriter$1","default"],"sources":["/home/rakshith/Documents/RemoteRendering/vtk-js-react-app/node_modules/@kitware/vtk.js/IO/XML/XMLWriter.js"],"sourcesContent":["import { create } from 'xmlbuilder2';\nimport { zlibSync } from 'fflate';\nimport macro from '../../macros.js';\nimport { fromArrayBuffer } from '../../Common/Core/Base64.js';\nimport { FormatTypes, TYPED_ARRAY } from './XMLWriter/Constants.js';\n\n// Global methods\n// ----------------------------------------------------------------------------\n\nfunction compressBlock(uncompressed) {\n  return zlibSync(uncompressed);\n}\n\nfunction processDataArray(dataArray, format, blockSize) {\n  var compressor = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'vtkZLibDataCompressor';\n\n  if (format === FormatTypes.ASCII) {\n    return dataArray.getData().join(' ');\n  }\n\n  if (format === FormatTypes.BINARY) {\n    if (compressor === 'vtkZLibDataCompressor') {\n      // ----------------------------------------------------------------------\n      // Layout of the data\n      // header[N, s1, s1, blockSize1, ..., blockSizeN], [padding???], block[compressedData], ..., block[compressedData]\n      // [header] N, s1 and s2 are uint 32 or 64 (defined by header_type=\"UInt64\" attribute on the root node)\n      // [header] s1: uncompress size of each block except the last one\n      // [header] s2: uncompress size of the last blocks\n      // [header] blockSize: size of the block in compressed space that represent to bloc to inflate in zlib. (This also give the offset to the next block)\n      // ----------------------------------------------------------------------\n      var componentUint8Size = dataArray.getElementComponentSize();\n      var uncompressedUint8Size = dataArray.getNumberOfValues() * componentUint8Size;\n      var blockUint8Size = blockSize;\n      var nbFullBlocks = Math.trunc(uncompressedUint8Size / blockUint8Size);\n      var lastBlockUint8Size = uncompressedUint8Size % blockUint8Size;\n      var nbBlocks = nbFullBlocks + (lastBlockUint8Size ? 1 : 0);\n      var header = new Uint32Array(3 + nbBlocks);\n      header[0] = nbBlocks; // N\n\n      header[1] = blockUint8Size; // s1\n\n      header[2] = lastBlockUint8Size; // s2\n\n      var totalUint8Length = 0;\n      var blocks = [];\n      var dataOffset = 0;\n      var lastBlockId = nbBlocks - 1;\n\n      for (var blockId = 0; blockId < nbBlocks; ++blockId) {\n        var currentBlockUint8Size = lastBlockUint8Size === 0 || blockId < lastBlockId ? blockUint8Size : header[2];\n        var uncompressedBlock = new Uint8Array(dataArray.getData().buffer, dataOffset, currentBlockUint8Size);\n        dataOffset += blockUint8Size;\n        var compressedUint8Block = compressBlock(uncompressedBlock);\n        blocks.push(compressedUint8Block);\n        header[3 + blockId] = compressedUint8Block.length;\n        totalUint8Length += compressedUint8Block.length;\n      }\n\n      var uint8 = new Uint8Array(totalUint8Length);\n      var uint8Offset = 0;\n      var headerUint8 = new Uint8Array(header.buffer);\n\n      for (var _blockId = 0; _blockId < nbBlocks; ++_blockId) {\n        uint8.set(blocks[_blockId], uint8Offset);\n        uint8Offset += header[3 + _blockId];\n      }\n\n      return fromArrayBuffer(headerUint8.buffer) + fromArrayBuffer(uint8.buffer);\n    }\n\n    throw new Error('Only vtkZLibDataCompressor is supported');\n  }\n\n  if (format === FormatTypes.APPENDED) {\n    throw new Error('Appended format is not supported');\n  }\n\n  throw new Error('Format is not supported');\n} // ----------------------------------------------------------------------------\n// vtkXMLWriter methods\n// ----------------------------------------------------------------------------\n\n\nfunction vtkXMLWriter(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkXMLWriter'); // Can be overridden in subclass\n\n  publicAPI.create = function (dataObject) {\n    return create().ele('VTKFile').att('type', model.dataType).att('version', '0.1').att('byte_order', 'LittleEndian').att('header_type', 'UInt32').att('compressor', model.format === FormatTypes.ASCII ? '' : 'vtkZLibDataCompressor');\n  };\n\n  publicAPI.write = function (object) {\n    return publicAPI.create(object).end({\n      pretty: true\n    });\n  };\n\n  publicAPI.processDataSetAttributes = function (parentElement, name, datasetAttributes) {\n    var activeAttributes = {};\n    var attrTypes = ['Scalars', 'Vectors', 'Normals', 'TCoords', 'Tensors', 'GlobalIds', 'PedigreeIds'];\n    attrTypes.forEach(function (attrType) {\n      var activeAttribute = datasetAttributes.getActiveAttribute(attrType);\n\n      if (activeAttribute) {\n        activeAttributes[attrType] = activeAttribute.getName();\n      }\n    });\n    var datasetAttributesEle = parentElement.ele(name, activeAttributes);\n\n    for (var i = 0; i < datasetAttributes.getNumberOfArrays(); ++i) {\n      publicAPI.processDataArray(datasetAttributesEle, datasetAttributes.getArrayByIndex(i));\n    }\n\n    return datasetAttributesEle;\n  };\n\n  publicAPI.processDataArray = function (parentEle, scalars) {\n    return parentEle.ele('DataArray', {\n      type: TYPED_ARRAY[scalars.getDataType()],\n      Name: scalars.getName(),\n      format: publicAPI.getFormat(),\n      RangeMin: scalars.getRange()[0],\n      RangeMax: scalars.getRange()[1],\n      NumberOfComponents: scalars.getNumberOfComponents()\n    }).txt(processDataArray(scalars, publicAPI.getFormat(), publicAPI.getBlockSize()));\n  };\n\n  publicAPI.requestData = function (inData, outData) {\n    model.file = publicAPI.write(inData);\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\n\nvar DEFAULT_VALUES = {\n  blockSize: 1024,\n  // file: null,\n  format: FormatTypes.BINARY\n}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Build VTK API\n\n  macro.obj(publicAPI, model);\n  macro.setGet(publicAPI, model, ['blockSize', 'format']);\n  macro.get(publicAPI, model, ['file']);\n  macro.algo(publicAPI, model, 1, 0); // vtkXMLWriter methods\n\n  vtkXMLWriter(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar vtkXMLWriter$1 = {\n  extend: extend,\n  compressBlock: compressBlock,\n  processDataArray: processDataArray,\n  FormatTypes: FormatTypes\n};\n\nexport { vtkXMLWriter$1 as default, extend };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}