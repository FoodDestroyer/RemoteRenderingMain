{"ast":null,"code":"import _toConsumableArray from '@babel/runtime/helpers/toConsumableArray';\nimport { mat4 } from 'gl-matrix';\nimport macro from '../../macros.js';\nimport vtkBoundingBox from '../../Common/DataModel/BoundingBox.js';\nimport vtkProp3D from './Prop3D.js';\nimport vtkImageProperty from './ImageProperty.js';\nvar vtkDebugMacro = macro.vtkDebugMacro; // ----------------------------------------------------------------------------\n// vtkImageSlice methods\n// ----------------------------------------------------------------------------\n\nfunction vtkImageSlice(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkImageSlice');\n  publicAPI.getActors = function () {\n    return publicAPI;\n  };\n  publicAPI.getImages = function () {\n    return publicAPI;\n  };\n  publicAPI.getIsOpaque = function () {\n    if (model.forceOpaque) {\n      return true;\n    }\n    if (model.forceTranslucent) {\n      return false;\n    } // make sure we have a property\n\n    if (!model.property) {\n      // force creation of a property\n      publicAPI.getProperty();\n    }\n    var isOpaque = model.property.getOpacity() >= 1.0; // are we using an opaque scalar array, if any?\n\n    isOpaque = isOpaque && (!model.mapper || model.mapper.getIsOpaque());\n    return isOpaque;\n  }; // Always render during opaque pass, to keep the behavior\n  // predictable and because depth-peeling kills alpha-blending.\n  // In the future, the Renderer should render images in layers,\n  // i.e. where each image will have a layer number assigned to it,\n  // and the Renderer will do the images in their own pass.\n\n  publicAPI.hasTranslucentPolygonalGeometry = function () {\n    return false;\n  };\n  publicAPI.makeProperty = vtkImageProperty.newInstance;\n  publicAPI.getProperty = function () {\n    if (model.property === null) {\n      model.property = publicAPI.makeProperty();\n    }\n    return model.property;\n  };\n  publicAPI.getBounds = function () {\n    if (model.mapper === null) {\n      return model.bounds;\n    } // Check for the special case when the mapper's bounds are unknown\n\n    var bds = model.mapper.getBounds();\n    if (!bds || bds.length !== 6) {\n      return bds;\n    } // Check for the special case when the actor is empty.\n\n    if (bds[0] > bds[1]) {\n      model.mapperBounds = bds.concat(); // copy the mapper's bounds\n\n      model.bounds = [1, -1, 1, -1, 1, -1];\n      model.boundsMTime.modified();\n      return bds;\n    } // Check if we have cached values for these bounds - we cache the\n    // values returned by model.mapper.getBounds() and we store the time\n    // of caching. If the values returned this time are different, or\n    // the modified time of this class is newer than the cached time,\n    // then we need to rebuild.\n\n    var zip = function zip(rows) {\n      return rows[0].map(function (_, c) {\n        return rows.map(function (row) {\n          return row[c];\n        });\n      });\n    };\n    if (!model.mapperBounds || !zip([bds, model.mapperBounds]).reduce(function (a, b) {\n      return a && b[0] === b[1];\n    }, true) || publicAPI.getMTime() > model.boundsMTime.getMTime()) {\n      vtkDebugMacro('Recomputing bounds...');\n      model.mapperBounds = bds.map(function (x) {\n        return x;\n      });\n      publicAPI.computeMatrix();\n      var tmp4 = new Float64Array(16);\n      mat4.transpose(tmp4, model.matrix);\n      vtkBoundingBox.transformBounds(bds, tmp4, model.bounds);\n      model.boundsMTime.modified();\n    }\n    return model.bounds;\n  };\n  publicAPI.getBoundsForSlice = function (slice, thickness) {\n    // Check for the special case when the mapper's bounds are unknown\n    var bds = model.mapper.getBoundsForSlice(slice, thickness); // Check for the special case when the actor is empty.\n\n    if (!vtkBoundingBox.isValid(bds)) {\n      return bds;\n    }\n    publicAPI.computeMatrix();\n    var tmp4 = new Float64Array(16);\n    mat4.transpose(tmp4, model.matrix);\n    var newBounds = vtkBoundingBox.transformBounds(bds, tmp4);\n    return newBounds;\n  }; //----------------------------------------------------------------------------\n  // Get the minimum X bound\n\n  publicAPI.getMinXBound = function () {\n    return publicAPI.getBounds()[0];\n  }; // Get the maximum X bound\n\n  publicAPI.getMaxXBound = function () {\n    return publicAPI.getBounds()[1];\n  }; // Get the minimum Y bound\n\n  publicAPI.getMinYBound = function () {\n    return publicAPI.getBounds()[2];\n  }; // Get the maximum Y bound\n\n  publicAPI.getMaxYBound = function () {\n    return publicAPI.getBounds()[3];\n  }; // Get the minimum Z bound\n\n  publicAPI.getMinZBound = function () {\n    return publicAPI.getBounds()[4];\n  }; // Get the maximum Z bound\n\n  publicAPI.getMaxZBound = function () {\n    return publicAPI.getBounds()[5];\n  };\n  publicAPI.getMTime = function () {\n    var mt = model.mtime;\n    if (model.property !== null) {\n      var time = model.property.getMTime();\n      mt = time > mt ? time : mt;\n    }\n    return mt;\n  };\n  publicAPI.getRedrawMTime = function () {\n    var mt = model.mtime;\n    if (model.mapper !== null) {\n      var time = model.mapper.getMTime();\n      mt = time > mt ? time : mt;\n      if (model.mapper.getInput() !== null) {\n        // FIXME !!! getInputAlgorithm / getInput\n        model.mapper.getInputAlgorithm().update();\n        time = model.mapper.getInput().getMTime();\n        mt = time > mt ? time : mt;\n      }\n    }\n    if (model.property !== null) {\n      var _time = model.property.getMTime();\n      mt = _time > mt ? _time : mt;\n      if (model.property.getRGBTransferFunction() !== null) {\n        _time = model.property.getRGBTransferFunction().getMTime();\n        mt = _time > mt ? _time : mt;\n      }\n    }\n    return mt;\n  };\n  publicAPI.getSupportsSelection = function () {\n    return model.mapper ? model.mapper.getSupportsSelection() : false;\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nvar DEFAULT_VALUES = {\n  mapper: null,\n  property: null,\n  bounds: _toConsumableArray(vtkBoundingBox.INIT_BOUNDS)\n}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Inheritance\n\n  vtkProp3D.extend(publicAPI, model, initialValues); // vtkTimeStamp\n\n  model.boundsMTime = {};\n  macro.obj(model.boundsMTime); // Build VTK API\n\n  macro.set(publicAPI, model, ['property']);\n  macro.setGet(publicAPI, model, ['mapper']);\n  macro.getArray(publicAPI, model, ['bounds'], 6); // Object methods\n\n  vtkImageSlice(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = macro.newInstance(extend, 'vtkImageSlice'); // ----------------------------------------------------------------------------\n\nvar vtkImageSlice$1 = {\n  newInstance: newInstance,\n  extend: extend\n};\nexport { vtkImageSlice$1 as default, extend, newInstance };","map":{"version":3,"names":["_toConsumableArray","mat4","macro","vtkBoundingBox","vtkProp3D","vtkImageProperty","vtkDebugMacro","vtkImageSlice","publicAPI","model","classHierarchy","push","getActors","getImages","getIsOpaque","forceOpaque","forceTranslucent","property","getProperty","isOpaque","getOpacity","mapper","hasTranslucentPolygonalGeometry","makeProperty","newInstance","getBounds","bounds","bds","length","mapperBounds","concat","boundsMTime","modified","zip","rows","map","_","c","row","reduce","a","b","getMTime","x","computeMatrix","tmp4","Float64Array","transpose","matrix","transformBounds","getBoundsForSlice","slice","thickness","isValid","newBounds","getMinXBound","getMaxXBound","getMinYBound","getMaxYBound","getMinZBound","getMaxZBound","mt","mtime","time","getRedrawMTime","getInput","getInputAlgorithm","update","_time","getRGBTransferFunction","getSupportsSelection","DEFAULT_VALUES","INIT_BOUNDS","extend","initialValues","arguments","undefined","Object","assign","obj","set","setGet","getArray","vtkImageSlice$1","default"],"sources":["/home/rakshith/Documents/RemoteRendering/vtk-js-react-app/node_modules/@kitware/vtk.js/Rendering/Core/ImageSlice.js"],"sourcesContent":["import _toConsumableArray from '@babel/runtime/helpers/toConsumableArray';\nimport { mat4 } from 'gl-matrix';\nimport macro from '../../macros.js';\nimport vtkBoundingBox from '../../Common/DataModel/BoundingBox.js';\nimport vtkProp3D from './Prop3D.js';\nimport vtkImageProperty from './ImageProperty.js';\n\nvar vtkDebugMacro = macro.vtkDebugMacro; // ----------------------------------------------------------------------------\n// vtkImageSlice methods\n// ----------------------------------------------------------------------------\n\nfunction vtkImageSlice(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkImageSlice');\n\n  publicAPI.getActors = function () {\n    return publicAPI;\n  };\n\n  publicAPI.getImages = function () {\n    return publicAPI;\n  };\n\n  publicAPI.getIsOpaque = function () {\n    if (model.forceOpaque) {\n      return true;\n    }\n\n    if (model.forceTranslucent) {\n      return false;\n    } // make sure we have a property\n\n\n    if (!model.property) {\n      // force creation of a property\n      publicAPI.getProperty();\n    }\n\n    var isOpaque = model.property.getOpacity() >= 1.0; // are we using an opaque scalar array, if any?\n\n    isOpaque = isOpaque && (!model.mapper || model.mapper.getIsOpaque());\n    return isOpaque;\n  }; // Always render during opaque pass, to keep the behavior\n  // predictable and because depth-peeling kills alpha-blending.\n  // In the future, the Renderer should render images in layers,\n  // i.e. where each image will have a layer number assigned to it,\n  // and the Renderer will do the images in their own pass.\n\n\n  publicAPI.hasTranslucentPolygonalGeometry = function () {\n    return false;\n  };\n\n  publicAPI.makeProperty = vtkImageProperty.newInstance;\n\n  publicAPI.getProperty = function () {\n    if (model.property === null) {\n      model.property = publicAPI.makeProperty();\n    }\n\n    return model.property;\n  };\n\n  publicAPI.getBounds = function () {\n    if (model.mapper === null) {\n      return model.bounds;\n    } // Check for the special case when the mapper's bounds are unknown\n\n\n    var bds = model.mapper.getBounds();\n\n    if (!bds || bds.length !== 6) {\n      return bds;\n    } // Check for the special case when the actor is empty.\n\n\n    if (bds[0] > bds[1]) {\n      model.mapperBounds = bds.concat(); // copy the mapper's bounds\n\n      model.bounds = [1, -1, 1, -1, 1, -1];\n      model.boundsMTime.modified();\n      return bds;\n    } // Check if we have cached values for these bounds - we cache the\n    // values returned by model.mapper.getBounds() and we store the time\n    // of caching. If the values returned this time are different, or\n    // the modified time of this class is newer than the cached time,\n    // then we need to rebuild.\n\n\n    var zip = function zip(rows) {\n      return rows[0].map(function (_, c) {\n        return rows.map(function (row) {\n          return row[c];\n        });\n      });\n    };\n\n    if (!model.mapperBounds || !zip([bds, model.mapperBounds]).reduce(function (a, b) {\n      return a && b[0] === b[1];\n    }, true) || publicAPI.getMTime() > model.boundsMTime.getMTime()) {\n      vtkDebugMacro('Recomputing bounds...');\n      model.mapperBounds = bds.map(function (x) {\n        return x;\n      });\n      publicAPI.computeMatrix();\n      var tmp4 = new Float64Array(16);\n      mat4.transpose(tmp4, model.matrix);\n      vtkBoundingBox.transformBounds(bds, tmp4, model.bounds);\n      model.boundsMTime.modified();\n    }\n\n    return model.bounds;\n  };\n\n  publicAPI.getBoundsForSlice = function (slice, thickness) {\n    // Check for the special case when the mapper's bounds are unknown\n    var bds = model.mapper.getBoundsForSlice(slice, thickness); // Check for the special case when the actor is empty.\n\n    if (!vtkBoundingBox.isValid(bds)) {\n      return bds;\n    }\n\n    publicAPI.computeMatrix();\n    var tmp4 = new Float64Array(16);\n    mat4.transpose(tmp4, model.matrix);\n    var newBounds = vtkBoundingBox.transformBounds(bds, tmp4);\n    return newBounds;\n  }; //----------------------------------------------------------------------------\n  // Get the minimum X bound\n\n\n  publicAPI.getMinXBound = function () {\n    return publicAPI.getBounds()[0];\n  }; // Get the maximum X bound\n\n\n  publicAPI.getMaxXBound = function () {\n    return publicAPI.getBounds()[1];\n  }; // Get the minimum Y bound\n\n\n  publicAPI.getMinYBound = function () {\n    return publicAPI.getBounds()[2];\n  }; // Get the maximum Y bound\n\n\n  publicAPI.getMaxYBound = function () {\n    return publicAPI.getBounds()[3];\n  }; // Get the minimum Z bound\n\n\n  publicAPI.getMinZBound = function () {\n    return publicAPI.getBounds()[4];\n  }; // Get the maximum Z bound\n\n\n  publicAPI.getMaxZBound = function () {\n    return publicAPI.getBounds()[5];\n  };\n\n  publicAPI.getMTime = function () {\n    var mt = model.mtime;\n\n    if (model.property !== null) {\n      var time = model.property.getMTime();\n      mt = time > mt ? time : mt;\n    }\n\n    return mt;\n  };\n\n  publicAPI.getRedrawMTime = function () {\n    var mt = model.mtime;\n\n    if (model.mapper !== null) {\n      var time = model.mapper.getMTime();\n      mt = time > mt ? time : mt;\n\n      if (model.mapper.getInput() !== null) {\n        // FIXME !!! getInputAlgorithm / getInput\n        model.mapper.getInputAlgorithm().update();\n        time = model.mapper.getInput().getMTime();\n        mt = time > mt ? time : mt;\n      }\n    }\n\n    if (model.property !== null) {\n      var _time = model.property.getMTime();\n\n      mt = _time > mt ? _time : mt;\n\n      if (model.property.getRGBTransferFunction() !== null) {\n        _time = model.property.getRGBTransferFunction().getMTime();\n        mt = _time > mt ? _time : mt;\n      }\n    }\n\n    return mt;\n  };\n\n  publicAPI.getSupportsSelection = function () {\n    return model.mapper ? model.mapper.getSupportsSelection() : false;\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\n\nvar DEFAULT_VALUES = {\n  mapper: null,\n  property: null,\n  bounds: _toConsumableArray(vtkBoundingBox.INIT_BOUNDS)\n}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Inheritance\n\n  vtkProp3D.extend(publicAPI, model, initialValues); // vtkTimeStamp\n\n  model.boundsMTime = {};\n  macro.obj(model.boundsMTime); // Build VTK API\n\n  macro.set(publicAPI, model, ['property']);\n  macro.setGet(publicAPI, model, ['mapper']);\n  macro.getArray(publicAPI, model, ['bounds'], 6); // Object methods\n\n  vtkImageSlice(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = macro.newInstance(extend, 'vtkImageSlice'); // ----------------------------------------------------------------------------\n\nvar vtkImageSlice$1 = {\n  newInstance: newInstance,\n  extend: extend\n};\n\nexport { vtkImageSlice$1 as default, extend, newInstance };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}