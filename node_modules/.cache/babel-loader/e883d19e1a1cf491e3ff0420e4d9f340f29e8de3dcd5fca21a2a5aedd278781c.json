{"ast":null,"code":"import _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport { mat4 } from 'gl-matrix';\nimport { ObjectType } from './BufferObject/Constants.js';\nimport { newInstance as newInstance$1, vtkErrorMacro as vtkErrorMacro$1 } from '../../macros.js';\nimport vtkBufferObject from './BufferObject.js';\nimport { r as radiansFromDegrees } from '../../Common/Core/Math/index.js';\nimport vtkShaderProgram from './ShaderProgram.js';\nimport vtkOpenGLPolyDataMapper from './PolyDataMapper.js';\nimport { v as vtkSphereMapperVS } from './glsl/vtkSphereMapperVS.glsl.js';\nimport { v as vtkPolyDataFS } from './glsl/vtkPolyDataFS.glsl.js';\nimport { registerOverride } from './ViewNodeFactory.js';\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n  return target;\n}\nvar vtkErrorMacro = vtkErrorMacro$1; // ----------------------------------------------------------------------------\n// vtkOpenGLSphereMapper methods\n// ----------------------------------------------------------------------------\n\nfunction vtkOpenGLSphereMapper(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkOpenGLSphereMapper'); // Capture 'parentClass' api for internal use\n\n  var superClass = _objectSpread({}, publicAPI);\n  publicAPI.getShaderTemplate = function (shaders, ren, actor) {\n    shaders.Vertex = vtkSphereMapperVS;\n    shaders.Fragment = vtkPolyDataFS;\n    shaders.Geometry = '';\n  };\n  publicAPI.replaceShaderValues = function (shaders, ren, actor) {\n    var VSSource = shaders.Vertex;\n    var FSSource = shaders.Fragment;\n    VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::Camera::Dec', ['uniform mat4 VCPCMatrix;\\n', 'uniform mat4 MCVCMatrix;']).result;\n    FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::PositionVC::Dec', ['varying vec4 vertexVCVSOutput;']).result; // we create vertexVC below, so turn off the default\n    // implementation\n\n    FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::PositionVC::Impl', ['vec4 vertexVC = vertexVCVSOutput;\\n']).result; // for lights kit and positional the VCPC matrix is already defined\n    // so don't redefine it\n\n    var replacement = ['uniform float invertedDepth;\\n', 'uniform int cameraParallel;\\n', 'varying float radiusVCVSOutput;\\n', 'varying vec3 centerVCVSOutput;\\n', 'uniform mat4 VCPCMatrix;\\n'];\n    FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Normal::Dec', replacement).result;\n    var fragString = '';\n    if (model.context.getExtension('EXT_frag_depth')) {\n      fragString = 'gl_FragDepthEXT = (pos.z / pos.w + 1.0) / 2.0;\\n';\n    }\n    if (model._openGLRenderWindow.getWebgl2()) {\n      fragString = 'gl_FragDepth = (pos.z / pos.w + 1.0) / 2.0;\\n';\n    }\n    FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Depth::Impl', [\n    // compute the eye position and unit direction\n    '  vec3 EyePos;\\n', '  vec3 EyeDir;\\n', '  if (cameraParallel != 0) {\\n', '    EyePos = vec3(vertexVC.x, vertexVC.y, vertexVC.z + 3.0*radiusVCVSOutput);\\n', '    EyeDir = vec3(0.0,0.0,-1.0); }\\n', '  else {\\n', '    EyeDir = vertexVC.xyz;\\n', '    EyePos = vec3(0.0,0.0,0.0);\\n', '    float lengthED = length(EyeDir);\\n', '    EyeDir = normalize(EyeDir);\\n',\n    // we adjust the EyePos to be closer if it is too far away\n    // to prevent floating point precision noise\n    '    if (lengthED > radiusVCVSOutput*3.0) {\\n', '      EyePos = vertexVC.xyz - EyeDir*3.0*radiusVCVSOutput; }\\n', '    }\\n',\n    // translate to Sphere center\n    '  EyePos = EyePos - centerVCVSOutput;\\n',\n    // scale to radius 1.0\n    '  EyePos = EyePos/radiusVCVSOutput;\\n',\n    // find the intersection\n    '  float b = 2.0*dot(EyePos,EyeDir);\\n', '  float c = dot(EyePos,EyePos) - 1.0;\\n', '  float d = b*b - 4.0*c;\\n', '  vec3 normalVCVSOutput = vec3(0.0,0.0,1.0);\\n', '  if (d < 0.0) { discard; }\\n', '  else {\\n', '    float t = (-b - invertedDepth*sqrt(d))*0.5;\\n',\n    // compute the normal, for unit sphere this is just\n    // the intersection point\n    '    normalVCVSOutput = invertedDepth*normalize(EyePos + t*EyeDir);\\n',\n    // compute the intersection point in VC\n    '    vertexVC.xyz = normalVCVSOutput*radiusVCVSOutput + centerVCVSOutput;\\n', '    }\\n',\n    // compute the pixel's depth\n    // ' normalVCVSOutput = vec3(0,0,1);\\n'\n    '  vec4 pos = VCPCMatrix * vertexVC;\\n', fragString]).result; // Strip out the normal line -- the normal is computed as part of the depth\n\n    FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Normal::Impl', '').result;\n    if (model.haveSeenDepthRequest) {\n      // special depth impl\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::ZBuffer::Impl', ['if (depthRequest == 1) {', 'float computedZ = (pos.z / pos.w + 1.0) / 2.0;', 'float iz = floor(computedZ * 65535.0 + 0.1);', 'float rf = floor(iz/256.0)/255.0;', 'float gf = mod(iz,256.0)/255.0;', 'gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }']).result;\n    }\n    shaders.Vertex = VSSource;\n    shaders.Fragment = FSSource;\n    superClass.replaceShaderValues(shaders, ren, actor);\n  };\n  publicAPI.setMapperShaderParameters = function (cellBO, ren, actor) {\n    if (cellBO.getCABO().getElementCount() && (model.VBOBuildTime > cellBO.getAttributeUpdateTime().getMTime() || cellBO.getShaderSourceTime().getMTime() > cellBO.getAttributeUpdateTime().getMTime()) && cellBO.getProgram().isAttributeUsed('offsetMC')) {\n      if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO(), 'offsetMC', 12,\n      // 12:this->VBO->ColorOffset+sizeof(float)\n      cellBO.getCABO().getStride(), model.context.FLOAT, 2, false)) {\n        vtkErrorMacro(\"Error setting 'offsetMC' in shader VAO.\");\n      }\n    }\n    if (cellBO.getProgram().isUniformUsed('invertedDepth')) {\n      cellBO.getProgram().setUniformf('invertedDepth', model.invert ? -1.0 : 1.0);\n    }\n    if (cellBO.getProgram().isUniformUsed('scaleFactor')) {\n      // apply scaling factor only if a scale array has been provided.\n      var poly = model.currentInput;\n      var pointData = poly.getPointData();\n      if (model.renderable.getScaleArray() != null && pointData.hasArray(model.renderable.getScaleArray())) {\n        cellBO.getProgram().setUniformf('scaleFactor', model.renderable.getScaleFactor());\n      } else {\n        cellBO.getProgram().setUniformf('scaleFactor', 1.0);\n      }\n    }\n    superClass.setMapperShaderParameters(cellBO, ren, actor);\n  };\n  publicAPI.setCameraShaderParameters = function (cellBO, ren, actor) {\n    var program = cellBO.getProgram();\n    var cam = ren.getActiveCamera();\n    var keyMats = model.openGLCamera.getKeyMatrices(ren);\n    if (program.isUniformUsed('VCPCMatrix')) {\n      program.setUniformMatrix('VCPCMatrix', keyMats.vcpc);\n    }\n    if (program.isUniformUsed('MCVCMatrix')) {\n      if (!actor.getIsIdentity()) {\n        var actMats = model.openGLActor.getKeyMatrices();\n        var tmp4 = new Float64Array(16);\n        mat4.multiply(tmp4, keyMats.wcvc, actMats.mcwc);\n        program.setUniformMatrix('MCVCMatrix', tmp4);\n      } else {\n        program.setUniformMatrix('MCVCMatrix', keyMats.wcvc);\n      }\n    }\n    if (program.isUniformUsed('cameraParallel')) {\n      cellBO.getProgram().setUniformi('cameraParallel', cam.getParallelProjection());\n    }\n  };\n  publicAPI.getOpenGLMode = function (rep, type) {\n    return model.context.TRIANGLES;\n  };\n  publicAPI.buildBufferObjects = function (ren, actor) {\n    var poly = model.currentInput;\n    if (poly === null) {\n      return;\n    }\n    model.renderable.mapScalars(poly, 1.0);\n    var c = model.renderable.getColorMapColors();\n    var vbo = model.primitives[model.primTypes.Tris].getCABO();\n    var pointData = poly.getPointData();\n    var points = poly.getPoints();\n    var numPoints = points.getNumberOfPoints();\n    var pointArray = points.getData();\n    var pointSize = 5; // x,y,z,orientation1,orientation2\n\n    var scales = null;\n    if (model.renderable.getScaleArray() != null && pointData.hasArray(model.renderable.getScaleArray())) {\n      scales = pointData.getArray(model.renderable.getScaleArray()).getData();\n    }\n    var colorData = null;\n    var colorComponents = 0;\n    var packedUCVBO = null;\n    if (c) {\n      colorComponents = c.getNumberOfComponents();\n      vbo.setColorOffset(0);\n      vbo.setColorBOStride(4);\n      colorData = c.getData();\n      packedUCVBO = new Uint8Array(3 * numPoints * 4);\n      if (!vbo.getColorBO()) {\n        vbo.setColorBO(vtkBufferObject.newInstance());\n      }\n      vbo.getColorBO().setOpenGLRenderWindow(model._openGLRenderWindow);\n    } else if (vbo.getColorBO()) {\n      vbo.setColorBO(null);\n    }\n    vbo.setColorComponents(colorComponents);\n    var packedVBO = new Float32Array(pointSize * numPoints * 3);\n    vbo.setStride(pointSize * 4);\n    var cos30 = Math.cos(radiansFromDegrees(30.0));\n    var pointIdx = 0;\n    var colorIdx = 0; //\n    // Generate points and point data for sides\n    //\n\n    var vboIdx = 0;\n    var ucIdx = 0;\n    for (var i = 0; i < numPoints; ++i) {\n      var radius = model.renderable.getRadius();\n      if (scales) {\n        radius = scales[i];\n      }\n      pointIdx = i * 3;\n      packedVBO[vboIdx++] = pointArray[pointIdx++];\n      packedVBO[vboIdx++] = pointArray[pointIdx++];\n      packedVBO[vboIdx++] = pointArray[pointIdx++];\n      packedVBO[vboIdx++] = -2.0 * radius * cos30;\n      packedVBO[vboIdx++] = -radius;\n      if (colorData) {\n        colorIdx = i * colorComponents;\n        packedUCVBO[ucIdx++] = colorData[colorIdx];\n        packedUCVBO[ucIdx++] = colorData[colorIdx + 1];\n        packedUCVBO[ucIdx++] = colorData[colorIdx + 2];\n        packedUCVBO[ucIdx++] = colorData[colorIdx + 3];\n      }\n      pointIdx = i * 3;\n      packedVBO[vboIdx++] = pointArray[pointIdx++];\n      packedVBO[vboIdx++] = pointArray[pointIdx++];\n      packedVBO[vboIdx++] = pointArray[pointIdx++];\n      packedVBO[vboIdx++] = 2.0 * radius * cos30;\n      packedVBO[vboIdx++] = -radius;\n      if (colorData) {\n        packedUCVBO[ucIdx++] = colorData[colorIdx];\n        packedUCVBO[ucIdx++] = colorData[colorIdx + 1];\n        packedUCVBO[ucIdx++] = colorData[colorIdx + 2];\n        packedUCVBO[ucIdx++] = colorData[colorIdx + 3];\n      }\n      pointIdx = i * 3;\n      packedVBO[vboIdx++] = pointArray[pointIdx++];\n      packedVBO[vboIdx++] = pointArray[pointIdx++];\n      packedVBO[vboIdx++] = pointArray[pointIdx++];\n      packedVBO[vboIdx++] = 0.0;\n      packedVBO[vboIdx++] = 2.0 * radius;\n      if (colorData) {\n        packedUCVBO[ucIdx++] = colorData[colorIdx];\n        packedUCVBO[ucIdx++] = colorData[colorIdx + 1];\n        packedUCVBO[ucIdx++] = colorData[colorIdx + 2];\n        packedUCVBO[ucIdx++] = colorData[colorIdx + 3];\n      }\n    }\n    vbo.setElementCount(vboIdx / pointSize);\n    vbo.upload(packedVBO, ObjectType.ARRAY_BUFFER);\n    if (c) {\n      vbo.getColorBO().upload(packedUCVBO, ObjectType.ARRAY_BUFFER);\n    }\n    model.VBOBuildTime.modified();\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nvar DEFAULT_VALUES = {}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Inheritance\n\n  vtkOpenGLPolyDataMapper.extend(publicAPI, model, initialValues); // Object methods\n\n  vtkOpenGLSphereMapper(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = newInstance$1(extend, 'vtkOpenGLSphereMapper'); // ----------------------------------------------------------------------------\n\nvar vtkSphereMapper = {\n  newInstance: newInstance,\n  extend: extend\n}; // Register ourself to OpenGL backend if imported\n\nregisterOverride('vtkSphereMapper', newInstance);\nexport { vtkSphereMapper as default, extend, newInstance };","map":{"version":3,"names":["_defineProperty","mat4","ObjectType","newInstance","newInstance$1","vtkErrorMacro","vtkErrorMacro$1","vtkBufferObject","r","radiansFromDegrees","vtkShaderProgram","vtkOpenGLPolyDataMapper","v","vtkSphereMapperVS","vtkPolyDataFS","registerOverride","ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","getOwnPropertyDescriptors","defineProperties","defineProperty","vtkOpenGLSphereMapper","publicAPI","model","classHierarchy","superClass","getShaderTemplate","shaders","ren","actor","Vertex","Fragment","Geometry","replaceShaderValues","VSSource","FSSource","substitute","result","replacement","fragString","context","getExtension","_openGLRenderWindow","getWebgl2","haveSeenDepthRequest","setMapperShaderParameters","cellBO","getCABO","getElementCount","VBOBuildTime","getAttributeUpdateTime","getMTime","getShaderSourceTime","getProgram","isAttributeUsed","getVAO","addAttributeArray","getStride","FLOAT","isUniformUsed","setUniformf","invert","poly","currentInput","pointData","getPointData","renderable","getScaleArray","hasArray","getScaleFactor","setCameraShaderParameters","program","cam","getActiveCamera","keyMats","openGLCamera","getKeyMatrices","setUniformMatrix","vcpc","getIsIdentity","actMats","openGLActor","tmp4","Float64Array","multiply","wcvc","mcwc","setUniformi","getParallelProjection","getOpenGLMode","rep","type","TRIANGLES","buildBufferObjects","mapScalars","c","getColorMapColors","vbo","primitives","primTypes","Tris","points","getPoints","numPoints","getNumberOfPoints","pointArray","getData","pointSize","scales","getArray","colorData","colorComponents","packedUCVBO","getNumberOfComponents","setColorOffset","setColorBOStride","Uint8Array","getColorBO","setColorBO","setOpenGLRenderWindow","setColorComponents","packedVBO","Float32Array","setStride","cos30","Math","cos","pointIdx","colorIdx","vboIdx","ucIdx","radius","getRadius","setElementCount","upload","ARRAY_BUFFER","modified","DEFAULT_VALUES","extend","initialValues","undefined","assign","vtkSphereMapper","default"],"sources":["/home/rakshith/Documents/RemoteRendering/vtk-js-react-app/node_modules/@kitware/vtk.js/Rendering/OpenGL/SphereMapper.js"],"sourcesContent":["import _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport { mat4 } from 'gl-matrix';\nimport { ObjectType } from './BufferObject/Constants.js';\nimport { newInstance as newInstance$1, vtkErrorMacro as vtkErrorMacro$1 } from '../../macros.js';\nimport vtkBufferObject from './BufferObject.js';\nimport { r as radiansFromDegrees } from '../../Common/Core/Math/index.js';\nimport vtkShaderProgram from './ShaderProgram.js';\nimport vtkOpenGLPolyDataMapper from './PolyDataMapper.js';\nimport { v as vtkSphereMapperVS } from './glsl/vtkSphereMapperVS.glsl.js';\nimport { v as vtkPolyDataFS } from './glsl/vtkPolyDataFS.glsl.js';\nimport { registerOverride } from './ViewNodeFactory.js';\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nvar vtkErrorMacro = vtkErrorMacro$1; // ----------------------------------------------------------------------------\n// vtkOpenGLSphereMapper methods\n// ----------------------------------------------------------------------------\n\nfunction vtkOpenGLSphereMapper(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkOpenGLSphereMapper'); // Capture 'parentClass' api for internal use\n\n  var superClass = _objectSpread({}, publicAPI);\n\n  publicAPI.getShaderTemplate = function (shaders, ren, actor) {\n    shaders.Vertex = vtkSphereMapperVS;\n    shaders.Fragment = vtkPolyDataFS;\n    shaders.Geometry = '';\n  };\n\n  publicAPI.replaceShaderValues = function (shaders, ren, actor) {\n    var VSSource = shaders.Vertex;\n    var FSSource = shaders.Fragment;\n    VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::Camera::Dec', ['uniform mat4 VCPCMatrix;\\n', 'uniform mat4 MCVCMatrix;']).result;\n    FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::PositionVC::Dec', ['varying vec4 vertexVCVSOutput;']).result; // we create vertexVC below, so turn off the default\n    // implementation\n\n    FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::PositionVC::Impl', ['vec4 vertexVC = vertexVCVSOutput;\\n']).result; // for lights kit and positional the VCPC matrix is already defined\n    // so don't redefine it\n\n    var replacement = ['uniform float invertedDepth;\\n', 'uniform int cameraParallel;\\n', 'varying float radiusVCVSOutput;\\n', 'varying vec3 centerVCVSOutput;\\n', 'uniform mat4 VCPCMatrix;\\n'];\n    FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Normal::Dec', replacement).result;\n    var fragString = '';\n\n    if (model.context.getExtension('EXT_frag_depth')) {\n      fragString = 'gl_FragDepthEXT = (pos.z / pos.w + 1.0) / 2.0;\\n';\n    }\n\n    if (model._openGLRenderWindow.getWebgl2()) {\n      fragString = 'gl_FragDepth = (pos.z / pos.w + 1.0) / 2.0;\\n';\n    }\n\n    FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Depth::Impl', [// compute the eye position and unit direction\n    '  vec3 EyePos;\\n', '  vec3 EyeDir;\\n', '  if (cameraParallel != 0) {\\n', '    EyePos = vec3(vertexVC.x, vertexVC.y, vertexVC.z + 3.0*radiusVCVSOutput);\\n', '    EyeDir = vec3(0.0,0.0,-1.0); }\\n', '  else {\\n', '    EyeDir = vertexVC.xyz;\\n', '    EyePos = vec3(0.0,0.0,0.0);\\n', '    float lengthED = length(EyeDir);\\n', '    EyeDir = normalize(EyeDir);\\n', // we adjust the EyePos to be closer if it is too far away\n    // to prevent floating point precision noise\n    '    if (lengthED > radiusVCVSOutput*3.0) {\\n', '      EyePos = vertexVC.xyz - EyeDir*3.0*radiusVCVSOutput; }\\n', '    }\\n', // translate to Sphere center\n    '  EyePos = EyePos - centerVCVSOutput;\\n', // scale to radius 1.0\n    '  EyePos = EyePos/radiusVCVSOutput;\\n', // find the intersection\n    '  float b = 2.0*dot(EyePos,EyeDir);\\n', '  float c = dot(EyePos,EyePos) - 1.0;\\n', '  float d = b*b - 4.0*c;\\n', '  vec3 normalVCVSOutput = vec3(0.0,0.0,1.0);\\n', '  if (d < 0.0) { discard; }\\n', '  else {\\n', '    float t = (-b - invertedDepth*sqrt(d))*0.5;\\n', // compute the normal, for unit sphere this is just\n    // the intersection point\n    '    normalVCVSOutput = invertedDepth*normalize(EyePos + t*EyeDir);\\n', // compute the intersection point in VC\n    '    vertexVC.xyz = normalVCVSOutput*radiusVCVSOutput + centerVCVSOutput;\\n', '    }\\n', // compute the pixel's depth\n    // ' normalVCVSOutput = vec3(0,0,1);\\n'\n    '  vec4 pos = VCPCMatrix * vertexVC;\\n', fragString]).result; // Strip out the normal line -- the normal is computed as part of the depth\n\n    FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Normal::Impl', '').result;\n\n    if (model.haveSeenDepthRequest) {\n      // special depth impl\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::ZBuffer::Impl', ['if (depthRequest == 1) {', 'float computedZ = (pos.z / pos.w + 1.0) / 2.0;', 'float iz = floor(computedZ * 65535.0 + 0.1);', 'float rf = floor(iz/256.0)/255.0;', 'float gf = mod(iz,256.0)/255.0;', 'gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }']).result;\n    }\n\n    shaders.Vertex = VSSource;\n    shaders.Fragment = FSSource;\n    superClass.replaceShaderValues(shaders, ren, actor);\n  };\n\n  publicAPI.setMapperShaderParameters = function (cellBO, ren, actor) {\n    if (cellBO.getCABO().getElementCount() && (model.VBOBuildTime > cellBO.getAttributeUpdateTime().getMTime() || cellBO.getShaderSourceTime().getMTime() > cellBO.getAttributeUpdateTime().getMTime()) && cellBO.getProgram().isAttributeUsed('offsetMC')) {\n      if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO(), 'offsetMC', 12, // 12:this->VBO->ColorOffset+sizeof(float)\n      cellBO.getCABO().getStride(), model.context.FLOAT, 2, false)) {\n        vtkErrorMacro(\"Error setting 'offsetMC' in shader VAO.\");\n      }\n    }\n\n    if (cellBO.getProgram().isUniformUsed('invertedDepth')) {\n      cellBO.getProgram().setUniformf('invertedDepth', model.invert ? -1.0 : 1.0);\n    }\n\n    if (cellBO.getProgram().isUniformUsed('scaleFactor')) {\n      // apply scaling factor only if a scale array has been provided.\n      var poly = model.currentInput;\n      var pointData = poly.getPointData();\n\n      if (model.renderable.getScaleArray() != null && pointData.hasArray(model.renderable.getScaleArray())) {\n        cellBO.getProgram().setUniformf('scaleFactor', model.renderable.getScaleFactor());\n      } else {\n        cellBO.getProgram().setUniformf('scaleFactor', 1.0);\n      }\n    }\n\n    superClass.setMapperShaderParameters(cellBO, ren, actor);\n  };\n\n  publicAPI.setCameraShaderParameters = function (cellBO, ren, actor) {\n    var program = cellBO.getProgram();\n    var cam = ren.getActiveCamera();\n    var keyMats = model.openGLCamera.getKeyMatrices(ren);\n\n    if (program.isUniformUsed('VCPCMatrix')) {\n      program.setUniformMatrix('VCPCMatrix', keyMats.vcpc);\n    }\n\n    if (program.isUniformUsed('MCVCMatrix')) {\n      if (!actor.getIsIdentity()) {\n        var actMats = model.openGLActor.getKeyMatrices();\n        var tmp4 = new Float64Array(16);\n        mat4.multiply(tmp4, keyMats.wcvc, actMats.mcwc);\n        program.setUniformMatrix('MCVCMatrix', tmp4);\n      } else {\n        program.setUniformMatrix('MCVCMatrix', keyMats.wcvc);\n      }\n    }\n\n    if (program.isUniformUsed('cameraParallel')) {\n      cellBO.getProgram().setUniformi('cameraParallel', cam.getParallelProjection());\n    }\n  };\n\n  publicAPI.getOpenGLMode = function (rep, type) {\n    return model.context.TRIANGLES;\n  };\n\n  publicAPI.buildBufferObjects = function (ren, actor) {\n    var poly = model.currentInput;\n\n    if (poly === null) {\n      return;\n    }\n\n    model.renderable.mapScalars(poly, 1.0);\n    var c = model.renderable.getColorMapColors();\n    var vbo = model.primitives[model.primTypes.Tris].getCABO();\n    var pointData = poly.getPointData();\n    var points = poly.getPoints();\n    var numPoints = points.getNumberOfPoints();\n    var pointArray = points.getData();\n    var pointSize = 5; // x,y,z,orientation1,orientation2\n\n    var scales = null;\n\n    if (model.renderable.getScaleArray() != null && pointData.hasArray(model.renderable.getScaleArray())) {\n      scales = pointData.getArray(model.renderable.getScaleArray()).getData();\n    }\n\n    var colorData = null;\n    var colorComponents = 0;\n    var packedUCVBO = null;\n\n    if (c) {\n      colorComponents = c.getNumberOfComponents();\n      vbo.setColorOffset(0);\n      vbo.setColorBOStride(4);\n      colorData = c.getData();\n      packedUCVBO = new Uint8Array(3 * numPoints * 4);\n\n      if (!vbo.getColorBO()) {\n        vbo.setColorBO(vtkBufferObject.newInstance());\n      }\n\n      vbo.getColorBO().setOpenGLRenderWindow(model._openGLRenderWindow);\n    } else if (vbo.getColorBO()) {\n      vbo.setColorBO(null);\n    }\n\n    vbo.setColorComponents(colorComponents);\n    var packedVBO = new Float32Array(pointSize * numPoints * 3);\n    vbo.setStride(pointSize * 4);\n    var cos30 = Math.cos(radiansFromDegrees(30.0));\n    var pointIdx = 0;\n    var colorIdx = 0; //\n    // Generate points and point data for sides\n    //\n\n    var vboIdx = 0;\n    var ucIdx = 0;\n\n    for (var i = 0; i < numPoints; ++i) {\n      var radius = model.renderable.getRadius();\n\n      if (scales) {\n        radius = scales[i];\n      }\n\n      pointIdx = i * 3;\n      packedVBO[vboIdx++] = pointArray[pointIdx++];\n      packedVBO[vboIdx++] = pointArray[pointIdx++];\n      packedVBO[vboIdx++] = pointArray[pointIdx++];\n      packedVBO[vboIdx++] = -2.0 * radius * cos30;\n      packedVBO[vboIdx++] = -radius;\n\n      if (colorData) {\n        colorIdx = i * colorComponents;\n        packedUCVBO[ucIdx++] = colorData[colorIdx];\n        packedUCVBO[ucIdx++] = colorData[colorIdx + 1];\n        packedUCVBO[ucIdx++] = colorData[colorIdx + 2];\n        packedUCVBO[ucIdx++] = colorData[colorIdx + 3];\n      }\n\n      pointIdx = i * 3;\n      packedVBO[vboIdx++] = pointArray[pointIdx++];\n      packedVBO[vboIdx++] = pointArray[pointIdx++];\n      packedVBO[vboIdx++] = pointArray[pointIdx++];\n      packedVBO[vboIdx++] = 2.0 * radius * cos30;\n      packedVBO[vboIdx++] = -radius;\n\n      if (colorData) {\n        packedUCVBO[ucIdx++] = colorData[colorIdx];\n        packedUCVBO[ucIdx++] = colorData[colorIdx + 1];\n        packedUCVBO[ucIdx++] = colorData[colorIdx + 2];\n        packedUCVBO[ucIdx++] = colorData[colorIdx + 3];\n      }\n\n      pointIdx = i * 3;\n      packedVBO[vboIdx++] = pointArray[pointIdx++];\n      packedVBO[vboIdx++] = pointArray[pointIdx++];\n      packedVBO[vboIdx++] = pointArray[pointIdx++];\n      packedVBO[vboIdx++] = 0.0;\n      packedVBO[vboIdx++] = 2.0 * radius;\n\n      if (colorData) {\n        packedUCVBO[ucIdx++] = colorData[colorIdx];\n        packedUCVBO[ucIdx++] = colorData[colorIdx + 1];\n        packedUCVBO[ucIdx++] = colorData[colorIdx + 2];\n        packedUCVBO[ucIdx++] = colorData[colorIdx + 3];\n      }\n    }\n\n    vbo.setElementCount(vboIdx / pointSize);\n    vbo.upload(packedVBO, ObjectType.ARRAY_BUFFER);\n\n    if (c) {\n      vbo.getColorBO().upload(packedUCVBO, ObjectType.ARRAY_BUFFER);\n    }\n\n    model.VBOBuildTime.modified();\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\n\nvar DEFAULT_VALUES = {}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Inheritance\n\n  vtkOpenGLPolyDataMapper.extend(publicAPI, model, initialValues); // Object methods\n\n  vtkOpenGLSphereMapper(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = newInstance$1(extend, 'vtkOpenGLSphereMapper'); // ----------------------------------------------------------------------------\n\nvar vtkSphereMapper = {\n  newInstance: newInstance,\n  extend: extend\n}; // Register ourself to OpenGL backend if imported\n\nregisterOverride('vtkSphereMapper', newInstance);\n\nexport { vtkSphereMapper as default, extend, newInstance };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}