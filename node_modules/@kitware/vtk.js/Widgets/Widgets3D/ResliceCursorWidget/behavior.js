import _toConsumableArray from '@babel/runtime/helpers/toConsumableArray';
import _defineProperty from '@babel/runtime/helpers/defineProperty';
import macro from '../../../macros.js';
import vtkBoundingBox from '../../../Common/DataModel/BoundingBox.js';
import vtkLine from '../../../Common/DataModel/Line.js';
import { k as add, l as normalize, s as subtract, d as dot, j as cross, m as multiplyAccumulate, w as multiplyScalar, S as signedAngleBetweenVectors } from '../../../Common/Core/Math/index.js';
import { getLineNames, getOtherLineName, updateState, boundPointOnPlane, getLinePlaneName, getLineInPlaneName, rotateVector } from './helpers.js';
import { InteractionMethodsName, ScrollingMethods, planeNameToViewType } from './Constants.js';

function widgetBehavior(publicAPI, model) {
  var _publicAPI$setCursorS;

  model._isDragging = false;
  var isScrolling = false;
  var previousPosition;
  macro.setGet(publicAPI, model, ['keepOrthogonality', {
    type: 'object',
    name: 'cursorStyles'
  }]); // Set default value for cursorStyles

  publicAPI.setCursorStyles((_publicAPI$setCursorS = {}, _defineProperty(_publicAPI$setCursorS, InteractionMethodsName.TranslateCenter, 'move'), _defineProperty(_publicAPI$setCursorS, InteractionMethodsName.RotateLine, 'alias'), _defineProperty(_publicAPI$setCursorS, InteractionMethodsName.TranslateAxis, 'pointer'), _defineProperty(_publicAPI$setCursorS, "default", 'default'), _publicAPI$setCursorS));

  publicAPI.setEnableTranslation = function (enable) {
    model.representations[0].setPickable(enable); // line handle

    model.representations[2].setPickable(enable); // center handle
  };

  publicAPI.setEnableRotation = function (enable) {
    model.representations[1].setPickable(enable); // rotation handle
  }; // FIXME: label information should be accessible from activeState instead of parent state.


  publicAPI.getActiveInteraction = function () {
    if (model.widgetState.getStatesWithLabel('rotation').includes(model.activeState)) {
      return InteractionMethodsName.RotateLine;
    }

    if (model.widgetState.getStatesWithLabel('line').includes(model.activeState)) {
      return InteractionMethodsName.TranslateAxis;
    }

    if (model.widgetState.getStatesWithLabel('center').includes(model.activeState)) {
      return InteractionMethodsName.TranslateCenter;
    }

    return null;
  };
  /**
   * ActiveState can be RotationHandle or a LineHandle
   * @returns 'YinX', 'ZinX', 'XinY', 'ZinY', 'XinZ' or 'YinZ'
   */


  publicAPI.getActiveLineName = function () {
    return getLineNames(model.widgetState).find(function (lineName) {
      return model.widgetState.getStatesWithLabel(lineName).includes(model.activeState);
    });
  }; // FIXME: label information should be accessible from activeState instead of parent state.


  publicAPI.getActiveLineHandle = function () {
    var _model$widgetState$, _model$widgetState;

    return (_model$widgetState$ = (_model$widgetState = model.widgetState)["getAxis".concat(publicAPI.getActiveLineName())]) === null || _model$widgetState$ === void 0 ? void 0 : _model$widgetState$.call(_model$widgetState);
  };
  /**
   * Return the line handle of the other line in the same view.
   * @param {string} lineName name of the line (YinX, ZinX, XinY, ZinY, XinZ, YinZ)
   * @returns ZinX if lineName == YinX, YinX if lineName == ZinX, ZinY if lineName == XinY...
   */


  publicAPI.getOtherLineHandle = function (lineName) {
    var _model$widgetState$2, _model$widgetState2;

    return (_model$widgetState$2 = (_model$widgetState2 = model.widgetState)["getAxis".concat(getOtherLineName(model.widgetState, lineName))]) === null || _model$widgetState$2 === void 0 ? void 0 : _model$widgetState$2.call(_model$widgetState2);
  }; // FIXME: label information should be accessible from activeState instead of parent state.

  /**
   * There are 2 rotation handles per axis: 'point0' and 'point1'.
   * This function returns which rotation handle (point0 or point1) is currently active.
   * ActiveState must be a RotationHandle.
   * @returns 'point0', 'point1' or null if no point is active (e.g. line is being rotated)
   */


  publicAPI.getActiveRotationPointName = function () {
    if (model.widgetState.getStatesWithLabel('point0').includes(model.activeState)) {
      return 'point0';
    }

    if (model.widgetState.getStatesWithLabel('point1').includes(model.activeState)) {
      return 'point1';
    }

    return null;
  };

  publicAPI.startScrolling = function (newPosition) {
    if (newPosition) {
      previousPosition = newPosition;
    }

    isScrolling = true;
    publicAPI.startInteraction();
  };

  publicAPI.endScrolling = function () {
    isScrolling = false;
    publicAPI.endInteraction();
  };

  publicAPI.updateCursor = function () {
    var cursorStyles = publicAPI.getCursorStyles();

    if (cursorStyles) {
      switch (publicAPI.getActiveInteraction()) {
        case InteractionMethodsName.TranslateCenter:
          model._apiSpecificRenderWindow.setCursor(cursorStyles.translateCenter);

          break;

        case InteractionMethodsName.RotateLine:
          model._apiSpecificRenderWindow.setCursor(cursorStyles.rotateLine);

          break;

        case InteractionMethodsName.TranslateAxis:
          model._apiSpecificRenderWindow.setCursor(cursorStyles.translateAxis);

          break;

        default:
          model._apiSpecificRenderWindow.setCursor(cursorStyles.default);

          break;
      }
    }
  };

  publicAPI.handleLeftButtonPress = function (callData) {
    if (model.activeState && model.activeState.getActive()) {
      var _model$activeState$ge, _model$activeState, _model$activeState$ge2;

      model._isDragging = true;
      var viewType = model.viewType;
      var currentPlaneNormal = model.widgetState.getPlanes()[viewType].normal;
      var manipulator = (_model$activeState$ge = (_model$activeState = model.activeState) === null || _model$activeState === void 0 ? void 0 : (_model$activeState$ge2 = _model$activeState.getManipulator) === null || _model$activeState$ge2 === void 0 ? void 0 : _model$activeState$ge2.call(_model$activeState)) !== null && _model$activeState$ge !== void 0 ? _model$activeState$ge : model.manipulator;
      manipulator.setWidgetOrigin(model.widgetState.getCenter());
      manipulator.setWidgetNormal(currentPlaneNormal);

      var _manipulator$handleEv = manipulator.handleEvent(callData, model._apiSpecificRenderWindow),
          worldCoords = _manipulator$handleEv.worldCoords;

      previousPosition = worldCoords;
      publicAPI.startInteraction();
    } else if (model.widgetState.getScrollingMethod() === ScrollingMethods.LEFT_MOUSE_BUTTON) {
      publicAPI.startScrolling(callData.position);
    } else {
      return macro.VOID;
    }

    return macro.EVENT_ABORT;
  };

  publicAPI.handleMouseMove = function (callData) {
    if (model._isDragging) {
      return publicAPI.handleEvent(callData);
    }

    if (isScrolling) {
      if (previousPosition.y !== callData.position.y) {
        var step = previousPosition.y - callData.position.y;
        publicAPI.translateCenterOnPlaneDirection(step);
        previousPosition = callData.position;
        publicAPI.invokeInternalInteractionEvent();
      }
    }

    return macro.VOID;
  };

  publicAPI.handleLeftButtonRelease = function () {
    if (model._isDragging || isScrolling) {
      publicAPI.endScrolling();
    }

    model._isDragging = false;
    model.widgetState.deactivate();
  };

  publicAPI.handleRightButtonPress = function (calldata) {
    if (model.widgetState.getScrollingMethod() === ScrollingMethods.RIGHT_MOUSE_BUTTON) {
      publicAPI.startScrolling(calldata.position);
    }
  };

  publicAPI.handleRightButtonRelease = function () {
    if (model.widgetState.getScrollingMethod() === ScrollingMethods.RIGHT_MOUSE_BUTTON) {
      publicAPI.endScrolling();
    }
  };

  publicAPI.handleStartMouseWheel = function () {
    publicAPI.startInteraction();
  };

  publicAPI.handleMouseWheel = function (calldata) {
    var step = calldata.spinY;
    isScrolling = true;
    publicAPI.translateCenterOnPlaneDirection(step);
    publicAPI.invokeInternalInteractionEvent();
    isScrolling = false;
    return macro.EVENT_ABORT;
  };

  publicAPI.handleEndMouseWheel = function () {
    publicAPI.endScrolling();
  };

  publicAPI.handleMiddleButtonPress = function (calldata) {
    if (model.widgetState.getScrollingMethod() === ScrollingMethods.MIDDLE_MOUSE_BUTTON) {
      publicAPI.startScrolling(calldata.position);
    }
  };

  publicAPI.handleMiddleButtonRelease = function () {
    if (model.widgetState.getScrollingMethod() === ScrollingMethods.MIDDLE_MOUSE_BUTTON) {
      publicAPI.endScrolling();
    }
  };

  publicAPI.handleEvent = function (callData) {
    if (model.activeState.getActive()) {
      publicAPI[publicAPI.getActiveInteraction()](callData);
      publicAPI.invokeInternalInteractionEvent();
      return macro.EVENT_ABORT;
    }

    return macro.VOID;
  };

  publicAPI.invokeInternalInteractionEvent = function () {
    var methodName = publicAPI.getActiveInteraction();
    var computeFocalPointOffset = methodName !== InteractionMethodsName.RotateLine;
    var canUpdateFocalPoint = methodName === InteractionMethodsName.RotateLine;
    publicAPI.invokeInteractionEvent({
      computeFocalPointOffset: computeFocalPointOffset,
      canUpdateFocalPoint: canUpdateFocalPoint
    });
  };

  publicAPI.startInteraction = function () {
    publicAPI.invokeStartInteractionEvent(); // When interacting, plane actor and lines must be re-rendered on other views

    publicAPI.getViewWidgets().forEach(function (viewWidget) {
      viewWidget.getInteractor().requestAnimation(publicAPI);
    });
  };

  publicAPI.endInteraction = function () {
    publicAPI.invokeEndInteractionEvent();
    publicAPI.getViewWidgets().forEach(function (viewWidget) {
      viewWidget.getInteractor().cancelAnimation(publicAPI);
    });
  };

  publicAPI.translateCenterOnPlaneDirection = function (nbSteps) {
    var dirProj = model.widgetState.getPlanes()[model.viewType].normal;
    var oldCenter = model.widgetState.getCenter();
    var image = model.widgetState.getImage();
    var imageSpacing = image.getSpacing(); // Use Chebyshev norm
    // https://math.stackexchange.com/questions/71423/what-is-the-term-for-the-projection-of-a-vector-onto-the-unit-cube

    var absDirProj = dirProj.map(function (value) {
      return Math.abs(value);
    });
    var index = absDirProj.indexOf(Math.max.apply(Math, _toConsumableArray(absDirProj)));
    var movingFactor = nbSteps * imageSpacing[index] / Math.abs(dirProj[index]); // Define the potentially new center

    var newCenter = [oldCenter[0] + movingFactor * dirProj[0], oldCenter[1] + movingFactor * dirProj[1], oldCenter[2] + movingFactor * dirProj[2]];
    newCenter = publicAPI.getBoundedCenter(newCenter);
    model.widgetState.setCenter(newCenter);
    updateState(model.widgetState, model._factory.getScaleInPixels(), model._factory.getRotationHandlePosition());
  };

  publicAPI[InteractionMethodsName.TranslateAxis] = function (calldata) {
    var _model$activeState$ge3, _model$activeState2, _model$activeState2$g, _model$activeState3, _model$activeState3$g;

    var lineHandle = publicAPI.getActiveLineHandle();
    var lineName = publicAPI.getActiveLineName();
    var pointOnLine = add(lineHandle.getOrigin(), lineHandle.getDirection(), []);
    var currentLineVector = lineHandle.getDirection();
    normalize(currentLineVector); // Translate the current line along the other line

    var otherLineHandle = publicAPI.getOtherLineHandle(lineName);
    var center = model.widgetState.getCenter();
    var manipulator = (_model$activeState$ge3 = (_model$activeState2 = model.activeState) === null || _model$activeState2 === void 0 ? void 0 : (_model$activeState2$g = _model$activeState2.getManipulator) === null || _model$activeState2$g === void 0 ? void 0 : _model$activeState2$g.call(_model$activeState2)) !== null && _model$activeState$ge3 !== void 0 ? _model$activeState$ge3 : model.manipulator;
    var worldCoords = null;
    var newOrigin = [];

    if ((_model$activeState3 = model.activeState) !== null && _model$activeState3 !== void 0 && (_model$activeState3$g = _model$activeState3.getManipulator) !== null && _model$activeState3$g !== void 0 && _model$activeState3$g.call(_model$activeState3)) {
      worldCoords = manipulator.handleEvent(calldata, model._apiSpecificRenderWindow).worldCoords;
      var translation = subtract(worldCoords, previousPosition, []);
      add(center, translation, newOrigin);
    } else if (otherLineHandle) {
      var otherLineVector = otherLineHandle.getDirection();
      normalize(otherLineVector);
      var axisTranslation = otherLineVector;
      var dot$1 = dot(currentLineVector, otherLineVector); // lines are colinear, translate along perpendicular axis from current line

      if (dot$1 === 1 || dot$1 === -1) {
        cross(currentLineVector, manipulator.getWidgetNormal(), axisTranslation);
      }

      var closestPoint = [];
      worldCoords = manipulator.handleEvent(calldata, model._apiSpecificRenderWindow).worldCoords;
      vtkLine.distanceToLine(worldCoords, lineHandle.getOrigin(), pointOnLine, closestPoint);
      var translationVector = subtract(worldCoords, closestPoint, []);
      var translationDistance = dot(translationVector, axisTranslation);
      newOrigin = multiplyAccumulate(center, axisTranslation, translationDistance, newOrigin);
    }

    newOrigin = publicAPI.getBoundedCenter(newOrigin);
    model.widgetState.setCenter(newOrigin);
    updateState(model.widgetState, model._factory.getScaleInPixels(), model._factory.getRotationHandlePosition());
    previousPosition = worldCoords;
  };

  publicAPI.getBoundedCenter = function (newCenter) {
    var oldCenter = model.widgetState.getCenter();
    var imageBounds = model.widgetState.getImage().getBounds();

    if (vtkBoundingBox.containsPoint.apply(vtkBoundingBox, [imageBounds].concat(_toConsumableArray(newCenter)))) {
      return newCenter;
    }

    return boundPointOnPlane(newCenter, oldCenter, imageBounds);
  };

  publicAPI[InteractionMethodsName.TranslateCenter] = function (calldata) {
    var _model$activeState$ge4, _model$activeState4, _model$activeState4$g;

    var manipulator = (_model$activeState$ge4 = (_model$activeState4 = model.activeState) === null || _model$activeState4 === void 0 ? void 0 : (_model$activeState4$g = _model$activeState4.getManipulator) === null || _model$activeState4$g === void 0 ? void 0 : _model$activeState4$g.call(_model$activeState4)) !== null && _model$activeState$ge4 !== void 0 ? _model$activeState$ge4 : model.manipulator;

    var _manipulator$handleEv2 = manipulator.handleEvent(calldata, model._apiSpecificRenderWindow),
        worldCoords = _manipulator$handleEv2.worldCoords;

    var translation = subtract(worldCoords, previousPosition, []);
    previousPosition = worldCoords;
    var newCenter = add(model.widgetState.getCenter(), translation, []);
    newCenter = publicAPI.getBoundedCenter(newCenter);
    model.widgetState.setCenter(newCenter);
    updateState(model.widgetState, model._factory.getScaleInPixels(), model._factory.getRotationHandlePosition());
  };

  publicAPI[InteractionMethodsName.RotateLine] = function (calldata) {
    var _model$activeState$ge5, _model$activeState5, _model$activeState5$g;

    var activeLineHandle = publicAPI.getActiveLineHandle();
    var manipulator = (_model$activeState$ge5 = (_model$activeState5 = model.activeState) === null || _model$activeState5 === void 0 ? void 0 : (_model$activeState5$g = _model$activeState5.getManipulator) === null || _model$activeState5$g === void 0 ? void 0 : _model$activeState5$g.call(_model$activeState5)) !== null && _model$activeState$ge5 !== void 0 ? _model$activeState$ge5 : model.manipulator;
    var planeNormal = manipulator.getWidgetNormal();

    var _manipulator$handleEv3 = manipulator.handleEvent(calldata, model._apiSpecificRenderWindow),
        worldCoords = _manipulator$handleEv3.worldCoords;

    if (!worldCoords || !worldCoords.length) {
      return;
    }

    var center = model.widgetState.getCenter();
    var currentVectorToOrigin = [0, 0, 0];
    subtract(worldCoords, center, currentVectorToOrigin);
    normalize(currentVectorToOrigin);
    var previousLineDirection = activeLineHandle.getDirection();
    normalize(previousLineDirection);
    var activePointName = publicAPI.getActiveRotationPointName();

    if (activePointName === 'point1' || !activePointName && dot(currentVectorToOrigin, previousLineDirection) < 0) {
      multiplyScalar(previousLineDirection, -1);
    }

    var radianAngle = signedAngleBetweenVectors(previousLineDirection, currentVectorToOrigin, planeNormal);
    publicAPI.rotateLineInView(publicAPI.getActiveLineName(), radianAngle);
  };
  /**
   * Rotate a line by a specified angle
   * @param {string} lineName The line name to rotate (e.g. YinX, ZinX, XinY, ZinY, XinZ, YinZ)
   * @param {Number} radianAngle Applied angle in radian
   */


  publicAPI.rotateLineInView = function (lineName, radianAngle) {
    var viewType = planeNameToViewType[getLinePlaneName(lineName)];
    var inViewType = planeNameToViewType[getLineInPlaneName(lineName)];
    var planeNormal = model.widgetState.getPlanes()[inViewType].normal;
    publicAPI.rotatePlane(viewType, radianAngle, planeNormal);

    if (publicAPI.getKeepOrthogonality()) {
      var otherLineName = getOtherLineName(model.widgetState, lineName);
      var otherPlaneName = getLinePlaneName(otherLineName);
      publicAPI.rotatePlane(planeNameToViewType[otherPlaneName], radianAngle, planeNormal);
    }

    updateState(model.widgetState, model._factory.getScaleInPixels(), model._factory.getRotationHandlePosition());
  };
  /**
   * Rotate a specified plane around an other specified plane.
   * @param {ViewTypes} viewType Define which plane will be rotated
   * @param {Number} radianAngle Applied angle in radian
   * @param {vec3} planeNormal Define the axis to rotate around
   */


  publicAPI.rotatePlane = function (viewType, radianAngle, planeNormal) {
    var _model$widgetState$ge = model.widgetState.getPlanes()[viewType],
        normal = _model$widgetState$ge.normal,
        viewUp = _model$widgetState$ge.viewUp;
    var newNormal = rotateVector(normal, planeNormal, radianAngle);
    var newViewUp = rotateVector(viewUp, planeNormal, radianAngle);
    model.widgetState.getPlanes()[viewType] = {
      normal: newNormal,
      viewUp: newViewUp
    };
  }; // --------------------------------------------------------------------------
  // initialization
  // --------------------------------------------------------------------------

}

export { widgetBehavior as default };
