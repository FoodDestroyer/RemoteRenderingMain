{"ast":null,"code":"import macro from '../../macros.js';\nvar vtkErrorMacro = macro.vtkErrorMacro; // ----------------------------------------------------------------------------\n// vtkPiecewiseFunction methods\n// ----------------------------------------------------------------------------\n\nfunction vtkPiecewiseFunction(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkPiecewiseFunction'); // Return the number of points which specify this function\n\n  publicAPI.getSize = function () {\n    return model.nodes.length;\n  }; // Return the type of function stored in object:\n  // Function Types:\n  //    0 : Constant        (No change in slope between end points)\n  //    1 : NonDecreasing   (Always increasing or zero slope)\n  //    2 : NonIncreasing   (Always decreasing or zero slope)\n  //    3 : Varied          (Contains both decreasing and increasing slopes)\n  //    4 : Unknown         (Error condition)\n  //\n\n  publicAPI.getType = function () {\n    var value;\n    var prevValue = 0.0;\n    var functionType = 0;\n    if (model.nodes.length > 0) {\n      prevValue = model.nodes[0].y;\n    }\n    for (var i = 1; i < model.nodes.length; i++) {\n      value = model.nodes[i].y; // Do not change the function type if equal\n\n      if (value !== prevValue) {\n        if (value > prevValue) {\n          switch (functionType) {\n            case 0:\n            case 1:\n              // NonDecreasing\n              functionType = 1;\n              break;\n            case 2:\n            default:\n              // Varied\n              functionType = 3;\n              break;\n          }\n        } else {\n          // value < prev_value\n          switch (functionType) {\n            case 0:\n            case 2:\n              // NonIncreasing\n              functionType = 2;\n              break;\n            case 1:\n            default:\n              // Varied\n              functionType = 3;\n              break;\n          }\n        }\n      }\n      prevValue = value; // Exit loop if we find a Varied function\n\n      if (functionType === 3) {\n        break;\n      }\n    }\n    switch (functionType) {\n      case 0:\n        return 'Constant';\n      case 1:\n        return 'NonDecreasing';\n      case 2:\n        return 'NonIncreasing';\n      case 3:\n      default:\n        return 'Varied';\n    }\n  }; // Since we no longer store the data in an array, we must\n  // copy out of the vector into an array. No modified check -\n  // could be added if performance is a problem\n\n  publicAPI.getDataPointer = function () {\n    var size = model.nodes.length;\n    model.function = null;\n    if (size > 0) {\n      model.function = [];\n      for (var i = 0; i < size; i++) {\n        model.function[2 * i] = model.nodes[i].x;\n        model.function[2 * i + 1] = model.nodes[i].y;\n      }\n    }\n    return model.function;\n  }; // Returns the first point location which starts a non-zero segment of the\n  // function. Note that the value at this point may be zero.\n\n  publicAPI.getFirstNonZeroValue = function () {\n    // Check if no points specified\n    if (model.nodes.length === 0) {\n      return 0;\n    }\n    var allZero = 1;\n    var x = 0.0;\n    var i = 0;\n    for (; i < model.nodes.length; i++) {\n      if (model.nodes[i].y !== 0.0) {\n        allZero = 0;\n        break;\n      }\n    } // If every specified point has a zero value then return\n    // a large value\n\n    if (allZero) {\n      x = Number.MAX_VALUE;\n    } else if (i > 0) {\n      // A point was found with a non-zero value\n      // Return the value of the point that precedes this one\n      x = model.nodes[i - 1].x;\n    } else if (model.clamping) {\n      // If this is the first point in the function, return its\n      // value is clamping is off, otherwise VTK_DOUBLE_MIN if\n      // clamping is on.\n      x = -Number.MAX_VALUE;\n    } else {\n      x = model.nodes[0].x;\n    }\n    return x;\n  }; // For a specified index value, get the node parameters\n\n  publicAPI.getNodeValue = function (index, val) {\n    var size = model.nodes.length;\n    if (index < 0 || index >= size) {\n      vtkErrorMacro('Index out of range!');\n      return -1;\n    }\n    val[0] = model.nodes[index].x;\n    val[1] = model.nodes[index].y;\n    val[2] = model.nodes[index].midpoint;\n    val[3] = model.nodes[index].sharpness;\n    return 1;\n  }; // For a specified index value, get the node parameters\n\n  publicAPI.setNodeValue = function (index, val) {\n    var size = model.nodes.length;\n    if (index < 0 || index >= size) {\n      vtkErrorMacro('Index out of range!');\n      return -1;\n    }\n    var oldX = model.nodes[index].x;\n    model.nodes[index].x = val[0];\n    model.nodes[index].y = val[1];\n    model.nodes[index].midpoint = val[2];\n    model.nodes[index].sharpness = val[3];\n    if (oldX !== val[0]) {\n      // The point has been moved, the order of points or the range might have\n      // been modified.\n      publicAPI.sortAndUpdateRange(); // No need to call Modified() here because SortAndUpdateRange() has done it\n      // already.\n    } else {\n      publicAPI.modified();\n    }\n    return 1;\n  }; // Adds a point to the function. If a duplicate point is inserted\n  // then the function value at that location is set to the new value.\n  // This is the legacy version that assumes midpoint = 0.5 and\n  // sharpness = 0.0\n\n  publicAPI.addPoint = function (x, y) {\n    return publicAPI.addPointLong(x, y, 0.5, 0.0);\n  }; // Adds a point to the function and returns the array index of the point.\n\n  publicAPI.addPointLong = function (x, y, midpoint, sharpness) {\n    // Error check\n    if (midpoint < 0.0 || midpoint > 1.0) {\n      vtkErrorMacro('Midpoint outside range [0.0, 1.0]');\n      return -1;\n    }\n    if (sharpness < 0.0 || sharpness > 1.0) {\n      vtkErrorMacro('Sharpness outside range [0.0, 1.0]');\n      return -1;\n    } // remove any node already at this X location\n\n    if (!model.allowDuplicateScalars) {\n      publicAPI.removePoint(x);\n    } // Create the new node\n\n    var node = {\n      x: x,\n      y: y,\n      midpoint: midpoint,\n      sharpness: sharpness\n    }; // Add it, then sort to get everything in order\n\n    model.nodes.push(node);\n    publicAPI.sortAndUpdateRange(); // Now find this node so we can return the index\n\n    var i;\n    for (i = 0; i < model.nodes.length; i++) {\n      if (model.nodes[i].x === x) {\n        break;\n      }\n    } // If we didn't find it, something went horribly wrong so\n    // return -1\n\n    if (i < model.nodes.length) {\n      return i;\n    }\n    return -1;\n  };\n  publicAPI.setNodes = function (nodes) {\n    if (model.nodes !== nodes) {\n      model.nodes = nodes;\n      publicAPI.sortAndUpdateRange();\n    }\n  }; // Sort the vector in increasing order, then fill in\n  // the Range\n\n  publicAPI.sortAndUpdateRange = function () {\n    model.nodes.sort(function (a, b) {\n      return a.x - b.x;\n    });\n    var modifiedInvoked = publicAPI.updateRange(); // If range is updated, Modified() has been called, don't call it again.\n\n    if (!modifiedInvoked) {\n      publicAPI.modified();\n    }\n  }; //----------------------------------------------------------------------------\n\n  publicAPI.updateRange = function () {\n    var oldRange = model.range.slice();\n    var size = model.nodes.length;\n    if (size) {\n      model.range[0] = model.nodes[0].x;\n      model.range[1] = model.nodes[size - 1].x;\n    } else {\n      model.range[0] = 0;\n      model.range[1] = 0;\n    } // If the rage is the same, then no need to call Modified()\n\n    if (oldRange[0] === model.range[0] && oldRange[1] === model.range[1]) {\n      return false;\n    }\n    publicAPI.modified();\n    return true;\n  }; // Removes a point from the function. If no point is found then function\n  // remains the same.\n\n  publicAPI.removePoint = function (x) {\n    // First find the node since we need to know its\n    // index as our return value\n    var i;\n    for (i = 0; i < model.nodes.length; i++) {\n      if (model.nodes[i].x === x) {\n        break;\n      }\n    } // If the node doesn't exist, we return -1\n\n    if (i >= model.nodes.length) {\n      return -1;\n    }\n    var retVal = i; // If the first or last point has been removed, then we update the range\n    // No need to sort here as the order of points hasn't changed.\n\n    var modifiedInvoked = false;\n    model.nodes.splice(i, 1);\n    if (i === 0 || i === model.nodes.length) {\n      modifiedInvoked = publicAPI.updateRange();\n    }\n    if (!modifiedInvoked) {\n      publicAPI.modified();\n    }\n    return retVal;\n  }; // Removes all points from the function.\n\n  publicAPI.removeAllPoints = function () {\n    model.nodes = [];\n    publicAPI.sortAndUpdateRange();\n  }; // Add in end points of line and remove any points between them\n  // Legacy method with no way to specify midpoint and sharpness\n\n  publicAPI.addSegment = function (x1, y1, x2, y2) {\n    // First, find all points in this range and remove them\n    publicAPI.sortAndUpdateRange();\n    for (var i = 0; i < model.nodes.length;) {\n      if (model.nodes[i].x >= x1 && model.nodes[i].x <= x2) {\n        model.nodes.splice(i, 1);\n      } else {\n        i++;\n      }\n    } // Now add the points\n\n    publicAPI.addPoint(x1, y1, 0.5, 0.0);\n    publicAPI.addPoint(x2, y2, 0.5, 0.0);\n  }; // Return the value of the function at a position\n\n  publicAPI.getValue = function (x) {\n    var table = [];\n    publicAPI.getTable(x, x, 1, table);\n    return table[0];\n  }; // Remove all points outside the range, and make sure a point\n  // exists at each end of the range. Used as a convenience method\n  // for transfer function editors\n\n  publicAPI.adjustRange = function (range) {\n    if (range.length < 2) {\n      return 0;\n    }\n    var functionRange = publicAPI.getRange(); // Make sure we have points at each end of the range\n\n    if (functionRange[0] < range[0]) {\n      publicAPI.addPoint(range[0], publicAPI.getValue(range[0]));\n    } else {\n      publicAPI.addPoint(range[0], publicAPI.getValue(functionRange[0]));\n    }\n    if (functionRange[1] > range[1]) {\n      publicAPI.addPoint(range[1], publicAPI.getValue(range[1]));\n    } else {\n      publicAPI.addPoint(range[1], publicAPI.getValue(functionRange[1]));\n    } // Remove all points out-of-range\n\n    publicAPI.sortAndUpdateRange();\n    for (var i = 0; i < model.nodes.length;) {\n      if (model.nodes[i].x >= range[0] && model.nodes[i].x <= range[1]) {\n        model.nodes.splice(i, 1);\n      } else {\n        ++i;\n      }\n    }\n    publicAPI.sortAndUpdateRange();\n    return 1;\n  }; //--------------------------------------------------------------------------\n\n  publicAPI.estimateMinNumberOfSamples = function (x1, x2) {\n    var d = publicAPI.findMinimumXDistance();\n    return Math.ceil((x2 - x1) / d);\n  }; //----------------------------------------------------------------------------\n\n  publicAPI.findMinimumXDistance = function () {\n    var size = model.nodes.length;\n    if (size < 2) {\n      return -1.0;\n    }\n    var distance = model.nodes[1].x - model.nodes[0].x;\n    for (var i = 0; i < size - 1; i++) {\n      var currentDist = model.nodes[i + 1].x - model.nodes[i].x;\n      if (currentDist < distance) {\n        distance = currentDist;\n      }\n    }\n    return distance;\n  }; // Returns a table of function values evaluated at regular intervals\n\n  /* eslint-disable prefer-destructuring */\n\n  /* eslint-disable no-continue */\n\n  publicAPI.getTable = function (xStart, xEnd, size, table) {\n    var stride = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1;\n    var i;\n    var idx = 0;\n    var numNodes = model.nodes.length; // Need to keep track of the last value so that\n    // we can fill in table locations past this with\n    // this value if Clamping is On.\n\n    var lastValue = 0.0;\n    if (numNodes !== 0) {\n      lastValue = model.nodes[numNodes - 1].y;\n    }\n    var x = 0.0;\n    var x1 = 0.0;\n    var x2 = 0.0;\n    var y1 = 0.0;\n    var y2 = 0.0;\n    var midpoint = 0.0;\n    var sharpness = 0.0; // For each table entry\n\n    for (i = 0; i < size; i++) {\n      // Find our location in the table\n      var tidx = stride * i; // Find our X location. If we are taking only 1 sample, make\n      // it halfway between start and end (usually start and end will\n      // be the same in this case)\n\n      if (size > 1) {\n        x = xStart + i / (size - 1.0) * (xEnd - xStart);\n      } else {\n        x = 0.5 * (xStart + xEnd);\n      } // Do we need to move to the next node?\n\n      while (idx < numNodes && x > model.nodes[idx].x) {\n        idx++; // If we are at a valid point index, fill in\n        // the value at this node, and the one before (the\n        // two that surround our current sample location)\n        // idx cannot be 0 since we just incremented it.\n\n        if (idx < numNodes) {\n          x1 = model.nodes[idx - 1].x;\n          x2 = model.nodes[idx].x;\n          y1 = model.nodes[idx - 1].y;\n          y2 = model.nodes[idx].y; // We only need the previous midpoint and sharpness\n          // since these control this region\n\n          midpoint = model.nodes[idx - 1].midpoint;\n          sharpness = model.nodes[idx - 1].sharpness; // Move midpoint away from extreme ends of range to avoid\n          // degenerate math\n\n          if (midpoint < 0.00001) {\n            midpoint = 0.00001;\n          }\n          if (midpoint > 0.99999) {\n            midpoint = 0.99999;\n          }\n        }\n      } // Are we at the end? If so, just use the last value\n\n      if (idx >= numNodes) {\n        table[tidx] = model.clamping ? lastValue : 0.0;\n      } else if (idx === 0) {\n        // Are we before the first node? If so, duplicate this nodes values\n        table[tidx] = model.clamping ? model.nodes[0].y : 0.0;\n      } else {\n        // Otherwise, we are between two nodes - interpolate\n        // Our first attempt at a normalized location [0,1] -\n        // we will be modifying this based on midpoint and\n        // sharpness to get the curve shape we want and to have\n        // it pass through (y1+y2)/2 at the midpoint.\n        var s = (x - x1) / (x2 - x1); // Readjust based on the midpoint - linear adjustment\n\n        if (s < midpoint) {\n          s = 0.5 * s / midpoint;\n        } else {\n          s = 0.5 + 0.5 * (s - midpoint) / (1.0 - midpoint);\n        } // override for sharpness > 0.99\n        // In this case we just want piecewise constant\n\n        if (sharpness > 0.99) {\n          // Use the first value since we are below the midpoint\n          if (s < 0.5) {\n            table[tidx] = y1;\n            continue;\n          } else {\n            // Use the second value at or above the midpoint\n            table[tidx] = y2;\n            continue;\n          }\n        } // Override for sharpness < 0.01\n        // In this case we want piecewise linear\n\n        if (sharpness < 0.01) {\n          // Simple linear interpolation\n          table[tidx] = (1 - s) * y1 + s * y2;\n          continue;\n        } // We have a sharpness between [0.01, 0.99] - we will\n        // used a modified hermite curve interpolation where we\n        // derive the slope based on the sharpness, and we compress\n        // the curve non-linearly based on the sharpness\n        // First, we will adjust our position based on sharpness in\n        // order to make the curve sharper (closer to piecewise constant)\n\n        if (s < 0.5) {\n          s = 0.5 * Math.pow(s * 2, 1.0 + 10 * sharpness);\n        } else if (s > 0.5) {\n          s = 1.0 - 0.5 * Math.pow((1.0 - s) * 2, 1 + 10 * sharpness);\n        } // Compute some coefficients we will need for the hermite curve\n\n        var ss = s * s;\n        var sss = ss * s;\n        var h1 = 2 * sss - 3 * ss + 1;\n        var h2 = -2 * sss + 3 * ss;\n        var h3 = sss - 2 * ss + s;\n        var h4 = sss - ss; // Use one slope for both end points\n\n        var slope = y2 - y1;\n        var t = (1.0 - sharpness) * slope; // Compute the value\n\n        table[tidx] = h1 * y1 + h2 * y2 + h3 * t + h4 * t; // Final error check to make sure we don't go outside\n        // the Y range\n\n        var min = y1 < y2 ? y1 : y2;\n        var max = y1 > y2 ? y1 : y2;\n        table[tidx] = table[tidx] < min ? min : table[tidx];\n        table[tidx] = table[tidx] > max ? max : table[tidx];\n      }\n    }\n  };\n}\n/* eslint-enable prefer-destructuring */\n\n/* eslint-enable no-continue */\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nvar DEFAULT_VALUES = {\n  // model.function = NULL;\n  range: [0, 0],\n  clamping: true,\n  allowDuplicateScalars: false\n}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Inheritance\n\n  macro.obj(publicAPI, model); // Internal objects initialization\n\n  model.nodes = []; // Create get-set macros\n\n  macro.setGet(publicAPI, model, ['allowDuplicateScalars', 'clamping']);\n  macro.setArray(publicAPI, model, ['range'], 2); // Create get macros for array\n\n  macro.getArray(publicAPI, model, ['range']); // For more macro methods, see \"Sources/macros.js\"\n  // Object specific methods\n\n  vtkPiecewiseFunction(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = macro.newInstance(extend, 'vtkPiecewiseFunction'); // ----------------------------------------------------------------------------\n\nvar vtkPiecewiseFunction$1 = {\n  newInstance: newInstance,\n  extend: extend\n};\nexport { vtkPiecewiseFunction$1 as default, extend, newInstance };","map":{"version":3,"names":["macro","vtkErrorMacro","vtkPiecewiseFunction","publicAPI","model","classHierarchy","push","getSize","nodes","length","getType","value","prevValue","functionType","y","i","getDataPointer","size","function","x","getFirstNonZeroValue","allZero","Number","MAX_VALUE","clamping","getNodeValue","index","val","midpoint","sharpness","setNodeValue","oldX","sortAndUpdateRange","modified","addPoint","addPointLong","allowDuplicateScalars","removePoint","node","setNodes","sort","a","b","modifiedInvoked","updateRange","oldRange","range","slice","retVal","splice","removeAllPoints","addSegment","x1","y1","x2","y2","getValue","table","getTable","adjustRange","functionRange","getRange","estimateMinNumberOfSamples","d","findMinimumXDistance","Math","ceil","distance","currentDist","xStart","xEnd","stride","arguments","undefined","idx","numNodes","lastValue","tidx","s","pow","ss","sss","h1","h2","h3","h4","slope","t","min","max","DEFAULT_VALUES","extend","initialValues","Object","assign","obj","setGet","setArray","getArray","newInstance","vtkPiecewiseFunction$1","default"],"sources":["/home/rakshith/Documents/RemoteRendering/vtk-js-react-app/node_modules/@kitware/vtk.js/Common/DataModel/PiecewiseFunction.js"],"sourcesContent":["import macro from '../../macros.js';\n\nvar vtkErrorMacro = macro.vtkErrorMacro; // ----------------------------------------------------------------------------\n// vtkPiecewiseFunction methods\n// ----------------------------------------------------------------------------\n\nfunction vtkPiecewiseFunction(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkPiecewiseFunction'); // Return the number of points which specify this function\n\n  publicAPI.getSize = function () {\n    return model.nodes.length;\n  }; // Return the type of function stored in object:\n  // Function Types:\n  //    0 : Constant        (No change in slope between end points)\n  //    1 : NonDecreasing   (Always increasing or zero slope)\n  //    2 : NonIncreasing   (Always decreasing or zero slope)\n  //    3 : Varied          (Contains both decreasing and increasing slopes)\n  //    4 : Unknown         (Error condition)\n  //\n\n\n  publicAPI.getType = function () {\n    var value;\n    var prevValue = 0.0;\n    var functionType = 0;\n\n    if (model.nodes.length > 0) {\n      prevValue = model.nodes[0].y;\n    }\n\n    for (var i = 1; i < model.nodes.length; i++) {\n      value = model.nodes[i].y; // Do not change the function type if equal\n\n      if (value !== prevValue) {\n        if (value > prevValue) {\n          switch (functionType) {\n            case 0:\n            case 1:\n              // NonDecreasing\n              functionType = 1;\n              break;\n\n            case 2:\n            default:\n              // Varied\n              functionType = 3;\n              break;\n          }\n        } else {\n          // value < prev_value\n          switch (functionType) {\n            case 0:\n            case 2:\n              // NonIncreasing\n              functionType = 2;\n              break;\n\n            case 1:\n            default:\n              // Varied\n              functionType = 3;\n              break;\n          }\n        }\n      }\n\n      prevValue = value; // Exit loop if we find a Varied function\n\n      if (functionType === 3) {\n        break;\n      }\n    }\n\n    switch (functionType) {\n      case 0:\n        return 'Constant';\n\n      case 1:\n        return 'NonDecreasing';\n\n      case 2:\n        return 'NonIncreasing';\n\n      case 3:\n      default:\n        return 'Varied';\n    }\n  }; // Since we no longer store the data in an array, we must\n  // copy out of the vector into an array. No modified check -\n  // could be added if performance is a problem\n\n\n  publicAPI.getDataPointer = function () {\n    var size = model.nodes.length;\n    model.function = null;\n\n    if (size > 0) {\n      model.function = [];\n\n      for (var i = 0; i < size; i++) {\n        model.function[2 * i] = model.nodes[i].x;\n        model.function[2 * i + 1] = model.nodes[i].y;\n      }\n    }\n\n    return model.function;\n  }; // Returns the first point location which starts a non-zero segment of the\n  // function. Note that the value at this point may be zero.\n\n\n  publicAPI.getFirstNonZeroValue = function () {\n    // Check if no points specified\n    if (model.nodes.length === 0) {\n      return 0;\n    }\n\n    var allZero = 1;\n    var x = 0.0;\n    var i = 0;\n\n    for (; i < model.nodes.length; i++) {\n      if (model.nodes[i].y !== 0.0) {\n        allZero = 0;\n        break;\n      }\n    } // If every specified point has a zero value then return\n    // a large value\n\n\n    if (allZero) {\n      x = Number.MAX_VALUE;\n    } else if (i > 0) {\n      // A point was found with a non-zero value\n      // Return the value of the point that precedes this one\n      x = model.nodes[i - 1].x;\n    } else if (model.clamping) {\n      // If this is the first point in the function, return its\n      // value is clamping is off, otherwise VTK_DOUBLE_MIN if\n      // clamping is on.\n      x = -Number.MAX_VALUE;\n    } else {\n      x = model.nodes[0].x;\n    }\n\n    return x;\n  }; // For a specified index value, get the node parameters\n\n\n  publicAPI.getNodeValue = function (index, val) {\n    var size = model.nodes.length;\n\n    if (index < 0 || index >= size) {\n      vtkErrorMacro('Index out of range!');\n      return -1;\n    }\n\n    val[0] = model.nodes[index].x;\n    val[1] = model.nodes[index].y;\n    val[2] = model.nodes[index].midpoint;\n    val[3] = model.nodes[index].sharpness;\n    return 1;\n  }; // For a specified index value, get the node parameters\n\n\n  publicAPI.setNodeValue = function (index, val) {\n    var size = model.nodes.length;\n\n    if (index < 0 || index >= size) {\n      vtkErrorMacro('Index out of range!');\n      return -1;\n    }\n\n    var oldX = model.nodes[index].x;\n    model.nodes[index].x = val[0];\n    model.nodes[index].y = val[1];\n    model.nodes[index].midpoint = val[2];\n    model.nodes[index].sharpness = val[3];\n\n    if (oldX !== val[0]) {\n      // The point has been moved, the order of points or the range might have\n      // been modified.\n      publicAPI.sortAndUpdateRange(); // No need to call Modified() here because SortAndUpdateRange() has done it\n      // already.\n    } else {\n      publicAPI.modified();\n    }\n\n    return 1;\n  }; // Adds a point to the function. If a duplicate point is inserted\n  // then the function value at that location is set to the new value.\n  // This is the legacy version that assumes midpoint = 0.5 and\n  // sharpness = 0.0\n\n\n  publicAPI.addPoint = function (x, y) {\n    return publicAPI.addPointLong(x, y, 0.5, 0.0);\n  }; // Adds a point to the function and returns the array index of the point.\n\n\n  publicAPI.addPointLong = function (x, y, midpoint, sharpness) {\n    // Error check\n    if (midpoint < 0.0 || midpoint > 1.0) {\n      vtkErrorMacro('Midpoint outside range [0.0, 1.0]');\n      return -1;\n    }\n\n    if (sharpness < 0.0 || sharpness > 1.0) {\n      vtkErrorMacro('Sharpness outside range [0.0, 1.0]');\n      return -1;\n    } // remove any node already at this X location\n\n\n    if (!model.allowDuplicateScalars) {\n      publicAPI.removePoint(x);\n    } // Create the new node\n\n\n    var node = {\n      x: x,\n      y: y,\n      midpoint: midpoint,\n      sharpness: sharpness\n    }; // Add it, then sort to get everything in order\n\n    model.nodes.push(node);\n    publicAPI.sortAndUpdateRange(); // Now find this node so we can return the index\n\n    var i;\n\n    for (i = 0; i < model.nodes.length; i++) {\n      if (model.nodes[i].x === x) {\n        break;\n      }\n    } // If we didn't find it, something went horribly wrong so\n    // return -1\n\n\n    if (i < model.nodes.length) {\n      return i;\n    }\n\n    return -1;\n  };\n\n  publicAPI.setNodes = function (nodes) {\n    if (model.nodes !== nodes) {\n      model.nodes = nodes;\n      publicAPI.sortAndUpdateRange();\n    }\n  }; // Sort the vector in increasing order, then fill in\n  // the Range\n\n\n  publicAPI.sortAndUpdateRange = function () {\n    model.nodes.sort(function (a, b) {\n      return a.x - b.x;\n    });\n    var modifiedInvoked = publicAPI.updateRange(); // If range is updated, Modified() has been called, don't call it again.\n\n    if (!modifiedInvoked) {\n      publicAPI.modified();\n    }\n  }; //----------------------------------------------------------------------------\n\n\n  publicAPI.updateRange = function () {\n    var oldRange = model.range.slice();\n    var size = model.nodes.length;\n\n    if (size) {\n      model.range[0] = model.nodes[0].x;\n      model.range[1] = model.nodes[size - 1].x;\n    } else {\n      model.range[0] = 0;\n      model.range[1] = 0;\n    } // If the rage is the same, then no need to call Modified()\n\n\n    if (oldRange[0] === model.range[0] && oldRange[1] === model.range[1]) {\n      return false;\n    }\n\n    publicAPI.modified();\n    return true;\n  }; // Removes a point from the function. If no point is found then function\n  // remains the same.\n\n\n  publicAPI.removePoint = function (x) {\n    // First find the node since we need to know its\n    // index as our return value\n    var i;\n\n    for (i = 0; i < model.nodes.length; i++) {\n      if (model.nodes[i].x === x) {\n        break;\n      }\n    } // If the node doesn't exist, we return -1\n\n\n    if (i >= model.nodes.length) {\n      return -1;\n    }\n\n    var retVal = i; // If the first or last point has been removed, then we update the range\n    // No need to sort here as the order of points hasn't changed.\n\n    var modifiedInvoked = false;\n    model.nodes.splice(i, 1);\n\n    if (i === 0 || i === model.nodes.length) {\n      modifiedInvoked = publicAPI.updateRange();\n    }\n\n    if (!modifiedInvoked) {\n      publicAPI.modified();\n    }\n\n    return retVal;\n  }; // Removes all points from the function.\n\n\n  publicAPI.removeAllPoints = function () {\n    model.nodes = [];\n    publicAPI.sortAndUpdateRange();\n  }; // Add in end points of line and remove any points between them\n  // Legacy method with no way to specify midpoint and sharpness\n\n\n  publicAPI.addSegment = function (x1, y1, x2, y2) {\n    // First, find all points in this range and remove them\n    publicAPI.sortAndUpdateRange();\n\n    for (var i = 0; i < model.nodes.length;) {\n      if (model.nodes[i].x >= x1 && model.nodes[i].x <= x2) {\n        model.nodes.splice(i, 1);\n      } else {\n        i++;\n      }\n    } // Now add the points\n\n\n    publicAPI.addPoint(x1, y1, 0.5, 0.0);\n    publicAPI.addPoint(x2, y2, 0.5, 0.0);\n  }; // Return the value of the function at a position\n\n\n  publicAPI.getValue = function (x) {\n    var table = [];\n    publicAPI.getTable(x, x, 1, table);\n    return table[0];\n  }; // Remove all points outside the range, and make sure a point\n  // exists at each end of the range. Used as a convenience method\n  // for transfer function editors\n\n\n  publicAPI.adjustRange = function (range) {\n    if (range.length < 2) {\n      return 0;\n    }\n\n    var functionRange = publicAPI.getRange(); // Make sure we have points at each end of the range\n\n    if (functionRange[0] < range[0]) {\n      publicAPI.addPoint(range[0], publicAPI.getValue(range[0]));\n    } else {\n      publicAPI.addPoint(range[0], publicAPI.getValue(functionRange[0]));\n    }\n\n    if (functionRange[1] > range[1]) {\n      publicAPI.addPoint(range[1], publicAPI.getValue(range[1]));\n    } else {\n      publicAPI.addPoint(range[1], publicAPI.getValue(functionRange[1]));\n    } // Remove all points out-of-range\n\n\n    publicAPI.sortAndUpdateRange();\n\n    for (var i = 0; i < model.nodes.length;) {\n      if (model.nodes[i].x >= range[0] && model.nodes[i].x <= range[1]) {\n        model.nodes.splice(i, 1);\n      } else {\n        ++i;\n      }\n    }\n\n    publicAPI.sortAndUpdateRange();\n    return 1;\n  }; //--------------------------------------------------------------------------\n\n\n  publicAPI.estimateMinNumberOfSamples = function (x1, x2) {\n    var d = publicAPI.findMinimumXDistance();\n    return Math.ceil((x2 - x1) / d);\n  }; //----------------------------------------------------------------------------\n\n\n  publicAPI.findMinimumXDistance = function () {\n    var size = model.nodes.length;\n\n    if (size < 2) {\n      return -1.0;\n    }\n\n    var distance = model.nodes[1].x - model.nodes[0].x;\n\n    for (var i = 0; i < size - 1; i++) {\n      var currentDist = model.nodes[i + 1].x - model.nodes[i].x;\n\n      if (currentDist < distance) {\n        distance = currentDist;\n      }\n    }\n\n    return distance;\n  }; // Returns a table of function values evaluated at regular intervals\n\n  /* eslint-disable prefer-destructuring */\n\n  /* eslint-disable no-continue */\n\n\n  publicAPI.getTable = function (xStart, xEnd, size, table) {\n    var stride = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1;\n    var i;\n    var idx = 0;\n    var numNodes = model.nodes.length; // Need to keep track of the last value so that\n    // we can fill in table locations past this with\n    // this value if Clamping is On.\n\n    var lastValue = 0.0;\n\n    if (numNodes !== 0) {\n      lastValue = model.nodes[numNodes - 1].y;\n    }\n\n    var x = 0.0;\n    var x1 = 0.0;\n    var x2 = 0.0;\n    var y1 = 0.0;\n    var y2 = 0.0;\n    var midpoint = 0.0;\n    var sharpness = 0.0; // For each table entry\n\n    for (i = 0; i < size; i++) {\n      // Find our location in the table\n      var tidx = stride * i; // Find our X location. If we are taking only 1 sample, make\n      // it halfway between start and end (usually start and end will\n      // be the same in this case)\n\n      if (size > 1) {\n        x = xStart + i / (size - 1.0) * (xEnd - xStart);\n      } else {\n        x = 0.5 * (xStart + xEnd);\n      } // Do we need to move to the next node?\n\n\n      while (idx < numNodes && x > model.nodes[idx].x) {\n        idx++; // If we are at a valid point index, fill in\n        // the value at this node, and the one before (the\n        // two that surround our current sample location)\n        // idx cannot be 0 since we just incremented it.\n\n        if (idx < numNodes) {\n          x1 = model.nodes[idx - 1].x;\n          x2 = model.nodes[idx].x;\n          y1 = model.nodes[idx - 1].y;\n          y2 = model.nodes[idx].y; // We only need the previous midpoint and sharpness\n          // since these control this region\n\n          midpoint = model.nodes[idx - 1].midpoint;\n          sharpness = model.nodes[idx - 1].sharpness; // Move midpoint away from extreme ends of range to avoid\n          // degenerate math\n\n          if (midpoint < 0.00001) {\n            midpoint = 0.00001;\n          }\n\n          if (midpoint > 0.99999) {\n            midpoint = 0.99999;\n          }\n        }\n      } // Are we at the end? If so, just use the last value\n\n\n      if (idx >= numNodes) {\n        table[tidx] = model.clamping ? lastValue : 0.0;\n      } else if (idx === 0) {\n        // Are we before the first node? If so, duplicate this nodes values\n        table[tidx] = model.clamping ? model.nodes[0].y : 0.0;\n      } else {\n        // Otherwise, we are between two nodes - interpolate\n        // Our first attempt at a normalized location [0,1] -\n        // we will be modifying this based on midpoint and\n        // sharpness to get the curve shape we want and to have\n        // it pass through (y1+y2)/2 at the midpoint.\n        var s = (x - x1) / (x2 - x1); // Readjust based on the midpoint - linear adjustment\n\n        if (s < midpoint) {\n          s = 0.5 * s / midpoint;\n        } else {\n          s = 0.5 + 0.5 * (s - midpoint) / (1.0 - midpoint);\n        } // override for sharpness > 0.99\n        // In this case we just want piecewise constant\n\n\n        if (sharpness > 0.99) {\n          // Use the first value since we are below the midpoint\n          if (s < 0.5) {\n            table[tidx] = y1;\n            continue;\n          } else {\n            // Use the second value at or above the midpoint\n            table[tidx] = y2;\n            continue;\n          }\n        } // Override for sharpness < 0.01\n        // In this case we want piecewise linear\n\n\n        if (sharpness < 0.01) {\n          // Simple linear interpolation\n          table[tidx] = (1 - s) * y1 + s * y2;\n          continue;\n        } // We have a sharpness between [0.01, 0.99] - we will\n        // used a modified hermite curve interpolation where we\n        // derive the slope based on the sharpness, and we compress\n        // the curve non-linearly based on the sharpness\n        // First, we will adjust our position based on sharpness in\n        // order to make the curve sharper (closer to piecewise constant)\n\n\n        if (s < 0.5) {\n          s = 0.5 * Math.pow(s * 2, 1.0 + 10 * sharpness);\n        } else if (s > 0.5) {\n          s = 1.0 - 0.5 * Math.pow((1.0 - s) * 2, 1 + 10 * sharpness);\n        } // Compute some coefficients we will need for the hermite curve\n\n\n        var ss = s * s;\n        var sss = ss * s;\n        var h1 = 2 * sss - 3 * ss + 1;\n        var h2 = -2 * sss + 3 * ss;\n        var h3 = sss - 2 * ss + s;\n        var h4 = sss - ss; // Use one slope for both end points\n\n        var slope = y2 - y1;\n        var t = (1.0 - sharpness) * slope; // Compute the value\n\n        table[tidx] = h1 * y1 + h2 * y2 + h3 * t + h4 * t; // Final error check to make sure we don't go outside\n        // the Y range\n\n        var min = y1 < y2 ? y1 : y2;\n        var max = y1 > y2 ? y1 : y2;\n        table[tidx] = table[tidx] < min ? min : table[tidx];\n        table[tidx] = table[tidx] > max ? max : table[tidx];\n      }\n    }\n  };\n}\n/* eslint-enable prefer-destructuring */\n\n/* eslint-enable no-continue */\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\n\nvar DEFAULT_VALUES = {\n  // model.function = NULL;\n  range: [0, 0],\n  clamping: true,\n  allowDuplicateScalars: false\n}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Inheritance\n\n  macro.obj(publicAPI, model); // Internal objects initialization\n\n  model.nodes = []; // Create get-set macros\n\n  macro.setGet(publicAPI, model, ['allowDuplicateScalars', 'clamping']);\n  macro.setArray(publicAPI, model, ['range'], 2); // Create get macros for array\n\n  macro.getArray(publicAPI, model, ['range']); // For more macro methods, see \"Sources/macros.js\"\n  // Object specific methods\n\n  vtkPiecewiseFunction(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = macro.newInstance(extend, 'vtkPiecewiseFunction'); // ----------------------------------------------------------------------------\n\nvar vtkPiecewiseFunction$1 = {\n  newInstance: newInstance,\n  extend: extend\n};\n\nexport { vtkPiecewiseFunction$1 as default, extend, newInstance };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}