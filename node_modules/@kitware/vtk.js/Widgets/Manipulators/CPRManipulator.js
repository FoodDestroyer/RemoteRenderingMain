import _defineProperty from '@babel/runtime/helpers/defineProperty';
import _toConsumableArray from '@babel/runtime/helpers/toConsumableArray';
import macro from '../../macros.js';
import vtkPlane from '../../Common/DataModel/Plane.js';
import vtkAbstractManipulator from './AbstractManipulator.js';
import { mat4, vec3, mat3 } from 'gl-matrix';

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function intersectDisplayWithPlane(x, y, planeOrigin, planeNormal, renderer, glRenderWindow) {
  var near = glRenderWindow.displayToWorld(x, y, 0, renderer);
  var far = glRenderWindow.displayToWorld(x, y, 1, renderer);
  return vtkPlane.intersectWithLine(near, far, planeOrigin, planeNormal).x;
} // ----------------------------------------------------------------------------
// vtkCPRManipulator methods
// ----------------------------------------------------------------------------

function vtkCPRManipulator(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkCPRManipulator');

  publicAPI.handleEvent = function (callData, glRenderWindow) {
    var _model$cprActor;

    var mapper = (_model$cprActor = model.cprActor) === null || _model$cprActor === void 0 ? void 0 : _model$cprActor.getMapper();

    if (!mapper) {
      return {
        worldCoords: null
      };
    } // Get normal and origin of the picking plane from the actor matrix


    var cprActorMatrix = [];
    mat4.transpose(cprActorMatrix, model.cprActor.getMatrix());
    var worldPlaneNormal = cprActorMatrix.slice(8, 11); // 3rd column

    var worldPlaneOrigin = cprActorMatrix.slice(12, 15); // 4th column
    // Convert world plane position to 2D position in the plane

    var inversecprActorMatrix = [];
    mat4.invert(inversecprActorMatrix, cprActorMatrix);
    var worldPlanePicking = intersectDisplayWithPlane(callData.position.x, callData.position.y, worldPlaneOrigin, worldPlaneNormal, callData.pokedRenderer, glRenderWindow);
    var modelPlanePicking = []; // (x, height - distance, 0)

    vec3.transformMat4(modelPlanePicking, worldPlanePicking, inversecprActorMatrix);
    var height = mapper.getHeight();
    var distance = height - modelPlanePicking[1];
    return publicAPI.distanceEvent(distance);
  };

  publicAPI.distanceEvent = function (distance) {
    var _model$cprActor2;

    var mapper = (_model$cprActor2 = model.cprActor) === null || _model$cprActor2 === void 0 ? void 0 : _model$cprActor2.getMapper();

    if (!mapper) {
      return {
        worldCoords: null
      };
    }

    var height = mapper.getHeight();
    var clampedDistance = Math.max(0, Math.min(height, distance));

    var _mapper$getCenterline = mapper.getCenterlinePositionAndOrientation(clampedDistance),
        position = _mapper$getCenterline.position,
        orientation = _mapper$getCenterline.orientation;

    var worldDirection;

    if (orientation) {
      var modelDirections = mat3.fromQuat([], orientation);
      var baseDirections = mapper.getDirectionMatrix();
      worldDirection = mat3.mul([], modelDirections, baseDirections);
    }

    model.currentDistance = clampedDistance;
    return {
      worldCoords: position,
      worldDirection: worldDirection
    };
  };

  publicAPI.handleScroll = function (nbSteps) {
    var distance = model.currentDistance + publicAPI.getDistanceStep() * nbSteps;
    return publicAPI.distanceEvent(distance);
  };

  publicAPI.getDistanceStep = function () {
    // Find default distanceStep from image spacing
    // This only works if the mapper in the actor already has an ImageData
    if (!model.distanceStep) {
      var _model$cprActor3, _model$cprActor3$getM, _model$cprActor3$getM2, _model$cprActor3$getM3;

      var imageSpacing = (_model$cprActor3 = model.cprActor) === null || _model$cprActor3 === void 0 ? void 0 : (_model$cprActor3$getM = _model$cprActor3.getMapper()) === null || _model$cprActor3$getM === void 0 ? void 0 : (_model$cprActor3$getM2 = _model$cprActor3$getM.getInputData(0)) === null || _model$cprActor3$getM2 === void 0 ? void 0 : (_model$cprActor3$getM3 = _model$cprActor3$getM2.getSpacing) === null || _model$cprActor3$getM3 === void 0 ? void 0 : _model$cprActor3$getM3.call(_model$cprActor3$getM2);

      if (imageSpacing) {
        return Math.min.apply(Math, _toConsumableArray(imageSpacing));
      }
    }

    return model.distanceStep;
  };
} // ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------
// currentDistance is the distance from the first point of the centerline
// cprActor.getMapper() should be a vtkImageCPRMapper


function defaultValues(initialValues) {
  return _objectSpread({
    distanceStep: 0,
    currentDistance: 0,
    cprActor: null
  }, initialValues);
} // ----------------------------------------------------------------------------


function extend(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  vtkAbstractManipulator.extend(publicAPI, model, defaultValues(initialValues));
  macro.setGet(publicAPI, model, ['distance', 'currentDistance', 'cprActor']);
  macro.set(publicAPI, model, ['distanceStep']);
  vtkCPRManipulator(publicAPI, model);
} // ----------------------------------------------------------------------------

var newInstance = macro.newInstance(extend, 'vtkCPRManipulator'); // ----------------------------------------------------------------------------

var index = {
  intersectDisplayWithPlane: intersectDisplayWithPlane,
  extend: extend,
  newInstance: newInstance
};

export { index as default, extend, intersectDisplayWithPlane, newInstance };
