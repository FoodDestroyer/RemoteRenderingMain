{"ast":null,"code":"import macro from '../../macros.js';\nimport vtkDataArray from '../../Common/Core/DataArray.js';\nimport vtkImageData from '../../Common/DataModel/ImageData.js';\nvar vtkErrorMacro = macro.vtkErrorMacro; // ----------------------------------------------------------------------------\n// vtkImageOutlineFilter methods\n// ----------------------------------------------------------------------------\n\nfunction vtkImageOutlineFilter(publicAPI, model) {\n  model.classHierarchy.push('vtkImageOutlineFilter');\n  publicAPI.requestData = function (inData, outData) {\n    // implement requestData\n    var input = inData[0];\n    if (!input || input.getClassName() !== 'vtkImageData') {\n      vtkErrorMacro('Invalid or missing input');\n      return;\n    }\n    var output = vtkImageData.newInstance(input.get('spacing', 'origin', 'direction'));\n    var getIndex = function getIndex(point, dims) {\n      return point[0] + point[1] * dims[0] + point[2] * dims[0] * dims[1];\n    };\n    var getIJK = function getIJK(index, dims) {\n      var ijk = [0, 0, 0];\n      ijk[0] = index % dims[0];\n      ijk[1] = Math.floor(index / dims[0]) % dims[1];\n      ijk[2] = Math.floor(index / (dims[0] * dims[1]));\n      return ijk;\n    };\n    var dims = input.getDimensions();\n    output.setDimensions(dims);\n    output.computeTransforms();\n    var values = new Uint8Array(input.getNumberOfPoints());\n    var inputDataArray = input.getPointData().getScalars().getData();\n    var kernelX = 0; // default K slicing mode\n\n    var kernelY = 1;\n    if (model.slicingMode === 1) {\n      kernelX = 0;\n      kernelY = 2;\n    } else if (model.slicingMode === 0) {\n      kernelX = 1;\n      kernelY = 2;\n    }\n    inputDataArray.forEach(function (el, index) {\n      if (el !== model.background) {\n        var ijk = getIJK(index, dims);\n        var isBorder = false;\n        for (var x = -1; x <= 1 && !isBorder; x++) {\n          for (var y = -1; y <= 1 && !isBorder; y++) {\n            var dx = x;\n            var dy = y;\n            var dz = 0;\n            if (model.slicingMode === 1) {\n              dx = x;\n              dy = 0;\n              dz = y;\n            } else if (model.slicingMode === 0) {\n              dx = 0;\n              dy = y;\n              dz = x;\n            }\n            var evalX = ijk[kernelX] + dx;\n            var evalY = ijk[kernelY] + dy; // check boundaries\n\n            if (evalX >= 0 && evalX < dims[kernelX] && evalY >= 0 && evalY < dims[kernelY]) {\n              var hoodValue = inputDataArray[getIndex([ijk[0] + dx, ijk[1] + dy, ijk[2] + dz], dims)];\n              if (hoodValue !== el) isBorder = true;\n            }\n          }\n        }\n        if (isBorder) values[index] = el;else values[index] = model.background;\n      } else {\n        values[index] = model.background;\n      }\n    });\n    var dataArray = vtkDataArray.newInstance({\n      numberOfComponents: 1,\n      values: values\n    });\n    output.getPointData().setScalars(dataArray);\n    outData[0] = output;\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nvar DEFAULT_VALUES = {\n  slicingMode: 2,\n  background: 0\n}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Make this a VTK object\n\n  macro.obj(publicAPI, model); // Also make it an algorithm with one input and one output\n\n  macro.algo(publicAPI, model, 1, 1);\n  macro.setGet(publicAPI, model, ['slicingMode', 'background']); // Object specific methods\n\n  vtkImageOutlineFilter(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = macro.newInstance(extend, 'vtkImageOutlineFilter'); // ----------------------------------------------------------------------------\n\nvar vtkImageOutlineFilter$1 = {\n  newInstance: newInstance,\n  extend: extend\n};\nexport { vtkImageOutlineFilter$1 as default, extend, newInstance };","map":{"version":3,"names":["macro","vtkDataArray","vtkImageData","vtkErrorMacro","vtkImageOutlineFilter","publicAPI","model","classHierarchy","push","requestData","inData","outData","input","getClassName","output","newInstance","get","getIndex","point","dims","getIJK","index","ijk","Math","floor","getDimensions","setDimensions","computeTransforms","values","Uint8Array","getNumberOfPoints","inputDataArray","getPointData","getScalars","getData","kernelX","kernelY","slicingMode","forEach","el","background","isBorder","x","y","dx","dy","dz","evalX","evalY","hoodValue","dataArray","numberOfComponents","setScalars","DEFAULT_VALUES","extend","initialValues","arguments","length","undefined","Object","assign","obj","algo","setGet","vtkImageOutlineFilter$1","default"],"sources":["/home/rakshith/Documents/RemoteRendering/vtk-js-react-app/node_modules/@kitware/vtk.js/Filters/General/ImageOutlineFilter.js"],"sourcesContent":["import macro from '../../macros.js';\nimport vtkDataArray from '../../Common/Core/DataArray.js';\nimport vtkImageData from '../../Common/DataModel/ImageData.js';\n\nvar vtkErrorMacro = macro.vtkErrorMacro; // ----------------------------------------------------------------------------\n// vtkImageOutlineFilter methods\n// ----------------------------------------------------------------------------\n\nfunction vtkImageOutlineFilter(publicAPI, model) {\n  model.classHierarchy.push('vtkImageOutlineFilter');\n\n  publicAPI.requestData = function (inData, outData) {\n    // implement requestData\n    var input = inData[0];\n\n    if (!input || input.getClassName() !== 'vtkImageData') {\n      vtkErrorMacro('Invalid or missing input');\n      return;\n    }\n\n    var output = vtkImageData.newInstance(input.get('spacing', 'origin', 'direction'));\n\n    var getIndex = function getIndex(point, dims) {\n      return point[0] + point[1] * dims[0] + point[2] * dims[0] * dims[1];\n    };\n\n    var getIJK = function getIJK(index, dims) {\n      var ijk = [0, 0, 0];\n      ijk[0] = index % dims[0];\n      ijk[1] = Math.floor(index / dims[0]) % dims[1];\n      ijk[2] = Math.floor(index / (dims[0] * dims[1]));\n      return ijk;\n    };\n\n    var dims = input.getDimensions();\n    output.setDimensions(dims);\n    output.computeTransforms();\n    var values = new Uint8Array(input.getNumberOfPoints());\n    var inputDataArray = input.getPointData().getScalars().getData();\n    var kernelX = 0; // default K slicing mode\n\n    var kernelY = 1;\n\n    if (model.slicingMode === 1) {\n      kernelX = 0;\n      kernelY = 2;\n    } else if (model.slicingMode === 0) {\n      kernelX = 1;\n      kernelY = 2;\n    }\n\n    inputDataArray.forEach(function (el, index) {\n      if (el !== model.background) {\n        var ijk = getIJK(index, dims);\n        var isBorder = false;\n\n        for (var x = -1; x <= 1 && !isBorder; x++) {\n          for (var y = -1; y <= 1 && !isBorder; y++) {\n            var dx = x;\n            var dy = y;\n            var dz = 0;\n\n            if (model.slicingMode === 1) {\n              dx = x;\n              dy = 0;\n              dz = y;\n            } else if (model.slicingMode === 0) {\n              dx = 0;\n              dy = y;\n              dz = x;\n            }\n\n            var evalX = ijk[kernelX] + dx;\n            var evalY = ijk[kernelY] + dy; // check boundaries\n\n            if (evalX >= 0 && evalX < dims[kernelX] && evalY >= 0 && evalY < dims[kernelY]) {\n              var hoodValue = inputDataArray[getIndex([ijk[0] + dx, ijk[1] + dy, ijk[2] + dz], dims)];\n              if (hoodValue !== el) isBorder = true;\n            }\n          }\n        }\n\n        if (isBorder) values[index] = el;else values[index] = model.background;\n      } else {\n        values[index] = model.background;\n      }\n    });\n    var dataArray = vtkDataArray.newInstance({\n      numberOfComponents: 1,\n      values: values\n    });\n    output.getPointData().setScalars(dataArray);\n    outData[0] = output;\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\n\nvar DEFAULT_VALUES = {\n  slicingMode: 2,\n  background: 0\n}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Make this a VTK object\n\n  macro.obj(publicAPI, model); // Also make it an algorithm with one input and one output\n\n  macro.algo(publicAPI, model, 1, 1);\n  macro.setGet(publicAPI, model, ['slicingMode', 'background']); // Object specific methods\n\n  vtkImageOutlineFilter(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = macro.newInstance(extend, 'vtkImageOutlineFilter'); // ----------------------------------------------------------------------------\n\nvar vtkImageOutlineFilter$1 = {\n  newInstance: newInstance,\n  extend: extend\n};\n\nexport { vtkImageOutlineFilter$1 as default, extend, newInstance };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}