{"ast":null,"code":"import _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport _classCallCheck from '@babel/runtime/helpers/classCallCheck';\nimport _createClass from '@babel/runtime/helpers/createClass';\nimport macro from '../../macros.js';\nimport Constants from './BufferManager/Constants.js';\nimport vtkProperty from '../Core/Property.js';\nimport vtkWebGPUBuffer from './Buffer.js';\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n  return target;\n}\nvar Representation = vtkProperty.Representation;\nvar PrimitiveTypes = Constants.PrimitiveTypes; // Simulate a small map of pointId to flatId for a cell. The original code\n// used a map and was 2.6x slower (4.7 to 1.9 seconds). Using two fixed\n// length arrays with a count is so much faster even with the required for\n// loops and if statements. This only works as we know the usage is\n// restricted to clear(), set() get() and has() so the count is always\n// incrmenting except for clear where it goes back to 0. Performance\n// improvement is probably due to this appoach not hitting the heap but wow\n// it is so much faster. Code that adds to these vectors checks against 9 to\n// make sure there is room. Switching to test against vec.length -1 results\n// in a small performance hit, so if you change 10, search for 9 in this\n// small class and change those as well.\n\nvar _LimitedMap = /*#__PURE__*/function () {\n  function _LimitedMap() {\n    _classCallCheck(this, _LimitedMap);\n    this.keys = new Uint32Array(10);\n    this.values = new Uint32Array(10);\n    this.count = 0;\n  }\n  _createClass(_LimitedMap, [{\n    key: \"clear\",\n    value: function clear() {\n      this.count = 0;\n    }\n  }, {\n    key: \"has\",\n    value: function has(key) {\n      for (var i = 0; i < this.count; i++) {\n        if (this.keys[i] === key) {\n          return true;\n        }\n      }\n      return undefined;\n    }\n  }, {\n    key: \"get\",\n    value: function get(key) {\n      for (var i = 0; i < this.count; i++) {\n        if (this.keys[i] === key) {\n          return this.values[i];\n        }\n      }\n      return undefined;\n    }\n  }, {\n    key: \"set\",\n    value: function set(key, value) {\n      if (this.count < 9) {\n        this.keys[this.count] = key;\n        this.values[this.count++] = value;\n      }\n    }\n  }]);\n  return _LimitedMap;\n}();\nfunction getPrimitiveName(primType) {\n  switch (primType) {\n    case PrimitiveTypes.Points:\n      return 'points';\n    case PrimitiveTypes.Lines:\n      return 'lines';\n    case PrimitiveTypes.Triangles:\n    case PrimitiveTypes.TriangleEdges:\n      return 'polys';\n    case PrimitiveTypes.TriangleStripEdges:\n    case PrimitiveTypes.TriangleStrips:\n      return 'strips';\n    default:\n      return '';\n  }\n}\nfunction _getOrAddFlatId(state, ptId, cellId) {\n  var flatId = state.pointIdToFlatId[ptId];\n  if (flatId < 0) {\n    flatId = state.flatId;\n    state.pointIdToFlatId[ptId] = flatId;\n    state.flatIdToPointId[state.flatId] = ptId;\n    state.flatIdToCellId[state.flatId] = cellId;\n    state.flatId++;\n  }\n  return flatId;\n}\nfunction fillCell(ptIds, cellId, state) {\n  var numPtIds = ptIds.length; // are any points already marked for this cell? If so use that as the provoking point\n\n  for (var ptIdx = 0; ptIdx < numPtIds; ptIdx++) {\n    var _ptId = ptIds[ptIdx];\n    if (state.cellProvokedMap.has(_ptId)) {\n      state.ibo[state.iboId++] = state.cellProvokedMap.get(_ptId); // insert remaining ptIds (they do not need to provoke)\n\n      for (var ptIdx2 = ptIdx + 1; ptIdx2 < ptIdx + numPtIds; ptIdx2++) {\n        _ptId = ptIds[ptIdx2 % numPtIds];\n        var _flatId = _getOrAddFlatId(state, _ptId, cellId); // add to ibo\n\n        state.ibo[state.iboId++] = _flatId;\n      } // all done now\n\n      return;\n    }\n  } // else have any of the points not been used yet? (not in provokedPointIds)\n\n  for (var _ptIdx = 0; _ptIdx < numPtIds; _ptIdx++) {\n    var _ptId2 = ptIds[_ptIdx];\n    if (!state.provokedPointIds[_ptId2]) {\n      var _flatId2 = _getOrAddFlatId(state, _ptId2, cellId); // mark provoking and add to ibo\n\n      state.provokedPointIds[_ptId2] = 1;\n      state.cellProvokedMap.set(_ptId2, _flatId2); // when provoking always set the cellId as an original non-provoking value\n      // will have been stored and we need to overwrite that\n\n      state.flatIdToCellId[_flatId2] = cellId;\n      state.ibo[state.iboId++] = _flatId2; // insert remaining ptIds (they do not need to provoke)\n\n      for (var _ptIdx2 = _ptIdx + 1; _ptIdx2 < _ptIdx + numPtIds; _ptIdx2++) {\n        _ptId2 = ptIds[_ptIdx2 % numPtIds];\n        _flatId2 = _getOrAddFlatId(state, _ptId2, cellId); // add to ibo\n\n        state.ibo[state.iboId++] = _flatId2;\n      } // all done now\n\n      return;\n    }\n  } // if we got here then none of the ptIds could be used to provoke\n  // so just duplicate the first one\n\n  var ptId = ptIds[0];\n  var flatId = state.flatId;\n  state.cellProvokedMap.set(ptId, flatId);\n  state.flatIdToPointId[state.flatId] = ptId;\n  state.flatIdToCellId[state.flatId] = cellId;\n  state.flatId++; // add to ibo\n\n  state.ibo[state.iboId++] = flatId; // insert remaining ptIds (they do not need to provoke)\n\n  for (var _ptIdx3 = 1; _ptIdx3 < numPtIds; _ptIdx3++) {\n    ptId = ptIds[_ptIdx3];\n    flatId = _getOrAddFlatId(state, ptId, cellId); // add to ibo\n\n    state.ibo[state.iboId++] = flatId;\n  }\n}\nfunction countCell(ptIds, cellId, state) {\n  var numPtIds = ptIds.length;\n  state.iboSize += numPtIds; // are any points already marked for this cell? If so use that as the provoking point\n\n  for (var ptIdx = 0; ptIdx < numPtIds; ptIdx++) {\n    var ptId = ptIds[ptIdx];\n    if (state.cellProvokedMap.has(ptId)) {\n      return;\n    }\n  } // else have any of the points not been used yet? (not in provokedPointIds)\n\n  for (var _ptIdx4 = 0; _ptIdx4 < numPtIds; _ptIdx4++) {\n    var _ptId3 = ptIds[_ptIdx4];\n    if (!state.provokedPointIds[_ptId3]) {\n      state.provokedPointIds[_ptId3] = 1;\n      state.cellProvokedMap.set(_ptId3, 1);\n      return;\n    }\n  } // if we got here then none of the ptIds could be used to provoke\n\n  state.cellProvokedMap.set(ptIds[0], 1);\n  state.extraPoints++;\n}\nvar processCell;\nvar _single = new Uint32Array(1);\nvar _double = new Uint32Array(2);\nvar _triple = new Uint32Array(3);\nvar _indexCellBuilders = {\n  // easy, every input point becomes an output point\n  anythingToPoints: function anythingToPoints(numPoints, cellPts, offset, cellId, state) {\n    for (var i = 0; i < numPoints; ++i) {\n      _single[0] = cellPts[offset + i];\n      processCell(_single, cellId, state);\n    }\n  },\n  linesToWireframe: function linesToWireframe(numPoints, cellPts, offset, cellId, state) {\n    // for lines we add a bunch of segments\n    for (var i = 0; i < numPoints - 1; ++i) {\n      _double[0] = cellPts[offset + i];\n      _double[1] = cellPts[offset + i + 1];\n      processCell(_double, cellId, state);\n    }\n  },\n  polysToWireframe: function polysToWireframe(numPoints, cellPts, offset, cellId, state) {\n    // for polys we add a bunch of segments and close it\n    if (numPoints > 2) {\n      for (var i = 0; i < numPoints; ++i) {\n        _double[0] = cellPts[offset + i];\n        _double[1] = cellPts[offset + (i + 1) % numPoints];\n        processCell(_double, cellId, state);\n      }\n    }\n  },\n  stripsToWireframe: function stripsToWireframe(numPoints, cellPts, offset, cellId, state) {\n    if (numPoints > 2) {\n      // for strips we add a bunch of segments and close it\n      for (var i = 0; i < numPoints - 1; ++i) {\n        _double[0] = cellPts[offset + i];\n        _double[1] = cellPts[offset + i + 1];\n        processCell(_double, cellId, state);\n      }\n      for (var _i = 0; _i < numPoints - 2; _i++) {\n        _double[0] = cellPts[offset + _i];\n        _double[1] = cellPts[offset + _i + 2];\n        processCell(_double, cellId, state);\n      }\n    }\n  },\n  polysToSurface: function polysToSurface(npts, cellPts, offset, cellId, state) {\n    for (var i = 0; i < npts - 2; i++) {\n      _triple[0] = cellPts[offset];\n      _triple[1] = cellPts[offset + i + 1];\n      _triple[2] = cellPts[offset + i + 2];\n      processCell(_triple, cellId, state);\n    }\n  },\n  stripsToSurface: function stripsToSurface(npts, cellPts, offset, cellId, state) {\n    for (var i = 0; i < npts - 2; i++) {\n      _triple[0] = cellPts[offset + i];\n      _triple[1] = cellPts[offset + i + 1 + i % 2];\n      _triple[2] = cellPts[offset + i + 1 + (i + 1) % 2];\n      processCell(_triple, cellId, state);\n    }\n  }\n}; // ----------------------------------------------------------------------------\n// vtkWebGPUIndexBufferManager methods\n// ----------------------------------------------------------------------------\n\nfunction vtkWebGPUIndexBuffer(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkWebGPUIndexBuffer');\n  publicAPI.buildIndexBuffer = function (req) {\n    var cellArray = req.cells;\n    var primitiveType = req.primitiveType;\n    var representation = req.representation;\n    var cellOffset = req.cellOffset;\n    var array = cellArray.getData();\n    var cellArraySize = array.length;\n    var inRepName = getPrimitiveName(primitiveType);\n    var numPts = req.numberOfPoints;\n    var state = {\n      provokedPointIds: new Uint8Array(numPts),\n      // size is good\n      extraPoints: 0,\n      iboSize: 0,\n      flatId: 0,\n      iboId: 0,\n      cellProvokedMap: new _LimitedMap()\n    };\n    var func = null;\n    if (representation === Representation.POINTS || primitiveType === PrimitiveTypes.Points) {\n      func = _indexCellBuilders.anythingToPoints;\n    } else if (representation === Representation.WIREFRAME || primitiveType === PrimitiveTypes.Lines) {\n      func = _indexCellBuilders[\"\".concat(inRepName, \"ToWireframe\")];\n    } else {\n      func = _indexCellBuilders[\"\".concat(inRepName, \"ToSurface\")];\n    } // first we count how many extra provoking points we need\n\n    processCell = countCell;\n    var cellId = cellOffset || 0;\n    for (var cellArrayIndex = 0; cellArrayIndex < cellArraySize;) {\n      state.cellProvokedMap.clear();\n      func(array[cellArrayIndex], array, cellArrayIndex + 1, cellId, state);\n      cellArrayIndex += array[cellArrayIndex] + 1;\n      cellId++;\n    } // then we allocate the remaining structures\n    // (we pick the best size to save space and transfer costs)\n\n    if (numPts <= 0xffff) {\n      state.flatIdToPointId = new Uint16Array(numPts + state.extraPoints);\n    } else {\n      state.flatIdToPointId = new Uint32Array(numPts + state.extraPoints);\n    }\n    if (numPts + state.extraPoints < 0x8fff) {\n      state.pointIdToFlatId = new Int16Array(numPts);\n    } else {\n      state.pointIdToFlatId = new Int32Array(numPts);\n    }\n    if (numPts + state.extraPoints <= 0xffff) {\n      state.ibo = new Uint16Array(state.iboSize);\n      req.format = 'uint16';\n    } else {\n      state.ibo = new Uint32Array(state.iboSize);\n      req.format = 'uint32';\n    }\n    if (cellId <= 0xffff) {\n      state.flatIdToCellId = new Uint16Array(numPts + state.extraPoints);\n    } else {\n      state.flatIdToCellId = new Uint32Array(numPts + state.extraPoints);\n    }\n    state.pointIdToFlatId.fill(-1);\n    state.provokedPointIds.fill(0); // and fill them in\n\n    processCell = fillCell;\n    cellId = cellOffset || 0;\n    for (var _cellArrayIndex = 0; _cellArrayIndex < cellArraySize;) {\n      state.cellProvokedMap.clear();\n      func(array[_cellArrayIndex], array, _cellArrayIndex + 1, cellId, state);\n      _cellArrayIndex += array[_cellArrayIndex] + 1;\n      cellId++;\n    }\n    delete state.provokedPointIds;\n    delete state.pointIdToFlatId; // store the results we need\n\n    req.nativeArray = state.ibo;\n    model.flatIdToPointId = state.flatIdToPointId;\n    model.flatIdToCellId = state.flatIdToCellId;\n    model.flatSize = state.flatId;\n    model.indexCount = state.iboId;\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nvar DEFAULT_VALUES = {\n  flatIdToPointId: null,\n  flatIdToCellId: null,\n  flatSize: 0,\n  indexCount: 0\n}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Inheritance\n\n  vtkWebGPUBuffer.extend(publicAPI, model, initialValues);\n  macro.setGet(publicAPI, model, ['flatIdToPointId', 'flatIdToCellId', 'flatSize', 'indexCount']);\n  vtkWebGPUIndexBuffer(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = macro.newInstance(extend); // ----------------------------------------------------------------------------\n\nvar vtkWebGPUIndexBuffer$1 = _objectSpread({\n  newInstance: newInstance,\n  extend: extend\n}, Constants);\nexport { vtkWebGPUIndexBuffer$1 as default, extend, newInstance };","map":{"version":3,"names":["_defineProperty","_classCallCheck","_createClass","macro","Constants","vtkProperty","vtkWebGPUBuffer","ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","getOwnPropertyDescriptors","defineProperties","defineProperty","Representation","PrimitiveTypes","_LimitedMap","Uint32Array","values","count","value","clear","has","undefined","get","set","getPrimitiveName","primType","Points","Lines","Triangles","TriangleEdges","TriangleStripEdges","TriangleStrips","_getOrAddFlatId","state","ptId","cellId","flatId","pointIdToFlatId","flatIdToPointId","flatIdToCellId","fillCell","ptIds","numPtIds","ptIdx","_ptId","cellProvokedMap","ibo","iboId","ptIdx2","_flatId","_ptIdx","_ptId2","provokedPointIds","_flatId2","_ptIdx2","_ptIdx3","countCell","iboSize","_ptIdx4","_ptId3","extraPoints","processCell","_single","_double","_triple","_indexCellBuilders","anythingToPoints","numPoints","cellPts","offset","linesToWireframe","polysToWireframe","stripsToWireframe","_i","polysToSurface","npts","stripsToSurface","vtkWebGPUIndexBuffer","publicAPI","model","classHierarchy","buildIndexBuffer","req","cellArray","cells","primitiveType","representation","cellOffset","array","getData","cellArraySize","inRepName","numPts","numberOfPoints","Uint8Array","func","POINTS","WIREFRAME","concat","cellArrayIndex","Uint16Array","Int16Array","Int32Array","format","fill","_cellArrayIndex","nativeArray","flatSize","indexCount","DEFAULT_VALUES","extend","initialValues","assign","setGet","newInstance","vtkWebGPUIndexBuffer$1","default"],"sources":["/home/rakshith/Documents/RemoteRendering/vtk-js-react-app/node_modules/@kitware/vtk.js/Rendering/WebGPU/IndexBuffer.js"],"sourcesContent":["import _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport _classCallCheck from '@babel/runtime/helpers/classCallCheck';\nimport _createClass from '@babel/runtime/helpers/createClass';\nimport macro from '../../macros.js';\nimport Constants from './BufferManager/Constants.js';\nimport vtkProperty from '../Core/Property.js';\nimport vtkWebGPUBuffer from './Buffer.js';\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nvar Representation = vtkProperty.Representation;\nvar PrimitiveTypes = Constants.PrimitiveTypes; // Simulate a small map of pointId to flatId for a cell. The original code\n// used a map and was 2.6x slower (4.7 to 1.9 seconds). Using two fixed\n// length arrays with a count is so much faster even with the required for\n// loops and if statements. This only works as we know the usage is\n// restricted to clear(), set() get() and has() so the count is always\n// incrmenting except for clear where it goes back to 0. Performance\n// improvement is probably due to this appoach not hitting the heap but wow\n// it is so much faster. Code that adds to these vectors checks against 9 to\n// make sure there is room. Switching to test against vec.length -1 results\n// in a small performance hit, so if you change 10, search for 9 in this\n// small class and change those as well.\n\nvar _LimitedMap = /*#__PURE__*/function () {\n  function _LimitedMap() {\n    _classCallCheck(this, _LimitedMap);\n\n    this.keys = new Uint32Array(10);\n    this.values = new Uint32Array(10);\n    this.count = 0;\n  }\n\n  _createClass(_LimitedMap, [{\n    key: \"clear\",\n    value: function clear() {\n      this.count = 0;\n    }\n  }, {\n    key: \"has\",\n    value: function has(key) {\n      for (var i = 0; i < this.count; i++) {\n        if (this.keys[i] === key) {\n          return true;\n        }\n      }\n\n      return undefined;\n    }\n  }, {\n    key: \"get\",\n    value: function get(key) {\n      for (var i = 0; i < this.count; i++) {\n        if (this.keys[i] === key) {\n          return this.values[i];\n        }\n      }\n\n      return undefined;\n    }\n  }, {\n    key: \"set\",\n    value: function set(key, value) {\n      if (this.count < 9) {\n        this.keys[this.count] = key;\n        this.values[this.count++] = value;\n      }\n    }\n  }]);\n\n  return _LimitedMap;\n}();\n\nfunction getPrimitiveName(primType) {\n  switch (primType) {\n    case PrimitiveTypes.Points:\n      return 'points';\n\n    case PrimitiveTypes.Lines:\n      return 'lines';\n\n    case PrimitiveTypes.Triangles:\n    case PrimitiveTypes.TriangleEdges:\n      return 'polys';\n\n    case PrimitiveTypes.TriangleStripEdges:\n    case PrimitiveTypes.TriangleStrips:\n      return 'strips';\n\n    default:\n      return '';\n  }\n}\n\nfunction _getOrAddFlatId(state, ptId, cellId) {\n  var flatId = state.pointIdToFlatId[ptId];\n\n  if (flatId < 0) {\n    flatId = state.flatId;\n    state.pointIdToFlatId[ptId] = flatId;\n    state.flatIdToPointId[state.flatId] = ptId;\n    state.flatIdToCellId[state.flatId] = cellId;\n    state.flatId++;\n  }\n\n  return flatId;\n}\n\nfunction fillCell(ptIds, cellId, state) {\n  var numPtIds = ptIds.length; // are any points already marked for this cell? If so use that as the provoking point\n\n  for (var ptIdx = 0; ptIdx < numPtIds; ptIdx++) {\n    var _ptId = ptIds[ptIdx];\n\n    if (state.cellProvokedMap.has(_ptId)) {\n      state.ibo[state.iboId++] = state.cellProvokedMap.get(_ptId); // insert remaining ptIds (they do not need to provoke)\n\n      for (var ptIdx2 = ptIdx + 1; ptIdx2 < ptIdx + numPtIds; ptIdx2++) {\n        _ptId = ptIds[ptIdx2 % numPtIds];\n\n        var _flatId = _getOrAddFlatId(state, _ptId, cellId); // add to ibo\n\n\n        state.ibo[state.iboId++] = _flatId;\n      } // all done now\n\n\n      return;\n    }\n  } // else have any of the points not been used yet? (not in provokedPointIds)\n\n\n  for (var _ptIdx = 0; _ptIdx < numPtIds; _ptIdx++) {\n    var _ptId2 = ptIds[_ptIdx];\n\n    if (!state.provokedPointIds[_ptId2]) {\n      var _flatId2 = _getOrAddFlatId(state, _ptId2, cellId); // mark provoking and add to ibo\n\n\n      state.provokedPointIds[_ptId2] = 1;\n      state.cellProvokedMap.set(_ptId2, _flatId2); // when provoking always set the cellId as an original non-provoking value\n      // will have been stored and we need to overwrite that\n\n      state.flatIdToCellId[_flatId2] = cellId;\n      state.ibo[state.iboId++] = _flatId2; // insert remaining ptIds (they do not need to provoke)\n\n      for (var _ptIdx2 = _ptIdx + 1; _ptIdx2 < _ptIdx + numPtIds; _ptIdx2++) {\n        _ptId2 = ptIds[_ptIdx2 % numPtIds];\n        _flatId2 = _getOrAddFlatId(state, _ptId2, cellId); // add to ibo\n\n        state.ibo[state.iboId++] = _flatId2;\n      } // all done now\n\n\n      return;\n    }\n  } // if we got here then none of the ptIds could be used to provoke\n  // so just duplicate the first one\n\n\n  var ptId = ptIds[0];\n  var flatId = state.flatId;\n  state.cellProvokedMap.set(ptId, flatId);\n  state.flatIdToPointId[state.flatId] = ptId;\n  state.flatIdToCellId[state.flatId] = cellId;\n  state.flatId++; // add to ibo\n\n  state.ibo[state.iboId++] = flatId; // insert remaining ptIds (they do not need to provoke)\n\n  for (var _ptIdx3 = 1; _ptIdx3 < numPtIds; _ptIdx3++) {\n    ptId = ptIds[_ptIdx3];\n    flatId = _getOrAddFlatId(state, ptId, cellId); // add to ibo\n\n    state.ibo[state.iboId++] = flatId;\n  }\n}\n\nfunction countCell(ptIds, cellId, state) {\n  var numPtIds = ptIds.length;\n  state.iboSize += numPtIds; // are any points already marked for this cell? If so use that as the provoking point\n\n  for (var ptIdx = 0; ptIdx < numPtIds; ptIdx++) {\n    var ptId = ptIds[ptIdx];\n\n    if (state.cellProvokedMap.has(ptId)) {\n      return;\n    }\n  } // else have any of the points not been used yet? (not in provokedPointIds)\n\n\n  for (var _ptIdx4 = 0; _ptIdx4 < numPtIds; _ptIdx4++) {\n    var _ptId3 = ptIds[_ptIdx4];\n\n    if (!state.provokedPointIds[_ptId3]) {\n      state.provokedPointIds[_ptId3] = 1;\n      state.cellProvokedMap.set(_ptId3, 1);\n      return;\n    }\n  } // if we got here then none of the ptIds could be used to provoke\n\n\n  state.cellProvokedMap.set(ptIds[0], 1);\n  state.extraPoints++;\n}\n\nvar processCell;\n\nvar _single = new Uint32Array(1);\n\nvar _double = new Uint32Array(2);\n\nvar _triple = new Uint32Array(3);\n\nvar _indexCellBuilders = {\n  // easy, every input point becomes an output point\n  anythingToPoints: function anythingToPoints(numPoints, cellPts, offset, cellId, state) {\n    for (var i = 0; i < numPoints; ++i) {\n      _single[0] = cellPts[offset + i];\n      processCell(_single, cellId, state);\n    }\n  },\n  linesToWireframe: function linesToWireframe(numPoints, cellPts, offset, cellId, state) {\n    // for lines we add a bunch of segments\n    for (var i = 0; i < numPoints - 1; ++i) {\n      _double[0] = cellPts[offset + i];\n      _double[1] = cellPts[offset + i + 1];\n      processCell(_double, cellId, state);\n    }\n  },\n  polysToWireframe: function polysToWireframe(numPoints, cellPts, offset, cellId, state) {\n    // for polys we add a bunch of segments and close it\n    if (numPoints > 2) {\n      for (var i = 0; i < numPoints; ++i) {\n        _double[0] = cellPts[offset + i];\n        _double[1] = cellPts[offset + (i + 1) % numPoints];\n        processCell(_double, cellId, state);\n      }\n    }\n  },\n  stripsToWireframe: function stripsToWireframe(numPoints, cellPts, offset, cellId, state) {\n    if (numPoints > 2) {\n      // for strips we add a bunch of segments and close it\n      for (var i = 0; i < numPoints - 1; ++i) {\n        _double[0] = cellPts[offset + i];\n        _double[1] = cellPts[offset + i + 1];\n        processCell(_double, cellId, state);\n      }\n\n      for (var _i = 0; _i < numPoints - 2; _i++) {\n        _double[0] = cellPts[offset + _i];\n        _double[1] = cellPts[offset + _i + 2];\n        processCell(_double, cellId, state);\n      }\n    }\n  },\n  polysToSurface: function polysToSurface(npts, cellPts, offset, cellId, state) {\n    for (var i = 0; i < npts - 2; i++) {\n      _triple[0] = cellPts[offset];\n      _triple[1] = cellPts[offset + i + 1];\n      _triple[2] = cellPts[offset + i + 2];\n      processCell(_triple, cellId, state);\n    }\n  },\n  stripsToSurface: function stripsToSurface(npts, cellPts, offset, cellId, state) {\n    for (var i = 0; i < npts - 2; i++) {\n      _triple[0] = cellPts[offset + i];\n      _triple[1] = cellPts[offset + i + 1 + i % 2];\n      _triple[2] = cellPts[offset + i + 1 + (i + 1) % 2];\n      processCell(_triple, cellId, state);\n    }\n  }\n}; // ----------------------------------------------------------------------------\n// vtkWebGPUIndexBufferManager methods\n// ----------------------------------------------------------------------------\n\nfunction vtkWebGPUIndexBuffer(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkWebGPUIndexBuffer');\n\n  publicAPI.buildIndexBuffer = function (req) {\n    var cellArray = req.cells;\n    var primitiveType = req.primitiveType;\n    var representation = req.representation;\n    var cellOffset = req.cellOffset;\n    var array = cellArray.getData();\n    var cellArraySize = array.length;\n    var inRepName = getPrimitiveName(primitiveType);\n    var numPts = req.numberOfPoints;\n    var state = {\n      provokedPointIds: new Uint8Array(numPts),\n      // size is good\n      extraPoints: 0,\n      iboSize: 0,\n      flatId: 0,\n      iboId: 0,\n      cellProvokedMap: new _LimitedMap()\n    };\n    var func = null;\n\n    if (representation === Representation.POINTS || primitiveType === PrimitiveTypes.Points) {\n      func = _indexCellBuilders.anythingToPoints;\n    } else if (representation === Representation.WIREFRAME || primitiveType === PrimitiveTypes.Lines) {\n      func = _indexCellBuilders[\"\".concat(inRepName, \"ToWireframe\")];\n    } else {\n      func = _indexCellBuilders[\"\".concat(inRepName, \"ToSurface\")];\n    } // first we count how many extra provoking points we need\n\n\n    processCell = countCell;\n    var cellId = cellOffset || 0;\n\n    for (var cellArrayIndex = 0; cellArrayIndex < cellArraySize;) {\n      state.cellProvokedMap.clear();\n      func(array[cellArrayIndex], array, cellArrayIndex + 1, cellId, state);\n      cellArrayIndex += array[cellArrayIndex] + 1;\n      cellId++;\n    } // then we allocate the remaining structures\n    // (we pick the best size to save space and transfer costs)\n\n\n    if (numPts <= 0xffff) {\n      state.flatIdToPointId = new Uint16Array(numPts + state.extraPoints);\n    } else {\n      state.flatIdToPointId = new Uint32Array(numPts + state.extraPoints);\n    }\n\n    if (numPts + state.extraPoints < 0x8fff) {\n      state.pointIdToFlatId = new Int16Array(numPts);\n    } else {\n      state.pointIdToFlatId = new Int32Array(numPts);\n    }\n\n    if (numPts + state.extraPoints <= 0xffff) {\n      state.ibo = new Uint16Array(state.iboSize);\n      req.format = 'uint16';\n    } else {\n      state.ibo = new Uint32Array(state.iboSize);\n      req.format = 'uint32';\n    }\n\n    if (cellId <= 0xffff) {\n      state.flatIdToCellId = new Uint16Array(numPts + state.extraPoints);\n    } else {\n      state.flatIdToCellId = new Uint32Array(numPts + state.extraPoints);\n    }\n\n    state.pointIdToFlatId.fill(-1);\n    state.provokedPointIds.fill(0); // and fill them in\n\n    processCell = fillCell;\n    cellId = cellOffset || 0;\n\n    for (var _cellArrayIndex = 0; _cellArrayIndex < cellArraySize;) {\n      state.cellProvokedMap.clear();\n      func(array[_cellArrayIndex], array, _cellArrayIndex + 1, cellId, state);\n      _cellArrayIndex += array[_cellArrayIndex] + 1;\n      cellId++;\n    }\n\n    delete state.provokedPointIds;\n    delete state.pointIdToFlatId; // store the results we need\n\n    req.nativeArray = state.ibo;\n    model.flatIdToPointId = state.flatIdToPointId;\n    model.flatIdToCellId = state.flatIdToCellId;\n    model.flatSize = state.flatId;\n    model.indexCount = state.iboId;\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\n\nvar DEFAULT_VALUES = {\n  flatIdToPointId: null,\n  flatIdToCellId: null,\n  flatSize: 0,\n  indexCount: 0\n}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Inheritance\n\n  vtkWebGPUBuffer.extend(publicAPI, model, initialValues);\n  macro.setGet(publicAPI, model, ['flatIdToPointId', 'flatIdToCellId', 'flatSize', 'indexCount']);\n  vtkWebGPUIndexBuffer(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = macro.newInstance(extend); // ----------------------------------------------------------------------------\n\nvar vtkWebGPUIndexBuffer$1 = _objectSpread({\n  newInstance: newInstance,\n  extend: extend\n}, Constants);\n\nexport { vtkWebGPUIndexBuffer$1 as default, extend, newInstance };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}