import _toConsumableArray from '@babel/runtime/helpers/toConsumableArray';
import { IDENTITY } from '../Core/Math/Constants.js';
import { vec3, mat4 } from 'gl-matrix';
import macro from '../../macros.js';
import { f as vtkMath } from '../Core/Math/index.js';

// vtkTransform methods
// ----------------------------------------------------------------------------
// eslint-disable-next-line import/no-mutable-exports

var newInstance;

function vtkTransform(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkAbstractTransform', 'vtkHomogeneousTransform', 'vtkTransform');

  publicAPI.transformPoint = function (point, out) {
    vec3.transformMat4(out, point, model.matrix);
    return out;
  };

  publicAPI.transformPoints = function (points, out) {
    var inPoint = new Float64Array(3);
    var outPoint = new Float64Array(3);

    for (var i = 0; i < points.length; i += 3) {
      inPoint[0] = points[i];
      inPoint[1] = points[i + 1];
      inPoint[2] = points[i + 2];
      vec3.transformMat4(outPoint, inPoint, model.matrix);
      out[i] = outPoint[0];
      out[i + 1] = outPoint[1];
      out[i + 2] = outPoint[2];
    }

    return out;
  };
  /**
   * Sets the internal state of the transform to PreMultiply.
   * All subsequent operations will occur before those already represented in the current transformation.
   * In homogeneous matrix notation, M = M*A where M is the current transformation matrix and A is the applied matrix.
   * The default is PreMultiply.
   */


  publicAPI.preMultiply = function () {
    publicAPI.setPreMultiplyFlag(true);
  };
  /**
   * Sets the internal state of the transform to PostMultiply.
   * All subsequent operations will occur after those already represented in the current transformation.
   * In homogeneous matrix notation, M = A*M where M is the current transformation matrix and A is the applied matrix.
   * The default is PreMultiply.
   */


  publicAPI.postMultiply = function () {
    publicAPI.setPreMultiplyFlag(false);
  };

  publicAPI.transformMatrix = function (matrix, out) {
    if (model.preMultiplyFlag) {
      mat4.multiply(out, model.matrix, matrix);
    } else {
      mat4.multiply(out, matrix, model.matrix);
    }

    return out;
  }; // Apply the transform to each matrix in the same way as transformMatrix
  // `matrices` can be a contiguous array of float or an array of array


  publicAPI.transformMatrices = function (matrices, out) {
    var inMat = new Float64Array(16);
    var outMat = new Float64Array(16);
    var transform = model.preMultiplyFlag ? function () {
      return mat4.multiply(outMat, model.matrix, inMat);
    } : function () {
      return mat4.multiply(outMat, inMat, model.matrix);
    };

    for (var i = 0; i < matrices.length; i += 16) {
      for (var j = 0; j < 16; ++j) {
        inMat[j] = matrices[i + j];
      }

      transform();

      for (var _j = 0; _j < 16; ++_j) {
        out[i + _j] = outMat[_j];
      }
    }

    return out;
  };

  publicAPI.getInverse = function () {
    return newInstance({
      matrix: vtkMath.invertMatrix(Array.from(model.matrix), [], 4),
      preMultiplyFlag: model.preMultiplyFlag
    });
  };
} // ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------


var DEFAULT_VALUES = {
  preMultiplyFlag: false,
  matrix: _toConsumableArray(IDENTITY)
}; // ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);
  macro.obj(publicAPI, model);
  macro.setGet(publicAPI, model, ['preMultiplyFlag']);
  macro.setGetArray(publicAPI, model, ['matrix'], 16);
  vtkTransform(publicAPI, model);
} // ----------------------------------------------------------------------------

newInstance = macro.newInstance(extend, 'vtkTransform');

var vtkTransform$1 = {
  newInstance: newInstance,
  extend: extend
};

export { vtkTransform$1 as default, extend, newInstance };
