{"ast":null,"code":"import vtkShaderProgram from './ShaderProgram.js';\nfunction implementReplaceShaderCoincidentOffset(publicAPI, model) {\n  publicAPI.replaceShaderCoincidentOffset = function (shaders, ren, actor) {\n    var cp = publicAPI.getCoincidentParameters(ren, actor); // if we need an offset handle it here\n    // The value of .000016 is suitable for depth buffers\n    // of at least 16 bit depth. We do not query the depth\n    // right now because we would need some mechanism to\n    // cache the result taking into account FBO changes etc.\n\n    if (cp && (cp.factor !== 0.0 || cp.offset !== 0.0)) {\n      var FSSource = shaders.Fragment;\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Coincident::Dec', ['uniform float cfactor;', 'uniform float coffset;']).result;\n      if (model.context.getExtension('EXT_frag_depth')) {\n        if (cp.factor !== 0.0) {\n          FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::UniformFlow::Impl', ['float cscale = length(vec2(dFdx(gl_FragCoord.z),dFdy(gl_FragCoord.z)));', '//VTK::UniformFlow::Impl'], false).result;\n          FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Depth::Impl', 'gl_FragDepthEXT = gl_FragCoord.z + cfactor*cscale + 0.000016*coffset;').result;\n        } else {\n          FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Depth::Impl', 'gl_FragDepthEXT = gl_FragCoord.z + 0.000016*coffset;').result;\n        }\n      }\n      if (model._openGLRenderWindow.getWebgl2()) {\n        if (cp.factor !== 0.0) {\n          FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::UniformFlow::Impl', ['float cscale = length(vec2(dFdx(gl_FragCoord.z),dFdy(gl_FragCoord.z)));', '//VTK::UniformFlow::Impl'], false).result;\n          FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Depth::Impl', 'gl_FragDepth = gl_FragCoord.z + cfactor*cscale + 0.000016*coffset;').result;\n        } else {\n          FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Depth::Impl', 'gl_FragDepth = gl_FragCoord.z + 0.000016*coffset;').result;\n        }\n      }\n      shaders.Fragment = FSSource;\n    }\n  };\n}\nfunction implementBuildShadersWithReplacements(publicAPI, model) {\n  publicAPI.applyShaderReplacements = function (shaders, viewSpec, pre) {\n    var shaderReplacements = null;\n    if (viewSpec) {\n      shaderReplacements = viewSpec.ShaderReplacements;\n    }\n    if (shaderReplacements) {\n      for (var i = 0; i < shaderReplacements.length; i++) {\n        var currReplacement = shaderReplacements[i];\n        if (pre && currReplacement.replaceFirst || !pre && !currReplacement.replaceFirst) {\n          var shaderType = currReplacement.shaderType;\n          var ssrc = shaders[shaderType];\n          var substituteRes = vtkShaderProgram.substitute(ssrc, currReplacement.originalValue, currReplacement.replacementValue, currReplacement.replaceAll);\n          shaders[shaderType] = substituteRes.result;\n        }\n      }\n    }\n  };\n  publicAPI.buildShaders = function (shaders, ren, actor) {\n    publicAPI.getReplacedShaderTemplate(shaders, ren, actor);\n    model.lastRenderPassShaderReplacement = model.currentRenderPass ? model.currentRenderPass.getShaderReplacement() : null; // apply any renderPassReplacements\n\n    if (model.lastRenderPassShaderReplacement) {\n      model.lastRenderPassShaderReplacement(shaders);\n    }\n    var openGLSpec = model.renderable.getViewSpecificProperties().OpenGL; // user specified pre replacements\n\n    publicAPI.applyShaderReplacements(shaders, openGLSpec, true);\n    publicAPI.replaceShaderValues(shaders, ren, actor); // user specified post replacements\n\n    publicAPI.applyShaderReplacements(shaders, openGLSpec);\n  };\n  publicAPI.getReplacedShaderTemplate = function (shaders, ren, actor) {\n    var openGLSpecProp = model.renderable.getViewSpecificProperties().OpenGL;\n    publicAPI.getShaderTemplate(shaders, ren, actor);\n    var vertexShaderCode = shaders.Vertex;\n    if (openGLSpecProp) {\n      var vertexSpecProp = openGLSpecProp.VertexShaderCode;\n      if (vertexSpecProp !== undefined && vertexSpecProp !== '') {\n        vertexShaderCode = vertexSpecProp;\n      }\n    }\n    shaders.Vertex = vertexShaderCode;\n    var fragmentShaderCode = shaders.Fragment;\n    if (openGLSpecProp) {\n      var fragmentSpecProp = openGLSpecProp.FragmentShaderCode;\n      if (fragmentSpecProp !== undefined && fragmentSpecProp !== '') {\n        fragmentShaderCode = fragmentSpecProp;\n      }\n    }\n    shaders.Fragment = fragmentShaderCode;\n    var geometryShaderCode = shaders.Geometry;\n    if (openGLSpecProp) {\n      var geometrySpecProp = openGLSpecProp.GeometryShaderCode;\n      if (geometrySpecProp !== undefined) {\n        geometryShaderCode = geometrySpecProp;\n      }\n    }\n    shaders.Geometry = geometryShaderCode;\n  };\n}\nvar vtkReplacementShaderMapper = {\n  implementReplaceShaderCoincidentOffset: implementReplaceShaderCoincidentOffset,\n  implementBuildShadersWithReplacements: implementBuildShadersWithReplacements\n};\nexport { vtkReplacementShaderMapper as default };","map":{"version":3,"names":["vtkShaderProgram","implementReplaceShaderCoincidentOffset","publicAPI","model","replaceShaderCoincidentOffset","shaders","ren","actor","cp","getCoincidentParameters","factor","offset","FSSource","Fragment","substitute","result","context","getExtension","_openGLRenderWindow","getWebgl2","implementBuildShadersWithReplacements","applyShaderReplacements","viewSpec","pre","shaderReplacements","ShaderReplacements","i","length","currReplacement","replaceFirst","shaderType","ssrc","substituteRes","originalValue","replacementValue","replaceAll","buildShaders","getReplacedShaderTemplate","lastRenderPassShaderReplacement","currentRenderPass","getShaderReplacement","openGLSpec","renderable","getViewSpecificProperties","OpenGL","replaceShaderValues","openGLSpecProp","getShaderTemplate","vertexShaderCode","Vertex","vertexSpecProp","VertexShaderCode","undefined","fragmentShaderCode","fragmentSpecProp","FragmentShaderCode","geometryShaderCode","Geometry","geometrySpecProp","GeometryShaderCode","vtkReplacementShaderMapper","default"],"sources":["/home/rakshith/Documents/RemoteRendering/vtk-js-react-app/node_modules/@kitware/vtk.js/Rendering/OpenGL/ReplacementShaderMapper.js"],"sourcesContent":["import vtkShaderProgram from './ShaderProgram.js';\n\nfunction implementReplaceShaderCoincidentOffset(publicAPI, model) {\n\n  publicAPI.replaceShaderCoincidentOffset = function (shaders, ren, actor) {\n    var cp = publicAPI.getCoincidentParameters(ren, actor); // if we need an offset handle it here\n    // The value of .000016 is suitable for depth buffers\n    // of at least 16 bit depth. We do not query the depth\n    // right now because we would need some mechanism to\n    // cache the result taking into account FBO changes etc.\n\n    if (cp && (cp.factor !== 0.0 || cp.offset !== 0.0)) {\n      var FSSource = shaders.Fragment;\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Coincident::Dec', ['uniform float cfactor;', 'uniform float coffset;']).result;\n\n      if (model.context.getExtension('EXT_frag_depth')) {\n        if (cp.factor !== 0.0) {\n          FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::UniformFlow::Impl', ['float cscale = length(vec2(dFdx(gl_FragCoord.z),dFdy(gl_FragCoord.z)));', '//VTK::UniformFlow::Impl'], false).result;\n          FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Depth::Impl', 'gl_FragDepthEXT = gl_FragCoord.z + cfactor*cscale + 0.000016*coffset;').result;\n        } else {\n          FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Depth::Impl', 'gl_FragDepthEXT = gl_FragCoord.z + 0.000016*coffset;').result;\n        }\n      }\n\n      if (model._openGLRenderWindow.getWebgl2()) {\n        if (cp.factor !== 0.0) {\n          FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::UniformFlow::Impl', ['float cscale = length(vec2(dFdx(gl_FragCoord.z),dFdy(gl_FragCoord.z)));', '//VTK::UniformFlow::Impl'], false).result;\n          FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Depth::Impl', 'gl_FragDepth = gl_FragCoord.z + cfactor*cscale + 0.000016*coffset;').result;\n        } else {\n          FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Depth::Impl', 'gl_FragDepth = gl_FragCoord.z + 0.000016*coffset;').result;\n        }\n      }\n\n      shaders.Fragment = FSSource;\n    }\n  };\n}\n\nfunction implementBuildShadersWithReplacements(publicAPI, model) {\n\n  publicAPI.applyShaderReplacements = function (shaders, viewSpec, pre) {\n    var shaderReplacements = null;\n\n    if (viewSpec) {\n      shaderReplacements = viewSpec.ShaderReplacements;\n    }\n\n    if (shaderReplacements) {\n      for (var i = 0; i < shaderReplacements.length; i++) {\n        var currReplacement = shaderReplacements[i];\n\n        if (pre && currReplacement.replaceFirst || !pre && !currReplacement.replaceFirst) {\n          var shaderType = currReplacement.shaderType;\n          var ssrc = shaders[shaderType];\n          var substituteRes = vtkShaderProgram.substitute(ssrc, currReplacement.originalValue, currReplacement.replacementValue, currReplacement.replaceAll);\n          shaders[shaderType] = substituteRes.result;\n        }\n      }\n    }\n  };\n\n  publicAPI.buildShaders = function (shaders, ren, actor) {\n    publicAPI.getReplacedShaderTemplate(shaders, ren, actor);\n    model.lastRenderPassShaderReplacement = model.currentRenderPass ? model.currentRenderPass.getShaderReplacement() : null; // apply any renderPassReplacements\n\n    if (model.lastRenderPassShaderReplacement) {\n      model.lastRenderPassShaderReplacement(shaders);\n    }\n\n    var openGLSpec = model.renderable.getViewSpecificProperties().OpenGL; // user specified pre replacements\n\n    publicAPI.applyShaderReplacements(shaders, openGLSpec, true);\n    publicAPI.replaceShaderValues(shaders, ren, actor); // user specified post replacements\n\n    publicAPI.applyShaderReplacements(shaders, openGLSpec);\n  };\n\n  publicAPI.getReplacedShaderTemplate = function (shaders, ren, actor) {\n    var openGLSpecProp = model.renderable.getViewSpecificProperties().OpenGL;\n    publicAPI.getShaderTemplate(shaders, ren, actor);\n    var vertexShaderCode = shaders.Vertex;\n\n    if (openGLSpecProp) {\n      var vertexSpecProp = openGLSpecProp.VertexShaderCode;\n\n      if (vertexSpecProp !== undefined && vertexSpecProp !== '') {\n        vertexShaderCode = vertexSpecProp;\n      }\n    }\n\n    shaders.Vertex = vertexShaderCode;\n    var fragmentShaderCode = shaders.Fragment;\n\n    if (openGLSpecProp) {\n      var fragmentSpecProp = openGLSpecProp.FragmentShaderCode;\n\n      if (fragmentSpecProp !== undefined && fragmentSpecProp !== '') {\n        fragmentShaderCode = fragmentSpecProp;\n      }\n    }\n\n    shaders.Fragment = fragmentShaderCode;\n    var geometryShaderCode = shaders.Geometry;\n\n    if (openGLSpecProp) {\n      var geometrySpecProp = openGLSpecProp.GeometryShaderCode;\n\n      if (geometrySpecProp !== undefined) {\n        geometryShaderCode = geometrySpecProp;\n      }\n    }\n\n    shaders.Geometry = geometryShaderCode;\n  };\n}\n\nvar vtkReplacementShaderMapper = {\n  implementReplaceShaderCoincidentOffset: implementReplaceShaderCoincidentOffset,\n  implementBuildShadersWithReplacements: implementBuildShadersWithReplacements\n};\n\nexport { vtkReplacementShaderMapper as default };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}