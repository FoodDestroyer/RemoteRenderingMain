{"ast":null,"code":"import _toConsumableArray from '@babel/runtime/helpers/toConsumableArray';\nimport macro from '../../macros.js';\nimport vtkImageData from '../../Common/DataModel/ImageData.js';\nimport vtkDataArray from '../../Common/Core/DataArray.js';\nvar vtkErrorMacro = macro.vtkErrorMacro; // ----------------------------------------------------------------------------\n// vtkImageCropFilter methods\n// ----------------------------------------------------------------------------\n\nfunction vtkImageCropFilter(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkImageCropFilter'); // --------------------------------------------------------------------------\n\n  publicAPI.reset = function () {\n    var data = publicAPI.getInputData();\n    if (data) {\n      publicAPI.setCroppingPlanes.apply(publicAPI, _toConsumableArray(data.getExtent()));\n    }\n  }; // --------------------------------------------------------------------------\n\n  publicAPI.requestData = function (inData, outData) {\n    // implement requestData\n    var input = inData[0];\n    if (!input) {\n      vtkErrorMacro('Invalid or missing input');\n      return;\n    }\n    var scalars = input.getPointData().getScalars();\n    if (!scalars) {\n      vtkErrorMacro('No scalars from input');\n      return;\n    }\n    var extent = input.getExtent();\n    var cropped = model.croppingPlanes && model.croppingPlanes.length === 6 ? extent.map(function (e, i) {\n      if (i % 2 === 0) {\n        // min plane\n        return Math.max(e, Math.round(model.croppingPlanes[i]));\n      } // max plane\n\n      return Math.min(e, Math.round(model.croppingPlanes[i]));\n    }) : extent.slice();\n    if (cropped[0] === extent[0] && cropped[1] === extent[1] && cropped[2] === extent[2] && cropped[3] === extent[3] && cropped[4] === extent[4] && cropped[5] === extent[5]) {\n      var sameAsInput = vtkImageData.newInstance();\n      sameAsInput.shallowCopy(input); // Force new mtime\n\n      outData[0] = sameAsInput;\n      return;\n    } // reorder if needed\n\n    for (var i = 0; i < 3; ++i) {\n      if (cropped[i * 2] > cropped[i * 2 + 1]) {\n        var _ref = [cropped[i * 2 + 1], cropped[i * 2]];\n        cropped[i * 2] = _ref[0];\n        cropped[i * 2 + 1] = _ref[1];\n      }\n    } // restrict crop bounds based on extent bounds\n\n    for (var _i = 0; _i < 6; _i += 2) {\n      // min case\n      cropped[_i] = Math.max(cropped[_i], extent[_i]); // max case\n\n      cropped[_i + 1] = Math.min(cropped[_i + 1], extent[_i + 1]);\n    }\n    var numberOfComponents = scalars.getNumberOfComponents();\n    var componentSize = (cropped[1] - cropped[0] + 1) * (cropped[3] - cropped[2] + 1) * (cropped[5] - cropped[4] + 1) * numberOfComponents;\n    var scalarsData = scalars.getData();\n    var dims = input.getDimensions();\n    var jStride = numberOfComponents * dims[0];\n    var kStride = numberOfComponents * dims[0] * dims[1];\n    var beginOffset = (cropped[0] - extent[0]) * numberOfComponents;\n    var stripSize = (cropped[1] - cropped[0] + 1) * numberOfComponents; // +1 because subarray end is exclusive\n    // crop image\n\n    var croppedArray = new scalarsData.constructor(componentSize);\n    var index = 0;\n    for (var k = cropped[4]; k <= cropped[5]; ++k) {\n      for (var j = cropped[2]; j <= cropped[3]; ++j) {\n        var begin = beginOffset + (j - extent[2]) * jStride + (k - extent[4]) * kStride;\n        var end = begin + stripSize;\n        var slice = scalarsData.subarray(begin, end);\n        croppedArray.set(slice, index);\n        index += slice.length;\n      }\n    }\n    var outImage = vtkImageData.newInstance({\n      extent: cropped,\n      origin: input.getOrigin(),\n      direction: input.getDirection(),\n      spacing: input.getSpacing()\n    });\n    var croppedScalars = vtkDataArray.newInstance({\n      name: scalars.getName(),\n      numberOfComponents: numberOfComponents,\n      values: croppedArray\n    });\n    outImage.getPointData().setScalars(croppedScalars);\n    outData[0] = outImage;\n  };\n  publicAPI.isResetAvailable = function () {\n    if (model.croppingPlanes == null || model.croppingPlanes.length === 0) {\n      return false;\n    }\n    var data = publicAPI.getInputData();\n    if (data) {\n      var originalExtent = data.getExtent();\n      var findDifference = originalExtent.find(function (v, i) {\n        return Math.abs(model.croppingPlanes[i] - v) > Number.EPSILON;\n      });\n      return findDifference !== undefined;\n    }\n    return false;\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nvar DEFAULT_VALUES = {// croppingPlanes: null,\n}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Make this a VTK object\n\n  macro.obj(publicAPI, model); // Also make it an algorithm with one input and one output\n\n  macro.algo(publicAPI, model, 1, 1); // no orientation support yet\n\n  macro.setGetArray(publicAPI, model, ['croppingPlanes'], 6); // Object specific methods\n\n  vtkImageCropFilter(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = macro.newInstance(extend, 'vtkImageCropFilter'); // ----------------------------------------------------------------------------\n\nvar vtkImageCropFilter$1 = {\n  newInstance: newInstance,\n  extend: extend\n};\nexport { vtkImageCropFilter$1 as default, extend, newInstance };","map":{"version":3,"names":["_toConsumableArray","macro","vtkImageData","vtkDataArray","vtkErrorMacro","vtkImageCropFilter","publicAPI","model","classHierarchy","push","reset","data","getInputData","setCroppingPlanes","apply","getExtent","requestData","inData","outData","input","scalars","getPointData","getScalars","extent","cropped","croppingPlanes","length","map","e","i","Math","max","round","min","slice","sameAsInput","newInstance","shallowCopy","_ref","_i","numberOfComponents","getNumberOfComponents","componentSize","scalarsData","getData","dims","getDimensions","jStride","kStride","beginOffset","stripSize","croppedArray","constructor","index","k","j","begin","end","subarray","set","outImage","origin","getOrigin","direction","getDirection","spacing","getSpacing","croppedScalars","name","getName","values","setScalars","isResetAvailable","originalExtent","findDifference","find","v","abs","Number","EPSILON","undefined","DEFAULT_VALUES","extend","initialValues","arguments","Object","assign","obj","algo","setGetArray","vtkImageCropFilter$1","default"],"sources":["/home/rakshith/Documents/RemoteRendering/vtk-js-react-app/node_modules/@kitware/vtk.js/Filters/General/ImageCropFilter.js"],"sourcesContent":["import _toConsumableArray from '@babel/runtime/helpers/toConsumableArray';\nimport macro from '../../macros.js';\nimport vtkImageData from '../../Common/DataModel/ImageData.js';\nimport vtkDataArray from '../../Common/Core/DataArray.js';\n\nvar vtkErrorMacro = macro.vtkErrorMacro; // ----------------------------------------------------------------------------\n// vtkImageCropFilter methods\n// ----------------------------------------------------------------------------\n\nfunction vtkImageCropFilter(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkImageCropFilter'); // --------------------------------------------------------------------------\n\n  publicAPI.reset = function () {\n    var data = publicAPI.getInputData();\n\n    if (data) {\n      publicAPI.setCroppingPlanes.apply(publicAPI, _toConsumableArray(data.getExtent()));\n    }\n  }; // --------------------------------------------------------------------------\n\n\n  publicAPI.requestData = function (inData, outData) {\n    // implement requestData\n    var input = inData[0];\n\n    if (!input) {\n      vtkErrorMacro('Invalid or missing input');\n      return;\n    }\n\n    var scalars = input.getPointData().getScalars();\n\n    if (!scalars) {\n      vtkErrorMacro('No scalars from input');\n      return;\n    }\n\n    var extent = input.getExtent();\n    var cropped = model.croppingPlanes && model.croppingPlanes.length === 6 ? extent.map(function (e, i) {\n      if (i % 2 === 0) {\n        // min plane\n        return Math.max(e, Math.round(model.croppingPlanes[i]));\n      } // max plane\n\n\n      return Math.min(e, Math.round(model.croppingPlanes[i]));\n    }) : extent.slice();\n\n    if (cropped[0] === extent[0] && cropped[1] === extent[1] && cropped[2] === extent[2] && cropped[3] === extent[3] && cropped[4] === extent[4] && cropped[5] === extent[5]) {\n      var sameAsInput = vtkImageData.newInstance();\n      sameAsInput.shallowCopy(input); // Force new mtime\n\n      outData[0] = sameAsInput;\n      return;\n    } // reorder if needed\n\n\n    for (var i = 0; i < 3; ++i) {\n      if (cropped[i * 2] > cropped[i * 2 + 1]) {\n        var _ref = [cropped[i * 2 + 1], cropped[i * 2]];\n        cropped[i * 2] = _ref[0];\n        cropped[i * 2 + 1] = _ref[1];\n      }\n    } // restrict crop bounds based on extent bounds\n\n\n    for (var _i = 0; _i < 6; _i += 2) {\n      // min case\n      cropped[_i] = Math.max(cropped[_i], extent[_i]); // max case\n\n      cropped[_i + 1] = Math.min(cropped[_i + 1], extent[_i + 1]);\n    }\n\n    var numberOfComponents = scalars.getNumberOfComponents();\n    var componentSize = (cropped[1] - cropped[0] + 1) * (cropped[3] - cropped[2] + 1) * (cropped[5] - cropped[4] + 1) * numberOfComponents;\n    var scalarsData = scalars.getData();\n    var dims = input.getDimensions();\n    var jStride = numberOfComponents * dims[0];\n    var kStride = numberOfComponents * dims[0] * dims[1];\n    var beginOffset = (cropped[0] - extent[0]) * numberOfComponents;\n    var stripSize = (cropped[1] - cropped[0] + 1) * numberOfComponents; // +1 because subarray end is exclusive\n    // crop image\n\n    var croppedArray = new scalarsData.constructor(componentSize);\n    var index = 0;\n\n    for (var k = cropped[4]; k <= cropped[5]; ++k) {\n      for (var j = cropped[2]; j <= cropped[3]; ++j) {\n        var begin = beginOffset + (j - extent[2]) * jStride + (k - extent[4]) * kStride;\n        var end = begin + stripSize;\n        var slice = scalarsData.subarray(begin, end);\n        croppedArray.set(slice, index);\n        index += slice.length;\n      }\n    }\n\n    var outImage = vtkImageData.newInstance({\n      extent: cropped,\n      origin: input.getOrigin(),\n      direction: input.getDirection(),\n      spacing: input.getSpacing()\n    });\n    var croppedScalars = vtkDataArray.newInstance({\n      name: scalars.getName(),\n      numberOfComponents: numberOfComponents,\n      values: croppedArray\n    });\n    outImage.getPointData().setScalars(croppedScalars);\n    outData[0] = outImage;\n  };\n\n  publicAPI.isResetAvailable = function () {\n    if (model.croppingPlanes == null || model.croppingPlanes.length === 0) {\n      return false;\n    }\n\n    var data = publicAPI.getInputData();\n\n    if (data) {\n      var originalExtent = data.getExtent();\n      var findDifference = originalExtent.find(function (v, i) {\n        return Math.abs(model.croppingPlanes[i] - v) > Number.EPSILON;\n      });\n      return findDifference !== undefined;\n    }\n\n    return false;\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\n\nvar DEFAULT_VALUES = {// croppingPlanes: null,\n}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Make this a VTK object\n\n  macro.obj(publicAPI, model); // Also make it an algorithm with one input and one output\n\n  macro.algo(publicAPI, model, 1, 1); // no orientation support yet\n\n  macro.setGetArray(publicAPI, model, ['croppingPlanes'], 6); // Object specific methods\n\n  vtkImageCropFilter(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = macro.newInstance(extend, 'vtkImageCropFilter'); // ----------------------------------------------------------------------------\n\nvar vtkImageCropFilter$1 = {\n  newInstance: newInstance,\n  extend: extend\n};\n\nexport { vtkImageCropFilter$1 as default, extend, newInstance };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}