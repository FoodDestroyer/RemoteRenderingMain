{"ast":null,"code":"import macro from '../../macros.js';\nimport vtkDataArray from '../../Common/Core/DataArray.js';\nimport vtkPoints from '../../Common/Core/Points.js';\nimport vtkPolyData from '../../Common/DataModel/PolyData.js';\nimport { DesiredOutputPrecision } from '../../Common/DataModel/DataSetAttributes/Constants.js';\nimport { VtkDataTypes } from '../../Common/Core/DataArray/Constants.js';\nvar vtkErrorMacro = macro.vtkErrorMacro;\nfunction offsetCellArray(typedArray, offset) {\n  var currentIdx = 0;\n  return typedArray.map(function (value, index) {\n    if (index === currentIdx) {\n      currentIdx += value + 1;\n      return value;\n    }\n    return value + offset;\n  });\n}\nfunction appendCellData(dest, src, ptOffset, cellOffset) {\n  dest.set(offsetCellArray(src, ptOffset), cellOffset);\n} // ----------------------------------------------------------------------------\n// vtkAppendPolyData methods\n// ----------------------------------------------------------------------------\n\nfunction vtkAppendPolyData(publicAPI, model) {\n  // Set our classname\n  model.classHierarchy.push('vtkAppendPolyData');\n  publicAPI.requestData = function (inData, outData) {\n    // implement requestData\n    var numberOfInputs = publicAPI.getNumberOfInputPorts();\n    if (!numberOfInputs) {\n      vtkErrorMacro('No input specified.');\n      return;\n    }\n    if (numberOfInputs === 1) {\n      // pass through filter\n      outData[0] = inData[0];\n      return;\n    } // Allocate output\n\n    var output = vtkPolyData.newInstance();\n    var numPts = 0;\n    var pointType = 0;\n    var ttype = 1;\n    var firstType = 1;\n    var numVerts = 0;\n    var numLines = 0;\n    var numStrips = 0;\n    var numPolys = 0; // Field data is propagated to output only if present in all inputs\n\n    var hasPtNormals = true; // assume present by default\n\n    var hasPtTCoords = true;\n    var hasPtScalars = true;\n    for (var i = 0; i < numberOfInputs; i++) {\n      var ds = inData[i];\n      if (!ds) {\n        // eslint-disable-next-line\n        continue;\n      }\n      var dsNumPts = ds.getPoints().getNumberOfPoints();\n      numPts += dsNumPts;\n      numVerts += ds.getVerts().getNumberOfValues();\n      numLines += ds.getLines().getNumberOfValues();\n      numStrips += ds.getStrips().getNumberOfValues();\n      numPolys += ds.getPolys().getNumberOfValues();\n      if (dsNumPts) {\n        if (firstType) {\n          firstType = 0;\n          pointType = ds.getPoints().getDataType();\n        }\n        ttype = ds.getPoints().getDataType();\n        pointType = pointType > ttype ? pointType : ttype;\n      }\n      var ptD = ds.getPointData();\n      if (ptD) {\n        hasPtNormals = hasPtNormals && ptD.getNormals() !== null;\n        hasPtTCoords = hasPtTCoords && ptD.getTCoords() !== null;\n        hasPtScalars = hasPtScalars && ptD.getScalars() !== null;\n      } else {\n        hasPtNormals = false;\n        hasPtTCoords = false;\n        hasPtScalars = false;\n      }\n    }\n    if (model.outputPointsPrecision === DesiredOutputPrecision.SINGLE) {\n      pointType = VtkDataTypes.FLOAT;\n    } else if (model.outputPointsPrecision === DesiredOutputPrecision.DOUBLE) {\n      pointType = VtkDataTypes.DOUBLE;\n    }\n    var points = vtkPoints.newInstance({\n      dataType: pointType\n    });\n    points.setNumberOfPoints(numPts);\n    var pointData = points.getData();\n    var vertData = new Uint32Array(numVerts);\n    var lineData = new Uint32Array(numLines);\n    var stripData = new Uint32Array(numStrips);\n    var polyData = new Uint32Array(numPolys);\n    var newPtNormals = null;\n    var newPtTCoords = null;\n    var newPtScalars = null;\n    var lds = inData[numberOfInputs - 1];\n    if (hasPtNormals) {\n      var dsNormals = lds.getPointData().getNormals();\n      newPtNormals = vtkDataArray.newInstance({\n        numberOfComponents: 3,\n        numberOfTuples: numPts,\n        size: 3 * numPts,\n        dataType: dsNormals.getDataType(),\n        name: dsNormals.getName()\n      });\n    }\n    if (hasPtTCoords) {\n      var dsTCoords = lds.getPointData().getTCoords();\n      newPtTCoords = vtkDataArray.newInstance({\n        numberOfComponents: 2,\n        numberOfTuples: numPts,\n        size: 2 * numPts,\n        dataType: dsTCoords.getDataType(),\n        name: dsTCoords.getName()\n      });\n    }\n    if (hasPtScalars) {\n      var dsScalars = lds.getPointData().getScalars();\n      newPtScalars = vtkDataArray.newInstance({\n        numberOfComponents: dsScalars.getNumberOfComponents(),\n        numberOfTuples: numPts,\n        size: numPts * dsScalars.getNumberOfComponents(),\n        dataType: dsScalars.getDataType(),\n        name: dsScalars.getName()\n      });\n    }\n    numPts = 0;\n    numVerts = 0;\n    numLines = 0;\n    numStrips = 0;\n    numPolys = 0;\n    for (var _i = 0; _i < numberOfInputs; _i++) {\n      var _ds = inData[_i];\n      pointData.set(_ds.getPoints().getData(), numPts * 3);\n      appendCellData(vertData, _ds.getVerts().getData(), numPts, numVerts);\n      numVerts += _ds.getVerts().getNumberOfValues();\n      appendCellData(lineData, _ds.getLines().getData(), numPts, numLines);\n      numLines += _ds.getLines().getNumberOfValues();\n      appendCellData(stripData, _ds.getStrips().getData(), numPts, numStrips);\n      numStrips += _ds.getStrips().getNumberOfValues();\n      appendCellData(polyData, _ds.getPolys().getData(), numPts, numPolys);\n      numPolys += _ds.getPolys().getNumberOfValues();\n      var dsPD = _ds.getPointData();\n      if (hasPtNormals) {\n        var ptNorms = dsPD.getNormals();\n        newPtNormals.getData().set(ptNorms.getData(), numPts * 3);\n      }\n      if (hasPtTCoords) {\n        var ptTCoords = dsPD.getTCoords();\n        newPtTCoords.getData().set(ptTCoords.getData(), numPts * 2);\n      }\n      if (hasPtScalars) {\n        var ptScalars = dsPD.getScalars();\n        newPtScalars.getData().set(ptScalars.getData(), numPts * newPtScalars.getNumberOfComponents());\n      }\n      numPts += _ds.getPoints().getNumberOfPoints();\n    }\n    output.setPoints(points);\n    output.getVerts().setData(vertData);\n    output.getLines().setData(lineData);\n    output.getStrips().setData(stripData);\n    output.getPolys().setData(polyData);\n    if (newPtNormals) {\n      output.getPointData().setNormals(newPtNormals);\n    }\n    if (newPtTCoords) {\n      output.getPointData().setTCoords(newPtTCoords);\n    }\n    if (newPtScalars) {\n      output.getPointData().setScalars(newPtScalars);\n    }\n    outData[0] = output;\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nvar DEFAULT_VALUES = {\n  outputPointsPrecision: DesiredOutputPrecision.DEFAULT\n}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Build VTK API\n\n  macro.setGet(publicAPI, model, ['outputPointsPrecision']); // Make this a VTK object\n\n  macro.obj(publicAPI, model); // Also make it an algorithm with one input and one output\n\n  macro.algo(publicAPI, model, 1, 1); // Object specific methods\n\n  vtkAppendPolyData(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = macro.newInstance(extend, 'vtkAppendPolyData'); // ----------------------------------------------------------------------------\n\nvar vtkAppendPolyData$1 = {\n  newInstance: newInstance,\n  extend: extend\n};\nexport { vtkAppendPolyData$1 as default, extend, newInstance };","map":{"version":3,"names":["macro","vtkDataArray","vtkPoints","vtkPolyData","DesiredOutputPrecision","VtkDataTypes","vtkErrorMacro","offsetCellArray","typedArray","offset","currentIdx","map","value","index","appendCellData","dest","src","ptOffset","cellOffset","set","vtkAppendPolyData","publicAPI","model","classHierarchy","push","requestData","inData","outData","numberOfInputs","getNumberOfInputPorts","output","newInstance","numPts","pointType","ttype","firstType","numVerts","numLines","numStrips","numPolys","hasPtNormals","hasPtTCoords","hasPtScalars","i","ds","dsNumPts","getPoints","getNumberOfPoints","getVerts","getNumberOfValues","getLines","getStrips","getPolys","getDataType","ptD","getPointData","getNormals","getTCoords","getScalars","outputPointsPrecision","SINGLE","FLOAT","DOUBLE","points","dataType","setNumberOfPoints","pointData","getData","vertData","Uint32Array","lineData","stripData","polyData","newPtNormals","newPtTCoords","newPtScalars","lds","dsNormals","numberOfComponents","numberOfTuples","size","name","getName","dsTCoords","dsScalars","getNumberOfComponents","_i","_ds","dsPD","ptNorms","ptTCoords","ptScalars","setPoints","setData","setNormals","setTCoords","setScalars","DEFAULT_VALUES","DEFAULT","extend","initialValues","arguments","length","undefined","Object","assign","setGet","obj","algo","vtkAppendPolyData$1","default"],"sources":["/home/rakshith/Documents/RemoteRendering/vtk-js-react-app/node_modules/@kitware/vtk.js/Filters/General/AppendPolyData.js"],"sourcesContent":["import macro from '../../macros.js';\nimport vtkDataArray from '../../Common/Core/DataArray.js';\nimport vtkPoints from '../../Common/Core/Points.js';\nimport vtkPolyData from '../../Common/DataModel/PolyData.js';\nimport { DesiredOutputPrecision } from '../../Common/DataModel/DataSetAttributes/Constants.js';\nimport { VtkDataTypes } from '../../Common/Core/DataArray/Constants.js';\n\nvar vtkErrorMacro = macro.vtkErrorMacro;\n\nfunction offsetCellArray(typedArray, offset) {\n  var currentIdx = 0;\n  return typedArray.map(function (value, index) {\n    if (index === currentIdx) {\n      currentIdx += value + 1;\n      return value;\n    }\n\n    return value + offset;\n  });\n}\n\nfunction appendCellData(dest, src, ptOffset, cellOffset) {\n  dest.set(offsetCellArray(src, ptOffset), cellOffset);\n} // ----------------------------------------------------------------------------\n// vtkAppendPolyData methods\n// ----------------------------------------------------------------------------\n\n\nfunction vtkAppendPolyData(publicAPI, model) {\n  // Set our classname\n  model.classHierarchy.push('vtkAppendPolyData');\n\n  publicAPI.requestData = function (inData, outData) {\n    // implement requestData\n    var numberOfInputs = publicAPI.getNumberOfInputPorts();\n\n    if (!numberOfInputs) {\n      vtkErrorMacro('No input specified.');\n      return;\n    }\n\n    if (numberOfInputs === 1) {\n      // pass through filter\n      outData[0] = inData[0];\n      return;\n    } // Allocate output\n\n\n    var output = vtkPolyData.newInstance();\n    var numPts = 0;\n    var pointType = 0;\n    var ttype = 1;\n    var firstType = 1;\n    var numVerts = 0;\n    var numLines = 0;\n    var numStrips = 0;\n    var numPolys = 0; // Field data is propagated to output only if present in all inputs\n\n    var hasPtNormals = true; // assume present by default\n\n    var hasPtTCoords = true;\n    var hasPtScalars = true;\n\n    for (var i = 0; i < numberOfInputs; i++) {\n      var ds = inData[i];\n\n      if (!ds) {\n        // eslint-disable-next-line\n        continue;\n      }\n\n      var dsNumPts = ds.getPoints().getNumberOfPoints();\n      numPts += dsNumPts;\n      numVerts += ds.getVerts().getNumberOfValues();\n      numLines += ds.getLines().getNumberOfValues();\n      numStrips += ds.getStrips().getNumberOfValues();\n      numPolys += ds.getPolys().getNumberOfValues();\n\n      if (dsNumPts) {\n        if (firstType) {\n          firstType = 0;\n          pointType = ds.getPoints().getDataType();\n        }\n\n        ttype = ds.getPoints().getDataType();\n        pointType = pointType > ttype ? pointType : ttype;\n      }\n\n      var ptD = ds.getPointData();\n\n      if (ptD) {\n        hasPtNormals = hasPtNormals && ptD.getNormals() !== null;\n        hasPtTCoords = hasPtTCoords && ptD.getTCoords() !== null;\n        hasPtScalars = hasPtScalars && ptD.getScalars() !== null;\n      } else {\n        hasPtNormals = false;\n        hasPtTCoords = false;\n        hasPtScalars = false;\n      }\n    }\n\n    if (model.outputPointsPrecision === DesiredOutputPrecision.SINGLE) {\n      pointType = VtkDataTypes.FLOAT;\n    } else if (model.outputPointsPrecision === DesiredOutputPrecision.DOUBLE) {\n      pointType = VtkDataTypes.DOUBLE;\n    }\n\n    var points = vtkPoints.newInstance({\n      dataType: pointType\n    });\n    points.setNumberOfPoints(numPts);\n    var pointData = points.getData();\n    var vertData = new Uint32Array(numVerts);\n    var lineData = new Uint32Array(numLines);\n    var stripData = new Uint32Array(numStrips);\n    var polyData = new Uint32Array(numPolys);\n    var newPtNormals = null;\n    var newPtTCoords = null;\n    var newPtScalars = null;\n    var lds = inData[numberOfInputs - 1];\n\n    if (hasPtNormals) {\n      var dsNormals = lds.getPointData().getNormals();\n      newPtNormals = vtkDataArray.newInstance({\n        numberOfComponents: 3,\n        numberOfTuples: numPts,\n        size: 3 * numPts,\n        dataType: dsNormals.getDataType(),\n        name: dsNormals.getName()\n      });\n    }\n\n    if (hasPtTCoords) {\n      var dsTCoords = lds.getPointData().getTCoords();\n      newPtTCoords = vtkDataArray.newInstance({\n        numberOfComponents: 2,\n        numberOfTuples: numPts,\n        size: 2 * numPts,\n        dataType: dsTCoords.getDataType(),\n        name: dsTCoords.getName()\n      });\n    }\n\n    if (hasPtScalars) {\n      var dsScalars = lds.getPointData().getScalars();\n      newPtScalars = vtkDataArray.newInstance({\n        numberOfComponents: dsScalars.getNumberOfComponents(),\n        numberOfTuples: numPts,\n        size: numPts * dsScalars.getNumberOfComponents(),\n        dataType: dsScalars.getDataType(),\n        name: dsScalars.getName()\n      });\n    }\n\n    numPts = 0;\n    numVerts = 0;\n    numLines = 0;\n    numStrips = 0;\n    numPolys = 0;\n\n    for (var _i = 0; _i < numberOfInputs; _i++) {\n      var _ds = inData[_i];\n      pointData.set(_ds.getPoints().getData(), numPts * 3);\n      appendCellData(vertData, _ds.getVerts().getData(), numPts, numVerts);\n      numVerts += _ds.getVerts().getNumberOfValues();\n      appendCellData(lineData, _ds.getLines().getData(), numPts, numLines);\n      numLines += _ds.getLines().getNumberOfValues();\n      appendCellData(stripData, _ds.getStrips().getData(), numPts, numStrips);\n      numStrips += _ds.getStrips().getNumberOfValues();\n      appendCellData(polyData, _ds.getPolys().getData(), numPts, numPolys);\n      numPolys += _ds.getPolys().getNumberOfValues();\n\n      var dsPD = _ds.getPointData();\n\n      if (hasPtNormals) {\n        var ptNorms = dsPD.getNormals();\n        newPtNormals.getData().set(ptNorms.getData(), numPts * 3);\n      }\n\n      if (hasPtTCoords) {\n        var ptTCoords = dsPD.getTCoords();\n        newPtTCoords.getData().set(ptTCoords.getData(), numPts * 2);\n      }\n\n      if (hasPtScalars) {\n        var ptScalars = dsPD.getScalars();\n        newPtScalars.getData().set(ptScalars.getData(), numPts * newPtScalars.getNumberOfComponents());\n      }\n\n      numPts += _ds.getPoints().getNumberOfPoints();\n    }\n\n    output.setPoints(points);\n    output.getVerts().setData(vertData);\n    output.getLines().setData(lineData);\n    output.getStrips().setData(stripData);\n    output.getPolys().setData(polyData);\n\n    if (newPtNormals) {\n      output.getPointData().setNormals(newPtNormals);\n    }\n\n    if (newPtTCoords) {\n      output.getPointData().setTCoords(newPtTCoords);\n    }\n\n    if (newPtScalars) {\n      output.getPointData().setScalars(newPtScalars);\n    }\n\n    outData[0] = output;\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\n\nvar DEFAULT_VALUES = {\n  outputPointsPrecision: DesiredOutputPrecision.DEFAULT\n}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Build VTK API\n\n  macro.setGet(publicAPI, model, ['outputPointsPrecision']); // Make this a VTK object\n\n  macro.obj(publicAPI, model); // Also make it an algorithm with one input and one output\n\n  macro.algo(publicAPI, model, 1, 1); // Object specific methods\n\n  vtkAppendPolyData(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = macro.newInstance(extend, 'vtkAppendPolyData'); // ----------------------------------------------------------------------------\n\nvar vtkAppendPolyData$1 = {\n  newInstance: newInstance,\n  extend: extend\n};\n\nexport { vtkAppendPolyData$1 as default, extend, newInstance };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}