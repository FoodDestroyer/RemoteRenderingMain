{"ast":null,"code":"import _typeof from '@babel/runtime/helpers/typeof';\nimport _classCallCheck from '@babel/runtime/helpers/classCallCheck';\nimport _createClass from '@babel/runtime/helpers/createClass';\nimport _assertThisInitialized from '@babel/runtime/helpers/assertThisInitialized';\nimport _inherits from '@babel/runtime/helpers/inherits';\nimport _possibleConstructorReturn from '@babel/runtime/helpers/possibleConstructorReturn';\nimport _get from '@babel/runtime/helpers/get';\nimport _getPrototypeOf from '@babel/runtime/helpers/getPrototypeOf';\nimport _wrapNativeSuper from '@babel/runtime/helpers/wrapNativeSuper';\nimport { newInstance as newInstance$1, obj, setGet, get } from '../../macros.js';\nimport vtkWebGPUBufferManager from './BufferManager.js';\nimport vtkWebGPUShaderCache from './ShaderCache.js';\nimport vtkWebGPUTextureManager from './TextureManager.js';\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n      result;\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n    return _possibleConstructorReturn(this, result);\n  };\n}\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n/**\n * provide a simple WeakRefMap class to share device objects based on\n * hash values so that buffers/textures etc can be shared betwen mappers.\n * This is roughly based on WeakLRUCache but without the actual caching\n * behavior. This is just a map of key -> WeakRef(value)\n */\n\n/* eslint-disable no-undef */\n\nvar WeakRefMap = /*#__PURE__*/function (_Map) {\n  _inherits(WeakRefMap, _Map);\n  var _super = _createSuper(WeakRefMap);\n  function WeakRefMap() {\n    var _thisSuper, _thisSuper2, _this;\n    _classCallCheck(this, WeakRefMap);\n    _this = _super.call(this);\n    _this.registry = new FinalizationRegistry(function (key) {\n      var entry = _get((_thisSuper = _assertThisInitialized(_this), _getPrototypeOf(WeakRefMap.prototype)), \"get\", _thisSuper).call(_thisSuper, key);\n      if (entry && entry.deref && entry.deref() === undefined) _get((_thisSuper2 = _assertThisInitialized(_this), _getPrototypeOf(WeakRefMap.prototype)), \"delete\", _thisSuper2).call(_thisSuper2, key);\n    });\n    return _this;\n  }\n  _createClass(WeakRefMap, [{\n    key: \"getValue\",\n    value: function getValue(key) {\n      var entry = _get(_getPrototypeOf(WeakRefMap.prototype), \"get\", this).call(this, key);\n      if (entry) {\n        var value = entry.deref();\n        if (value !== undefined) return value;\n        _get(_getPrototypeOf(WeakRefMap.prototype), \"delete\", this).call(this, key);\n      }\n      return undefined;\n    }\n  }, {\n    key: \"setValue\",\n    value: function setValue(key, value) {\n      var entry;\n      if (value && _typeof(value) === 'object') {\n        entry = new WeakRef(value);\n        this.registry.register(value, key);\n        _get(_getPrototypeOf(WeakRefMap.prototype), \"set\", this).call(this, key, entry);\n      } // else entry is undefined\n\n      return entry;\n    }\n  }]);\n  return WeakRefMap;\n}( /*#__PURE__*/_wrapNativeSuper(Map));\n/* eslint-enable no-undef */\n// ----------------------------------------------------------------------------\n// vtkWebGPUDevice methods\n// ----------------------------------------------------------------------------\n\nfunction vtkWebGPUDevice(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkWebGPUDevice');\n  publicAPI.initialize = function (handle) {\n    model.handle = handle;\n  };\n  publicAPI.createCommandEncoder = function () {\n    return model.handle.createCommandEncoder();\n  };\n  publicAPI.submitCommandEncoder = function (commandEncoder) {\n    model.handle.queue.submit([commandEncoder.finish()]);\n  };\n  publicAPI.getShaderModule = function (sd) {\n    return model.shaderCache.getShaderModule(sd);\n  };\n  /* eslint-disable no-bitwise */\n\n  /* eslint-disable no-undef */\n\n  publicAPI.getBindGroupLayout = function (val) {\n    if (!val.entries) {\n      return null;\n    } // add in basic required values if missing\n\n    for (var i = 0; i < val.entries.length; i++) {\n      var ent = val.entries[i];\n      ent.binding = ent.binding || 0;\n      ent.visibility = ent.visibility || GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT;\n    } // do we already have one?\n\n    var sval = JSON.stringify(val);\n    for (var _i = 0; _i < model.bindGroupLayouts.length; _i++) {\n      if (model.bindGroupLayouts[_i].sval === sval) {\n        return model.bindGroupLayouts[_i].layout;\n      }\n    } // create one and store it\n\n    var layout = model.handle.createBindGroupLayout(val); // we actually only store the stringified version\n    // as that is what we always compare against\n\n    model.bindGroupLayouts.push({\n      sval: sval,\n      layout: layout\n    });\n    return layout;\n  };\n  publicAPI.getBindGroupLayoutDescription = function (layout) {\n    for (var i = 0; i < model.bindGroupLayouts.length; i++) {\n      if (model.bindGroupLayouts[i].layout === layout) {\n        return model.bindGroupLayouts[i].sval;\n      }\n    }\n    vtkErrorMacro('layout not found');\n    console.trace();\n    return null;\n  };\n  publicAPI.getPipeline = function (hash) {\n    if (hash in model.pipelines) {\n      return model.pipelines[hash];\n    }\n    return null;\n  };\n  publicAPI.createPipeline = function (hash, pipeline) {\n    pipeline.initialize(publicAPI, hash);\n    model.pipelines[hash] = pipeline;\n  };\n  publicAPI.onSubmittedWorkDone = function () {\n    return model.handle.queue.onSubmittedWorkDone();\n  }; // The Device has an object cache that can be used to cache buffers,\n  // textures and other objects that can be shared. The basic approach is to\n  // call getCachedObject with a request and a create function. The request\n  // is based on a hash. The cache lookup just returns any entry that has a\n  // matching hash. If a match isn't found then the create function is\n  // called with any extra arguments.\n  // is the object already cached?\n\n  publicAPI.hasCachedObject = function (hash) {\n    return model.objectCache.getValue(hash);\n  };\n  publicAPI.getCachedObject = function (hash, creator) {\n    if (!hash) {\n      vtkErrorMacro('attempt to cache an object without a hash');\n      return null;\n    }\n    var existingValue = model.objectCache.getValue(hash);\n    if (existingValue) {\n      return existingValue;\n    }\n    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n      args[_key - 2] = arguments[_key];\n    }\n    var createdObject = creator.apply(void 0, args);\n    model.objectCache.setValue(hash, createdObject);\n    return createdObject;\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nvar DEFAULT_VALUES = {\n  handle: null,\n  pipelines: null,\n  shaderCache: null,\n  bindGroupLayouts: null,\n  bufferManager: null,\n  textureManager: null\n}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Build VTK API\n\n  obj(publicAPI, model);\n  setGet(publicAPI, model, ['handle']);\n  get(publicAPI, model, ['bufferManager', 'shaderCache', 'textureManager']); // this is a weak ref cache implementation, we create it without\n  // an expirer (so it is strictly based on garbage collection and\n  // objects are not held if there are no external references)\n  // model.objectCache = new WeakLRUCache({ expirer: false });\n\n  model.objectCache = new WeakRefMap();\n  model.shaderCache = vtkWebGPUShaderCache.newInstance();\n  model.shaderCache.setDevice(publicAPI);\n  model.bindGroupLayouts = [];\n  model.bufferManager = vtkWebGPUBufferManager.newInstance();\n  model.bufferManager.setDevice(publicAPI);\n  model.textureManager = vtkWebGPUTextureManager.newInstance();\n  model.textureManager.setDevice(publicAPI);\n  model.pipelines = {}; // For more macro methods, see \"Sources/macros.js\"\n  // Object specific methods\n\n  vtkWebGPUDevice(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = newInstance$1(extend, 'vtkWebGPUDevice'); // ----------------------------------------------------------------------------\n\nvar vtkWebGPUDevice$1 = {\n  newInstance: newInstance,\n  extend: extend\n};\nexport { WeakRefMap, vtkWebGPUDevice$1 as default, extend, newInstance };","map":{"version":3,"names":["_typeof","_classCallCheck","_createClass","_assertThisInitialized","_inherits","_possibleConstructorReturn","_get","_getPrototypeOf","_wrapNativeSuper","newInstance","newInstance$1","obj","setGet","get","vtkWebGPUBufferManager","vtkWebGPUShaderCache","vtkWebGPUTextureManager","_createSuper","Derived","hasNativeReflectConstruct","_isNativeReflectConstruct","_createSuperInternal","Super","result","NewTarget","constructor","Reflect","construct","arguments","apply","sham","Proxy","Boolean","prototype","valueOf","call","e","WeakRefMap","_Map","_super","_thisSuper","_thisSuper2","_this","registry","FinalizationRegistry","key","entry","deref","undefined","value","getValue","setValue","WeakRef","register","Map","vtkWebGPUDevice","publicAPI","model","classHierarchy","push","initialize","handle","createCommandEncoder","submitCommandEncoder","commandEncoder","queue","submit","finish","getShaderModule","sd","shaderCache","getBindGroupLayout","val","entries","i","length","ent","binding","visibility","GPUShaderStage","VERTEX","FRAGMENT","sval","JSON","stringify","_i","bindGroupLayouts","layout","createBindGroupLayout","getBindGroupLayoutDescription","vtkErrorMacro","console","trace","getPipeline","hash","pipelines","createPipeline","pipeline","onSubmittedWorkDone","hasCachedObject","objectCache","getCachedObject","creator","existingValue","_len","args","Array","_key","createdObject","DEFAULT_VALUES","bufferManager","textureManager","extend","initialValues","Object","assign","setDevice","vtkWebGPUDevice$1","default"],"sources":["/home/rakshith/Documents/RemoteRendering/vtk-js-react-app/node_modules/@kitware/vtk.js/Rendering/WebGPU/Device.js"],"sourcesContent":["import _typeof from '@babel/runtime/helpers/typeof';\nimport _classCallCheck from '@babel/runtime/helpers/classCallCheck';\nimport _createClass from '@babel/runtime/helpers/createClass';\nimport _assertThisInitialized from '@babel/runtime/helpers/assertThisInitialized';\nimport _inherits from '@babel/runtime/helpers/inherits';\nimport _possibleConstructorReturn from '@babel/runtime/helpers/possibleConstructorReturn';\nimport _get from '@babel/runtime/helpers/get';\nimport _getPrototypeOf from '@babel/runtime/helpers/getPrototypeOf';\nimport _wrapNativeSuper from '@babel/runtime/helpers/wrapNativeSuper';\nimport { newInstance as newInstance$1, obj, setGet, get } from '../../macros.js';\nimport vtkWebGPUBufferManager from './BufferManager.js';\nimport vtkWebGPUShaderCache from './ShaderCache.js';\nimport vtkWebGPUTextureManager from './TextureManager.js';\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n/**\n * provide a simple WeakRefMap class to share device objects based on\n * hash values so that buffers/textures etc can be shared betwen mappers.\n * This is roughly based on WeakLRUCache but without the actual caching\n * behavior. This is just a map of key -> WeakRef(value)\n */\n\n/* eslint-disable no-undef */\n\nvar WeakRefMap = /*#__PURE__*/function (_Map) {\n  _inherits(WeakRefMap, _Map);\n\n  var _super = _createSuper(WeakRefMap);\n\n  function WeakRefMap() {\n    var _thisSuper, _thisSuper2, _this;\n\n    _classCallCheck(this, WeakRefMap);\n\n    _this = _super.call(this);\n    _this.registry = new FinalizationRegistry(function (key) {\n      var entry = _get((_thisSuper = _assertThisInitialized(_this), _getPrototypeOf(WeakRefMap.prototype)), \"get\", _thisSuper).call(_thisSuper, key);\n\n      if (entry && entry.deref && entry.deref() === undefined) _get((_thisSuper2 = _assertThisInitialized(_this), _getPrototypeOf(WeakRefMap.prototype)), \"delete\", _thisSuper2).call(_thisSuper2, key);\n    });\n    return _this;\n  }\n\n  _createClass(WeakRefMap, [{\n    key: \"getValue\",\n    value: function getValue(key) {\n      var entry = _get(_getPrototypeOf(WeakRefMap.prototype), \"get\", this).call(this, key);\n\n      if (entry) {\n        var value = entry.deref();\n        if (value !== undefined) return value;\n\n        _get(_getPrototypeOf(WeakRefMap.prototype), \"delete\", this).call(this, key);\n      }\n\n      return undefined;\n    }\n  }, {\n    key: \"setValue\",\n    value: function setValue(key, value) {\n      var entry;\n\n      if (value && _typeof(value) === 'object') {\n        entry = new WeakRef(value);\n        this.registry.register(value, key);\n\n        _get(_getPrototypeOf(WeakRefMap.prototype), \"set\", this).call(this, key, entry);\n      } // else entry is undefined\n\n\n      return entry;\n    }\n  }]);\n\n  return WeakRefMap;\n}( /*#__PURE__*/_wrapNativeSuper(Map));\n/* eslint-enable no-undef */\n// ----------------------------------------------------------------------------\n// vtkWebGPUDevice methods\n// ----------------------------------------------------------------------------\n\nfunction vtkWebGPUDevice(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkWebGPUDevice');\n\n  publicAPI.initialize = function (handle) {\n    model.handle = handle;\n  };\n\n  publicAPI.createCommandEncoder = function () {\n    return model.handle.createCommandEncoder();\n  };\n\n  publicAPI.submitCommandEncoder = function (commandEncoder) {\n    model.handle.queue.submit([commandEncoder.finish()]);\n  };\n\n  publicAPI.getShaderModule = function (sd) {\n    return model.shaderCache.getShaderModule(sd);\n  };\n  /* eslint-disable no-bitwise */\n\n  /* eslint-disable no-undef */\n\n\n  publicAPI.getBindGroupLayout = function (val) {\n    if (!val.entries) {\n      return null;\n    } // add in basic required values if missing\n\n\n    for (var i = 0; i < val.entries.length; i++) {\n      var ent = val.entries[i];\n      ent.binding = ent.binding || 0;\n      ent.visibility = ent.visibility || GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT;\n    } // do we already have one?\n\n\n    var sval = JSON.stringify(val);\n\n    for (var _i = 0; _i < model.bindGroupLayouts.length; _i++) {\n      if (model.bindGroupLayouts[_i].sval === sval) {\n        return model.bindGroupLayouts[_i].layout;\n      }\n    } // create one and store it\n\n\n    var layout = model.handle.createBindGroupLayout(val); // we actually only store the stringified version\n    // as that is what we always compare against\n\n    model.bindGroupLayouts.push({\n      sval: sval,\n      layout: layout\n    });\n    return layout;\n  };\n\n  publicAPI.getBindGroupLayoutDescription = function (layout) {\n    for (var i = 0; i < model.bindGroupLayouts.length; i++) {\n      if (model.bindGroupLayouts[i].layout === layout) {\n        return model.bindGroupLayouts[i].sval;\n      }\n    }\n\n    vtkErrorMacro('layout not found');\n    console.trace();\n    return null;\n  };\n\n  publicAPI.getPipeline = function (hash) {\n    if (hash in model.pipelines) {\n      return model.pipelines[hash];\n    }\n\n    return null;\n  };\n\n  publicAPI.createPipeline = function (hash, pipeline) {\n    pipeline.initialize(publicAPI, hash);\n    model.pipelines[hash] = pipeline;\n  };\n\n  publicAPI.onSubmittedWorkDone = function () {\n    return model.handle.queue.onSubmittedWorkDone();\n  }; // The Device has an object cache that can be used to cache buffers,\n  // textures and other objects that can be shared. The basic approach is to\n  // call getCachedObject with a request and a create function. The request\n  // is based on a hash. The cache lookup just returns any entry that has a\n  // matching hash. If a match isn't found then the create function is\n  // called with any extra arguments.\n  // is the object already cached?\n\n\n  publicAPI.hasCachedObject = function (hash) {\n    return model.objectCache.getValue(hash);\n  };\n\n  publicAPI.getCachedObject = function (hash, creator) {\n    if (!hash) {\n      vtkErrorMacro('attempt to cache an object without a hash');\n      return null;\n    }\n\n    var existingValue = model.objectCache.getValue(hash);\n\n    if (existingValue) {\n      return existingValue;\n    }\n\n    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n      args[_key - 2] = arguments[_key];\n    }\n\n    var createdObject = creator.apply(void 0, args);\n    model.objectCache.setValue(hash, createdObject);\n    return createdObject;\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\n\nvar DEFAULT_VALUES = {\n  handle: null,\n  pipelines: null,\n  shaderCache: null,\n  bindGroupLayouts: null,\n  bufferManager: null,\n  textureManager: null\n}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Build VTK API\n\n  obj(publicAPI, model);\n  setGet(publicAPI, model, ['handle']);\n  get(publicAPI, model, ['bufferManager', 'shaderCache', 'textureManager']); // this is a weak ref cache implementation, we create it without\n  // an expirer (so it is strictly based on garbage collection and\n  // objects are not held if there are no external references)\n  // model.objectCache = new WeakLRUCache({ expirer: false });\n\n  model.objectCache = new WeakRefMap();\n  model.shaderCache = vtkWebGPUShaderCache.newInstance();\n  model.shaderCache.setDevice(publicAPI);\n  model.bindGroupLayouts = [];\n  model.bufferManager = vtkWebGPUBufferManager.newInstance();\n  model.bufferManager.setDevice(publicAPI);\n  model.textureManager = vtkWebGPUTextureManager.newInstance();\n  model.textureManager.setDevice(publicAPI);\n  model.pipelines = {}; // For more macro methods, see \"Sources/macros.js\"\n  // Object specific methods\n\n  vtkWebGPUDevice(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = newInstance$1(extend, 'vtkWebGPUDevice'); // ----------------------------------------------------------------------------\n\nvar vtkWebGPUDevice$1 = {\n  newInstance: newInstance,\n  extend: extend\n};\n\nexport { WeakRefMap, vtkWebGPUDevice$1 as default, extend, newInstance };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}