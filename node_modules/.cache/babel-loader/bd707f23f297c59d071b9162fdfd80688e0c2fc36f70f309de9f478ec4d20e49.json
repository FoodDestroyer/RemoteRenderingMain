{"ast":null,"code":"import macro from '../../macros.js';\nimport vtkPolyData from '../../Common/DataModel/PolyData.js';\nimport vtkDataArray from '../../Common/Core/DataArray.js';\n\n// vtkSphereSource methods\n// ----------------------------------------------------------------------------\n\nfunction vtkSphereSource(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkSphereSource');\n  publicAPI.requestData = function (inData, outData) {\n    if (model.deleted) {\n      return;\n    }\n    var dataset = outData[0];\n    var pointDataType = dataset ? dataset.getPoints().getDataType() : model.pointType;\n    dataset = vtkPolyData.newInstance(); // ----------------------------------------------------------------------\n\n    var numPoles = 0; // Check data, determine increments, and convert to radians\n\n    var thetaResolution = model.thetaResolution;\n    var startTheta = model.startTheta < model.endTheta ? model.startTheta : model.endTheta;\n    startTheta *= Math.PI / 180.0;\n    var endTheta = model.endTheta > model.startTheta ? model.endTheta : model.startTheta;\n    endTheta *= Math.PI / 180.0;\n    var startPhi = model.startPhi < model.endPhi ? model.startPhi : model.endPhi;\n    startPhi *= Math.PI / 180.0;\n    var endPhi = model.endPhi > model.startPhi ? model.endPhi : model.startPhi;\n    endPhi *= Math.PI / 180.0;\n    if (Math.abs(startTheta - endTheta) < 2.0 * Math.PI) {\n      ++thetaResolution;\n    }\n    var deltaTheta = (endTheta - startTheta) / model.thetaResolution;\n    var jStart = model.startPhi <= 0.0 ? 1 : 0;\n    var jEnd = model.phiResolution + (model.endPhi >= 180.0 ? -1 : 0);\n    var numPts = model.phiResolution * thetaResolution + 2;\n    var numPolys = model.phiResolution * 2 * model.thetaResolution; // Points\n\n    var pointIdx = 0;\n    var points = macro.newTypedArray(pointDataType, numPts * 3); // Normals\n\n    var normals = new Float32Array(numPts * 3); // Cells\n\n    var cellLocation = 0;\n    var polys = new Uint32Array(numPolys * 5); // Create north pole if needed\n\n    if (model.startPhi <= 0.0) {\n      points[pointIdx * 3 + 0] = model.center[0];\n      points[pointIdx * 3 + 1] = model.center[1];\n      points[pointIdx * 3 + 2] = model.center[2] + model.radius;\n      normals[pointIdx * 3 + 0] = 0;\n      normals[pointIdx * 3 + 1] = 0;\n      normals[pointIdx * 3 + 2] = 1;\n      pointIdx++;\n      numPoles++;\n    } // Create south pole if needed\n\n    if (model.endPhi >= 180.0) {\n      points[pointIdx * 3 + 0] = model.center[0];\n      points[pointIdx * 3 + 1] = model.center[1];\n      points[pointIdx * 3 + 2] = model.center[2] - model.radius;\n      normals[pointIdx * 3 + 0] = 0;\n      normals[pointIdx * 3 + 1] = 0;\n      normals[pointIdx * 3 + 2] = -1;\n      pointIdx++;\n      numPoles++;\n    }\n    var phiResolution = model.phiResolution - numPoles;\n    var deltaPhi = (endPhi - startPhi) / (model.phiResolution - 1); // Create intermediate points\n\n    for (var i = 0; i < thetaResolution; i++) {\n      var theta = startTheta + i * deltaTheta;\n      for (var j = jStart; j < jEnd; j++) {\n        var phi = startPhi + j * deltaPhi;\n        var radius = model.radius * Math.sin(phi);\n        normals[pointIdx * 3 + 0] = radius * Math.cos(theta);\n        normals[pointIdx * 3 + 1] = radius * Math.sin(theta);\n        normals[pointIdx * 3 + 2] = model.radius * Math.cos(phi);\n        points[pointIdx * 3 + 0] = normals[pointIdx * 3 + 0] + model.center[0];\n        points[pointIdx * 3 + 1] = normals[pointIdx * 3 + 1] + model.center[1];\n        points[pointIdx * 3 + 2] = normals[pointIdx * 3 + 2] + model.center[2];\n        var norm = Math.sqrt(normals[pointIdx * 3 + 0] * normals[pointIdx * 3 + 0] + normals[pointIdx * 3 + 1] * normals[pointIdx * 3 + 1] + normals[pointIdx * 3 + 2] * normals[pointIdx * 3 + 2]);\n        norm = norm === 0 ? 1 : norm;\n        normals[pointIdx * 3 + 0] /= norm;\n        normals[pointIdx * 3 + 1] /= norm;\n        normals[pointIdx * 3 + 2] /= norm;\n        pointIdx++;\n      }\n    } // Generate mesh connectivity\n\n    var base = phiResolution * thetaResolution;\n    if (Math.abs(startTheta - endTheta) < 2.0 * Math.PI) {\n      --thetaResolution;\n    } // around north pole\n\n    if (model.startPhi <= 0.0) {\n      for (var _i = 0; _i < thetaResolution; _i++) {\n        polys[cellLocation++] = 3;\n        polys[cellLocation++] = phiResolution * _i + numPoles;\n        polys[cellLocation++] = phiResolution * (_i + 1) % base + numPoles;\n        polys[cellLocation++] = 0;\n      }\n    } // around south pole\n\n    if (model.endPhi >= 180.0) {\n      var numOffset = phiResolution - 1 + numPoles;\n      for (var _i2 = 0; _i2 < thetaResolution; _i2++) {\n        polys[cellLocation++] = 3;\n        polys[cellLocation++] = phiResolution * _i2 + numOffset;\n        polys[cellLocation++] = numPoles - 1;\n        polys[cellLocation++] = phiResolution * (_i2 + 1) % base + numOffset;\n      }\n    } // bands in-between poles\n\n    for (var _i3 = 0; _i3 < thetaResolution; _i3++) {\n      for (var _j = 0; _j < phiResolution - 1; _j++) {\n        var a = phiResolution * _i3 + _j + numPoles;\n        var b = a + 1;\n        var c = (phiResolution * (_i3 + 1) + _j) % base + numPoles + 1;\n        if (!model.latLongTessellation) {\n          polys[cellLocation++] = 3;\n          polys[cellLocation++] = a;\n          polys[cellLocation++] = b;\n          polys[cellLocation++] = c;\n          polys[cellLocation++] = 3;\n          polys[cellLocation++] = a;\n          polys[cellLocation++] = c;\n          polys[cellLocation++] = c - 1;\n        } else {\n          polys[cellLocation++] = 4;\n          polys[cellLocation++] = a;\n          polys[cellLocation++] = b;\n          polys[cellLocation++] = c;\n          polys[cellLocation++] = c - 1;\n        }\n      }\n    } // Squeeze\n\n    points = points.subarray(0, pointIdx * 3);\n    dataset.getPoints().setData(points, 3);\n    normals = normals.subarray(0, pointIdx * 3);\n    var normalArray = vtkDataArray.newInstance({\n      name: 'Normals',\n      values: normals,\n      numberOfComponents: 3\n    });\n    dataset.getPointData().setNormals(normalArray);\n    polys = polys.subarray(0, cellLocation);\n    dataset.getPolys().setData(polys, 1); // Update output\n\n    outData[0] = dataset;\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nvar DEFAULT_VALUES = {\n  radius: 0.5,\n  latLongTessellation: false,\n  thetaResolution: 8,\n  startTheta: 0.0,\n  endTheta: 360.0,\n  phiResolution: 8,\n  startPhi: 0.0,\n  endPhi: 180.0,\n  center: [0, 0, 0],\n  pointType: 'Float64Array'\n}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Build VTK API\n\n  macro.obj(publicAPI, model);\n  macro.setGet(publicAPI, model, ['radius', 'latLongTessellation', 'thetaResolution', 'startTheta', 'endTheta', 'phiResolution', 'startPhi', 'endPhi']);\n  macro.setGetArray(publicAPI, model, ['center'], 3);\n  macro.algo(publicAPI, model, 0, 1);\n  vtkSphereSource(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = macro.newInstance(extend, 'vtkSphereSource'); // ----------------------------------------------------------------------------\n\nvar vtkSphereSource$1 = {\n  newInstance: newInstance,\n  extend: extend\n};\nexport { vtkSphereSource$1 as default, extend, newInstance };","map":{"version":3,"names":["macro","vtkPolyData","vtkDataArray","vtkSphereSource","publicAPI","model","classHierarchy","push","requestData","inData","outData","deleted","dataset","pointDataType","getPoints","getDataType","pointType","newInstance","numPoles","thetaResolution","startTheta","endTheta","Math","PI","startPhi","endPhi","abs","deltaTheta","jStart","jEnd","phiResolution","numPts","numPolys","pointIdx","points","newTypedArray","normals","Float32Array","cellLocation","polys","Uint32Array","center","radius","deltaPhi","i","theta","j","phi","sin","cos","norm","sqrt","base","_i","numOffset","_i2","_i3","_j","a","b","c","latLongTessellation","subarray","setData","normalArray","name","values","numberOfComponents","getPointData","setNormals","getPolys","DEFAULT_VALUES","extend","initialValues","arguments","length","undefined","Object","assign","obj","setGet","setGetArray","algo","vtkSphereSource$1","default"],"sources":["/home/rakshith/Documents/RemoteRendering/vtk-js-react-app/node_modules/@kitware/vtk.js/Filters/Sources/SphereSource.js"],"sourcesContent":["import macro from '../../macros.js';\nimport vtkPolyData from '../../Common/DataModel/PolyData.js';\nimport vtkDataArray from '../../Common/Core/DataArray.js';\n\n// vtkSphereSource methods\n// ----------------------------------------------------------------------------\n\nfunction vtkSphereSource(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkSphereSource');\n\n  publicAPI.requestData = function (inData, outData) {\n    if (model.deleted) {\n      return;\n    }\n\n    var dataset = outData[0];\n    var pointDataType = dataset ? dataset.getPoints().getDataType() : model.pointType;\n    dataset = vtkPolyData.newInstance(); // ----------------------------------------------------------------------\n\n    var numPoles = 0; // Check data, determine increments, and convert to radians\n\n    var thetaResolution = model.thetaResolution;\n    var startTheta = model.startTheta < model.endTheta ? model.startTheta : model.endTheta;\n    startTheta *= Math.PI / 180.0;\n    var endTheta = model.endTheta > model.startTheta ? model.endTheta : model.startTheta;\n    endTheta *= Math.PI / 180.0;\n    var startPhi = model.startPhi < model.endPhi ? model.startPhi : model.endPhi;\n    startPhi *= Math.PI / 180.0;\n    var endPhi = model.endPhi > model.startPhi ? model.endPhi : model.startPhi;\n    endPhi *= Math.PI / 180.0;\n\n    if (Math.abs(startTheta - endTheta) < 2.0 * Math.PI) {\n      ++thetaResolution;\n    }\n\n    var deltaTheta = (endTheta - startTheta) / model.thetaResolution;\n    var jStart = model.startPhi <= 0.0 ? 1 : 0;\n    var jEnd = model.phiResolution + (model.endPhi >= 180.0 ? -1 : 0);\n    var numPts = model.phiResolution * thetaResolution + 2;\n    var numPolys = model.phiResolution * 2 * model.thetaResolution; // Points\n\n    var pointIdx = 0;\n    var points = macro.newTypedArray(pointDataType, numPts * 3); // Normals\n\n    var normals = new Float32Array(numPts * 3); // Cells\n\n    var cellLocation = 0;\n    var polys = new Uint32Array(numPolys * 5); // Create north pole if needed\n\n    if (model.startPhi <= 0.0) {\n      points[pointIdx * 3 + 0] = model.center[0];\n      points[pointIdx * 3 + 1] = model.center[1];\n      points[pointIdx * 3 + 2] = model.center[2] + model.radius;\n      normals[pointIdx * 3 + 0] = 0;\n      normals[pointIdx * 3 + 1] = 0;\n      normals[pointIdx * 3 + 2] = 1;\n      pointIdx++;\n      numPoles++;\n    } // Create south pole if needed\n\n\n    if (model.endPhi >= 180.0) {\n      points[pointIdx * 3 + 0] = model.center[0];\n      points[pointIdx * 3 + 1] = model.center[1];\n      points[pointIdx * 3 + 2] = model.center[2] - model.radius;\n      normals[pointIdx * 3 + 0] = 0;\n      normals[pointIdx * 3 + 1] = 0;\n      normals[pointIdx * 3 + 2] = -1;\n      pointIdx++;\n      numPoles++;\n    }\n\n    var phiResolution = model.phiResolution - numPoles;\n    var deltaPhi = (endPhi - startPhi) / (model.phiResolution - 1); // Create intermediate points\n\n    for (var i = 0; i < thetaResolution; i++) {\n      var theta = startTheta + i * deltaTheta;\n\n      for (var j = jStart; j < jEnd; j++) {\n        var phi = startPhi + j * deltaPhi;\n        var radius = model.radius * Math.sin(phi);\n        normals[pointIdx * 3 + 0] = radius * Math.cos(theta);\n        normals[pointIdx * 3 + 1] = radius * Math.sin(theta);\n        normals[pointIdx * 3 + 2] = model.radius * Math.cos(phi);\n        points[pointIdx * 3 + 0] = normals[pointIdx * 3 + 0] + model.center[0];\n        points[pointIdx * 3 + 1] = normals[pointIdx * 3 + 1] + model.center[1];\n        points[pointIdx * 3 + 2] = normals[pointIdx * 3 + 2] + model.center[2];\n        var norm = Math.sqrt(normals[pointIdx * 3 + 0] * normals[pointIdx * 3 + 0] + normals[pointIdx * 3 + 1] * normals[pointIdx * 3 + 1] + normals[pointIdx * 3 + 2] * normals[pointIdx * 3 + 2]);\n        norm = norm === 0 ? 1 : norm;\n        normals[pointIdx * 3 + 0] /= norm;\n        normals[pointIdx * 3 + 1] /= norm;\n        normals[pointIdx * 3 + 2] /= norm;\n        pointIdx++;\n      }\n    } // Generate mesh connectivity\n\n\n    var base = phiResolution * thetaResolution;\n\n    if (Math.abs(startTheta - endTheta) < 2.0 * Math.PI) {\n      --thetaResolution;\n    } // around north pole\n\n\n    if (model.startPhi <= 0.0) {\n      for (var _i = 0; _i < thetaResolution; _i++) {\n        polys[cellLocation++] = 3;\n        polys[cellLocation++] = phiResolution * _i + numPoles;\n        polys[cellLocation++] = phiResolution * (_i + 1) % base + numPoles;\n        polys[cellLocation++] = 0;\n      }\n    } // around south pole\n\n\n    if (model.endPhi >= 180.0) {\n      var numOffset = phiResolution - 1 + numPoles;\n\n      for (var _i2 = 0; _i2 < thetaResolution; _i2++) {\n        polys[cellLocation++] = 3;\n        polys[cellLocation++] = phiResolution * _i2 + numOffset;\n        polys[cellLocation++] = numPoles - 1;\n        polys[cellLocation++] = phiResolution * (_i2 + 1) % base + numOffset;\n      }\n    } // bands in-between poles\n\n\n    for (var _i3 = 0; _i3 < thetaResolution; _i3++) {\n      for (var _j = 0; _j < phiResolution - 1; _j++) {\n        var a = phiResolution * _i3 + _j + numPoles;\n        var b = a + 1;\n        var c = (phiResolution * (_i3 + 1) + _j) % base + numPoles + 1;\n\n        if (!model.latLongTessellation) {\n          polys[cellLocation++] = 3;\n          polys[cellLocation++] = a;\n          polys[cellLocation++] = b;\n          polys[cellLocation++] = c;\n          polys[cellLocation++] = 3;\n          polys[cellLocation++] = a;\n          polys[cellLocation++] = c;\n          polys[cellLocation++] = c - 1;\n        } else {\n          polys[cellLocation++] = 4;\n          polys[cellLocation++] = a;\n          polys[cellLocation++] = b;\n          polys[cellLocation++] = c;\n          polys[cellLocation++] = c - 1;\n        }\n      }\n    } // Squeeze\n\n\n    points = points.subarray(0, pointIdx * 3);\n    dataset.getPoints().setData(points, 3);\n    normals = normals.subarray(0, pointIdx * 3);\n    var normalArray = vtkDataArray.newInstance({\n      name: 'Normals',\n      values: normals,\n      numberOfComponents: 3\n    });\n    dataset.getPointData().setNormals(normalArray);\n    polys = polys.subarray(0, cellLocation);\n    dataset.getPolys().setData(polys, 1); // Update output\n\n    outData[0] = dataset;\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\n\nvar DEFAULT_VALUES = {\n  radius: 0.5,\n  latLongTessellation: false,\n  thetaResolution: 8,\n  startTheta: 0.0,\n  endTheta: 360.0,\n  phiResolution: 8,\n  startPhi: 0.0,\n  endPhi: 180.0,\n  center: [0, 0, 0],\n  pointType: 'Float64Array'\n}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Build VTK API\n\n  macro.obj(publicAPI, model);\n  macro.setGet(publicAPI, model, ['radius', 'latLongTessellation', 'thetaResolution', 'startTheta', 'endTheta', 'phiResolution', 'startPhi', 'endPhi']);\n  macro.setGetArray(publicAPI, model, ['center'], 3);\n  macro.algo(publicAPI, model, 0, 1);\n  vtkSphereSource(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = macro.newInstance(extend, 'vtkSphereSource'); // ----------------------------------------------------------------------------\n\nvar vtkSphereSource$1 = {\n  newInstance: newInstance,\n  extend: extend\n};\n\nexport { vtkSphereSource$1 as default, extend, newInstance };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}