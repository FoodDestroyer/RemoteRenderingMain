{"ast":null,"code":"import _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport macro from '../../macros.js';\nimport vtkCellTypes from '../../Common/DataModel/CellTypes.js';\nimport vtkLine from '../../Common/DataModel/Line.js';\nimport vtkPicker from './Picker.js';\nimport vtkPolyLine from '../../Common/DataModel/PolyLine.js';\nimport vtkTriangle from '../../Common/DataModel/Triangle.js';\nimport vtkQuad from '../../Common/DataModel/Quad.js';\nimport { l as normalize } from '../../Common/Core/Math/index.js';\nimport { CellType } from '../../Common/DataModel/CellTypes/Constants.js';\nimport { vec3 } from 'gl-matrix';\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n  return target;\n}\n// Global methods\n// ----------------------------------------------------------------------------\n\nfunction createCellMap() {\n  var _ref;\n  return _ref = {}, _defineProperty(_ref, CellType.VTK_LINE, vtkLine.newInstance()), _defineProperty(_ref, CellType.VTK_POLY_LINE, vtkPolyLine.newInstance()), _defineProperty(_ref, CellType.VTK_TRIANGLE, vtkTriangle.newInstance()), _defineProperty(_ref, CellType.VTK_QUAD, vtkQuad.newInstance()), _ref;\n}\nfunction clipLineWithPlane(mapper, matrix, p1, p2) {\n  var outObj = {\n    planeId: -1,\n    t1: 0.0,\n    t2: 1.0,\n    intersect: 0\n  };\n  var nbClippingPlanes = mapper.getNumberOfClippingPlanes();\n  var plane = [];\n  for (var i = 0; i < nbClippingPlanes; i++) {\n    mapper.getClippingPlaneInDataCoords(matrix, i, plane);\n    var d1 = plane[0] * p1[0] + plane[1] * p1[1] + plane[2] * p1[2] + plane[3];\n    var d2 = plane[0] * p2[0] + plane[1] * p2[1] + plane[2] * p2[2] + plane[3]; // If both distances are negative, both points are outside\n\n    if (d1 < 0 && d2 < 0) {\n      return 0;\n    }\n    if (d1 < 0 || d2 < 0) {\n      // If only one of the distances is negative, the line crosses the plane\n      // Compute fractional distance \"t\" of the crossing between p1 & p2\n      var t = 0.0; // The \"if\" here just avoids an expensive division when possible\n\n      if (d1 !== 0) {\n        // We will never have d1==d2 since they have different signs\n        t = d1 / (d1 - d2);\n      } // If point p1 was clipped, adjust t1\n\n      if (d1 < 0) {\n        if (t >= outObj.t1) {\n          outObj.t1 = t;\n          outObj.planeId = i;\n        }\n      } else if (t <= outObj.t2) {\n        // else point p2 was clipped, so adjust t2\n        outObj.t2 = t;\n      } // If this happens, there's no line left\n\n      if (outObj.t1 > outObj.t2) {\n        outObj.intersect = 0;\n        return outObj;\n      }\n    }\n  }\n  outObj.intersect = 1;\n  return outObj;\n} // ----------------------------------------------------------------------------\n// Static API\n// ----------------------------------------------------------------------------\n\nvar STATIC = {\n  clipLineWithPlane: clipLineWithPlane\n}; // ----------------------------------------------------------------------------\n// vtkCellPicker methods\n// ----------------------------------------------------------------------------\n\nfunction vtkCellPicker(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkCellPicker');\n  var superClass = _objectSpread({}, publicAPI);\n  function resetCellPickerInfo() {\n    model.cellId = -1;\n    model.pCoords[0] = 0.0;\n    model.pCoords[1] = 0.0;\n    model.pCoords[2] = 0.0;\n    model.cellIJK[0] = 0.0;\n    model.cellIJK[1] = 0.0;\n    model.cellIJK[2] = 0.0;\n    model.mapperNormal[0] = 0.0;\n    model.mapperNormal[1] = 0.0;\n    model.mapperNormal[2] = 1.0;\n    model.pickNormal[0] = 0.0;\n    model.pickNormal[1] = 0.0;\n    model.pickNormal[2] = 1.0;\n  }\n  function resetPickInfo() {\n    model.dataSet = null;\n    model.mapper = null;\n    resetCellPickerInfo();\n  }\n  publicAPI.initialize = function () {\n    resetPickInfo();\n    superClass.initialize();\n  };\n  publicAPI.computeSurfaceNormal = function (data, cell, weights, normal) {\n    var normals = data.getPointData().getNormals(); // TODO add getCellDimension on vtkCell\n\n    if (normals) {\n      normal[0] = 0.0;\n      normal[1] = 0.0;\n      normal[2] = 0.0;\n      var pointNormal = [];\n      for (var i = 0; i < 3; i++) {\n        normals.getTuple(cell.getPointsIds()[i], pointNormal);\n        normal[0] += pointNormal[0] * weights[i];\n        normal[1] += pointNormal[1] * weights[i];\n        normal[2] += pointNormal[2] * weights[i];\n      }\n      normalize(normal);\n    } else {\n      return 0;\n    }\n    return 1;\n  };\n  publicAPI.pick = function (selection, renderer) {\n    publicAPI.initialize();\n    var pickResult = superClass.pick(selection, renderer);\n    if (pickResult) {\n      var camera = renderer.getActiveCamera();\n      var cameraPos = [];\n      camera.getPosition(cameraPos);\n      if (camera.getParallelProjection()) {\n        // For parallel projection, use -ve direction of projection\n        var cameraFocus = [];\n        camera.getFocalPoint(cameraFocus);\n        model.pickNormal[0] = cameraPos[0] - cameraFocus[0];\n        model.pickNormal[1] = cameraPos[1] - cameraFocus[1];\n        model.pickNormal[2] = cameraPos[2] - cameraFocus[2];\n      } else {\n        // Get the vector from pick position to the camera\n        model.pickNormal[0] = cameraPos[0] - model.pickPosition[0];\n        model.pickNormal[1] = cameraPos[1] - model.pickPosition[1];\n        model.pickNormal[2] = cameraPos[2] - model.pickPosition[2];\n      }\n      normalize(model.pickNormal);\n    }\n    return pickResult;\n  };\n  publicAPI.intersectWithLine = function (p1, p2, tol, mapper) {\n    var tMin = Number.MAX_VALUE;\n    var t1 = 0.0;\n    var t2 = 1.0;\n    var vtkCellPickerPlaneTol = 1e-14;\n    var clipLine = clipLineWithPlane(mapper, model.transformMatrix, p1, p2);\n    if (mapper && !clipLine.intersect) {\n      return Number.MAX_VALUE;\n    }\n    if (mapper.isA('vtkImageMapper') || mapper.isA('vtkImageArrayMapper')) {\n      var pickData = mapper.intersectWithLineForCellPicking(p1, p2);\n      if (pickData) {\n        tMin = pickData.t;\n        model.cellIJK = pickData.ijk;\n        model.pCoords = pickData.pCoords;\n      }\n    } else if (mapper.isA('vtkMapper')) {\n      tMin = publicAPI.intersectActorWithLine(p1, p2, t1, t2, tol, mapper);\n    }\n    if (tMin < model.globalTMin) {\n      model.globalTMin = tMin;\n      if (Math.abs(tMin - t1) < vtkCellPickerPlaneTol && clipLine.clippingPlaneId >= 0) {\n        model.mapperPosition[0] = p1[0] * (1 - t1) + p2[0] * t1;\n        model.mapperPosition[1] = p1[1] * (1 - t1) + p2[1] * t1;\n        model.mapperPosition[2] = p1[2] * (1 - t1) + p2[2] * t1;\n        var plane = [];\n        mapper.getClippingPlaneInDataCoords(model.transformMatrix, clipLine.clippingPlaneId, plane);\n        normalize(plane); // Want normal outward from the planes, not inward\n\n        model.mapperNormal[0] = -plane[0];\n        model.mapperNormal[1] = -plane[1];\n        model.mapperNormal[2] = -plane[2];\n      }\n      vec3.transformMat4(model.pickPosition, model.mapperPosition, model.transformMatrix); // Transform vector\n\n      var mat = model.transformMatrix;\n      model.mapperNormal[0] = mat[0] * model.pickNormal[0] + mat[4] * model.pickNormal[1] + mat[8] * model.pickNormal[2];\n      model.mapperNormal[1] = mat[1] * model.pickNormal[0] + mat[5] * model.pickNormal[1] + mat[9] * model.pickNormal[2];\n      model.mapperNormal[2] = mat[2] * model.pickNormal[0] + mat[6] * model.pickNormal[1] + mat[10] * model.pickNormal[2];\n    }\n    return tMin;\n  };\n  publicAPI.intersectActorWithLine = function (p1, p2, t1, t2, tol, mapper) {\n    var tMin = Number.MAX_VALUE;\n    var minXYZ = [0, 0, 0];\n    var pDistMin = Number.MAX_VALUE;\n    var minPCoords = [0, 0, 0];\n    var minCellId = null;\n    var minCell = null;\n    var minCellType = null;\n    var subId = null;\n    var x = [];\n    var data = mapper.getInputData();\n    var q1 = [0, 0, 0];\n    var q2 = [0, 0, 0];\n    q1[0] = p1[0];\n    q1[1] = p1[1];\n    q1[2] = p1[2];\n    q2[0] = p2[0];\n    q2[1] = p2[1];\n    q2[2] = p2[2];\n    if (t1 !== 0.0 || t2 !== 1.0) {\n      for (var j = 0; j < 3; j++) {\n        q1[j] = p1[j] * (1.0 - t1) + p2[j] * t1;\n        q2[j] = p1[j] * (1.0 - t2) + p2[j] * t2;\n      }\n    }\n    if (data.getCells) {\n      if (!data.getCells()) {\n        data.buildLinks();\n      }\n      var tempCellMap = createCellMap();\n      var minCellMap = createCellMap();\n      var numberOfCells = data.getNumberOfCells();\n      /* eslint-disable no-continue */\n\n      for (var cellId = 0; cellId < numberOfCells; cellId++) {\n        var pCoords = [0, 0, 0];\n        minCellType = data.getCellType(cellId); // Skip cells that are marked as empty\n\n        if (minCellType === CellType.VTK_EMPTY_CELL) {\n          continue;\n        }\n        var cell = tempCellMap[minCellType];\n        if (cell == null) {\n          continue;\n        }\n        minCell = minCellMap[minCellType];\n        data.getCell(cellId, cell);\n        var cellPicked = void 0;\n        {\n          if (vtkCellTypes.hasSubCells(minCellType)) {\n            cellPicked = cell.intersectWithLine(t1, t2, p1, p2, tol, x, pCoords);\n          } else {\n            cellPicked = cell.intersectWithLine(p1, p2, tol, x, pCoords);\n          }\n        }\n        if (cellPicked.intersect === 1 && cellPicked.t <= tMin + model.tolerance && cellPicked.t >= t1 && cellPicked.t <= t2) {\n          var pDist = cell.getParametricDistance(pCoords);\n          if (pDist < pDistMin || pDist === pDistMin && cellPicked.t < tMin) {\n            tMin = cellPicked.t;\n            pDistMin = pDist;\n            subId = cellPicked.subId;\n            minCellId = cellId;\n            cell.deepCopy(minCell);\n            for (var k = 0; k < 3; k++) {\n              minXYZ[k] = x[k];\n              minPCoords[k] = pCoords[k];\n            }\n          }\n        }\n      }\n      /* eslint-enable no-continue */\n    }\n\n    if (minCellId >= 0 && tMin < model.globalTMin) {\n      resetPickInfo();\n      var nbPointsInCell = minCell.getNumberOfPoints();\n      var weights = new Array(nbPointsInCell);\n      for (var i = 0; i < nbPointsInCell; i++) {\n        weights[i] = 0.0;\n      }\n      var point = [];\n      if (vtkCellTypes.hasSubCells(minCellType)) {\n        minCell.evaluateLocation(subId, minPCoords, point, weights);\n      } else {\n        minCell.evaluateLocation(minPCoords, point, weights);\n      } // Return the polydata to the user\n\n      model.dataSet = data;\n      model.cellId = minCellId;\n      model.pCoords[0] = minPCoords[0];\n      model.pCoords[1] = minPCoords[1];\n      model.pCoords[2] = minPCoords[2]; // Find the point with the maximum weight\n\n      var maxWeight = 0;\n      var iMaxWeight = -1;\n      for (var _i = 0; _i < nbPointsInCell; _i++) {\n        if (weights[_i] > maxWeight) {\n          iMaxWeight = _i;\n          maxWeight = weights[_i];\n        }\n      } // If maximum weight is found, use it to get the PointId\n\n      if (iMaxWeight !== -1) {\n        model.pointId = minCell.getPointsIds()[iMaxWeight];\n      } // Set the mapper position\n\n      model.mapperPosition[0] = minXYZ[0];\n      model.mapperPosition[1] = minXYZ[1];\n      model.mapperPosition[2] = minXYZ[2]; // Compute the normal\n\n      if (!publicAPI.computeSurfaceNormal(data, minCell, weights, model.mapperNormal)) {\n        // By default, the normal points back along view ray\n        model.mapperNormal[0] = p1[0] - p2[0];\n        model.mapperNormal[1] = p1[1] - p2[1];\n        model.mapperNormal[2] = p1[2] - p2[2];\n        normalize(model.mapperNormal);\n      }\n    }\n    return tMin;\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nvar DEFAULT_VALUES = {\n  cellId: -1,\n  pCoords: [],\n  cellIJK: [],\n  pickNormal: [],\n  mapperNormal: []\n}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Inheritance\n\n  vtkPicker.extend(publicAPI, model, initialValues);\n  macro.getArray(publicAPI, model, ['pickNormal', 'mapperNormal', 'pCoords', 'cellIJK']);\n  macro.get(publicAPI, model, ['cellId']); // Object methods\n\n  vtkCellPicker(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = macro.newInstance(extend, 'vtkCellPicker'); // ----------------------------------------------------------------------------\n\nvar vtkCellPicker$1 = _objectSpread({\n  newInstance: newInstance,\n  extend: extend\n}, STATIC);\nexport { STATIC, vtkCellPicker$1 as default, extend, newInstance };","map":{"version":3,"names":["_defineProperty","macro","vtkCellTypes","vtkLine","vtkPicker","vtkPolyLine","vtkTriangle","vtkQuad","l","normalize","CellType","vec3","ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","getOwnPropertyDescriptors","defineProperties","defineProperty","createCellMap","_ref","VTK_LINE","newInstance","VTK_POLY_LINE","VTK_TRIANGLE","VTK_QUAD","clipLineWithPlane","mapper","matrix","p1","p2","outObj","planeId","t1","t2","intersect","nbClippingPlanes","getNumberOfClippingPlanes","plane","getClippingPlaneInDataCoords","d1","d2","t","STATIC","vtkCellPicker","publicAPI","model","classHierarchy","superClass","resetCellPickerInfo","cellId","pCoords","cellIJK","mapperNormal","pickNormal","resetPickInfo","dataSet","initialize","computeSurfaceNormal","data","cell","weights","normal","normals","getPointData","getNormals","pointNormal","getTuple","getPointsIds","pick","selection","renderer","pickResult","camera","getActiveCamera","cameraPos","getPosition","getParallelProjection","cameraFocus","getFocalPoint","pickPosition","intersectWithLine","tol","tMin","Number","MAX_VALUE","vtkCellPickerPlaneTol","clipLine","transformMatrix","isA","pickData","intersectWithLineForCellPicking","ijk","intersectActorWithLine","globalTMin","Math","abs","clippingPlaneId","mapperPosition","transformMat4","mat","minXYZ","pDistMin","minPCoords","minCellId","minCell","minCellType","subId","x","getInputData","q1","q2","j","getCells","buildLinks","tempCellMap","minCellMap","numberOfCells","getNumberOfCells","getCellType","VTK_EMPTY_CELL","getCell","cellPicked","hasSubCells","tolerance","pDist","getParametricDistance","deepCopy","k","nbPointsInCell","getNumberOfPoints","Array","point","evaluateLocation","maxWeight","iMaxWeight","_i","pointId","DEFAULT_VALUES","extend","initialValues","undefined","assign","getArray","get","vtkCellPicker$1","default"],"sources":["/home/rakshith/Documents/RemoteRendering/vtk-js-react-app/node_modules/@kitware/vtk.js/Rendering/Core/CellPicker.js"],"sourcesContent":["import _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport macro from '../../macros.js';\nimport vtkCellTypes from '../../Common/DataModel/CellTypes.js';\nimport vtkLine from '../../Common/DataModel/Line.js';\nimport vtkPicker from './Picker.js';\nimport vtkPolyLine from '../../Common/DataModel/PolyLine.js';\nimport vtkTriangle from '../../Common/DataModel/Triangle.js';\nimport vtkQuad from '../../Common/DataModel/Quad.js';\nimport { l as normalize } from '../../Common/Core/Math/index.js';\nimport { CellType } from '../../Common/DataModel/CellTypes/Constants.js';\nimport { vec3 } from 'gl-matrix';\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n// Global methods\n// ----------------------------------------------------------------------------\n\nfunction createCellMap() {\n  var _ref;\n\n  return _ref = {}, _defineProperty(_ref, CellType.VTK_LINE, vtkLine.newInstance()), _defineProperty(_ref, CellType.VTK_POLY_LINE, vtkPolyLine.newInstance()), _defineProperty(_ref, CellType.VTK_TRIANGLE, vtkTriangle.newInstance()), _defineProperty(_ref, CellType.VTK_QUAD, vtkQuad.newInstance()), _ref;\n}\n\nfunction clipLineWithPlane(mapper, matrix, p1, p2) {\n  var outObj = {\n    planeId: -1,\n    t1: 0.0,\n    t2: 1.0,\n    intersect: 0\n  };\n  var nbClippingPlanes = mapper.getNumberOfClippingPlanes();\n  var plane = [];\n\n  for (var i = 0; i < nbClippingPlanes; i++) {\n    mapper.getClippingPlaneInDataCoords(matrix, i, plane);\n    var d1 = plane[0] * p1[0] + plane[1] * p1[1] + plane[2] * p1[2] + plane[3];\n    var d2 = plane[0] * p2[0] + plane[1] * p2[1] + plane[2] * p2[2] + plane[3]; // If both distances are negative, both points are outside\n\n    if (d1 < 0 && d2 < 0) {\n      return 0;\n    }\n\n    if (d1 < 0 || d2 < 0) {\n      // If only one of the distances is negative, the line crosses the plane\n      // Compute fractional distance \"t\" of the crossing between p1 & p2\n      var t = 0.0; // The \"if\" here just avoids an expensive division when possible\n\n      if (d1 !== 0) {\n        // We will never have d1==d2 since they have different signs\n        t = d1 / (d1 - d2);\n      } // If point p1 was clipped, adjust t1\n\n\n      if (d1 < 0) {\n        if (t >= outObj.t1) {\n          outObj.t1 = t;\n          outObj.planeId = i;\n        }\n      } else if (t <= outObj.t2) {\n        // else point p2 was clipped, so adjust t2\n        outObj.t2 = t;\n      } // If this happens, there's no line left\n\n\n      if (outObj.t1 > outObj.t2) {\n        outObj.intersect = 0;\n        return outObj;\n      }\n    }\n  }\n\n  outObj.intersect = 1;\n  return outObj;\n} // ----------------------------------------------------------------------------\n// Static API\n// ----------------------------------------------------------------------------\n\n\nvar STATIC = {\n  clipLineWithPlane: clipLineWithPlane\n}; // ----------------------------------------------------------------------------\n// vtkCellPicker methods\n// ----------------------------------------------------------------------------\n\nfunction vtkCellPicker(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkCellPicker');\n\n  var superClass = _objectSpread({}, publicAPI);\n\n  function resetCellPickerInfo() {\n    model.cellId = -1;\n    model.pCoords[0] = 0.0;\n    model.pCoords[1] = 0.0;\n    model.pCoords[2] = 0.0;\n    model.cellIJK[0] = 0.0;\n    model.cellIJK[1] = 0.0;\n    model.cellIJK[2] = 0.0;\n    model.mapperNormal[0] = 0.0;\n    model.mapperNormal[1] = 0.0;\n    model.mapperNormal[2] = 1.0;\n    model.pickNormal[0] = 0.0;\n    model.pickNormal[1] = 0.0;\n    model.pickNormal[2] = 1.0;\n  }\n\n  function resetPickInfo() {\n    model.dataSet = null;\n    model.mapper = null;\n    resetCellPickerInfo();\n  }\n\n  publicAPI.initialize = function () {\n    resetPickInfo();\n    superClass.initialize();\n  };\n\n  publicAPI.computeSurfaceNormal = function (data, cell, weights, normal) {\n    var normals = data.getPointData().getNormals(); // TODO add getCellDimension on vtkCell\n\n    if (normals) {\n      normal[0] = 0.0;\n      normal[1] = 0.0;\n      normal[2] = 0.0;\n      var pointNormal = [];\n\n      for (var i = 0; i < 3; i++) {\n        normals.getTuple(cell.getPointsIds()[i], pointNormal);\n        normal[0] += pointNormal[0] * weights[i];\n        normal[1] += pointNormal[1] * weights[i];\n        normal[2] += pointNormal[2] * weights[i];\n      }\n\n      normalize(normal);\n    } else {\n      return 0;\n    }\n\n    return 1;\n  };\n\n  publicAPI.pick = function (selection, renderer) {\n    publicAPI.initialize();\n    var pickResult = superClass.pick(selection, renderer);\n\n    if (pickResult) {\n      var camera = renderer.getActiveCamera();\n      var cameraPos = [];\n      camera.getPosition(cameraPos);\n\n      if (camera.getParallelProjection()) {\n        // For parallel projection, use -ve direction of projection\n        var cameraFocus = [];\n        camera.getFocalPoint(cameraFocus);\n        model.pickNormal[0] = cameraPos[0] - cameraFocus[0];\n        model.pickNormal[1] = cameraPos[1] - cameraFocus[1];\n        model.pickNormal[2] = cameraPos[2] - cameraFocus[2];\n      } else {\n        // Get the vector from pick position to the camera\n        model.pickNormal[0] = cameraPos[0] - model.pickPosition[0];\n        model.pickNormal[1] = cameraPos[1] - model.pickPosition[1];\n        model.pickNormal[2] = cameraPos[2] - model.pickPosition[2];\n      }\n\n      normalize(model.pickNormal);\n    }\n\n    return pickResult;\n  };\n\n  publicAPI.intersectWithLine = function (p1, p2, tol, mapper) {\n    var tMin = Number.MAX_VALUE;\n    var t1 = 0.0;\n    var t2 = 1.0;\n    var vtkCellPickerPlaneTol = 1e-14;\n    var clipLine = clipLineWithPlane(mapper, model.transformMatrix, p1, p2);\n\n    if (mapper && !clipLine.intersect) {\n      return Number.MAX_VALUE;\n    }\n\n    if (mapper.isA('vtkImageMapper') || mapper.isA('vtkImageArrayMapper')) {\n      var pickData = mapper.intersectWithLineForCellPicking(p1, p2);\n\n      if (pickData) {\n        tMin = pickData.t;\n        model.cellIJK = pickData.ijk;\n        model.pCoords = pickData.pCoords;\n      }\n    } else if (mapper.isA('vtkMapper')) {\n      tMin = publicAPI.intersectActorWithLine(p1, p2, t1, t2, tol, mapper);\n    }\n\n    if (tMin < model.globalTMin) {\n      model.globalTMin = tMin;\n\n      if (Math.abs(tMin - t1) < vtkCellPickerPlaneTol && clipLine.clippingPlaneId >= 0) {\n        model.mapperPosition[0] = p1[0] * (1 - t1) + p2[0] * t1;\n        model.mapperPosition[1] = p1[1] * (1 - t1) + p2[1] * t1;\n        model.mapperPosition[2] = p1[2] * (1 - t1) + p2[2] * t1;\n        var plane = [];\n        mapper.getClippingPlaneInDataCoords(model.transformMatrix, clipLine.clippingPlaneId, plane);\n        normalize(plane); // Want normal outward from the planes, not inward\n\n        model.mapperNormal[0] = -plane[0];\n        model.mapperNormal[1] = -plane[1];\n        model.mapperNormal[2] = -plane[2];\n      }\n\n      vec3.transformMat4(model.pickPosition, model.mapperPosition, model.transformMatrix); // Transform vector\n\n      var mat = model.transformMatrix;\n      model.mapperNormal[0] = mat[0] * model.pickNormal[0] + mat[4] * model.pickNormal[1] + mat[8] * model.pickNormal[2];\n      model.mapperNormal[1] = mat[1] * model.pickNormal[0] + mat[5] * model.pickNormal[1] + mat[9] * model.pickNormal[2];\n      model.mapperNormal[2] = mat[2] * model.pickNormal[0] + mat[6] * model.pickNormal[1] + mat[10] * model.pickNormal[2];\n    }\n\n    return tMin;\n  };\n\n  publicAPI.intersectActorWithLine = function (p1, p2, t1, t2, tol, mapper) {\n    var tMin = Number.MAX_VALUE;\n    var minXYZ = [0, 0, 0];\n    var pDistMin = Number.MAX_VALUE;\n    var minPCoords = [0, 0, 0];\n    var minCellId = null;\n    var minCell = null;\n    var minCellType = null;\n    var subId = null;\n    var x = [];\n    var data = mapper.getInputData();\n\n    var q1 = [0, 0, 0];\n    var q2 = [0, 0, 0];\n    q1[0] = p1[0];\n    q1[1] = p1[1];\n    q1[2] = p1[2];\n    q2[0] = p2[0];\n    q2[1] = p2[1];\n    q2[2] = p2[2];\n\n    if (t1 !== 0.0 || t2 !== 1.0) {\n      for (var j = 0; j < 3; j++) {\n        q1[j] = p1[j] * (1.0 - t1) + p2[j] * t1;\n        q2[j] = p1[j] * (1.0 - t2) + p2[j] * t2;\n      }\n    }\n\n    if (data.getCells) {\n      if (!data.getCells()) {\n        data.buildLinks();\n      }\n\n      var tempCellMap = createCellMap();\n      var minCellMap = createCellMap();\n      var numberOfCells = data.getNumberOfCells();\n      /* eslint-disable no-continue */\n\n      for (var cellId = 0; cellId < numberOfCells; cellId++) {\n        var pCoords = [0, 0, 0];\n        minCellType = data.getCellType(cellId); // Skip cells that are marked as empty\n\n        if (minCellType === CellType.VTK_EMPTY_CELL) {\n          continue;\n        }\n\n        var cell = tempCellMap[minCellType];\n\n        if (cell == null) {\n          continue;\n        }\n\n        minCell = minCellMap[minCellType];\n        data.getCell(cellId, cell);\n        var cellPicked = void 0;\n\n        {\n          if (vtkCellTypes.hasSubCells(minCellType)) {\n            cellPicked = cell.intersectWithLine(t1, t2, p1, p2, tol, x, pCoords);\n          } else {\n            cellPicked = cell.intersectWithLine(p1, p2, tol, x, pCoords);\n          }\n        }\n\n        if (cellPicked.intersect === 1 && cellPicked.t <= tMin + model.tolerance && cellPicked.t >= t1 && cellPicked.t <= t2) {\n          var pDist = cell.getParametricDistance(pCoords);\n\n          if (pDist < pDistMin || pDist === pDistMin && cellPicked.t < tMin) {\n            tMin = cellPicked.t;\n            pDistMin = pDist;\n            subId = cellPicked.subId;\n            minCellId = cellId;\n            cell.deepCopy(minCell);\n\n            for (var k = 0; k < 3; k++) {\n              minXYZ[k] = x[k];\n              minPCoords[k] = pCoords[k];\n            }\n          }\n        }\n      }\n      /* eslint-enable no-continue */\n\n    }\n\n    if (minCellId >= 0 && tMin < model.globalTMin) {\n      resetPickInfo();\n      var nbPointsInCell = minCell.getNumberOfPoints();\n      var weights = new Array(nbPointsInCell);\n\n      for (var i = 0; i < nbPointsInCell; i++) {\n        weights[i] = 0.0;\n      }\n\n      var point = [];\n\n      if (vtkCellTypes.hasSubCells(minCellType)) {\n        minCell.evaluateLocation(subId, minPCoords, point, weights);\n      } else {\n        minCell.evaluateLocation(minPCoords, point, weights);\n      } // Return the polydata to the user\n\n\n      model.dataSet = data;\n      model.cellId = minCellId;\n      model.pCoords[0] = minPCoords[0];\n      model.pCoords[1] = minPCoords[1];\n      model.pCoords[2] = minPCoords[2]; // Find the point with the maximum weight\n\n      var maxWeight = 0;\n      var iMaxWeight = -1;\n\n      for (var _i = 0; _i < nbPointsInCell; _i++) {\n        if (weights[_i] > maxWeight) {\n          iMaxWeight = _i;\n          maxWeight = weights[_i];\n        }\n      } // If maximum weight is found, use it to get the PointId\n\n\n      if (iMaxWeight !== -1) {\n        model.pointId = minCell.getPointsIds()[iMaxWeight];\n      } // Set the mapper position\n\n\n      model.mapperPosition[0] = minXYZ[0];\n      model.mapperPosition[1] = minXYZ[1];\n      model.mapperPosition[2] = minXYZ[2]; // Compute the normal\n\n      if (!publicAPI.computeSurfaceNormal(data, minCell, weights, model.mapperNormal)) {\n        // By default, the normal points back along view ray\n        model.mapperNormal[0] = p1[0] - p2[0];\n        model.mapperNormal[1] = p1[1] - p2[1];\n        model.mapperNormal[2] = p1[2] - p2[2];\n        normalize(model.mapperNormal);\n      }\n    }\n\n    return tMin;\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\n\nvar DEFAULT_VALUES = {\n  cellId: -1,\n  pCoords: [],\n  cellIJK: [],\n  pickNormal: [],\n  mapperNormal: []\n}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Inheritance\n\n  vtkPicker.extend(publicAPI, model, initialValues);\n  macro.getArray(publicAPI, model, ['pickNormal', 'mapperNormal', 'pCoords', 'cellIJK']);\n  macro.get(publicAPI, model, ['cellId']); // Object methods\n\n  vtkCellPicker(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = macro.newInstance(extend, 'vtkCellPicker'); // ----------------------------------------------------------------------------\n\nvar vtkCellPicker$1 = _objectSpread({\n  newInstance: newInstance,\n  extend: extend\n}, STATIC);\n\nexport { STATIC, vtkCellPicker$1 as default, extend, newInstance };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}