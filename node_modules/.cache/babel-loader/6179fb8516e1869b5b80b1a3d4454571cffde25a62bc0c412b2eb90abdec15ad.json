{"ast":null,"code":"import _classCallCheck from '@babel/runtime/helpers/classCallCheck';\nimport _createClass from '@babel/runtime/helpers/createClass';\nimport macro from '../../macros.js';\nimport vtkCellArray from '../../Common/Core/CellArray.js';\nimport vtkPolyData from '../../Common/DataModel/PolyData.js';\nvar vtkErrorMacro = macro.vtkErrorMacro;\nvar SegmentAgregator = /*#__PURE__*/function () {\n  function SegmentAgregator() {\n    _classCallCheck(this, SegmentAgregator);\n    this.segmentMapping = {};\n    this.segments = [null]; // to force first id to be 1\n\n    this.faces = [];\n  }\n  _createClass(SegmentAgregator, [{\n    key: \"addSegment\",\n    value: function addSegment(segment) {\n      var first = segment[0];\n      var last = segment[segment.length - 1];\n      if (first === last || segment.length < 2) {\n        return;\n      }\n      var mappingFirst = this.segmentMapping[first];\n      var mappingLast = this.segmentMapping[last];\n      if (mappingFirst !== undefined && mappingLast !== undefined) {\n        if (Math.abs(mappingFirst) === Math.abs(mappingLast)) {\n          // This make a closing loop\n          var idx = mappingFirst < mappingLast ? mappingLast : mappingFirst;\n          var seg = this.segments[idx];\n          if (mappingFirst > 0) {\n            for (var i = 1; i < segment.length - 1; i++) {\n              seg.push(segment[i]);\n            }\n          } else {\n            for (var _i = 1; _i < segment.length - 1; _i++) {\n              seg.unshift(segment[segment.length - 1 - _i]);\n            }\n          }\n          this.faces.push(seg);\n          this.segments[idx] = null;\n          this.segmentMapping[first] = undefined;\n          this.segmentMapping[last] = undefined;\n        } else {\n          // we need to merge segments\n          // strategie:\n          // => remove and add them again in special order to induce merge\n          var idxHead = Math.abs(mappingFirst);\n          var idxTail = Math.abs(mappingLast);\n          var segHead = this.segments[idxHead];\n          var segTail = this.segments[idxTail];\n          this.segments[idxHead] = null;\n          this.segments[idxTail] = null;\n          this.segmentMapping[segHead[0]] = undefined;\n          this.segmentMapping[segTail[0]] = undefined;\n          this.segmentMapping[segHead[segHead.length - 1]] = undefined;\n          this.segmentMapping[segTail[segTail.length - 1]] = undefined; // This will lead to a single segment\n\n          this.addSegment(segment);\n          this.addSegment(segHead);\n          this.addSegment(segTail);\n        }\n      } else if (mappingFirst !== undefined) {\n        if (mappingFirst > 0) {\n          // The head of our segment match the tail of the existing one\n          var _seg = this.segments[mappingFirst];\n          for (var _i2 = 1; _i2 < segment.length; _i2++) {\n            _seg.push(segment[_i2]);\n          } // record new tail\n\n          this.segmentMapping[last] = mappingFirst;\n        } else {\n          // our segment should be reverted and put on the front of the existing one\n          var _seg2 = this.segments[-mappingFirst]; // record new head\n\n          this.segmentMapping[last] = mappingFirst;\n          for (var _i3 = 1; _i3 < segment.length; _i3++) {\n            _seg2.unshift(segment[_i3]);\n          }\n        } // Erase used connection\n\n        this.segmentMapping[first] = undefined;\n      } else if (mappingLast !== undefined) {\n        if (mappingLast > 0) {\n          // The tail of our segment match the tail of the existing one\n          var _seg3 = this.segments[mappingLast];\n          for (var _i4 = 1; _i4 < segment.length; _i4++) {\n            _seg3.push(segment[segment.length - 1 - _i4]);\n          } // record new tail\n\n          this.segmentMapping[first] = mappingLast;\n        } else {\n          // our segment should be reverted and put on the front of the existing one\n          var _seg4 = this.segments[-mappingLast]; // record new head\n\n          this.segmentMapping[first] = mappingLast;\n          for (var _i5 = 1; _i5 < segment.length; _i5++) {\n            _seg4.unshift(segment[segment.length - _i5 - 1]);\n          }\n        } // Erase used connection\n\n        this.segmentMapping[last] = undefined;\n      } else {\n        // store segment for now\n        var id = this.segments.length;\n        this.segments.push(segment);\n        this.segmentMapping[first] = -id;\n        this.segmentMapping[last] = id;\n      }\n    }\n  }]);\n  return SegmentAgregator;\n}(); // ----------------------------------------------------------------------------\n// vtkClosedPolyLineToSurfaceFilter methods\n// ----------------------------------------------------------------------------\n\nfunction vtkClosedPolyLineToSurfaceFilter(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkClosedPolyLineToSurfaceFilter'); // --------------------------------------------------------------------------\n\n  publicAPI.requestData = function (inData, outData) {\n    // implement requestData\n    var input = inData[0];\n    if (!input) {\n      vtkErrorMacro('Invalid or missing input');\n      return;\n    }\n    var output = vtkPolyData.newInstance();\n    output.shallowCopy(input); // Extract faces\n\n    var agregator = new SegmentAgregator();\n    var lines = input.getLines().getData();\n    var offset = 0;\n    while (offset < lines.length) {\n      var lineSize = lines[offset++];\n      var lineSegment = [];\n      for (var i = 0; i < lineSize; i++) {\n        lineSegment.push(lines[offset + i]);\n      }\n      agregator.addSegment(lineSegment);\n      offset += lineSize;\n    } // Create CellArray for polys\n\n    var faces = agregator.faces;\n    var cellArraySize = faces.length;\n    for (var _i6 = 0; _i6 < faces.length; _i6++) {\n      cellArraySize += faces[_i6].length;\n    }\n    var cellArray = new Uint16Array(cellArraySize);\n    offset = 0;\n    for (var _i7 = 0; _i7 < faces.length; _i7++) {\n      var face = faces[_i7];\n      cellArray[offset++] = face.length;\n      for (var j = 0; j < face.length; j++) {\n        cellArray[offset++] = face[j];\n      }\n    }\n    output.setPolys(vtkCellArray.newInstance({\n      values: cellArray,\n      name: 'faces'\n    }));\n    outData[0] = output;\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nvar DEFAULT_VALUES = {}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Make this a VTK object\n\n  macro.obj(publicAPI, model); // Also make it an algorithm with one input and one output\n\n  macro.algo(publicAPI, model, 1, 1); // Object specific methods\n\n  vtkClosedPolyLineToSurfaceFilter(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = macro.newInstance(extend, 'vtkClosedPolyLineToSurfaceFilter'); // ----------------------------------------------------------------------------\n\nvar vtkClosedPolyLineToSurfaceFilter$1 = {\n  newInstance: newInstance,\n  extend: extend\n};\nexport { vtkClosedPolyLineToSurfaceFilter$1 as default, extend, newInstance };","map":{"version":3,"names":["_classCallCheck","_createClass","macro","vtkCellArray","vtkPolyData","vtkErrorMacro","SegmentAgregator","segmentMapping","segments","faces","key","value","addSegment","segment","first","last","length","mappingFirst","mappingLast","undefined","Math","abs","idx","seg","i","push","_i","unshift","idxHead","idxTail","segHead","segTail","_seg","_i2","_seg2","_i3","_seg3","_i4","_seg4","_i5","id","vtkClosedPolyLineToSurfaceFilter","publicAPI","model","classHierarchy","requestData","inData","outData","input","output","newInstance","shallowCopy","agregator","lines","getLines","getData","offset","lineSize","lineSegment","cellArraySize","_i6","cellArray","Uint16Array","_i7","face","j","setPolys","values","name","DEFAULT_VALUES","extend","initialValues","arguments","Object","assign","obj","algo","vtkClosedPolyLineToSurfaceFilter$1","default"],"sources":["/home/rakshith/Documents/RemoteRendering/vtk-js-react-app/node_modules/@kitware/vtk.js/Filters/General/ClosedPolyLineToSurfaceFilter.js"],"sourcesContent":["import _classCallCheck from '@babel/runtime/helpers/classCallCheck';\nimport _createClass from '@babel/runtime/helpers/createClass';\nimport macro from '../../macros.js';\nimport vtkCellArray from '../../Common/Core/CellArray.js';\nimport vtkPolyData from '../../Common/DataModel/PolyData.js';\n\nvar vtkErrorMacro = macro.vtkErrorMacro;\n\nvar SegmentAgregator = /*#__PURE__*/function () {\n  function SegmentAgregator() {\n    _classCallCheck(this, SegmentAgregator);\n\n    this.segmentMapping = {};\n    this.segments = [null]; // to force first id to be 1\n\n    this.faces = [];\n  }\n\n  _createClass(SegmentAgregator, [{\n    key: \"addSegment\",\n    value: function addSegment(segment) {\n      var first = segment[0];\n      var last = segment[segment.length - 1];\n\n      if (first === last || segment.length < 2) {\n        return;\n      }\n\n      var mappingFirst = this.segmentMapping[first];\n      var mappingLast = this.segmentMapping[last];\n\n      if (mappingFirst !== undefined && mappingLast !== undefined) {\n        if (Math.abs(mappingFirst) === Math.abs(mappingLast)) {\n          // This make a closing loop\n          var idx = mappingFirst < mappingLast ? mappingLast : mappingFirst;\n          var seg = this.segments[idx];\n\n          if (mappingFirst > 0) {\n            for (var i = 1; i < segment.length - 1; i++) {\n              seg.push(segment[i]);\n            }\n          } else {\n            for (var _i = 1; _i < segment.length - 1; _i++) {\n              seg.unshift(segment[segment.length - 1 - _i]);\n            }\n          }\n\n          this.faces.push(seg);\n          this.segments[idx] = null;\n          this.segmentMapping[first] = undefined;\n          this.segmentMapping[last] = undefined;\n        } else {\n          // we need to merge segments\n          // strategie:\n          // => remove and add them again in special order to induce merge\n          var idxHead = Math.abs(mappingFirst);\n          var idxTail = Math.abs(mappingLast);\n          var segHead = this.segments[idxHead];\n          var segTail = this.segments[idxTail];\n          this.segments[idxHead] = null;\n          this.segments[idxTail] = null;\n          this.segmentMapping[segHead[0]] = undefined;\n          this.segmentMapping[segTail[0]] = undefined;\n          this.segmentMapping[segHead[segHead.length - 1]] = undefined;\n          this.segmentMapping[segTail[segTail.length - 1]] = undefined; // This will lead to a single segment\n\n          this.addSegment(segment);\n          this.addSegment(segHead);\n          this.addSegment(segTail);\n        }\n      } else if (mappingFirst !== undefined) {\n        if (mappingFirst > 0) {\n          // The head of our segment match the tail of the existing one\n          var _seg = this.segments[mappingFirst];\n\n          for (var _i2 = 1; _i2 < segment.length; _i2++) {\n            _seg.push(segment[_i2]);\n          } // record new tail\n\n\n          this.segmentMapping[last] = mappingFirst;\n        } else {\n          // our segment should be reverted and put on the front of the existing one\n          var _seg2 = this.segments[-mappingFirst]; // record new head\n\n          this.segmentMapping[last] = mappingFirst;\n\n          for (var _i3 = 1; _i3 < segment.length; _i3++) {\n            _seg2.unshift(segment[_i3]);\n          }\n        } // Erase used connection\n\n\n        this.segmentMapping[first] = undefined;\n      } else if (mappingLast !== undefined) {\n        if (mappingLast > 0) {\n          // The tail of our segment match the tail of the existing one\n          var _seg3 = this.segments[mappingLast];\n\n          for (var _i4 = 1; _i4 < segment.length; _i4++) {\n            _seg3.push(segment[segment.length - 1 - _i4]);\n          } // record new tail\n\n\n          this.segmentMapping[first] = mappingLast;\n        } else {\n          // our segment should be reverted and put on the front of the existing one\n          var _seg4 = this.segments[-mappingLast]; // record new head\n\n          this.segmentMapping[first] = mappingLast;\n\n          for (var _i5 = 1; _i5 < segment.length; _i5++) {\n            _seg4.unshift(segment[segment.length - _i5 - 1]);\n          }\n        } // Erase used connection\n\n\n        this.segmentMapping[last] = undefined;\n      } else {\n        // store segment for now\n        var id = this.segments.length;\n        this.segments.push(segment);\n        this.segmentMapping[first] = -id;\n        this.segmentMapping[last] = id;\n      }\n    }\n  }]);\n\n  return SegmentAgregator;\n}(); // ----------------------------------------------------------------------------\n// vtkClosedPolyLineToSurfaceFilter methods\n// ----------------------------------------------------------------------------\n\n\nfunction vtkClosedPolyLineToSurfaceFilter(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkClosedPolyLineToSurfaceFilter'); // --------------------------------------------------------------------------\n\n  publicAPI.requestData = function (inData, outData) {\n    // implement requestData\n    var input = inData[0];\n\n    if (!input) {\n      vtkErrorMacro('Invalid or missing input');\n      return;\n    }\n\n    var output = vtkPolyData.newInstance();\n    output.shallowCopy(input); // Extract faces\n\n    var agregator = new SegmentAgregator();\n    var lines = input.getLines().getData();\n    var offset = 0;\n\n    while (offset < lines.length) {\n      var lineSize = lines[offset++];\n      var lineSegment = [];\n\n      for (var i = 0; i < lineSize; i++) {\n        lineSegment.push(lines[offset + i]);\n      }\n\n      agregator.addSegment(lineSegment);\n      offset += lineSize;\n    } // Create CellArray for polys\n\n\n    var faces = agregator.faces;\n    var cellArraySize = faces.length;\n\n    for (var _i6 = 0; _i6 < faces.length; _i6++) {\n      cellArraySize += faces[_i6].length;\n    }\n\n    var cellArray = new Uint16Array(cellArraySize);\n    offset = 0;\n\n    for (var _i7 = 0; _i7 < faces.length; _i7++) {\n      var face = faces[_i7];\n      cellArray[offset++] = face.length;\n\n      for (var j = 0; j < face.length; j++) {\n        cellArray[offset++] = face[j];\n      }\n    }\n\n    output.setPolys(vtkCellArray.newInstance({\n      values: cellArray,\n      name: 'faces'\n    }));\n    outData[0] = output;\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\n\nvar DEFAULT_VALUES = {}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Make this a VTK object\n\n  macro.obj(publicAPI, model); // Also make it an algorithm with one input and one output\n\n  macro.algo(publicAPI, model, 1, 1); // Object specific methods\n\n  vtkClosedPolyLineToSurfaceFilter(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = macro.newInstance(extend, 'vtkClosedPolyLineToSurfaceFilter'); // ----------------------------------------------------------------------------\n\nvar vtkClosedPolyLineToSurfaceFilter$1 = {\n  newInstance: newInstance,\n  extend: extend\n};\n\nexport { vtkClosedPolyLineToSurfaceFilter$1 as default, extend, newInstance };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}