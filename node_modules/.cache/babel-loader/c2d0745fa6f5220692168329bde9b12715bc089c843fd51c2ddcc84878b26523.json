{"ast":null,"code":"import vtk from '../../vtk.js';\nimport macro from '../../macros.js';\nimport vtkPoints from '../../Common/Core/Points.js';\nvar vtkDebugMacro = macro.vtkDebugMacro,\n  vtkErrorMacro = macro.vtkErrorMacro; // ----------------------------------------------------------------------------\n// vtkWarpScalar methods\n// ----------------------------------------------------------------------------\n\nfunction vtkWarpScalar(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkWarpScalar');\n  publicAPI.requestData = function (inData, outData) {\n    // implement requestData\n    var input = inData[0];\n    if (!input) {\n      vtkErrorMacro('Invalid or missing input');\n      return 1;\n    } // First, copy the input to the output as a starting point\n    // output->CopyStructure( input );\n\n    var inPts = input.getPoints();\n    var pd = input.getPointData();\n    var inNormals = pd.getNormals();\n    var inScalars = publicAPI.getInputArrayToProcess(0);\n    if (!inPts || !inScalars) {\n      vtkDebugMacro('No data to warp', !!inPts, !!inScalars);\n      outData[0] = inData[0];\n      return 1;\n    }\n    var numPts = inPts.getNumberOfPoints();\n    var pointNormal = null;\n    var normal = [0, 0, 1];\n    if (inNormals && !model.useNormal) {\n      pointNormal = function pointNormal(id, array) {\n        return [array.getData()[id * 3], array.getData()[id * 3 + 1], array.getData()[id * 3 + 2]];\n      };\n      vtkDebugMacro('Using data normals');\n    } else if (publicAPI.getXyPlane()) {\n      pointNormal = function pointNormal(id, array) {\n        return normal;\n      };\n      vtkDebugMacro('Using x-y plane normal');\n    } else {\n      pointNormal = function pointNormal(id, array) {\n        return model.normal;\n      };\n      vtkDebugMacro('Using Normal instance variable');\n    }\n    var newPtsData = new Float32Array(numPts * 3);\n    var inPoints = inPts.getData();\n    var ptOffset = 0;\n    var n = [0, 0, 1];\n    var s = 1; // Loop over all points, adjusting locations\n\n    var scalarDataArray = inScalars.getData();\n    var nc = inScalars.getNumberOfComponents();\n    for (var ptId = 0; ptId < numPts; ++ptId) {\n      ptOffset = ptId * 3;\n      n = pointNormal(ptId, inNormals);\n      if (model.xyPlane) {\n        s = inPoints[ptOffset + 2];\n      } else {\n        // Use component 0 of array if there are multiple components\n        s = scalarDataArray[ptId * nc];\n      }\n      newPtsData[ptOffset] = inPoints[ptOffset] + model.scaleFactor * s * n[0];\n      newPtsData[ptOffset + 1] = inPoints[ptOffset + 1] + model.scaleFactor * s * n[1];\n      newPtsData[ptOffset + 2] = inPoints[ptOffset + 2] + model.scaleFactor * s * n[2];\n    }\n    var newDataSet = vtk({\n      vtkClass: input.getClassName()\n    });\n    newDataSet.shallowCopy(input);\n    var points = vtkPoints.newInstance();\n    points.setData(newPtsData, 3);\n    newDataSet.setPoints(points);\n    outData[0] = newDataSet;\n    return 1;\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nvar DEFAULT_VALUES = {\n  scaleFactor: 1,\n  useNormal: false,\n  normal: [0, 0, 1],\n  xyPlane: false\n}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Make this a VTK object\n\n  macro.obj(publicAPI, model); // Also make it an algorithm with one input and one output\n\n  macro.algo(publicAPI, model, 1, 1); // Generate macros for properties\n\n  macro.setGet(publicAPI, model, ['scaleFactor', 'useNormal', 'xyPlane']);\n  macro.setGetArray(publicAPI, model, ['normal'], 3); // Object specific methods\n\n  vtkWarpScalar(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = macro.newInstance(extend, 'vtkWarpScalar'); // ----------------------------------------------------------------------------\n\nvar vtkWarpScalar$1 = {\n  newInstance: newInstance,\n  extend: extend\n};\nexport { vtkWarpScalar$1 as default, extend, newInstance };","map":{"version":3,"names":["vtk","macro","vtkPoints","vtkDebugMacro","vtkErrorMacro","vtkWarpScalar","publicAPI","model","classHierarchy","push","requestData","inData","outData","input","inPts","getPoints","pd","getPointData","inNormals","getNormals","inScalars","getInputArrayToProcess","numPts","getNumberOfPoints","pointNormal","normal","useNormal","id","array","getData","getXyPlane","newPtsData","Float32Array","inPoints","ptOffset","n","s","scalarDataArray","nc","getNumberOfComponents","ptId","xyPlane","scaleFactor","newDataSet","vtkClass","getClassName","shallowCopy","points","newInstance","setData","setPoints","DEFAULT_VALUES","extend","initialValues","arguments","length","undefined","Object","assign","obj","algo","setGet","setGetArray","vtkWarpScalar$1","default"],"sources":["/home/rakshith/Documents/RemoteRendering/vtk-js-react-app/node_modules/@kitware/vtk.js/Filters/General/WarpScalar.js"],"sourcesContent":["import vtk from '../../vtk.js';\nimport macro from '../../macros.js';\nimport vtkPoints from '../../Common/Core/Points.js';\n\nvar vtkDebugMacro = macro.vtkDebugMacro,\n    vtkErrorMacro = macro.vtkErrorMacro; // ----------------------------------------------------------------------------\n// vtkWarpScalar methods\n// ----------------------------------------------------------------------------\n\nfunction vtkWarpScalar(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkWarpScalar');\n\n  publicAPI.requestData = function (inData, outData) {\n    // implement requestData\n    var input = inData[0];\n\n    if (!input) {\n      vtkErrorMacro('Invalid or missing input');\n      return 1;\n    } // First, copy the input to the output as a starting point\n    // output->CopyStructure( input );\n\n\n    var inPts = input.getPoints();\n    var pd = input.getPointData();\n    var inNormals = pd.getNormals();\n    var inScalars = publicAPI.getInputArrayToProcess(0);\n\n    if (!inPts || !inScalars) {\n      vtkDebugMacro('No data to warp', !!inPts, !!inScalars);\n      outData[0] = inData[0];\n      return 1;\n    }\n\n    var numPts = inPts.getNumberOfPoints();\n    var pointNormal = null;\n    var normal = [0, 0, 1];\n\n    if (inNormals && !model.useNormal) {\n      pointNormal = function pointNormal(id, array) {\n        return [array.getData()[id * 3], array.getData()[id * 3 + 1], array.getData()[id * 3 + 2]];\n      };\n\n      vtkDebugMacro('Using data normals');\n    } else if (publicAPI.getXyPlane()) {\n      pointNormal = function pointNormal(id, array) {\n        return normal;\n      };\n\n      vtkDebugMacro('Using x-y plane normal');\n    } else {\n      pointNormal = function pointNormal(id, array) {\n        return model.normal;\n      };\n\n      vtkDebugMacro('Using Normal instance variable');\n    }\n\n    var newPtsData = new Float32Array(numPts * 3);\n    var inPoints = inPts.getData();\n    var ptOffset = 0;\n    var n = [0, 0, 1];\n    var s = 1; // Loop over all points, adjusting locations\n\n    var scalarDataArray = inScalars.getData();\n    var nc = inScalars.getNumberOfComponents();\n\n    for (var ptId = 0; ptId < numPts; ++ptId) {\n      ptOffset = ptId * 3;\n      n = pointNormal(ptId, inNormals);\n\n      if (model.xyPlane) {\n        s = inPoints[ptOffset + 2];\n      } else {\n        // Use component 0 of array if there are multiple components\n        s = scalarDataArray[ptId * nc];\n      }\n\n      newPtsData[ptOffset] = inPoints[ptOffset] + model.scaleFactor * s * n[0];\n      newPtsData[ptOffset + 1] = inPoints[ptOffset + 1] + model.scaleFactor * s * n[1];\n      newPtsData[ptOffset + 2] = inPoints[ptOffset + 2] + model.scaleFactor * s * n[2];\n    }\n\n    var newDataSet = vtk({\n      vtkClass: input.getClassName()\n    });\n    newDataSet.shallowCopy(input);\n    var points = vtkPoints.newInstance();\n    points.setData(newPtsData, 3);\n    newDataSet.setPoints(points);\n    outData[0] = newDataSet;\n    return 1;\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\n\nvar DEFAULT_VALUES = {\n  scaleFactor: 1,\n  useNormal: false,\n  normal: [0, 0, 1],\n  xyPlane: false\n}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Make this a VTK object\n\n  macro.obj(publicAPI, model); // Also make it an algorithm with one input and one output\n\n  macro.algo(publicAPI, model, 1, 1); // Generate macros for properties\n\n  macro.setGet(publicAPI, model, ['scaleFactor', 'useNormal', 'xyPlane']);\n  macro.setGetArray(publicAPI, model, ['normal'], 3); // Object specific methods\n\n  vtkWarpScalar(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = macro.newInstance(extend, 'vtkWarpScalar'); // ----------------------------------------------------------------------------\n\nvar vtkWarpScalar$1 = {\n  newInstance: newInstance,\n  extend: extend\n};\n\nexport { vtkWarpScalar$1 as default, extend, newInstance };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}