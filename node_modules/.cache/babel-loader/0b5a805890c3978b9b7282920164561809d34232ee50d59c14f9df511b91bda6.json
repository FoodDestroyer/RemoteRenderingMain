{"ast":null,"code":"import _toConsumableArray from '@babel/runtime/helpers/toConsumableArray';\nimport macro from '../../macros.js';\nimport vtkCell from './Cell.js';\n\n// Global methods\n// ----------------------------------------------------------------------------\n\nvar InitLink = {\n  ncells: 0,\n  cells: null\n};\nfunction resize(model, sz) {\n  var newSize = sz;\n  if (sz >= model.array.length) {\n    newSize += model.array.length;\n  }\n  while (newSize > model.array.length) {\n    model.array.push({\n      ncells: 0,\n      cells: null\n    });\n  }\n  model.array.length = newSize;\n} // ----------------------------------------------------------------------------\n// vtkCellLinks methods\n// ----------------------------------------------------------------------------\n\nfunction vtkCellLinks(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkCellLinks');\n  /**\n   * Build the link list array. All subclasses of vtkAbstractCellLinks\n   * must support this method.\n   */\n\n  publicAPI.buildLinks = function (data) {\n    var numPts = data.getPoints().getNumberOfPoints();\n    var numCells = data.getNumberOfCells(); // fill out lists with number of references to cells\n\n    var linkLoc = new Uint32Array(numPts); // Use fast path if polydata\n\n    if (data.isA('vtkPolyData')) {\n      // traverse data to determine number of uses of each point\n      for (var cellId = 0; cellId < numCells; ++cellId) {\n        var _data$getCellPoints = data.getCellPoints(cellId),\n          cellPointIds = _data$getCellPoints.cellPointIds;\n        cellPointIds.forEach(function (cellPointId) {\n          publicAPI.incrementLinkCount(cellPointId);\n        });\n      } // now allocate storage for the links\n\n      publicAPI.allocateLinks(numPts);\n      model.maxId = numPts - 1;\n      var _loop = function _loop(_cellId) {\n        var _data$getCellPoints2 = data.getCellPoints(_cellId),\n          cellPointIds = _data$getCellPoints2.cellPointIds;\n        cellPointIds.forEach(function (cellPointId) {\n          publicAPI.insertCellReference(cellPointId, linkLoc[cellPointId]++, _cellId);\n        });\n      };\n      for (var _cellId = 0; _cellId < numCells; ++_cellId) {\n        _loop(_cellId);\n      }\n    } // any other type of dataset\n    else {\n      // traverse data to determine number of uses of each point\n      for (var _cellId2 = 0; _cellId2 < numCells; _cellId2++) {\n        // TODO: Currently not supported: const cell = data.getCell(cellId);\n        var cell = vtkCell.newInstance();\n        cell.getPointsIds().forEach(function (cellPointId) {\n          publicAPI.incrementLinkCount(cellPointId);\n        });\n      } // now allocate storage for the links\n\n      publicAPI.allocateLinks(numPts);\n      model.maxId = numPts - 1;\n      var _loop2 = function _loop2(_cellId3) {\n        // TODO: Currently not supported: const cell = data.getCell(cellId);\n        var cell = vtkCell.newInstance();\n        cell.getPointsIds().forEach(function (cellPointId) {\n          publicAPI.insertCellReference(cellPointId, linkLoc[cellPointId]++, _cellId3);\n        });\n      };\n      for (var _cellId3 = 0; _cellId3 < numCells; ++_cellId3) {\n        _loop2(_cellId3);\n      }\n    } // end else\n  };\n  /**\n   * Build the link list array with a provided connectivity array.\n   */\n  // publicAPI.buildLinks = (data, connectivity) => {};\n\n  /**\n   * Allocate the specified number of links (i.e., number of points) that\n   * will be built.\n   */\n\n  publicAPI.allocate = function (numLinks) {\n    var ext = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1000;\n    model.array = Array(numLinks).fill().map(function () {\n      return {\n        ncells: 0,\n        cells: null\n      };\n    });\n    model.extend = ext;\n    model.maxId = -1;\n  };\n  publicAPI.initialize = function () {\n    model.array = null;\n  };\n  /**\n   * Get a link structure given a point id.\n   */\n\n  publicAPI.getLink = function (ptId) {\n    return model.array[ptId];\n  };\n  /**\n   * Get the number of cells using the point specified by ptId.\n   */\n\n  publicAPI.getNcells = function (ptId) {\n    return model.array[ptId].ncells;\n  };\n  /**\n   * Return a list of cell ids using the point.\n   */\n\n  publicAPI.getCells = function (ptId) {\n    return model.array[ptId].cells;\n  };\n  /**\n   * Insert a new point into the cell-links data structure. The size parameter\n   * is the initial size of the list.\n   */\n\n  publicAPI.insertNextPoint = function (numLinks) {\n    model.array.push({\n      ncells: numLinks,\n      cells: Array(numLinks)\n    });\n    ++model.maxId;\n  };\n  /**\n   * Insert a cell id into the list of cells (at the end) using the cell id\n   * provided. (Make sure to extend the link list (if necessary) using the\n   * method resizeCellList().)\n   */\n\n  publicAPI.insertNextCellReference = function (ptId, cellId) {\n    model.array[ptId].cells[model.array[ptId].ncells++] = cellId;\n  };\n  /**\n   * Delete point (and storage) by destroying links to using cells.\n   */\n\n  publicAPI.deletePoint = function (ptId) {\n    model.array[ptId].ncells = 0;\n    model.array[ptId].cells = null;\n  };\n  /**\n   * Delete the reference to the cell (cellId) from the point (ptId). This\n   * removes the reference to the cellId from the cell list, but does not\n   * resize the list (recover memory with resizeCellList(), if necessary).\n   */\n\n  publicAPI.removeCellReference = function (cellId, ptId) {\n    model.array[ptId].cells = model.array[ptId].cells.filter(function (cell) {\n      return cell !== cellId;\n    });\n    model.array[ptId].ncells = model.array[ptId].cells.length;\n  };\n  /**\n   * Add the reference to the cell (cellId) from the point (ptId). This\n   * adds a reference to the cellId from the cell list, but does not resize\n   * the list (extend memory with resizeCellList(), if necessary).\n   */\n\n  publicAPI.addCellReference = function (cellId, ptId) {\n    model.array[ptId].cells[model.array[ptId].ncells++] = cellId;\n  };\n  /**\n   * Change the length of a point's link list (i.e., list of cells using a\n   * point) by the size specified.\n   */\n\n  publicAPI.resizeCellList = function (ptId, size) {\n    model.array[ptId].cells.length = size;\n  };\n  /**\n   * Reclaim any unused memory.\n   */\n\n  publicAPI.squeeze = function () {\n    resize(model, model.maxId + 1);\n  };\n  /**\n   * Reset to a state of no entries without freeing the memory.\n   */\n\n  publicAPI.reset = function () {\n    model.maxId = -1;\n  };\n  /**\n   * Standard DeepCopy method.  Since this object contains no reference\n   * to other objects, there is no ShallowCopy.\n   */\n\n  publicAPI.deepCopy = function (src) {\n    model.array = _toConsumableArray(src.array);\n    model.extend = src.extend;\n    model.maxId = src.maxId;\n  };\n  /**\n   * Increment the count of the number of cells using the point.\n   */\n\n  publicAPI.incrementLinkCount = function (ptId) {\n    ++model.array[ptId].ncells;\n  };\n  publicAPI.allocateLinks = function (n) {\n    for (var i = 0; i < n; ++i) {\n      model.array[i].cells = new Array(model.array[i].ncells);\n    }\n  };\n  /**\n   * Insert a cell id into the list of cells using the point.\n   */\n\n  publicAPI.insertCellReference = function (ptId, pos, cellId) {\n    model.array[ptId].cells[pos] = cellId;\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nvar DEFAULT_VALUES = {\n  array: null,\n  // pointer to data\n  maxId: 0,\n  // maximum index inserted thus far\n  extend: 0 // grow array by this point\n}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n  macro.obj(publicAPI, model);\n  vtkCellLinks(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = macro.newInstance(extend, 'vtkCellLinks'); // ----------------------------------------------------------------------------\n\nvar vtkCellLinks$1 = {\n  newInstance: newInstance,\n  extend: extend\n};\nexport { InitLink, vtkCellLinks$1 as default, extend, newInstance };","map":{"version":3,"names":["_toConsumableArray","macro","vtkCell","InitLink","ncells","cells","resize","model","sz","newSize","array","length","push","vtkCellLinks","publicAPI","classHierarchy","buildLinks","data","numPts","getPoints","getNumberOfPoints","numCells","getNumberOfCells","linkLoc","Uint32Array","isA","cellId","_data$getCellPoints","getCellPoints","cellPointIds","forEach","cellPointId","incrementLinkCount","allocateLinks","maxId","_loop","_cellId","_data$getCellPoints2","insertCellReference","_cellId2","cell","newInstance","getPointsIds","_loop2","_cellId3","allocate","numLinks","ext","arguments","undefined","Array","fill","map","extend","initialize","getLink","ptId","getNcells","getCells","insertNextPoint","insertNextCellReference","deletePoint","removeCellReference","filter","addCellReference","resizeCellList","size","squeeze","reset","deepCopy","src","n","i","pos","DEFAULT_VALUES","initialValues","Object","assign","obj","vtkCellLinks$1","default"],"sources":["/home/rakshith/Documents/RemoteRendering/vtk-js-react-app/node_modules/@kitware/vtk.js/Common/DataModel/CellLinks.js"],"sourcesContent":["import _toConsumableArray from '@babel/runtime/helpers/toConsumableArray';\nimport macro from '../../macros.js';\nimport vtkCell from './Cell.js';\n\n// Global methods\n// ----------------------------------------------------------------------------\n\nvar InitLink = {\n  ncells: 0,\n  cells: null\n};\n\nfunction resize(model, sz) {\n  var newSize = sz;\n\n  if (sz >= model.array.length) {\n    newSize += model.array.length;\n  }\n\n  while (newSize > model.array.length) {\n    model.array.push({\n      ncells: 0,\n      cells: null\n    });\n  }\n\n  model.array.length = newSize;\n} // ----------------------------------------------------------------------------\n// vtkCellLinks methods\n// ----------------------------------------------------------------------------\n\n\nfunction vtkCellLinks(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkCellLinks');\n  /**\n   * Build the link list array. All subclasses of vtkAbstractCellLinks\n   * must support this method.\n   */\n\n  publicAPI.buildLinks = function (data) {\n    var numPts = data.getPoints().getNumberOfPoints();\n    var numCells = data.getNumberOfCells(); // fill out lists with number of references to cells\n\n    var linkLoc = new Uint32Array(numPts); // Use fast path if polydata\n\n    if (data.isA('vtkPolyData')) {\n      // traverse data to determine number of uses of each point\n      for (var cellId = 0; cellId < numCells; ++cellId) {\n        var _data$getCellPoints = data.getCellPoints(cellId),\n            cellPointIds = _data$getCellPoints.cellPointIds;\n\n        cellPointIds.forEach(function (cellPointId) {\n          publicAPI.incrementLinkCount(cellPointId);\n        });\n      } // now allocate storage for the links\n\n\n      publicAPI.allocateLinks(numPts);\n      model.maxId = numPts - 1;\n\n      var _loop = function _loop(_cellId) {\n        var _data$getCellPoints2 = data.getCellPoints(_cellId),\n            cellPointIds = _data$getCellPoints2.cellPointIds;\n\n        cellPointIds.forEach(function (cellPointId) {\n          publicAPI.insertCellReference(cellPointId, linkLoc[cellPointId]++, _cellId);\n        });\n      };\n\n      for (var _cellId = 0; _cellId < numCells; ++_cellId) {\n        _loop(_cellId);\n      }\n    } // any other type of dataset\n    else {\n      // traverse data to determine number of uses of each point\n      for (var _cellId2 = 0; _cellId2 < numCells; _cellId2++) {\n        // TODO: Currently not supported: const cell = data.getCell(cellId);\n        var cell = vtkCell.newInstance();\n        cell.getPointsIds().forEach(function (cellPointId) {\n          publicAPI.incrementLinkCount(cellPointId);\n        });\n      } // now allocate storage for the links\n\n\n      publicAPI.allocateLinks(numPts);\n      model.maxId = numPts - 1;\n\n      var _loop2 = function _loop2(_cellId3) {\n        // TODO: Currently not supported: const cell = data.getCell(cellId);\n        var cell = vtkCell.newInstance();\n        cell.getPointsIds().forEach(function (cellPointId) {\n          publicAPI.insertCellReference(cellPointId, linkLoc[cellPointId]++, _cellId3);\n        });\n      };\n\n      for (var _cellId3 = 0; _cellId3 < numCells; ++_cellId3) {\n        _loop2(_cellId3);\n      }\n    } // end else\n\n  };\n  /**\n   * Build the link list array with a provided connectivity array.\n   */\n  // publicAPI.buildLinks = (data, connectivity) => {};\n\n  /**\n   * Allocate the specified number of links (i.e., number of points) that\n   * will be built.\n   */\n\n\n  publicAPI.allocate = function (numLinks) {\n    var ext = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1000;\n    model.array = Array(numLinks).fill().map(function () {\n      return {\n        ncells: 0,\n        cells: null\n      };\n    });\n    model.extend = ext;\n    model.maxId = -1;\n  };\n\n  publicAPI.initialize = function () {\n    model.array = null;\n  };\n  /**\n   * Get a link structure given a point id.\n   */\n\n\n  publicAPI.getLink = function (ptId) {\n    return model.array[ptId];\n  };\n  /**\n   * Get the number of cells using the point specified by ptId.\n   */\n\n\n  publicAPI.getNcells = function (ptId) {\n    return model.array[ptId].ncells;\n  };\n  /**\n   * Return a list of cell ids using the point.\n   */\n\n\n  publicAPI.getCells = function (ptId) {\n    return model.array[ptId].cells;\n  };\n  /**\n   * Insert a new point into the cell-links data structure. The size parameter\n   * is the initial size of the list.\n   */\n\n\n  publicAPI.insertNextPoint = function (numLinks) {\n    model.array.push({\n      ncells: numLinks,\n      cells: Array(numLinks)\n    });\n    ++model.maxId;\n  };\n  /**\n   * Insert a cell id into the list of cells (at the end) using the cell id\n   * provided. (Make sure to extend the link list (if necessary) using the\n   * method resizeCellList().)\n   */\n\n\n  publicAPI.insertNextCellReference = function (ptId, cellId) {\n    model.array[ptId].cells[model.array[ptId].ncells++] = cellId;\n  };\n  /**\n   * Delete point (and storage) by destroying links to using cells.\n   */\n\n\n  publicAPI.deletePoint = function (ptId) {\n    model.array[ptId].ncells = 0;\n    model.array[ptId].cells = null;\n  };\n  /**\n   * Delete the reference to the cell (cellId) from the point (ptId). This\n   * removes the reference to the cellId from the cell list, but does not\n   * resize the list (recover memory with resizeCellList(), if necessary).\n   */\n\n\n  publicAPI.removeCellReference = function (cellId, ptId) {\n    model.array[ptId].cells = model.array[ptId].cells.filter(function (cell) {\n      return cell !== cellId;\n    });\n    model.array[ptId].ncells = model.array[ptId].cells.length;\n  };\n  /**\n   * Add the reference to the cell (cellId) from the point (ptId). This\n   * adds a reference to the cellId from the cell list, but does not resize\n   * the list (extend memory with resizeCellList(), if necessary).\n   */\n\n\n  publicAPI.addCellReference = function (cellId, ptId) {\n    model.array[ptId].cells[model.array[ptId].ncells++] = cellId;\n  };\n  /**\n   * Change the length of a point's link list (i.e., list of cells using a\n   * point) by the size specified.\n   */\n\n\n  publicAPI.resizeCellList = function (ptId, size) {\n    model.array[ptId].cells.length = size;\n  };\n  /**\n   * Reclaim any unused memory.\n   */\n\n\n  publicAPI.squeeze = function () {\n    resize(model, model.maxId + 1);\n  };\n  /**\n   * Reset to a state of no entries without freeing the memory.\n   */\n\n\n  publicAPI.reset = function () {\n    model.maxId = -1;\n  };\n  /**\n   * Standard DeepCopy method.  Since this object contains no reference\n   * to other objects, there is no ShallowCopy.\n   */\n\n\n  publicAPI.deepCopy = function (src) {\n    model.array = _toConsumableArray(src.array);\n    model.extend = src.extend;\n    model.maxId = src.maxId;\n  };\n  /**\n   * Increment the count of the number of cells using the point.\n   */\n\n\n  publicAPI.incrementLinkCount = function (ptId) {\n    ++model.array[ptId].ncells;\n  };\n\n  publicAPI.allocateLinks = function (n) {\n    for (var i = 0; i < n; ++i) {\n      model.array[i].cells = new Array(model.array[i].ncells);\n    }\n  };\n  /**\n   * Insert a cell id into the list of cells using the point.\n   */\n\n\n  publicAPI.insertCellReference = function (ptId, pos, cellId) {\n    model.array[ptId].cells[pos] = cellId;\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\n\nvar DEFAULT_VALUES = {\n  array: null,\n  // pointer to data\n  maxId: 0,\n  // maximum index inserted thus far\n  extend: 0 // grow array by this point\n\n}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n  macro.obj(publicAPI, model);\n  vtkCellLinks(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = macro.newInstance(extend, 'vtkCellLinks'); // ----------------------------------------------------------------------------\n\nvar vtkCellLinks$1 = {\n  newInstance: newInstance,\n  extend: extend\n};\n\nexport { InitLink, vtkCellLinks$1 as default, extend, newInstance };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}