{"ast":null,"code":"import _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport _toConsumableArray from '@babel/runtime/helpers/toConsumableArray';\nimport _slicedToArray from '@babel/runtime/helpers/slicedToArray';\nimport macro from '../../macros.js';\nimport { f as vtkMath } from '../Core/Math/index.js';\nimport vtkBoundingBox from './BoundingBox.js';\nimport vtkIncrementalOctreeNode from './IncrementalOctreeNode.js';\nimport vtkAbstractPointLocator from './AbstractPointLocator.js';\nimport { VtkDataTypes } from '../Core/DataArray/Constants.js';\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n  return target;\n}\nvar vtkErrorMacro = macro.vtkErrorMacro;\nfunction vtkIncrementalOctreePointLocator(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkIncrementalOctreePointLocator');\n  function getLeafContainer(node, pnt) {\n    return node.isLeaf() ? node : getLeafContainer(node.getChild(node.getChildIndex(pnt)), pnt);\n  } //------------------------------------------------------------------------------\n\n  publicAPI.freeSearchStructure = function () {\n    model.octreeRootNode = null;\n    model.numberOfNodes = 0;\n    model.locatorPoints = null;\n  }; //------------------------------------------------------------------------------\n\n  publicAPI.findClosestPointInLeafNode = function (leafNode, point) {\n    // NOTE: dist2 MUST be initiated with a very huge value below, but instead of\n    // model.octreeMaxDimSize * model.octreeMaxDimSize * 4.0, because the point\n    // under check may be outside the octree and hence the squared distance can\n    // be greater than the latter or other similar octree-based specific values.\n    var dist2 = Number.MAX_VALUE;\n    if (leafNode.getPointIdSet() == null) {\n      return [-1, dist2];\n    }\n    var numPts = 0;\n    var tmpDst = 0.0;\n    var tmpPnt = [];\n    var tmpIdx = -1;\n    var pntIdx = -1;\n    var idList = leafNode.getPointIdSet();\n    numPts = idList.length;\n    for (var i = 0; i < numPts; i++) {\n      tmpIdx = idList[i];\n      model.locatorPoints.getPoint(tmpIdx, tmpPnt);\n      tmpDst = vtkMath.distance2BetweenPoints(tmpPnt, point);\n      if (tmpDst < dist2) {\n        dist2 = tmpDst;\n        pntIdx = tmpIdx;\n      }\n      if (dist2 === 0.0) {\n        break;\n      }\n    }\n    idList = null;\n    return [pntIdx, dist2];\n  };\n  publicAPI.findClosestPointInSphere = function (point, radius2, maskNode, refDist2) {\n    var pointIndx = -1;\n    var minDist2 = Number.MAX_VALUE;\n    var nodesBase = [];\n    nodesBase.push(model.octreeRootNode);\n    var checkNode;\n    var childNode;\n    var distToData;\n    var tempDist2;\n    var tempPntId;\n    while (!nodesBase.length === 0 && minDist2 > 0.0) {\n      checkNode = nodesBase.top();\n      nodesBase.pop();\n      if (!checkNode.isLeaf()) {\n        for (var i = 0; i < 8; i++) {\n          childNode = checkNode.getChild(i); // use ( radius2 + radius2 ) to skip empty nodes\n\n          distToData = childNode.getNumberOfPoints() ? childNode.getDistance2ToBoundary(point, model.octreeRootNode, 1) : radius2 + radius2; // If a child node is not the mask node AND its distance, specifically\n          // the data bounding box (determined by the points inside or under) to\n          // the point, is less than the threshold radius (one exception is the\n          // point's container nodes), it is pushed to the stack as a suspect.\n\n          if (childNode !== maskNode && (distToData <= refDist2 || childNode.containsPoint(point) === 1)) {\n            nodesBase.push(childNode);\n          }\n          childNode = null;\n        }\n      } else {\n        // now that the node under check is a leaf, let's find the closest\n        // point therein and the minimum distance\n        var _publicAPI$findCloses = publicAPI.findClosestPointInLeafNode(checkNode, point);\n        var _publicAPI$findCloses2 = _slicedToArray(_publicAPI$findCloses, 2);\n        tempPntId = _publicAPI$findCloses2[0];\n        tempDist2 = _publicAPI$findCloses2[1];\n        if (tempDist2 < minDist2) {\n          minDist2 = tempDist2;\n          pointIndx = tempPntId;\n        }\n      }\n      checkNode = null;\n    }\n    return [minDist2 <= radius2 ? pointIndx : -1, minDist2];\n  }; //------------------------------------------------------------------------------\n\n  publicAPI.initPointInsertion = function (points, bounds) {\n    var _model$octreeRootNode;\n    var i = 0;\n    var bbIndex = 0;\n    if (points == null) {\n      vtkErrorMacro('a valid vtkPoints object required for point insertion');\n      return false;\n    } // destroy the existing octree, if any\n\n    publicAPI.freeSearchStructure();\n    model.locatorPoints = points; // obtain the threshold squared distance\n\n    model.insertTolerance2 = model.tolerance * model.tolerance; // Fix bounds\n    // (1) push out a little bit if the original volume is too flat --- a slab\n    // (2) pull back the x, y, and z's lower bounds a little bit such that\n    //     points are clearly \"inside\" the spatial region.  Point p is taken as\n    //     \"inside\" range r = [r1, r2] if and only if r1 < p <= r2.\n\n    model.octreeMaxDimSize = 0.0;\n    var tmpBbox = _toConsumableArray(bounds);\n    var dimDiff = vtkBoundingBox.getLengths(bounds);\n    model.octreeMaxDimSize = Math.max.apply(Math, _toConsumableArray(dimDiff));\n    if (model.buildCubicOctree) {\n      // make the bounding box a cube and hence descendant octants cubes too\n      for (i = 0; i < 3; i++) {\n        if (dimDiff[i] !== model.octreeMaxDimSize) {\n          var delta = model.octreeMaxDimSize - dimDiff[i];\n          tmpBbox[2 * i] -= 0.5 * delta;\n          tmpBbox[2 * i + 1] += 0.5 * delta;\n          dimDiff[i] = model.octreeMaxDimSize;\n        }\n      }\n    }\n    model.fudgeFactor = model.octreeMaxDimSize * 10e-6;\n    var minSideSize = model.octreeMaxDimSize * 10e-2;\n    for (i = 0; i < 3; i++) {\n      if (dimDiff[i] < minSideSize) {\n        // case (1) above\n        bbIndex = 2 * i;\n        var tempVal = tmpBbox[bbIndex];\n        tmpBbox[bbIndex] = tmpBbox[bbIndex + 1] - minSideSize;\n        tmpBbox[bbIndex + 1] = tempVal + minSideSize;\n      } else {\n        // case (2) above\n        tmpBbox[2 * i] -= model.fudgeFactor;\n      }\n    } // init the octree with an empty leaf node\n\n    model.octreeRootNode = vtkIncrementalOctreeNode.newInstance();\n    ++model.numberOfNodes; // this call internally inits the middle (center) and data range, too\n\n    (_model$octreeRootNode = model.octreeRootNode).setBounds.apply(_model$octreeRootNode, _toConsumableArray(tmpBbox));\n    return true;\n  };\n  publicAPI.findClosestPointInSphereWithTolerance = function (point, radius2, maskNode) {\n    return publicAPI.findClosestPointInSphere(point, radius2, maskNode, model.octreeMaxDimSize * model.octreeMaxDimSize * 4.0, radius2);\n  }; //------------------------------------------------------------------------------\n\n  publicAPI.findDuplicateFloatTypePointInVisitedLeafNode = function (leafNode, point) {\n    var tmpPnt;\n    var tmpIdx = -1;\n    var pntIdx = -1; // float thePnt[3]; // TODO\n    // thePnt[0] = static_cast<float>(point[0]);\n    // thePnt[1] = static_cast<float>(point[1]);\n    // thePnt[2] = static_cast<float>(point[2]);\n\n    var idList = leafNode.getPointIdSet(); // float* pFloat = (static_cast<vtkFloatArray*>(model.locatorPoints.getData())).getPointer(0);\n\n    var values = model.locatorPoints.getData();\n    for (var i = 0; i < idList.length; i++) {\n      tmpIdx = idList[i]; // eslint-disable-next-line no-bitwise\n\n      tmpPnt = (tmpIdx << 1) + tmpIdx;\n      if (point[0] === values[tmpPnt] && point[1] === values[tmpPnt + 1] && point[2] === values[tmpPnt + 2]) {\n        pntIdx = tmpIdx;\n        break;\n      }\n    }\n    return pntIdx;\n  }; //------------------------------------------------------------------------------\n\n  publicAPI.findDuplicateDoubleTypePointInVisitedLeafNode = function (leafNode, point) {\n    var tmpPnt;\n    var tmpIdx = -1;\n    var pntIdx = -1;\n    var idList = leafNode.getPointIdSet();\n    var values = model.locatorPoints.getData();\n    for (var i = 0; i < idList.length; i++) {\n      tmpIdx = idList[i]; // eslint-disable-next-line no-bitwise\n\n      tmpPnt = (tmpIdx << 1) + tmpIdx;\n      if (point[0] === values[tmpPnt] && point[1] === values[tmpPnt + 1] && point[2] === values[tmpPnt + 2]) {\n        pntIdx = tmpIdx;\n        break;\n      }\n    }\n    return pntIdx;\n  }; //------------------------------------------------------------------------------\n\n  publicAPI.findDuplicatePointInLeafNode = function (leafNode, point) {\n    if (leafNode.getPointIdSet() == null) {\n      return -1;\n    }\n    return model.locatorPoints.getDataType() === VtkDataTypes.FLOAT ? publicAPI.findDuplicateFloatTypePointInVisitedLeafNode(leafNode, point) : publicAPI.findDuplicateDoubleTypePointInVisitedLeafNode(leafNode, point);\n  }; //------------------------------------------------------------------------------\n\n  publicAPI.insertPoint = function (ptId, x) {\n    var leafcontainer = getLeafContainer(model.octreeRootNode, x);\n    var _leafcontainer$insert = leafcontainer.insertPoint(model.locatorPoints, x, model.maxPointsPerLeaf, ptId, 1, model.numberOfNodes);\n    model.numberOfNodes = _leafcontainer$insert.numberOfNodes;\n  }; //------------------------------------------------------------------------------\n\n  publicAPI.insertUniquePoint = function (point) {\n    // TODO: We have a mix of let and const here.\n    // eslint-disable-next-line prefer-const\n    var _publicAPI$isInserted = publicAPI.isInsertedPoint(point),\n      pointIdx = _publicAPI$isInserted.pointIdx,\n      leafContainer = _publicAPI$isInserted.leafContainer;\n    if (pointIdx > -1) {\n      return {\n        success: false,\n        idx: pointIdx\n      };\n    } // TODO: pointIdx\n\n    var numberOfNodes; // eslint-disable-next-line prefer-const\n\n    var _leafContainer$insert = leafContainer.insertPoint(model.locatorPoints, point, model.maxPointsPerLeaf, pointIdx, 2, model.numberOfNodes);\n    numberOfNodes = _leafContainer$insert.numberOfNodes;\n    pointIdx = _leafContainer$insert.pointIdx;\n    model.numberOfNodes = numberOfNodes;\n    return {\n      success: true,\n      idx: pointIdx\n    };\n  }; //------------------------------------------------------------------------------\n\n  publicAPI.insertNextPoint = function (x) {\n    var leafContainer = getLeafContainer(model.octreeRootNode, x);\n    var _leafContainer$insert2 = leafContainer.insertPoint(model.locatorPoints, x, model.maxPointsPerLeaf, -1, 2, model.numberOfNodes),\n      numberOfNodes = _leafContainer$insert2.numberOfNodes,\n      pointIdx = _leafContainer$insert2.pointIdx;\n    model.numberOfNodes = numberOfNodes;\n    return pointIdx;\n  }; //------------------------------------------------------------------------------\n\n  publicAPI.isInsertedPointForZeroTolerance = function (x) {\n    // the target leaf node always exists there since the root node of the\n    // octree has been initialized to cover all possible points to be inserted\n    // and therefore we do not need to check it here\n    var leafContainer = getLeafContainer(model.octreeRootNode, x);\n    var pointIdx = publicAPI.findDuplicatePointInLeafNode(leafContainer, x);\n    return {\n      pointIdx: pointIdx,\n      leafContainer: leafContainer\n    };\n  }; //------------------------------------------------------------------------------\n\n  publicAPI.isInsertedPointForNonZeroTolerance = function (x) {\n    // minDist2 // min distance to ALL existing points\n    // elseDst2 // min distance to other nodes (inner boundaries)\n    var dist2Ext; // min distance to an EXTended set of nodes\n\n    var pntIdExt; // the target leaf node always exists there since the root node of the\n    // octree has been initialized to cover all possible points to be inserted\n    // and therefore we do not need to check it here\n\n    var leafContainer = getLeafContainer(model.octreeRootNode, x);\n    var _publicAPI$findCloses3 = publicAPI.findClosestPointInLeafNode(leafContainer, x),\n      _publicAPI$findCloses4 = _slicedToArray(_publicAPI$findCloses3, 2),\n      pointIdx = _publicAPI$findCloses4[0],\n      minDist2 = _publicAPI$findCloses4[1];\n    if (minDist2 === 0.0) {\n      return {\n        pointIdx: pointIdx,\n        leafContainer: leafContainer\n      };\n    } // As no any 'duplicate' point exists in this leaf node, we need to expand\n    // the search scope to capture possible closer points in other nodes.\n\n    var elseDst2 = leafContainer.getDistance2ToInnerBoundary(x, model.octreeRootNode);\n    if (elseDst2 < model.insertTolerance2) {\n      // one or multiple closer points might exist in the neighboring nodes\n      // TODO: dist2Ext\n      pntIdExt = publicAPI.findClosestPointInSphereWithTolerance(x, model.insertTolerance2, leafContainer, dist2Ext);\n      if (dist2Ext < minDist2) {\n        minDist2 = dist2Ext;\n        pointIdx = pntIdExt;\n      }\n    }\n    pointIdx = minDist2 <= model.insertTolerance2 ? pointIdx : -1;\n    return {\n      pointIdx: pointIdx,\n      leafContainer: leafContainer\n    };\n  }; //------------------------------------------------------------------------------\n\n  publicAPI.isInsertedPoint = function (x, leafContainer) {\n    return model.insertTolerance2 === 0.0 ? publicAPI.isInsertedPointForZeroTolerance(x, leafContainer) : publicAPI.isInsertedPointForNonZeroTolerance(x, leafContainer);\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nfunction defaultValues(initialValues) {\n  return _objectSpread({\n    fudgeFactor: 0,\n    octreeMaxDimSize: 0,\n    buildCubicOctree: false,\n    maxPointsPerLeaf: 128,\n    insertTolerance2: 0.000001,\n    locatorPoints: null,\n    octreeRootNode: null,\n    numberOfNodes: 0\n  }, initialValues);\n} // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  vtkAbstractPointLocator.extend(publicAPI, model, defaultValues(initialValues)); // Make this a VTK object\n\n  macro.obj(publicAPI, model);\n  macro.setGet(publicAPI, model, ['fudgeFactor', 'octreeMaxDimSize', 'buildCubicOctree', 'maxPointsPerLeaf', 'insertTolerance2', 'locatorPoints', 'octreeRootNode', 'numberOfNodes']); // Object specific methods\n\n  vtkIncrementalOctreePointLocator(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = macro.newInstance(extend, 'vtkIncrementalOctreePointLocator'); // ----------------------------------------------------------------------------\n\nvar vtkIncrementalOctreePointLocator$1 = {\n  newInstance: newInstance,\n  extend: extend\n};\nexport { vtkIncrementalOctreePointLocator$1 as default, extend, newInstance };","map":{"version":3,"names":["_defineProperty","_toConsumableArray","_slicedToArray","macro","f","vtkMath","vtkBoundingBox","vtkIncrementalOctreeNode","vtkAbstractPointLocator","VtkDataTypes","ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","getOwnPropertyDescriptors","defineProperties","defineProperty","vtkErrorMacro","vtkIncrementalOctreePointLocator","publicAPI","model","classHierarchy","getLeafContainer","node","pnt","isLeaf","getChild","getChildIndex","freeSearchStructure","octreeRootNode","numberOfNodes","locatorPoints","findClosestPointInLeafNode","leafNode","point","dist2","Number","MAX_VALUE","getPointIdSet","numPts","tmpDst","tmpPnt","tmpIdx","pntIdx","idList","getPoint","distance2BetweenPoints","findClosestPointInSphere","radius2","maskNode","refDist2","pointIndx","minDist2","nodesBase","checkNode","childNode","distToData","tempDist2","tempPntId","top","pop","getNumberOfPoints","getDistance2ToBoundary","containsPoint","_publicAPI$findCloses","_publicAPI$findCloses2","initPointInsertion","points","bounds","_model$octreeRootNode","bbIndex","insertTolerance2","tolerance","octreeMaxDimSize","tmpBbox","dimDiff","getLengths","Math","max","buildCubicOctree","delta","fudgeFactor","minSideSize","tempVal","newInstance","setBounds","findClosestPointInSphereWithTolerance","findDuplicateFloatTypePointInVisitedLeafNode","values","getData","findDuplicateDoubleTypePointInVisitedLeafNode","findDuplicatePointInLeafNode","getDataType","FLOAT","insertPoint","ptId","x","leafcontainer","_leafcontainer$insert","maxPointsPerLeaf","insertUniquePoint","_publicAPI$isInserted","isInsertedPoint","pointIdx","leafContainer","success","idx","_leafContainer$insert","insertNextPoint","_leafContainer$insert2","isInsertedPointForZeroTolerance","isInsertedPointForNonZeroTolerance","dist2Ext","pntIdExt","_publicAPI$findCloses3","_publicAPI$findCloses4","elseDst2","getDistance2ToInnerBoundary","defaultValues","initialValues","extend","undefined","obj","setGet","vtkIncrementalOctreePointLocator$1","default"],"sources":["/home/rakshith/Documents/RemoteRendering/vtk-js-react-app/node_modules/@kitware/vtk.js/Common/DataModel/IncrementalOctreePointLocator.js"],"sourcesContent":["import _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport _toConsumableArray from '@babel/runtime/helpers/toConsumableArray';\nimport _slicedToArray from '@babel/runtime/helpers/slicedToArray';\nimport macro from '../../macros.js';\nimport { f as vtkMath } from '../Core/Math/index.js';\nimport vtkBoundingBox from './BoundingBox.js';\nimport vtkIncrementalOctreeNode from './IncrementalOctreeNode.js';\nimport vtkAbstractPointLocator from './AbstractPointLocator.js';\nimport { VtkDataTypes } from '../Core/DataArray/Constants.js';\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nvar vtkErrorMacro = macro.vtkErrorMacro;\n\nfunction vtkIncrementalOctreePointLocator(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkIncrementalOctreePointLocator');\n\n  function getLeafContainer(node, pnt) {\n    return node.isLeaf() ? node : getLeafContainer(node.getChild(node.getChildIndex(pnt)), pnt);\n  } //------------------------------------------------------------------------------\n\n\n  publicAPI.freeSearchStructure = function () {\n    model.octreeRootNode = null;\n    model.numberOfNodes = 0;\n    model.locatorPoints = null;\n  }; //------------------------------------------------------------------------------\n\n\n  publicAPI.findClosestPointInLeafNode = function (leafNode, point) {\n    // NOTE: dist2 MUST be initiated with a very huge value below, but instead of\n    // model.octreeMaxDimSize * model.octreeMaxDimSize * 4.0, because the point\n    // under check may be outside the octree and hence the squared distance can\n    // be greater than the latter or other similar octree-based specific values.\n    var dist2 = Number.MAX_VALUE;\n\n    if (leafNode.getPointIdSet() == null) {\n      return [-1, dist2];\n    }\n\n    var numPts = 0;\n    var tmpDst = 0.0;\n    var tmpPnt = [];\n    var tmpIdx = -1;\n    var pntIdx = -1;\n    var idList = leafNode.getPointIdSet();\n    numPts = idList.length;\n\n    for (var i = 0; i < numPts; i++) {\n      tmpIdx = idList[i];\n      model.locatorPoints.getPoint(tmpIdx, tmpPnt);\n      tmpDst = vtkMath.distance2BetweenPoints(tmpPnt, point);\n\n      if (tmpDst < dist2) {\n        dist2 = tmpDst;\n        pntIdx = tmpIdx;\n      }\n\n      if (dist2 === 0.0) {\n        break;\n      }\n    }\n\n    idList = null;\n    return [pntIdx, dist2];\n  };\n\n  publicAPI.findClosestPointInSphere = function (point, radius2, maskNode, refDist2) {\n    var pointIndx = -1;\n    var minDist2 = Number.MAX_VALUE;\n    var nodesBase = [];\n    nodesBase.push(model.octreeRootNode);\n    var checkNode;\n    var childNode;\n    var distToData;\n    var tempDist2;\n    var tempPntId;\n\n    while (!nodesBase.length === 0 && minDist2 > 0.0) {\n      checkNode = nodesBase.top();\n      nodesBase.pop();\n\n      if (!checkNode.isLeaf()) {\n        for (var i = 0; i < 8; i++) {\n          childNode = checkNode.getChild(i); // use ( radius2 + radius2 ) to skip empty nodes\n\n          distToData = childNode.getNumberOfPoints() ? childNode.getDistance2ToBoundary(point, model.octreeRootNode, 1) : radius2 + radius2; // If a child node is not the mask node AND its distance, specifically\n          // the data bounding box (determined by the points inside or under) to\n          // the point, is less than the threshold radius (one exception is the\n          // point's container nodes), it is pushed to the stack as a suspect.\n\n          if (childNode !== maskNode && (distToData <= refDist2 || childNode.containsPoint(point) === 1)) {\n            nodesBase.push(childNode);\n          }\n\n          childNode = null;\n        }\n      } else {\n        // now that the node under check is a leaf, let's find the closest\n        // point therein and the minimum distance\n        var _publicAPI$findCloses = publicAPI.findClosestPointInLeafNode(checkNode, point);\n\n        var _publicAPI$findCloses2 = _slicedToArray(_publicAPI$findCloses, 2);\n\n        tempPntId = _publicAPI$findCloses2[0];\n        tempDist2 = _publicAPI$findCloses2[1];\n\n        if (tempDist2 < minDist2) {\n          minDist2 = tempDist2;\n          pointIndx = tempPntId;\n        }\n      }\n\n      checkNode = null;\n    }\n\n    return [minDist2 <= radius2 ? pointIndx : -1, minDist2];\n  }; //------------------------------------------------------------------------------\n\n\n  publicAPI.initPointInsertion = function (points, bounds) {\n    var _model$octreeRootNode;\n    var i = 0;\n    var bbIndex = 0;\n\n    if (points == null) {\n      vtkErrorMacro('a valid vtkPoints object required for point insertion');\n      return false;\n    } // destroy the existing octree, if any\n\n\n    publicAPI.freeSearchStructure();\n    model.locatorPoints = points; // obtain the threshold squared distance\n\n    model.insertTolerance2 = model.tolerance * model.tolerance; // Fix bounds\n    // (1) push out a little bit if the original volume is too flat --- a slab\n    // (2) pull back the x, y, and z's lower bounds a little bit such that\n    //     points are clearly \"inside\" the spatial region.  Point p is taken as\n    //     \"inside\" range r = [r1, r2] if and only if r1 < p <= r2.\n\n    model.octreeMaxDimSize = 0.0;\n\n    var tmpBbox = _toConsumableArray(bounds);\n\n    var dimDiff = vtkBoundingBox.getLengths(bounds);\n    model.octreeMaxDimSize = Math.max.apply(Math, _toConsumableArray(dimDiff));\n\n    if (model.buildCubicOctree) {\n      // make the bounding box a cube and hence descendant octants cubes too\n      for (i = 0; i < 3; i++) {\n        if (dimDiff[i] !== model.octreeMaxDimSize) {\n          var delta = model.octreeMaxDimSize - dimDiff[i];\n          tmpBbox[2 * i] -= 0.5 * delta;\n          tmpBbox[2 * i + 1] += 0.5 * delta;\n          dimDiff[i] = model.octreeMaxDimSize;\n        }\n      }\n    }\n\n    model.fudgeFactor = model.octreeMaxDimSize * 10e-6;\n    var minSideSize = model.octreeMaxDimSize * 10e-2;\n\n    for (i = 0; i < 3; i++) {\n      if (dimDiff[i] < minSideSize) {\n        // case (1) above\n        bbIndex = 2 * i;\n        var tempVal = tmpBbox[bbIndex];\n        tmpBbox[bbIndex] = tmpBbox[bbIndex + 1] - minSideSize;\n        tmpBbox[bbIndex + 1] = tempVal + minSideSize;\n      } else {\n        // case (2) above\n        tmpBbox[2 * i] -= model.fudgeFactor;\n      }\n    } // init the octree with an empty leaf node\n\n\n    model.octreeRootNode = vtkIncrementalOctreeNode.newInstance();\n    ++model.numberOfNodes; // this call internally inits the middle (center) and data range, too\n\n    (_model$octreeRootNode = model.octreeRootNode).setBounds.apply(_model$octreeRootNode, _toConsumableArray(tmpBbox));\n\n    return true;\n  };\n\n  publicAPI.findClosestPointInSphereWithTolerance = function (point, radius2, maskNode) {\n    return publicAPI.findClosestPointInSphere(point, radius2, maskNode, model.octreeMaxDimSize * model.octreeMaxDimSize * 4.0, radius2);\n  }; //------------------------------------------------------------------------------\n\n\n  publicAPI.findDuplicateFloatTypePointInVisitedLeafNode = function (leafNode, point) {\n    var tmpPnt;\n    var tmpIdx = -1;\n    var pntIdx = -1; // float thePnt[3]; // TODO\n    // thePnt[0] = static_cast<float>(point[0]);\n    // thePnt[1] = static_cast<float>(point[1]);\n    // thePnt[2] = static_cast<float>(point[2]);\n\n    var idList = leafNode.getPointIdSet(); // float* pFloat = (static_cast<vtkFloatArray*>(model.locatorPoints.getData())).getPointer(0);\n\n    var values = model.locatorPoints.getData();\n\n    for (var i = 0; i < idList.length; i++) {\n      tmpIdx = idList[i]; // eslint-disable-next-line no-bitwise\n\n      tmpPnt = (tmpIdx << 1) + tmpIdx;\n\n      if (point[0] === values[tmpPnt] && point[1] === values[tmpPnt + 1] && point[2] === values[tmpPnt + 2]) {\n        pntIdx = tmpIdx;\n        break;\n      }\n    }\n\n    return pntIdx;\n  }; //------------------------------------------------------------------------------\n\n\n  publicAPI.findDuplicateDoubleTypePointInVisitedLeafNode = function (leafNode, point) {\n    var tmpPnt;\n    var tmpIdx = -1;\n    var pntIdx = -1;\n    var idList = leafNode.getPointIdSet();\n    var values = model.locatorPoints.getData();\n\n    for (var i = 0; i < idList.length; i++) {\n      tmpIdx = idList[i]; // eslint-disable-next-line no-bitwise\n\n      tmpPnt = (tmpIdx << 1) + tmpIdx;\n\n      if (point[0] === values[tmpPnt] && point[1] === values[tmpPnt + 1] && point[2] === values[tmpPnt + 2]) {\n        pntIdx = tmpIdx;\n        break;\n      }\n    }\n\n    return pntIdx;\n  }; //------------------------------------------------------------------------------\n\n\n  publicAPI.findDuplicatePointInLeafNode = function (leafNode, point) {\n    if (leafNode.getPointIdSet() == null) {\n      return -1;\n    }\n\n    return model.locatorPoints.getDataType() === VtkDataTypes.FLOAT ? publicAPI.findDuplicateFloatTypePointInVisitedLeafNode(leafNode, point) : publicAPI.findDuplicateDoubleTypePointInVisitedLeafNode(leafNode, point);\n  }; //------------------------------------------------------------------------------\n\n\n  publicAPI.insertPoint = function (ptId, x) {\n    var leafcontainer = getLeafContainer(model.octreeRootNode, x);\n\n    var _leafcontainer$insert = leafcontainer.insertPoint(model.locatorPoints, x, model.maxPointsPerLeaf, ptId, 1, model.numberOfNodes);\n\n    model.numberOfNodes = _leafcontainer$insert.numberOfNodes;\n  }; //------------------------------------------------------------------------------\n\n\n  publicAPI.insertUniquePoint = function (point) {\n    // TODO: We have a mix of let and const here.\n    // eslint-disable-next-line prefer-const\n    var _publicAPI$isInserted = publicAPI.isInsertedPoint(point),\n        pointIdx = _publicAPI$isInserted.pointIdx,\n        leafContainer = _publicAPI$isInserted.leafContainer;\n\n    if (pointIdx > -1) {\n      return {\n        success: false,\n        idx: pointIdx\n      };\n    } // TODO: pointIdx\n\n\n    var numberOfNodes; // eslint-disable-next-line prefer-const\n\n    var _leafContainer$insert = leafContainer.insertPoint(model.locatorPoints, point, model.maxPointsPerLeaf, pointIdx, 2, model.numberOfNodes);\n\n    numberOfNodes = _leafContainer$insert.numberOfNodes;\n    pointIdx = _leafContainer$insert.pointIdx;\n    model.numberOfNodes = numberOfNodes;\n    return {\n      success: true,\n      idx: pointIdx\n    };\n  }; //------------------------------------------------------------------------------\n\n\n  publicAPI.insertNextPoint = function (x) {\n    var leafContainer = getLeafContainer(model.octreeRootNode, x);\n\n    var _leafContainer$insert2 = leafContainer.insertPoint(model.locatorPoints, x, model.maxPointsPerLeaf, -1, 2, model.numberOfNodes),\n        numberOfNodes = _leafContainer$insert2.numberOfNodes,\n        pointIdx = _leafContainer$insert2.pointIdx;\n\n    model.numberOfNodes = numberOfNodes;\n    return pointIdx;\n  }; //------------------------------------------------------------------------------\n\n\n  publicAPI.isInsertedPointForZeroTolerance = function (x) {\n    // the target leaf node always exists there since the root node of the\n    // octree has been initialized to cover all possible points to be inserted\n    // and therefore we do not need to check it here\n    var leafContainer = getLeafContainer(model.octreeRootNode, x);\n    var pointIdx = publicAPI.findDuplicatePointInLeafNode(leafContainer, x);\n    return {\n      pointIdx: pointIdx,\n      leafContainer: leafContainer\n    };\n  }; //------------------------------------------------------------------------------\n\n\n  publicAPI.isInsertedPointForNonZeroTolerance = function (x) {\n    // minDist2 // min distance to ALL existing points\n    // elseDst2 // min distance to other nodes (inner boundaries)\n    var dist2Ext; // min distance to an EXTended set of nodes\n\n    var pntIdExt; // the target leaf node always exists there since the root node of the\n    // octree has been initialized to cover all possible points to be inserted\n    // and therefore we do not need to check it here\n\n    var leafContainer = getLeafContainer(model.octreeRootNode, x);\n\n    var _publicAPI$findCloses3 = publicAPI.findClosestPointInLeafNode(leafContainer, x),\n        _publicAPI$findCloses4 = _slicedToArray(_publicAPI$findCloses3, 2),\n        pointIdx = _publicAPI$findCloses4[0],\n        minDist2 = _publicAPI$findCloses4[1];\n\n    if (minDist2 === 0.0) {\n      return {\n        pointIdx: pointIdx,\n        leafContainer: leafContainer\n      };\n    } // As no any 'duplicate' point exists in this leaf node, we need to expand\n    // the search scope to capture possible closer points in other nodes.\n\n\n    var elseDst2 = leafContainer.getDistance2ToInnerBoundary(x, model.octreeRootNode);\n\n    if (elseDst2 < model.insertTolerance2) {\n      // one or multiple closer points might exist in the neighboring nodes\n      // TODO: dist2Ext\n      pntIdExt = publicAPI.findClosestPointInSphereWithTolerance(x, model.insertTolerance2, leafContainer, dist2Ext);\n\n      if (dist2Ext < minDist2) {\n        minDist2 = dist2Ext;\n        pointIdx = pntIdExt;\n      }\n    }\n\n    pointIdx = minDist2 <= model.insertTolerance2 ? pointIdx : -1;\n    return {\n      pointIdx: pointIdx,\n      leafContainer: leafContainer\n    };\n  }; //------------------------------------------------------------------------------\n\n\n  publicAPI.isInsertedPoint = function (x, leafContainer) {\n    return model.insertTolerance2 === 0.0 ? publicAPI.isInsertedPointForZeroTolerance(x, leafContainer) : publicAPI.isInsertedPointForNonZeroTolerance(x, leafContainer);\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\n\nfunction defaultValues(initialValues) {\n  return _objectSpread({\n    fudgeFactor: 0,\n    octreeMaxDimSize: 0,\n    buildCubicOctree: false,\n    maxPointsPerLeaf: 128,\n    insertTolerance2: 0.000001,\n    locatorPoints: null,\n    octreeRootNode: null,\n    numberOfNodes: 0\n  }, initialValues);\n} // ----------------------------------------------------------------------------\n\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  vtkAbstractPointLocator.extend(publicAPI, model, defaultValues(initialValues)); // Make this a VTK object\n\n  macro.obj(publicAPI, model);\n  macro.setGet(publicAPI, model, ['fudgeFactor', 'octreeMaxDimSize', 'buildCubicOctree', 'maxPointsPerLeaf', 'insertTolerance2', 'locatorPoints', 'octreeRootNode', 'numberOfNodes']); // Object specific methods\n\n  vtkIncrementalOctreePointLocator(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = macro.newInstance(extend, 'vtkIncrementalOctreePointLocator'); // ----------------------------------------------------------------------------\n\nvar vtkIncrementalOctreePointLocator$1 = {\n  newInstance: newInstance,\n  extend: extend\n};\n\nexport { vtkIncrementalOctreePointLocator$1 as default, extend, newInstance };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}