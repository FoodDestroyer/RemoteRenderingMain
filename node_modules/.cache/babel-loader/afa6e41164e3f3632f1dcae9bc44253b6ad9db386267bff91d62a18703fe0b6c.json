{"ast":null,"code":"import { vec3 } from 'gl-matrix';\nimport vtkPlane from '../../../Common/DataModel/Plane.js';\n\n/**\n * Perform plane-line intersection, where the line is defined by two points (p1, p2),\n * and the plane is defined by the imageData and slice number.\n *\n * @param {Vector3} p1\n * @param {Vector3} p2\n * @param {vtkImageMapper|vtkImageArrayMapper} mapper\n */\n\nfunction doPicking(p1, p2, mapper) {\n  var imageData = mapper.getCurrentImage();\n  var extent = imageData.getExtent(); // Slice origin\n\n  var ijk = [extent[0], extent[2], extent[4]];\n  var _mapper$getClosestIJK = mapper.getClosestIJKAxis(),\n    ijkMode = _mapper$getClosestIJK.ijkMode;\n  var nSlice = mapper.isA('vtkImageArrayMapper') ? mapper.getSubSlice() : mapper.getSlice();\n  if (ijkMode !== mapper.getSlicingMode()) {\n    // If not IJK slicing, get the IJK slice from the XYZ position/slice\n    nSlice = mapper.getSliceAtPosition(nSlice);\n  }\n  ijk[ijkMode] += nSlice;\n  var worldOrigin = [0, 0, 0];\n  imageData.indexToWorld(ijk, worldOrigin); // Normal computation\n\n  ijk[ijkMode] += 1;\n  var worldNormal = [0, 0, 0];\n  imageData.indexToWorld(ijk, worldNormal);\n  worldNormal[0] -= worldOrigin[0];\n  worldNormal[1] -= worldOrigin[1];\n  worldNormal[2] -= worldOrigin[2];\n  vec3.normalize(worldNormal, worldNormal);\n  var intersect = vtkPlane.intersectWithLine(p1, p2, worldOrigin, worldNormal);\n  if (intersect.intersection) {\n    var point = intersect.x;\n    var absoluteIJK = [0, 0, 0];\n    imageData.worldToIndex(point, absoluteIJK); // `t` is the parametric position along the line\n    // defined in Plane.intersectWithLine\n\n    return {\n      t: intersect.t,\n      absoluteIJK: absoluteIJK\n    };\n  }\n  return null;\n}\n/**\n * Implement point picking for image plane.\n * The plane is defined by the imageData and current slice number,\n * set in the input mapper.\n *\n * @param {Vector3} p1\n * @param {Vector3} p2\n * @param {vtkImageMapper|vtkImageArrayMapper} mapper\n */\n\nfunction intersectWithLineForPointPicking(p1, p2, mapper) {\n  var pickingData = doPicking(p1, p2, mapper);\n  if (pickingData) {\n    var imageData = mapper.getCurrentImage();\n    var extent = imageData.getExtent(); // Get closer integer ijk\n    // NB: point picking means closest slice, means rounding\n\n    var ijk = [Math.round(pickingData.absoluteIJK[0]), Math.round(pickingData.absoluteIJK[1]), Math.round(pickingData.absoluteIJK[2])]; // Are we outside our actual extent\n\n    if (ijk[0] < extent[0] || ijk[0] > extent[1] || ijk[1] < extent[2] || ijk[1] > extent[3] || ijk[2] < extent[4] || ijk[2] > extent[5]) {\n      return null;\n    }\n    return {\n      t: pickingData.t,\n      ijk: ijk\n    };\n  }\n  return null;\n}\n/**\n * Implement cell picking for image plane.\n * The plane is defined by the imageData and current slice number,\n * set in the input mapper.\n *\n * @param {Vector3} p1\n * @param {Vector3} p2\n * @param {vtkImageMapper|vtkImageArrayMapper} mapper\n */\n\nfunction intersectWithLineForCellPicking(p1, p2, mapper) {\n  var pickingData = doPicking(p1, p2, mapper);\n  if (pickingData) {\n    var imageData = mapper.getCurrentImage();\n    var extent = imageData.getExtent();\n    var absIJK = pickingData.absoluteIJK; // Get closer integer ijk\n    // NB: cell picking means closest voxel, means flooring\n\n    var ijk = [Math.floor(absIJK[0]), Math.floor(absIJK[1]), Math.floor(absIJK[2])]; // Are we outside our actual extent\n\n    if (ijk[0] < extent[0] || ijk[0] > extent[1] - 1 || ijk[1] < extent[2] || ijk[1] > extent[3] - 1 || ijk[2] < extent[4] ||\n    // handle single-slice images\n    ijk[2] > (extent[5] ? extent[5] - 1 : extent[5])) {\n      return null;\n    } // Parametric coordinates within cell\n\n    var pCoords = [absIJK[0] - ijk[0], absIJK[1] - ijk[1], absIJK[2] - ijk[2]];\n    return {\n      t: pickingData.t,\n      ijk: ijk,\n      pCoords: pCoords\n    };\n  }\n  return null;\n}\nexport { intersectWithLineForCellPicking, intersectWithLineForPointPicking };","map":{"version":3,"names":["vec3","vtkPlane","doPicking","p1","p2","mapper","imageData","getCurrentImage","extent","getExtent","ijk","_mapper$getClosestIJK","getClosestIJKAxis","ijkMode","nSlice","isA","getSubSlice","getSlice","getSlicingMode","getSliceAtPosition","worldOrigin","indexToWorld","worldNormal","normalize","intersect","intersectWithLine","intersection","point","x","absoluteIJK","worldToIndex","t","intersectWithLineForPointPicking","pickingData","Math","round","intersectWithLineForCellPicking","absIJK","floor","pCoords"],"sources":["/home/rakshith/Documents/RemoteRendering/vtk-js-react-app/node_modules/@kitware/vtk.js/Rendering/Core/AbstractImageMapper/helper.js"],"sourcesContent":["import { vec3 } from 'gl-matrix';\nimport vtkPlane from '../../../Common/DataModel/Plane.js';\n\n/**\n * Perform plane-line intersection, where the line is defined by two points (p1, p2),\n * and the plane is defined by the imageData and slice number.\n *\n * @param {Vector3} p1\n * @param {Vector3} p2\n * @param {vtkImageMapper|vtkImageArrayMapper} mapper\n */\n\nfunction doPicking(p1, p2, mapper) {\n  var imageData = mapper.getCurrentImage();\n  var extent = imageData.getExtent(); // Slice origin\n\n  var ijk = [extent[0], extent[2], extent[4]];\n\n  var _mapper$getClosestIJK = mapper.getClosestIJKAxis(),\n      ijkMode = _mapper$getClosestIJK.ijkMode;\n\n  var nSlice = mapper.isA('vtkImageArrayMapper') ? mapper.getSubSlice() : mapper.getSlice();\n\n  if (ijkMode !== mapper.getSlicingMode()) {\n    // If not IJK slicing, get the IJK slice from the XYZ position/slice\n    nSlice = mapper.getSliceAtPosition(nSlice);\n  }\n\n  ijk[ijkMode] += nSlice;\n  var worldOrigin = [0, 0, 0];\n  imageData.indexToWorld(ijk, worldOrigin); // Normal computation\n\n  ijk[ijkMode] += 1;\n  var worldNormal = [0, 0, 0];\n  imageData.indexToWorld(ijk, worldNormal);\n  worldNormal[0] -= worldOrigin[0];\n  worldNormal[1] -= worldOrigin[1];\n  worldNormal[2] -= worldOrigin[2];\n  vec3.normalize(worldNormal, worldNormal);\n  var intersect = vtkPlane.intersectWithLine(p1, p2, worldOrigin, worldNormal);\n\n  if (intersect.intersection) {\n    var point = intersect.x;\n    var absoluteIJK = [0, 0, 0];\n    imageData.worldToIndex(point, absoluteIJK); // `t` is the parametric position along the line\n    // defined in Plane.intersectWithLine\n\n    return {\n      t: intersect.t,\n      absoluteIJK: absoluteIJK\n    };\n  }\n\n  return null;\n}\n/**\n * Implement point picking for image plane.\n * The plane is defined by the imageData and current slice number,\n * set in the input mapper.\n *\n * @param {Vector3} p1\n * @param {Vector3} p2\n * @param {vtkImageMapper|vtkImageArrayMapper} mapper\n */\n\n\nfunction intersectWithLineForPointPicking(p1, p2, mapper) {\n  var pickingData = doPicking(p1, p2, mapper);\n\n  if (pickingData) {\n    var imageData = mapper.getCurrentImage();\n    var extent = imageData.getExtent(); // Get closer integer ijk\n    // NB: point picking means closest slice, means rounding\n\n    var ijk = [Math.round(pickingData.absoluteIJK[0]), Math.round(pickingData.absoluteIJK[1]), Math.round(pickingData.absoluteIJK[2])]; // Are we outside our actual extent\n\n    if (ijk[0] < extent[0] || ijk[0] > extent[1] || ijk[1] < extent[2] || ijk[1] > extent[3] || ijk[2] < extent[4] || ijk[2] > extent[5]) {\n      return null;\n    }\n\n    return {\n      t: pickingData.t,\n      ijk: ijk\n    };\n  }\n\n  return null;\n}\n/**\n * Implement cell picking for image plane.\n * The plane is defined by the imageData and current slice number,\n * set in the input mapper.\n *\n * @param {Vector3} p1\n * @param {Vector3} p2\n * @param {vtkImageMapper|vtkImageArrayMapper} mapper\n */\n\nfunction intersectWithLineForCellPicking(p1, p2, mapper) {\n  var pickingData = doPicking(p1, p2, mapper);\n\n  if (pickingData) {\n    var imageData = mapper.getCurrentImage();\n    var extent = imageData.getExtent();\n    var absIJK = pickingData.absoluteIJK; // Get closer integer ijk\n    // NB: cell picking means closest voxel, means flooring\n\n    var ijk = [Math.floor(absIJK[0]), Math.floor(absIJK[1]), Math.floor(absIJK[2])]; // Are we outside our actual extent\n\n    if (ijk[0] < extent[0] || ijk[0] > extent[1] - 1 || ijk[1] < extent[2] || ijk[1] > extent[3] - 1 || ijk[2] < extent[4] || // handle single-slice images\n    ijk[2] > (extent[5] ? extent[5] - 1 : extent[5])) {\n      return null;\n    } // Parametric coordinates within cell\n\n\n    var pCoords = [absIJK[0] - ijk[0], absIJK[1] - ijk[1], absIJK[2] - ijk[2]];\n    return {\n      t: pickingData.t,\n      ijk: ijk,\n      pCoords: pCoords\n    };\n  }\n\n  return null;\n}\n\nexport { intersectWithLineForCellPicking, intersectWithLineForPointPicking };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}