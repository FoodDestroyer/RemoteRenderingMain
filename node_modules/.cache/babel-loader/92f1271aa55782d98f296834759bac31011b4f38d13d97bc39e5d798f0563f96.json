{"ast":null,"code":"import _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport _toConsumableArray from '@babel/runtime/helpers/toConsumableArray';\nimport macro from '../../macros.js';\nimport { d as dot, e as distance2BetweenPoints } from '../../Common/Core/Math/index.js';\nimport vtkCellArray from '../../Common/Core/CellArray.js';\nimport vtkDataArray from '../../Common/Core/DataArray.js';\nimport { VtkDataTypes } from '../../Common/Core/DataArray/Constants.js';\nimport vtkPoints from '../../Common/Core/Points.js';\nimport vtkDataSetAttributes from '../../Common/DataModel/DataSetAttributes.js';\nimport vtkPolyData from '../../Common/DataModel/PolyData.js';\nimport vtkContourTriangulator from './ContourTriangulator.js';\nimport vtkEdgeLocator from '../../Common/DataModel/EdgeLocator.js';\nimport Constants from './ClipClosedSurface/Constants.js';\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n  return target;\n}\nvar vtkErrorMacro = macro.vtkErrorMacro,\n  capitalize = macro.capitalize;\nvar ScalarMode = Constants.ScalarMode;\nfunction vtkClipClosedSurface(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkClipClosedSurface');\n  publicAPI.getMTime = function () {\n    return model.clippingPlanes.reduce(function (a, b) {\n      return b.getMTime() > a ? b.getMTime() : a;\n    }, model.mtime);\n  };\n  /**\n   * Take three colors as doubles, and convert to unsigned char.\n   *\n   * @param {Number} color1\n   * @param {Number} color2\n   * @param {Number} color3\n   * @param {Number[3][3]} colors\n   */\n\n  function createColorValues(color1, color2, color3, colors) {\n    var dcolors = [color1, color2, color3];\n    var clamp = function clamp(n, min, max) {\n      return Math.min(Math.max(n, min), max);\n    };\n    for (var i = 0; i < 3; i++) {\n      for (var j = 0; j < 3; j++) {\n        colors[i][j] = Math.round(clamp(dcolors[i][j], 0, 1) * 255);\n      }\n    }\n  }\n  /**\n   * Point interpolation for clipping and contouring, given the scalar\n   * values (v0, v1) for the two endpoints (p0, p1).  The use of this\n   * function guarantees perfect consistency in the results.\n   *\n   * @param {vtkPoints} points\n   * @param {vtkDataArray} pointData\n   * @param {CCSEdgeLocator} locator\n   * @param {Number} tol\n   * @param {Number} i0\n   * @param {Number} i1\n   * @param {Number} v0\n   * @param {Number} v1\n   * @param {Number} i\n   * @returns {Number}\n   */\n\n  function interpolateEdge(points, pointData, locator, tol, i0, i1, v0, v1) {\n    // This swap guarantees that exactly the same point is computed\n    // for both line directions, as long as the endpoints are the same.\n    if (v1 > 0) {\n      // eslint-disable-next-line no-param-reassign\n      var _ref = [i1, i0];\n      i0 = _ref[0];\n      i1 = _ref[1];\n      var _ref2 = [v1, v0];\n      v0 = _ref2[0];\n      v1 = _ref2[1];\n    } // After the above swap, i0 will be kept, and i1 will be clipped\n    // Check to see if this point has already been computed\n\n    var edge = locator.insertUniqueEdge(i0, i1);\n    if (edge.value != null) {\n      return edge.value;\n    } // Get the edge and interpolate the new point\n\n    var p0 = points.getPoint(i0);\n    var p1 = points.getPoint(i1);\n    var f = v0 / (v0 - v1);\n    var s = 1.0 - f;\n    var t = 1.0 - s;\n    var p = [s * p0[0] + t * p1[0], s * p0[1] + t * p1[1], s * p0[2] + t * p1[2]];\n    var tol2 = tol * tol; // Make sure that new point is far enough from kept point\n\n    if (distance2BetweenPoints(p, p0) < tol2) {\n      edge.value = i0;\n      return i0;\n    }\n    if (distance2BetweenPoints(p, p1) < tol2) {\n      edge.value = i1;\n      return i1;\n    }\n    edge.value = points.insertNextTuple(p);\n    pointData.interpolateData(pointData, i0, i1, edge.value, t);\n    return edge.value;\n  }\n  /**\n   * Method for clipping lines and copying the scalar data.\n   *\n   * @param {vtkPoints} points\n   * @param {vtkDataArray} pointScalars\n   * @param {vtkDataSetAttributesk} pointData\n   * @param {vtkEdgeLocator} edgeLocator\n   * @param {vtkCellArray} inputLines\n   * @param {vtkCellArray} outputLines\n   * @param {vtkDataSetAttributes} inLineData\n   * @param {vtkDataSetAttributes} outLineData\n   */\n\n  function clipLines(points, pointScalars, pointData, edgeLocator, inputLines, outputLines, inLineData, outLineData) {\n    var numPts;\n    var i0;\n    var i1;\n    var v0;\n    var v1;\n    var c0;\n    var c1;\n    var linePts = [];\n    var values = inputLines.getData();\n    var cellId = 0;\n    for (var i = 0; i < values.length; i += numPts + 1, cellId++) {\n      numPts = values[i];\n      i1 = values[i + 1];\n      v1 = pointScalars.getData()[i1];\n      c1 = v1 > 0;\n      for (var j = 2; j <= numPts; j++) {\n        i0 = i1;\n        v0 = v1;\n        c0 = c1;\n        i1 = values[i + j];\n        v1 = pointScalars.getData()[i1];\n        c1 = v1 > 0; // If at least one point wasn't clipped\n\n        if (c0 || c1) {\n          // If only one end was clipped, interpolate new point\n          if (c0 ? !c1 : c1) {\n            linePts[c0 ? 1 : 0] = interpolateEdge(points, pointData, edgeLocator, model.tolerance, i0, i1, v0, v1);\n          } // If endpoints are different, insert the line segment\n\n          if (i0 !== i1) {\n            linePts[0] = i0;\n            linePts[1] = i1;\n            var newCellId = outputLines.insertNextCell(linePts); // outLineData.copyData(inLineData, cellId, newCellId);\n\n            outLineData.passData(inLineData, cellId, newCellId);\n          }\n        }\n      }\n    }\n  }\n  /**\n   * Break polylines into individual lines, copying scalar values from\n   * inputScalars starting at firstLineScalar.  If inputScalars is zero,\n   * then scalars will be set to color.  If scalars is zero, then no\n   * scalars will be generated.\n   *\n   * @param {vtkCellArray} inputLines\n   * @param {vtkCellArray} outputLines\n   * @param {vtkDataArray} inputScalars\n   * @param {Number} firstLineScalar\n   * @param {vtkDataArray} scalars\n   * @param {Vector3} color\n   */\n\n  function breakPolylines(inputLines, outputLines, inputScalars, firstLineScalar, scalars, color) {\n    var cellColor = _toConsumableArray(color);\n    var cellId = 0;\n    var values = inputLines.getData();\n    var numPts;\n    for (var i = 0; i < values.length; i += numPts + 1) {\n      numPts = values[i];\n      if (inputScalars) {\n        inputScalars.getTuple(firstLineScalar + cellId++, cellColor);\n      }\n      for (var j = 1; j < numPts; j++) {\n        outputLines.insertNextCell([values[i + j], values[i + j + 1]]);\n        if (scalars) {\n          scalars.insertNextTuple(cellColor);\n        }\n      }\n    }\n  }\n  /**\n   * Copy polygons and their associated scalars to a new array.\n   * If inputScalars is set to zero, set polyScalars to color instead.\n   * If polyScalars is set to zero, don't generate scalars.\n   *\n   * @param {vtkCellArray} inputPolys\n   * @param {vtkCellArray} outputPolys\n   * @param {vtkDataArray} inputScalars\n   * @param {Number} firstPolyScalar\n   * @param {vtkDataArray} polyScalars\n   * @param {Vector3} color\n   */\n\n  function copyPolygons(inputPolys, outputPolys, inputScalars, firstPolyScalar, polyScalars, color) {\n    if (!inputPolys) {\n      return;\n    }\n    outputPolys.deepCopy(inputPolys);\n    if (polyScalars) {\n      var scalarValue = _toConsumableArray(color);\n      var n = outputPolys.getNumberOfCells();\n      polyScalars.insertTuple(n - 1, scalarValue);\n      if (inputScalars) {\n        for (var i = 0; i < n; i++) {\n          inputScalars.getTuple(i + firstPolyScalar, scalarValue);\n          polyScalars.setTuple(i, scalarValue);\n        }\n      } else {\n        for (var _i = 0; _i < n; _i++) {\n          polyScalars.setTuple(_i, scalarValue);\n        }\n      }\n    }\n  }\n  function breakTriangleStrips(inputStrips, polys, inputScalars, firstStripScalar, polyScalars, color) {\n    if (inputStrips.getNumberOfCells() === 0) {\n      return;\n    }\n    var values = inputStrips.getData();\n    var cellId = firstStripScalar;\n    var numPts;\n    for (var i = 0; i < values.length; i += numPts + 1, cellId++) {\n      numPts = values[i]; // vtkTriangleStrip.decomposeStrip(numPts, values, polys);\n\n      var p1 = values[i + 1];\n      var p2 = values[i + 2];\n      for (var j = 0; j < numPts - 2; j++) {\n        var p3 = values[i + j + 3];\n        if (j % 2) {\n          polys.insertNextCell([p2, p1, p3]);\n        } else {\n          polys.insertNextCell([p1, p2, p3]);\n        }\n        p1 = p2;\n        p2 = p3;\n      }\n      if (polyScalars) {\n        var scalarValue = _toConsumableArray(color);\n        if (inputScalars) {\n          // If there are input scalars, use them instead of \"color\"\n          inputScalars.getTuple(cellId, scalarValue);\n        }\n        var n = numPts - 3;\n        var m = polyScalars.getNumberOfTuples();\n        if (n >= 0) {\n          // First insert is just to allocate space\n          polyScalars.insertTuple(m + n, scalarValue);\n          for (var k = 0; k < n; k++) {\n            polyScalars.setTuple(m + k, scalarValue);\n          }\n        }\n      }\n    }\n  }\n  /**\n   * Given some closed contour lines, create a triangle mesh that\n   * fills those lines.  The input lines must be single-segment lines,\n   * not polylines.  The input lines do not have to be in order.\n   * Only lines from firstLine to will be used.  Specify the normal\n   * of the clip plane, which will be opposite the normals\n   * of the polys that will be produced.  If outCD has scalars, then color\n   * scalars will be added for each poly that is created.\n   *\n   * @param {vtkPolyData} polyData\n   * @param {Number} firstLine\n   * @param {Number} numLines\n   * @param {vtkCellArray} outputPolys\n   * @param {Vector3} normal\n   */\n\n  function triangulateContours(polyData, firstLine, numLines, outputPolys, normal) {\n    // If no cut lines were generated, there's nothing to do\n    if (numLines <= 0) {\n      return;\n    }\n    var triangulationError = !vtkContourTriangulator.triangulateContours(polyData, firstLine, numLines, outputPolys, [-normal[0], -normal[1], -normal[2]]);\n    if (triangulationError && model.triangulationErrorDisplay) {\n      vtkErrorMacro('Triangulation failed, polyData may not be watertight.');\n    }\n  }\n  /**\n   * Break polylines into individual lines, copying scalar values from\n   * inputScalars starting at firstLineScalar. If inputScalars is zero,\n   * then scalars will be set to color. If scalars is zero, then no\n   * scalars will be generated.\n   *\n   * @param {Number[]} polygon\n   * @param {vtkPoints} points\n   * @param {vtkCellArray} triangles\n   * @returns {Boolean}\n   */\n\n  function triangulatePolygon(polygon, points, triangles) {\n    return vtkContourTriangulator.triangulatePolygon(polygon, points, triangles);\n  }\n  /**\n   * Clip and contour polys in one step, in order to guarantee\n   * that the contour lines exactly match the new free edges of\n   * the clipped polygons.  This exact correspondence is necessary\n   * in order to guarantee that the surface remains closed.\n   *\n   * @param {vtkPoints} points\n   * @param {vtkDataArray} pointScalars\n   * @param {vtkDataSetAttributes} pointData\n   * @param {vtkEdgeLocator} edgeLocator\n   * @param {Number} triangulate\n   * @param {vtkCellArray} inputPolys\n   * @param {vtkCellArray} outputPolys\n   * @param {vtkCellArray} outputLines\n   * @param {vtkDataSetAttributes} inCellData\n   * @param {vtkDataSetAttributes} outPolyData\n   * @param {vtkDataSetAttributes} outLineData\n   */\n\n  function clipAndContourPolys(points, pointScalars, pointData, edgeLocator, triangulate, inputPolys, outputPolys, outputLines, inCellData, outPolyData, outLineData) {\n    var idList = model._idList; // How many sides for output polygons?\n\n    var polyMax = Number.MAX_VALUE;\n    if (triangulate) {\n      if (triangulate < 4) {\n        // triangles only\n        polyMax = 3;\n      } else if (triangulate === 4) {\n        // allow triangles and quads\n        polyMax = 4;\n      }\n    } // eslint-disable-next-line prefer-const\n\n    var triangulationFailure = false; // Go through all cells and clip them\n\n    var values = inputPolys.getData();\n    var linePts = [];\n    var cellId = 0;\n    var numPts;\n    for (var i = 0; i < values.length; i += numPts + 1, cellId++) {\n      numPts = values[i];\n      var i1 = values[i + numPts];\n      var v1 = pointScalars.getData()[i1];\n      var c1 = v1 > 0; // The ids for the current edge: init j0 to -1 if i1 will be clipped\n\n      var j0 = c1 ? i1 : -1;\n      var j1 = 0; // To store the ids of the contour line\n\n      linePts[0] = 0;\n      linePts[1] = 0;\n      var idListIdx = 0;\n      for (var j = 1; j <= numPts; j++) {\n        // Save previous point info\n        var i0 = i1;\n        var v0 = v1;\n        var c0 = c1; // Generate new point info\n\n        i1 = values[i + j];\n        v1 = pointScalars.getData()[i1];\n        c1 = v1 > 0; // If at least one edge end point wasn't clipped\n\n        if (c0 || c1) {\n          // If only one end was clipped, interpolate new point\n          if (c0 ? !c1 : c1) {\n            j1 = interpolateEdge(points, pointData, edgeLocator, model.tolerance, i0, i1, v0, v1);\n            if (j1 !== j0) {\n              idList[idListIdx++] = j1;\n              j0 = j1;\n            } // Save as one end of the contour line\n\n            linePts[c0 ? 1 : 0] = j1;\n          }\n          if (c1) {\n            j1 = i1;\n            if (j1 !== j0) {\n              idList[idListIdx++] = j1;\n              j0 = j1;\n            }\n          }\n        }\n      } // Insert the clipped poly\n\n      var numPoints = idListIdx;\n      idList.length = numPoints;\n      if (model.triangulatePolys && numPoints > polyMax) {\n        // TODO: Support triangulatePolygon\n        var newCellId = outputPolys.getNumberOfCells(); // Triangulate the poly and insert triangles into output.\n\n        var success = triangulatePolygon(idList, points, outputPolys);\n        if (!success) {\n          triangulationFailure = true;\n        } // Copy the attribute data to the triangle cells\n\n        var ncells = outputPolys.getNumberOfCells();\n        for (; newCellId < ncells; newCellId++) {\n          outPolyData.passData(inCellData, cellId, newCellId);\n        }\n      } else if (numPoints > 2) {\n        // Insert the polygon without triangulating it\n        var _newCellId = outputPolys.insertNextCell(idList);\n        outPolyData.passData(inCellData, cellId, _newCellId);\n      } // Insert the contour line if one was created\n\n      if (linePts[0] !== linePts[1]) {\n        var _newCellId2 = outputLines.insertNextCell(linePts);\n        outLineData.passData(inCellData, cellId, _newCellId2);\n      }\n    }\n    if (triangulationFailure && model.triangulationErrorDisplay) {\n      vtkErrorMacro('Triangulation failed, output may not be watertight');\n    }\n  }\n  /**\n   * Squeeze the points and store them in the output.  Only the points that\n   * are used by the cells will be saved, and the pointIds of the cells will\n   * be modified.\n   *\n   * @param {vtkPolyData} output\n   * @param {vtkPoints} points\n   * @param {vtkDataSetAttributes} pointData\n   * @param {String} outputPointDataType\n   */\n\n  function squeezeOutputPoints(output, points, pointData, outputPointDataType) {\n    // Create a list of points used by cells\n    var n = points.getNumberOfPoints();\n    var numNewPoints = 0;\n    var outPointData = output.getPointData();\n    var pointMap = [];\n    pointMap.length = n;\n    var cellArrays = [output.getVerts(), output.getLines(), output.getPolys(), output.getStrips()]; // Find all the newPoints that are used by cells\n\n    cellArrays.forEach(function (cellArray) {\n      if (!cellArray) {\n        return;\n      }\n      var values = cellArray.getData();\n      var numPts;\n      var pointId;\n      for (var i = 0; i < values.length; i += numPts + 1) {\n        numPts = values[i];\n        for (var j = 1; j <= numPts; j++) {\n          pointId = values[i + j];\n          if (pointMap[pointId] === undefined) {\n            pointMap[pointId] = numNewPoints++;\n          }\n        }\n      }\n    }); // Create exactly the number of points that are required\n\n    var newPoints = vtkPoints.newInstance({\n      size: numNewPoints * 3,\n      dataType: outputPointDataType\n    }); // outPointData.copyAllocate(pointData, numNewPoints, 0);\n\n    var p = [];\n    var newPointId;\n    for (var pointId = 0; pointId < n; pointId++) {\n      newPointId = pointMap[pointId];\n      if (newPointId !== undefined) {\n        points.getPoint(pointId, p);\n        newPoints.setTuple(newPointId, p);\n        outPointData.passData(pointData, pointId, newPointId); // outPointData.copyData(pointData, pointId, newPointId);\n      }\n    } // Change the cell pointIds to reflect the new point array\n\n    cellArrays.forEach(function (cellArray) {\n      if (!cellArray) {\n        return;\n      }\n      var values = cellArray.getData();\n      var numPts;\n      var pointId;\n      for (var i = 0; i < values.length; i += numPts + 1) {\n        numPts = values[i];\n        for (var j = 1; j <= numPts; j++) {\n          pointId = values[i + j];\n          values[i + j] = pointMap[pointId];\n        }\n      }\n    });\n    output.setPoints(newPoints);\n  }\n  publicAPI.requestData = function (inData, outData) {\n    var _input$getVerts, _input$getStrips;\n\n    // implement requestData\n    var input = inData[0];\n    var output = vtkPolyData.newInstance();\n    outData[0] = output;\n    if (!input) {\n      vtkErrorMacro('Invalid or missing input');\n      return;\n    }\n    if (model._idList == null) {\n      model._idList = [];\n    } else {\n      model._idList.length = 0;\n    } // Get the input points\n\n    var inputPoints = input.getPoints();\n    var numPts = 0;\n    var inputPointsType = VtkDataTypes.FLOAT;\n    if (inputPoints) {\n      numPts = inputPoints.getNumberOfPoints();\n      inputPointsType = inputPoints.getDataType();\n    } // Force points to double precision, copy the point attributes\n\n    var points = vtkPoints.newInstance({\n      size: numPts * 3,\n      dataType: VtkDataTypes.DOUBLE\n    });\n    var pointData = vtkDataSetAttributes.newInstance();\n    var inPointData = null;\n    if (model.passPointData) {\n      inPointData = input.getPointData(); // pointData.interpolateAllocate(inPointData, numPts, 0);\n    }\n\n    var point = [];\n    for (var ptId = 0; ptId < numPts; ptId++) {\n      inputPoints.getPoint(ptId, point);\n      points.setTuple(ptId, point);\n      if (inPointData) {\n        // pointData.copyData(inPointData, ptId, ptId);\n        pointData.passData(inPointData, ptId, ptId);\n      }\n    } // An edge locator to avoid point duplication while clipping\n\n    var edgeLocator = vtkEdgeLocator.newInstance(); // A temporary polydata for the contour lines that are triangulated\n\n    var tmpContourData = vtkPolyData.newInstance(); // The cell scalars\n\n    var lineScalars;\n    var polyScalars;\n    var inputScalars; // For input scalars: the offsets to the various cell types\n\n    var firstLineScalar = 0;\n    var firstPolyScalar = 0;\n    var firstStripScalar = 0; // Make the colors to be used on the data\n\n    var numberOfScalarComponents = 1;\n    var colors = [[0, 0, 0], [0, 0, 0], [0, 0, 0]];\n    if (model.scalarMode === ScalarMode.COLORS) {\n      numberOfScalarComponents = 3;\n      createColorValues(model.baseColor, model.clipColor, model.activePlaneColor, colors);\n    } else if (model.scalarMode === ScalarMode.LABELS) {\n      colors[0][0] = 0;\n      colors[1][0] = 1;\n      colors[2][0] = 2;\n    } // This is set if we have to work with scalars. The input scalars\n    // will be copied if they are unsigned char with 3 components, otherwise\n    // new scalars will be generated.\n\n    var numVerts = ((_input$getVerts = input.getVerts()) === null || _input$getVerts === void 0 ? void 0 : _input$getVerts.getNumberOfCells()) || 0;\n    var inputLines = input.getLines();\n    var numLines = (inputLines === null || inputLines === void 0 ? void 0 : inputLines.getNumberOfCells()) || 0;\n    var inputPolys = input.getPolys();\n    var numPolys = (inputPolys === null || inputPolys === void 0 ? void 0 : inputPolys.getNumberOfCells()) || 0;\n    var numStrips = ((_input$getStrips = input.getStrips()) === null || _input$getStrips === void 0 ? void 0 : _input$getStrips.getNumberOfCells()) || 0;\n    if (model.scalarMode !== ScalarMode.NONE) {\n      lineScalars = vtkDataArray.newInstance({\n        dataType: VtkDataTypes.UNSIGNED_CHAR,\n        empty: true,\n        // size: 0,\n        // values: new Uint8Array(numLines * 3),\n        numberOfComponents: numberOfScalarComponents\n      });\n      var tryInputScalars = input.getCellData().getScalars(); // Get input scalars if they are RGB color scalars\n\n      if (tryInputScalars && tryInputScalars.getDataType() === VtkDataTypes.UNSIGNED_CHAR && numberOfScalarComponents === 3 && tryInputScalars.getNumberOfComponents() === 3) {\n        inputScalars = input.getCellData().getScalars();\n        firstLineScalar = numVerts;\n        firstPolyScalar = numVerts + numLines;\n        firstStripScalar = numVerts + numLines + numPolys;\n      }\n    } // Break the input lines into segments, generate scalars for lines\n\n    var lines;\n    if (numLines > 0) {\n      lines = vtkCellArray.newInstance({\n        dataType: inputLines.getDataType(),\n        values: new Uint8Array(numLines * 3),\n        // we will have at least that amount of lines\n        size: 0\n      });\n      breakPolylines(inputLines, lines, inputScalars, firstLineScalar, lineScalars, colors[0]);\n    } else {\n      lines = vtkCellArray.newInstance({\n        empty: true\n      });\n    }\n    var polys = null;\n    var polyMax = 3;\n    if (numPolys > 0 || numStrips > 0) {\n      // If there are line scalars, then poly scalars are needed too\n      if (lineScalars) {\n        polyScalars = vtkDataArray.newInstance({\n          dataType: VtkDataTypes.UNSIGNED_CHAR,\n          empty: true,\n          // size: 0,\n          // values: new Uint8Array(inputPolys.getNumberOfCells(false) * 3),\n          numberOfComponents: numberOfScalarComponents\n        });\n      }\n      polys = vtkCellArray.newInstance();\n      copyPolygons(inputPolys, polys, inputScalars, firstPolyScalar, polyScalars, colors[0]); // TODO: Support triangle strips\n\n      breakTriangleStrips(input.getStrips(), polys, inputScalars, firstStripScalar, polyScalars, colors[0]); // Check if the input has polys and quads or just triangles\n\n      polyMax = inputPolys.getCellSizes().reduce(function (a, b) {\n        return a > b ? a : b;\n      }, 0);\n    } // Arrays for storing the clipped lines and polys\n\n    var newLines = vtkCellArray.newInstance({\n      dataType: lines.getDataType(),\n      empty: true\n    });\n    var newPolys = null;\n    if (polys) {\n      newPolys = vtkCellArray.newInstance({\n        dataType: polys.getDataType(),\n        empty: true\n      });\n    } // The line scalars, for coloring the outline\n\n    var inLineData = vtkDataSetAttributes.newInstance();\n    inLineData.copyScalarsOn();\n    inLineData.setScalars(lineScalars); // The poly scalars, for coloring the faces\n\n    var inPolyData = vtkDataSetAttributes.newInstance();\n    inPolyData.copyScalarsOn();\n    inPolyData.setScalars(polyScalars); // Also create output attribute data\n\n    var outLineData = vtkDataSetAttributes.newInstance();\n    outLineData.copyScalarsOn();\n    var outPolyData = vtkDataSetAttributes.newInstance();\n    outPolyData.copyScalarsOn();\n    var planes = model.clippingPlanes; // Go through the clipping planes and clip the input with each plane\n\n    for (var planeId = 0; planeId < planes.length; planeId++) {\n      var plane = planes[planeId];\n      var triangulate = 5;\n      if (planeId === planes.length - 1) {\n        triangulate = polyMax;\n      }\n      var active = planeId === model.activePlaneId; // Convert the plane into an easy-to-evaluate function\n\n      var pc = plane.getNormal(); // OK to modify pc because vtkPlane.getNormal() returns a copy\n\n      pc[3] = -dot(pc, plane.getOrigin()); // Create the clip scalars by evaluating the plane at each point\n\n      var numPoints = points.getNumberOfPoints(); // The point scalars, needed for clipping (not for the output!)\n\n      var pointScalars = vtkDataArray.newInstance({\n        dataType: VtkDataTypes.DOUBLE,\n        size: numPoints\n      });\n      var pointScalarsData = pointScalars.getData();\n      var pointsData = points.getData();\n      var i = 0;\n      for (var pointId = 0; pointId < numPoints; pointId) {\n        pointScalarsData[pointId++] = pointsData[i++] * pc[0] + pointsData[i++] * pc[1] + pointsData[i++] * pc[2] + pc[3];\n      } // Prepare the output scalars\n      // outLineData.copyAllocate(inLineData, 0, 0);\n      // outPolyData.copyAllocate(inPolyData, 0, 0);\n      // Reset the locator\n\n      edgeLocator.initialize(); // Clip the lines\n\n      clipLines(points, pointScalars, pointData, edgeLocator, lines, newLines, inLineData, outLineData); // Clip the polys\n\n      if (polys) {\n        // Get the number of lines remaining after the clipping\n        var numClipLines = newLines.getNumberOfCells(); // Cut the polys to generate more lines\n\n        clipAndContourPolys(points, pointScalars, pointData, edgeLocator, triangulate, polys, newPolys, newLines, inPolyData, outPolyData, outLineData); // Add scalars for the newly-created contour lines\n\n        var _scalars = outLineData.getScalars();\n        if (_scalars) {\n          // Set the color to the active color if plane is active\n          var color = colors[1 + (active ? 1 : 0)];\n          var activeColor = colors[2];\n          var numNewLines = newLines.getNumberOfCells();\n          var oldColor = [];\n          for (var lineId = numClipLines; lineId < numNewLines; lineId++) {\n            _scalars.getTuple(lineId, oldColor);\n            if (numberOfScalarComponents !== 3 || oldColor[0] !== activeColor[0] || oldColor[1] !== activeColor[1] || oldColor[2] !== activeColor[2]) {\n              _scalars.setTuple(lineId, color);\n            }\n          }\n        } // Generate new polys from the cut lines\n\n        var cellId = newPolys.getNumberOfCells();\n        var numClipAndContourLines = newLines.getNumberOfCells(); // Create a polydata for the lines\n\n        tmpContourData.setPoints(points);\n        tmpContourData.setLines(newLines);\n        tmpContourData.buildCells();\n        triangulateContours(tmpContourData, numClipLines, numClipAndContourLines - numClipLines, newPolys, pc); // Add scalars for the newly-created polys\n\n        _scalars = outPolyData.getScalars();\n        if (_scalars) {\n          var _color = colors[1 + (active ? 1 : 0)];\n          var numCells = newPolys.getNumberOfCells();\n          if (numCells > cellId) {\n            // The insert allocates space up to numCells - 1\n            _scalars.insertTuple(numCells - 1, _color);\n            for (; cellId < numCells; cellId++) {\n              _scalars.setTuple(cellId, _color);\n            }\n          }\n        } // Add scalars to any diagnostic lines that added by\n        // triangulateContours(). In usual operation, no lines are added.\n\n        _scalars = outLineData.getScalars();\n        if (_scalars) {\n          var _color2 = [0, 255, 255];\n          var _numCells = newLines.getNumberOfCells();\n          if (_numCells > numClipAndContourLines) {\n            // The insert allocates space up to numCells - 1\n            _scalars.insertTuple(_numCells - 1, _color2);\n            for (var lineCellId = numClipAndContourLines; lineCellId < _numCells; lineCellId++) {\n              _scalars.setTuple(lineCellId, _color2);\n            }\n          }\n        }\n      } // Swap the lines, points, etcetera: old output becomes new input\n\n      var _ref3 = [newLines, lines];\n      lines = _ref3[0];\n      newLines = _ref3[1];\n      newLines.initialize();\n      if (polys) {\n        var _ref4 = [newPolys, polys];\n        polys = _ref4[0];\n        newPolys = _ref4[1];\n        newPolys.initialize();\n      }\n      var _ref5 = [outLineData, inLineData];\n      inLineData = _ref5[0];\n      outLineData = _ref5[1];\n      outLineData.initialize();\n      var _ref6 = [outPolyData, inPolyData];\n      inPolyData = _ref6[0];\n      outPolyData = _ref6[1];\n      outPolyData.initialize();\n    } // Get the line scalars\n\n    var scalars = inLineData.getScalars();\n    if (model.generateOutline) {\n      output.setLines(lines);\n    } else if (scalars) {\n      scalars.initialize();\n    }\n    if (model.generateFaces) {\n      output.setPolys(polys);\n      if (polys && scalars) {\n        var pScalars = inPolyData.getScalars();\n        var m = scalars.getNumberOfTuples();\n        var n = pScalars.getNumberOfTuples();\n        if (n > 0) {\n          var _color3 = [0, 0, 0]; // This is just to expand the array\n\n          scalars.insertTuple(n + m - 1, _color3); // Fill in the poly scalars\n\n          for (var _i2 = 0; _i2 < n; _i2++) {\n            pScalars.getTuple(_i2, _color3);\n            scalars.setTuple(_i2 + m, _color3);\n          }\n        }\n      }\n    }\n    if (scalars && model.scalarMode === ScalarMode.COLORS) {\n      scalars.setName('Colors');\n      output.getCellData().setScalars(scalars);\n    } else if (model.scalarMode === ScalarMode.LABELS) {\n      // Don't use VTK_UNSIGNED_CHAR or they will look like color scalars\n      // const categories = vtkSignedCharArray.newInstance();\n      // categories.deepCopy(scalars);\n      // categories.setName(\"Labels\");\n      // output.getCellData().setScalars(categories);\n      // categories.delete();\n      // TODO: Check\n      var categories = scalars.newClone();\n      categories.setData(scalars.getData().slice());\n      categories.setName('Labels');\n      output.getCellData().setScalars(categories);\n    } else {\n      output.getCellData().setScalars(null);\n    } // Finally, store the points in the output\n\n    squeezeOutputPoints(output, points, pointData, inputPointsType); // TODO: Check\n    // output.squeeze();\n\n    outData[0] = output;\n  };\n  Object.keys(ScalarMode).forEach(function (key) {\n    var name = capitalize(key.toLowerCase());\n    publicAPI[\"setScalarModeTo\".concat(name)] = function () {\n      model.scalarMode = ScalarMode[key];\n    };\n  });\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nvar DEFAULT_VALUES = {\n  clippingPlanes: null,\n  tolerance: 1e-6,\n  passPointData: false,\n  triangulatePolys: false,\n  scalarMode: ScalarMode.NONE,\n  generateOutline: false,\n  generateFaces: true,\n  activePlaneId: -1,\n  baseColor: [255 / 255, 99 / 255, 71 / 255],\n  // Tomato\n  clipColor: [244 / 255, 164 / 255, 96 / 255],\n  // Sandy brown\n  activePlaneColor: [227 / 255, 207 / 255, 87 / 255],\n  // Banana\n  triangulationErrorDisplay: false // _idList: null,\n}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Make this a VTK object\n\n  macro.obj(publicAPI, model); // Also make it an algorithm with one input and one output\n\n  macro.algo(publicAPI, model, 1, 1);\n  macro.setGet(publicAPI, model, ['clippingPlanes', 'tolerance', 'passPointData', 'triangulatePolys', 'scalarMode', 'generateOutline', 'generateFaces', 'activePlaneId', 'triangulationErrorDisplay']);\n  macro.setGetArray(publicAPI, model, ['baseColor', 'clipColor', 'activePlaneColor'], 3); // Object specific methods\n\n  vtkClipClosedSurface(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = macro.newInstance(extend, 'vtkClipClosedSurface'); // ----------------------------------------------------------------------------\n\nvar vtkClipClosedSurface$1 = _objectSpread({\n  newInstance: newInstance,\n  extend: extend\n}, Constants);\nexport { vtkClipClosedSurface$1 as default, extend, newInstance };","map":{"version":3,"names":["_defineProperty","_toConsumableArray","macro","d","dot","e","distance2BetweenPoints","vtkCellArray","vtkDataArray","VtkDataTypes","vtkPoints","vtkDataSetAttributes","vtkPolyData","vtkContourTriangulator","vtkEdgeLocator","Constants","ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","getOwnPropertyDescriptors","defineProperties","defineProperty","vtkErrorMacro","capitalize","ScalarMode","vtkClipClosedSurface","publicAPI","model","classHierarchy","getMTime","clippingPlanes","reduce","a","b","mtime","createColorValues","color1","color2","color3","colors","dcolors","clamp","n","min","max","Math","j","round","interpolateEdge","points","pointData","locator","tol","i0","i1","v0","v1","_ref","_ref2","edge","insertUniqueEdge","value","p0","getPoint","p1","f","s","t","p","tol2","insertNextTuple","interpolateData","clipLines","pointScalars","edgeLocator","inputLines","outputLines","inLineData","outLineData","numPts","c0","c1","linePts","values","getData","cellId","tolerance","newCellId","insertNextCell","passData","breakPolylines","inputScalars","firstLineScalar","scalars","color","cellColor","getTuple","copyPolygons","inputPolys","outputPolys","firstPolyScalar","polyScalars","deepCopy","scalarValue","getNumberOfCells","insertTuple","setTuple","_i","breakTriangleStrips","inputStrips","polys","firstStripScalar","p2","p3","m","getNumberOfTuples","k","triangulateContours","polyData","firstLine","numLines","normal","triangulationError","triangulationErrorDisplay","triangulatePolygon","polygon","triangles","clipAndContourPolys","triangulate","inCellData","outPolyData","idList","_idList","polyMax","Number","MAX_VALUE","triangulationFailure","j0","j1","idListIdx","numPoints","triangulatePolys","success","ncells","_newCellId","_newCellId2","squeezeOutputPoints","output","outputPointDataType","getNumberOfPoints","numNewPoints","outPointData","getPointData","pointMap","cellArrays","getVerts","getLines","getPolys","getStrips","cellArray","pointId","undefined","newPoints","newInstance","size","dataType","newPointId","setPoints","requestData","inData","outData","_input$getVerts","_input$getStrips","input","inputPoints","getPoints","inputPointsType","FLOAT","getDataType","DOUBLE","inPointData","passPointData","point","ptId","tmpContourData","lineScalars","numberOfScalarComponents","scalarMode","COLORS","baseColor","clipColor","activePlaneColor","LABELS","numVerts","numPolys","numStrips","NONE","UNSIGNED_CHAR","empty","numberOfComponents","tryInputScalars","getCellData","getScalars","getNumberOfComponents","lines","Uint8Array","getCellSizes","newLines","newPolys","copyScalarsOn","setScalars","inPolyData","planes","planeId","plane","active","activePlaneId","pc","getNormal","getOrigin","pointScalarsData","pointsData","initialize","numClipLines","_scalars","activeColor","numNewLines","oldColor","lineId","numClipAndContourLines","setLines","buildCells","_color","numCells","_color2","_numCells","lineCellId","_ref3","_ref4","_ref5","_ref6","generateOutline","generateFaces","setPolys","pScalars","_color3","_i2","setName","categories","newClone","setData","slice","name","toLowerCase","concat","DEFAULT_VALUES","extend","initialValues","assign","obj","algo","setGet","setGetArray","vtkClipClosedSurface$1","default"],"sources":["/home/rakshith/Documents/RemoteRendering/vtk-js-react-app/node_modules/@kitware/vtk.js/Filters/General/ClipClosedSurface.js"],"sourcesContent":["import _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport _toConsumableArray from '@babel/runtime/helpers/toConsumableArray';\nimport macro from '../../macros.js';\nimport { d as dot, e as distance2BetweenPoints } from '../../Common/Core/Math/index.js';\nimport vtkCellArray from '../../Common/Core/CellArray.js';\nimport vtkDataArray from '../../Common/Core/DataArray.js';\nimport { VtkDataTypes } from '../../Common/Core/DataArray/Constants.js';\nimport vtkPoints from '../../Common/Core/Points.js';\nimport vtkDataSetAttributes from '../../Common/DataModel/DataSetAttributes.js';\nimport vtkPolyData from '../../Common/DataModel/PolyData.js';\nimport vtkContourTriangulator from './ContourTriangulator.js';\nimport vtkEdgeLocator from '../../Common/DataModel/EdgeLocator.js';\nimport Constants from './ClipClosedSurface/Constants.js';\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nvar vtkErrorMacro = macro.vtkErrorMacro,\n    capitalize = macro.capitalize;\nvar ScalarMode = Constants.ScalarMode;\n\nfunction vtkClipClosedSurface(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkClipClosedSurface');\n\n  publicAPI.getMTime = function () {\n    return model.clippingPlanes.reduce(function (a, b) {\n      return b.getMTime() > a ? b.getMTime() : a;\n    }, model.mtime);\n  };\n  /**\n   * Take three colors as doubles, and convert to unsigned char.\n   *\n   * @param {Number} color1\n   * @param {Number} color2\n   * @param {Number} color3\n   * @param {Number[3][3]} colors\n   */\n\n\n  function createColorValues(color1, color2, color3, colors) {\n    var dcolors = [color1, color2, color3];\n\n    var clamp = function clamp(n, min, max) {\n      return Math.min(Math.max(n, min), max);\n    };\n\n    for (var i = 0; i < 3; i++) {\n      for (var j = 0; j < 3; j++) {\n        colors[i][j] = Math.round(clamp(dcolors[i][j], 0, 1) * 255);\n      }\n    }\n  }\n  /**\n   * Point interpolation for clipping and contouring, given the scalar\n   * values (v0, v1) for the two endpoints (p0, p1).  The use of this\n   * function guarantees perfect consistency in the results.\n   *\n   * @param {vtkPoints} points\n   * @param {vtkDataArray} pointData\n   * @param {CCSEdgeLocator} locator\n   * @param {Number} tol\n   * @param {Number} i0\n   * @param {Number} i1\n   * @param {Number} v0\n   * @param {Number} v1\n   * @param {Number} i\n   * @returns {Number}\n   */\n\n\n  function interpolateEdge(points, pointData, locator, tol, i0, i1, v0, v1) {\n    // This swap guarantees that exactly the same point is computed\n    // for both line directions, as long as the endpoints are the same.\n    if (v1 > 0) {\n      // eslint-disable-next-line no-param-reassign\n      var _ref = [i1, i0];\n      i0 = _ref[0];\n      i1 = _ref[1];\n      var _ref2 = [v1, v0];\n      v0 = _ref2[0];\n      v1 = _ref2[1];\n    } // After the above swap, i0 will be kept, and i1 will be clipped\n    // Check to see if this point has already been computed\n\n\n    var edge = locator.insertUniqueEdge(i0, i1);\n\n    if (edge.value != null) {\n      return edge.value;\n    } // Get the edge and interpolate the new point\n\n\n    var p0 = points.getPoint(i0);\n    var p1 = points.getPoint(i1);\n    var f = v0 / (v0 - v1);\n    var s = 1.0 - f;\n    var t = 1.0 - s;\n    var p = [s * p0[0] + t * p1[0], s * p0[1] + t * p1[1], s * p0[2] + t * p1[2]];\n    var tol2 = tol * tol; // Make sure that new point is far enough from kept point\n\n    if (distance2BetweenPoints(p, p0) < tol2) {\n      edge.value = i0;\n      return i0;\n    }\n\n    if (distance2BetweenPoints(p, p1) < tol2) {\n      edge.value = i1;\n      return i1;\n    }\n\n    edge.value = points.insertNextTuple(p);\n    pointData.interpolateData(pointData, i0, i1, edge.value, t);\n    return edge.value;\n  }\n  /**\n   * Method for clipping lines and copying the scalar data.\n   *\n   * @param {vtkPoints} points\n   * @param {vtkDataArray} pointScalars\n   * @param {vtkDataSetAttributesk} pointData\n   * @param {vtkEdgeLocator} edgeLocator\n   * @param {vtkCellArray} inputLines\n   * @param {vtkCellArray} outputLines\n   * @param {vtkDataSetAttributes} inLineData\n   * @param {vtkDataSetAttributes} outLineData\n   */\n\n\n  function clipLines(points, pointScalars, pointData, edgeLocator, inputLines, outputLines, inLineData, outLineData) {\n    var numPts;\n    var i0;\n    var i1;\n    var v0;\n    var v1;\n    var c0;\n    var c1;\n    var linePts = [];\n    var values = inputLines.getData();\n    var cellId = 0;\n\n    for (var i = 0; i < values.length; i += numPts + 1, cellId++) {\n      numPts = values[i];\n      i1 = values[i + 1];\n      v1 = pointScalars.getData()[i1];\n      c1 = v1 > 0;\n\n      for (var j = 2; j <= numPts; j++) {\n        i0 = i1;\n        v0 = v1;\n        c0 = c1;\n        i1 = values[i + j];\n        v1 = pointScalars.getData()[i1];\n        c1 = v1 > 0; // If at least one point wasn't clipped\n\n        if (c0 || c1) {\n          // If only one end was clipped, interpolate new point\n          if (c0 ? !c1 : c1) {\n            linePts[c0 ? 1 : 0] = interpolateEdge(points, pointData, edgeLocator, model.tolerance, i0, i1, v0, v1);\n          } // If endpoints are different, insert the line segment\n\n\n          if (i0 !== i1) {\n            linePts[0] = i0;\n            linePts[1] = i1;\n            var newCellId = outputLines.insertNextCell(linePts); // outLineData.copyData(inLineData, cellId, newCellId);\n\n            outLineData.passData(inLineData, cellId, newCellId);\n          }\n        }\n      }\n    }\n  }\n  /**\n   * Break polylines into individual lines, copying scalar values from\n   * inputScalars starting at firstLineScalar.  If inputScalars is zero,\n   * then scalars will be set to color.  If scalars is zero, then no\n   * scalars will be generated.\n   *\n   * @param {vtkCellArray} inputLines\n   * @param {vtkCellArray} outputLines\n   * @param {vtkDataArray} inputScalars\n   * @param {Number} firstLineScalar\n   * @param {vtkDataArray} scalars\n   * @param {Vector3} color\n   */\n\n\n  function breakPolylines(inputLines, outputLines, inputScalars, firstLineScalar, scalars, color) {\n    var cellColor = _toConsumableArray(color);\n\n    var cellId = 0;\n    var values = inputLines.getData();\n    var numPts;\n\n    for (var i = 0; i < values.length; i += numPts + 1) {\n      numPts = values[i];\n\n      if (inputScalars) {\n        inputScalars.getTuple(firstLineScalar + cellId++, cellColor);\n      }\n\n      for (var j = 1; j < numPts; j++) {\n        outputLines.insertNextCell([values[i + j], values[i + j + 1]]);\n\n        if (scalars) {\n          scalars.insertNextTuple(cellColor);\n        }\n      }\n    }\n  }\n  /**\n   * Copy polygons and their associated scalars to a new array.\n   * If inputScalars is set to zero, set polyScalars to color instead.\n   * If polyScalars is set to zero, don't generate scalars.\n   *\n   * @param {vtkCellArray} inputPolys\n   * @param {vtkCellArray} outputPolys\n   * @param {vtkDataArray} inputScalars\n   * @param {Number} firstPolyScalar\n   * @param {vtkDataArray} polyScalars\n   * @param {Vector3} color\n   */\n\n\n  function copyPolygons(inputPolys, outputPolys, inputScalars, firstPolyScalar, polyScalars, color) {\n    if (!inputPolys) {\n      return;\n    }\n\n    outputPolys.deepCopy(inputPolys);\n\n    if (polyScalars) {\n      var scalarValue = _toConsumableArray(color);\n\n      var n = outputPolys.getNumberOfCells();\n      polyScalars.insertTuple(n - 1, scalarValue);\n\n      if (inputScalars) {\n        for (var i = 0; i < n; i++) {\n          inputScalars.getTuple(i + firstPolyScalar, scalarValue);\n          polyScalars.setTuple(i, scalarValue);\n        }\n      } else {\n        for (var _i = 0; _i < n; _i++) {\n          polyScalars.setTuple(_i, scalarValue);\n        }\n      }\n    }\n  }\n\n  function breakTriangleStrips(inputStrips, polys, inputScalars, firstStripScalar, polyScalars, color) {\n    if (inputStrips.getNumberOfCells() === 0) {\n      return;\n    }\n\n    var values = inputStrips.getData();\n    var cellId = firstStripScalar;\n    var numPts;\n\n    for (var i = 0; i < values.length; i += numPts + 1, cellId++) {\n      numPts = values[i]; // vtkTriangleStrip.decomposeStrip(numPts, values, polys);\n\n      var p1 = values[i + 1];\n      var p2 = values[i + 2];\n\n      for (var j = 0; j < numPts - 2; j++) {\n        var p3 = values[i + j + 3];\n\n        if (j % 2) {\n          polys.insertNextCell([p2, p1, p3]);\n        } else {\n          polys.insertNextCell([p1, p2, p3]);\n        }\n\n        p1 = p2;\n        p2 = p3;\n      }\n\n      if (polyScalars) {\n        var scalarValue = _toConsumableArray(color);\n\n        if (inputScalars) {\n          // If there are input scalars, use them instead of \"color\"\n          inputScalars.getTuple(cellId, scalarValue);\n        }\n\n        var n = numPts - 3;\n        var m = polyScalars.getNumberOfTuples();\n\n        if (n >= 0) {\n          // First insert is just to allocate space\n          polyScalars.insertTuple(m + n, scalarValue);\n\n          for (var k = 0; k < n; k++) {\n            polyScalars.setTuple(m + k, scalarValue);\n          }\n        }\n      }\n    }\n  }\n  /**\n   * Given some closed contour lines, create a triangle mesh that\n   * fills those lines.  The input lines must be single-segment lines,\n   * not polylines.  The input lines do not have to be in order.\n   * Only lines from firstLine to will be used.  Specify the normal\n   * of the clip plane, which will be opposite the normals\n   * of the polys that will be produced.  If outCD has scalars, then color\n   * scalars will be added for each poly that is created.\n   *\n   * @param {vtkPolyData} polyData\n   * @param {Number} firstLine\n   * @param {Number} numLines\n   * @param {vtkCellArray} outputPolys\n   * @param {Vector3} normal\n   */\n\n\n  function triangulateContours(polyData, firstLine, numLines, outputPolys, normal) {\n    // If no cut lines were generated, there's nothing to do\n    if (numLines <= 0) {\n      return;\n    }\n\n    var triangulationError = !vtkContourTriangulator.triangulateContours(polyData, firstLine, numLines, outputPolys, [-normal[0], -normal[1], -normal[2]]);\n\n    if (triangulationError && model.triangulationErrorDisplay) {\n      vtkErrorMacro('Triangulation failed, polyData may not be watertight.');\n    }\n  }\n  /**\n   * Break polylines into individual lines, copying scalar values from\n   * inputScalars starting at firstLineScalar. If inputScalars is zero,\n   * then scalars will be set to color. If scalars is zero, then no\n   * scalars will be generated.\n   *\n   * @param {Number[]} polygon\n   * @param {vtkPoints} points\n   * @param {vtkCellArray} triangles\n   * @returns {Boolean}\n   */\n\n\n  function triangulatePolygon(polygon, points, triangles) {\n    return vtkContourTriangulator.triangulatePolygon(polygon, points, triangles);\n  }\n  /**\n   * Clip and contour polys in one step, in order to guarantee\n   * that the contour lines exactly match the new free edges of\n   * the clipped polygons.  This exact correspondence is necessary\n   * in order to guarantee that the surface remains closed.\n   *\n   * @param {vtkPoints} points\n   * @param {vtkDataArray} pointScalars\n   * @param {vtkDataSetAttributes} pointData\n   * @param {vtkEdgeLocator} edgeLocator\n   * @param {Number} triangulate\n   * @param {vtkCellArray} inputPolys\n   * @param {vtkCellArray} outputPolys\n   * @param {vtkCellArray} outputLines\n   * @param {vtkDataSetAttributes} inCellData\n   * @param {vtkDataSetAttributes} outPolyData\n   * @param {vtkDataSetAttributes} outLineData\n   */\n\n\n  function clipAndContourPolys(points, pointScalars, pointData, edgeLocator, triangulate, inputPolys, outputPolys, outputLines, inCellData, outPolyData, outLineData) {\n    var idList = model._idList; // How many sides for output polygons?\n\n    var polyMax = Number.MAX_VALUE;\n\n    if (triangulate) {\n      if (triangulate < 4) {\n        // triangles only\n        polyMax = 3;\n      } else if (triangulate === 4) {\n        // allow triangles and quads\n        polyMax = 4;\n      }\n    } // eslint-disable-next-line prefer-const\n\n\n    var triangulationFailure = false; // Go through all cells and clip them\n\n    var values = inputPolys.getData();\n    var linePts = [];\n    var cellId = 0;\n    var numPts;\n\n    for (var i = 0; i < values.length; i += numPts + 1, cellId++) {\n      numPts = values[i];\n      var i1 = values[i + numPts];\n      var v1 = pointScalars.getData()[i1];\n      var c1 = v1 > 0; // The ids for the current edge: init j0 to -1 if i1 will be clipped\n\n      var j0 = c1 ? i1 : -1;\n      var j1 = 0; // To store the ids of the contour line\n\n      linePts[0] = 0;\n      linePts[1] = 0;\n      var idListIdx = 0;\n\n      for (var j = 1; j <= numPts; j++) {\n        // Save previous point info\n        var i0 = i1;\n        var v0 = v1;\n        var c0 = c1; // Generate new point info\n\n        i1 = values[i + j];\n        v1 = pointScalars.getData()[i1];\n        c1 = v1 > 0; // If at least one edge end point wasn't clipped\n\n        if (c0 || c1) {\n          // If only one end was clipped, interpolate new point\n          if (c0 ? !c1 : c1) {\n            j1 = interpolateEdge(points, pointData, edgeLocator, model.tolerance, i0, i1, v0, v1);\n\n            if (j1 !== j0) {\n              idList[idListIdx++] = j1;\n              j0 = j1;\n            } // Save as one end of the contour line\n\n\n            linePts[c0 ? 1 : 0] = j1;\n          }\n\n          if (c1) {\n            j1 = i1;\n\n            if (j1 !== j0) {\n              idList[idListIdx++] = j1;\n              j0 = j1;\n            }\n          }\n        }\n      } // Insert the clipped poly\n\n\n      var numPoints = idListIdx;\n      idList.length = numPoints;\n\n      if (model.triangulatePolys && numPoints > polyMax) {\n        // TODO: Support triangulatePolygon\n        var newCellId = outputPolys.getNumberOfCells(); // Triangulate the poly and insert triangles into output.\n\n        var success = triangulatePolygon(idList, points, outputPolys);\n\n        if (!success) {\n          triangulationFailure = true;\n        } // Copy the attribute data to the triangle cells\n\n\n        var ncells = outputPolys.getNumberOfCells();\n\n        for (; newCellId < ncells; newCellId++) {\n          outPolyData.passData(inCellData, cellId, newCellId);\n        }\n      } else if (numPoints > 2) {\n        // Insert the polygon without triangulating it\n        var _newCellId = outputPolys.insertNextCell(idList);\n\n        outPolyData.passData(inCellData, cellId, _newCellId);\n      } // Insert the contour line if one was created\n\n\n      if (linePts[0] !== linePts[1]) {\n        var _newCellId2 = outputLines.insertNextCell(linePts);\n\n        outLineData.passData(inCellData, cellId, _newCellId2);\n      }\n    }\n\n    if (triangulationFailure && model.triangulationErrorDisplay) {\n      vtkErrorMacro('Triangulation failed, output may not be watertight');\n    }\n  }\n  /**\n   * Squeeze the points and store them in the output.  Only the points that\n   * are used by the cells will be saved, and the pointIds of the cells will\n   * be modified.\n   *\n   * @param {vtkPolyData} output\n   * @param {vtkPoints} points\n   * @param {vtkDataSetAttributes} pointData\n   * @param {String} outputPointDataType\n   */\n\n\n  function squeezeOutputPoints(output, points, pointData, outputPointDataType) {\n    // Create a list of points used by cells\n    var n = points.getNumberOfPoints();\n    var numNewPoints = 0;\n    var outPointData = output.getPointData();\n    var pointMap = [];\n    pointMap.length = n;\n    var cellArrays = [output.getVerts(), output.getLines(), output.getPolys(), output.getStrips()]; // Find all the newPoints that are used by cells\n\n    cellArrays.forEach(function (cellArray) {\n      if (!cellArray) {\n        return;\n      }\n\n      var values = cellArray.getData();\n      var numPts;\n      var pointId;\n\n      for (var i = 0; i < values.length; i += numPts + 1) {\n        numPts = values[i];\n\n        for (var j = 1; j <= numPts; j++) {\n          pointId = values[i + j];\n\n          if (pointMap[pointId] === undefined) {\n            pointMap[pointId] = numNewPoints++;\n          }\n        }\n      }\n    }); // Create exactly the number of points that are required\n\n    var newPoints = vtkPoints.newInstance({\n      size: numNewPoints * 3,\n      dataType: outputPointDataType\n    }); // outPointData.copyAllocate(pointData, numNewPoints, 0);\n\n    var p = [];\n    var newPointId;\n\n    for (var pointId = 0; pointId < n; pointId++) {\n      newPointId = pointMap[pointId];\n\n      if (newPointId !== undefined) {\n        points.getPoint(pointId, p);\n        newPoints.setTuple(newPointId, p);\n        outPointData.passData(pointData, pointId, newPointId); // outPointData.copyData(pointData, pointId, newPointId);\n      }\n    } // Change the cell pointIds to reflect the new point array\n\n\n    cellArrays.forEach(function (cellArray) {\n      if (!cellArray) {\n        return;\n      }\n\n      var values = cellArray.getData();\n      var numPts;\n      var pointId;\n\n      for (var i = 0; i < values.length; i += numPts + 1) {\n        numPts = values[i];\n\n        for (var j = 1; j <= numPts; j++) {\n          pointId = values[i + j];\n          values[i + j] = pointMap[pointId];\n        }\n      }\n    });\n    output.setPoints(newPoints);\n  }\n\n  publicAPI.requestData = function (inData, outData) {\n    var _input$getVerts, _input$getStrips;\n\n    // implement requestData\n    var input = inData[0];\n    var output = vtkPolyData.newInstance();\n    outData[0] = output;\n\n    if (!input) {\n      vtkErrorMacro('Invalid or missing input');\n      return;\n    }\n\n    if (model._idList == null) {\n      model._idList = [];\n    } else {\n      model._idList.length = 0;\n    } // Get the input points\n\n\n    var inputPoints = input.getPoints();\n    var numPts = 0;\n    var inputPointsType = VtkDataTypes.FLOAT;\n\n    if (inputPoints) {\n      numPts = inputPoints.getNumberOfPoints();\n      inputPointsType = inputPoints.getDataType();\n    } // Force points to double precision, copy the point attributes\n\n\n    var points = vtkPoints.newInstance({\n      size: numPts * 3,\n      dataType: VtkDataTypes.DOUBLE\n    });\n    var pointData = vtkDataSetAttributes.newInstance();\n    var inPointData = null;\n\n    if (model.passPointData) {\n      inPointData = input.getPointData(); // pointData.interpolateAllocate(inPointData, numPts, 0);\n    }\n\n    var point = [];\n\n    for (var ptId = 0; ptId < numPts; ptId++) {\n      inputPoints.getPoint(ptId, point);\n      points.setTuple(ptId, point);\n\n      if (inPointData) {\n        // pointData.copyData(inPointData, ptId, ptId);\n        pointData.passData(inPointData, ptId, ptId);\n      }\n    } // An edge locator to avoid point duplication while clipping\n\n\n    var edgeLocator = vtkEdgeLocator.newInstance(); // A temporary polydata for the contour lines that are triangulated\n\n    var tmpContourData = vtkPolyData.newInstance(); // The cell scalars\n\n    var lineScalars;\n    var polyScalars;\n    var inputScalars; // For input scalars: the offsets to the various cell types\n\n    var firstLineScalar = 0;\n    var firstPolyScalar = 0;\n    var firstStripScalar = 0; // Make the colors to be used on the data\n\n    var numberOfScalarComponents = 1;\n    var colors = [[0, 0, 0], [0, 0, 0], [0, 0, 0]];\n\n    if (model.scalarMode === ScalarMode.COLORS) {\n      numberOfScalarComponents = 3;\n      createColorValues(model.baseColor, model.clipColor, model.activePlaneColor, colors);\n    } else if (model.scalarMode === ScalarMode.LABELS) {\n      colors[0][0] = 0;\n      colors[1][0] = 1;\n      colors[2][0] = 2;\n    } // This is set if we have to work with scalars. The input scalars\n    // will be copied if they are unsigned char with 3 components, otherwise\n    // new scalars will be generated.\n\n\n    var numVerts = ((_input$getVerts = input.getVerts()) === null || _input$getVerts === void 0 ? void 0 : _input$getVerts.getNumberOfCells()) || 0;\n    var inputLines = input.getLines();\n    var numLines = (inputLines === null || inputLines === void 0 ? void 0 : inputLines.getNumberOfCells()) || 0;\n    var inputPolys = input.getPolys();\n    var numPolys = (inputPolys === null || inputPolys === void 0 ? void 0 : inputPolys.getNumberOfCells()) || 0;\n    var numStrips = ((_input$getStrips = input.getStrips()) === null || _input$getStrips === void 0 ? void 0 : _input$getStrips.getNumberOfCells()) || 0;\n\n    if (model.scalarMode !== ScalarMode.NONE) {\n      lineScalars = vtkDataArray.newInstance({\n        dataType: VtkDataTypes.UNSIGNED_CHAR,\n        empty: true,\n        // size: 0,\n        // values: new Uint8Array(numLines * 3),\n        numberOfComponents: numberOfScalarComponents\n      });\n      var tryInputScalars = input.getCellData().getScalars(); // Get input scalars if they are RGB color scalars\n\n      if (tryInputScalars && tryInputScalars.getDataType() === VtkDataTypes.UNSIGNED_CHAR && numberOfScalarComponents === 3 && tryInputScalars.getNumberOfComponents() === 3) {\n        inputScalars = input.getCellData().getScalars();\n        firstLineScalar = numVerts;\n        firstPolyScalar = numVerts + numLines;\n        firstStripScalar = numVerts + numLines + numPolys;\n      }\n    } // Break the input lines into segments, generate scalars for lines\n\n\n    var lines;\n\n    if (numLines > 0) {\n      lines = vtkCellArray.newInstance({\n        dataType: inputLines.getDataType(),\n        values: new Uint8Array(numLines * 3),\n        // we will have at least that amount of lines\n        size: 0\n      });\n      breakPolylines(inputLines, lines, inputScalars, firstLineScalar, lineScalars, colors[0]);\n    } else {\n      lines = vtkCellArray.newInstance({\n        empty: true\n      });\n    }\n\n    var polys = null;\n    var polyMax = 3;\n\n    if (numPolys > 0 || numStrips > 0) {\n      // If there are line scalars, then poly scalars are needed too\n      if (lineScalars) {\n        polyScalars = vtkDataArray.newInstance({\n          dataType: VtkDataTypes.UNSIGNED_CHAR,\n          empty: true,\n          // size: 0,\n          // values: new Uint8Array(inputPolys.getNumberOfCells(false) * 3),\n          numberOfComponents: numberOfScalarComponents\n        });\n      }\n\n      polys = vtkCellArray.newInstance();\n      copyPolygons(inputPolys, polys, inputScalars, firstPolyScalar, polyScalars, colors[0]); // TODO: Support triangle strips\n\n      breakTriangleStrips(input.getStrips(), polys, inputScalars, firstStripScalar, polyScalars, colors[0]); // Check if the input has polys and quads or just triangles\n\n      polyMax = inputPolys.getCellSizes().reduce(function (a, b) {\n        return a > b ? a : b;\n      }, 0);\n    } // Arrays for storing the clipped lines and polys\n\n\n    var newLines = vtkCellArray.newInstance({\n      dataType: lines.getDataType(),\n      empty: true\n    });\n    var newPolys = null;\n\n    if (polys) {\n      newPolys = vtkCellArray.newInstance({\n        dataType: polys.getDataType(),\n        empty: true\n      });\n    } // The line scalars, for coloring the outline\n\n\n    var inLineData = vtkDataSetAttributes.newInstance();\n    inLineData.copyScalarsOn();\n    inLineData.setScalars(lineScalars); // The poly scalars, for coloring the faces\n\n    var inPolyData = vtkDataSetAttributes.newInstance();\n    inPolyData.copyScalarsOn();\n    inPolyData.setScalars(polyScalars); // Also create output attribute data\n\n    var outLineData = vtkDataSetAttributes.newInstance();\n    outLineData.copyScalarsOn();\n    var outPolyData = vtkDataSetAttributes.newInstance();\n    outPolyData.copyScalarsOn();\n    var planes = model.clippingPlanes; // Go through the clipping planes and clip the input with each plane\n\n    for (var planeId = 0; planeId < planes.length; planeId++) {\n      var plane = planes[planeId];\n      var triangulate = 5;\n\n      if (planeId === planes.length - 1) {\n        triangulate = polyMax;\n      }\n\n      var active = planeId === model.activePlaneId; // Convert the plane into an easy-to-evaluate function\n\n      var pc = plane.getNormal(); // OK to modify pc because vtkPlane.getNormal() returns a copy\n\n      pc[3] = -dot(pc, plane.getOrigin()); // Create the clip scalars by evaluating the plane at each point\n\n      var numPoints = points.getNumberOfPoints(); // The point scalars, needed for clipping (not for the output!)\n\n      var pointScalars = vtkDataArray.newInstance({\n        dataType: VtkDataTypes.DOUBLE,\n        size: numPoints\n      });\n      var pointScalarsData = pointScalars.getData();\n      var pointsData = points.getData();\n      var i = 0;\n\n      for (var pointId = 0; pointId < numPoints; pointId) {\n        pointScalarsData[pointId++] = pointsData[i++] * pc[0] + pointsData[i++] * pc[1] + pointsData[i++] * pc[2] + pc[3];\n      } // Prepare the output scalars\n      // outLineData.copyAllocate(inLineData, 0, 0);\n      // outPolyData.copyAllocate(inPolyData, 0, 0);\n      // Reset the locator\n\n\n      edgeLocator.initialize(); // Clip the lines\n\n      clipLines(points, pointScalars, pointData, edgeLocator, lines, newLines, inLineData, outLineData); // Clip the polys\n\n      if (polys) {\n        // Get the number of lines remaining after the clipping\n        var numClipLines = newLines.getNumberOfCells(); // Cut the polys to generate more lines\n\n        clipAndContourPolys(points, pointScalars, pointData, edgeLocator, triangulate, polys, newPolys, newLines, inPolyData, outPolyData, outLineData); // Add scalars for the newly-created contour lines\n\n        var _scalars = outLineData.getScalars();\n\n        if (_scalars) {\n          // Set the color to the active color if plane is active\n          var color = colors[1 + (active ? 1 : 0)];\n          var activeColor = colors[2];\n          var numNewLines = newLines.getNumberOfCells();\n          var oldColor = [];\n\n          for (var lineId = numClipLines; lineId < numNewLines; lineId++) {\n            _scalars.getTuple(lineId, oldColor);\n\n            if (numberOfScalarComponents !== 3 || oldColor[0] !== activeColor[0] || oldColor[1] !== activeColor[1] || oldColor[2] !== activeColor[2]) {\n              _scalars.setTuple(lineId, color);\n            }\n          }\n        } // Generate new polys from the cut lines\n\n\n        var cellId = newPolys.getNumberOfCells();\n        var numClipAndContourLines = newLines.getNumberOfCells(); // Create a polydata for the lines\n\n        tmpContourData.setPoints(points);\n        tmpContourData.setLines(newLines);\n        tmpContourData.buildCells();\n        triangulateContours(tmpContourData, numClipLines, numClipAndContourLines - numClipLines, newPolys, pc); // Add scalars for the newly-created polys\n\n        _scalars = outPolyData.getScalars();\n\n        if (_scalars) {\n          var _color = colors[1 + (active ? 1 : 0)];\n          var numCells = newPolys.getNumberOfCells();\n\n          if (numCells > cellId) {\n            // The insert allocates space up to numCells - 1\n            _scalars.insertTuple(numCells - 1, _color);\n\n            for (; cellId < numCells; cellId++) {\n              _scalars.setTuple(cellId, _color);\n            }\n          }\n        } // Add scalars to any diagnostic lines that added by\n        // triangulateContours(). In usual operation, no lines are added.\n\n\n        _scalars = outLineData.getScalars();\n\n        if (_scalars) {\n          var _color2 = [0, 255, 255];\n\n          var _numCells = newLines.getNumberOfCells();\n\n          if (_numCells > numClipAndContourLines) {\n            // The insert allocates space up to numCells - 1\n            _scalars.insertTuple(_numCells - 1, _color2);\n\n            for (var lineCellId = numClipAndContourLines; lineCellId < _numCells; lineCellId++) {\n              _scalars.setTuple(lineCellId, _color2);\n            }\n          }\n        }\n      } // Swap the lines, points, etcetera: old output becomes new input\n\n\n      var _ref3 = [newLines, lines];\n      lines = _ref3[0];\n      newLines = _ref3[1];\n      newLines.initialize();\n\n      if (polys) {\n        var _ref4 = [newPolys, polys];\n        polys = _ref4[0];\n        newPolys = _ref4[1];\n        newPolys.initialize();\n      }\n\n      var _ref5 = [outLineData, inLineData];\n      inLineData = _ref5[0];\n      outLineData = _ref5[1];\n      outLineData.initialize();\n      var _ref6 = [outPolyData, inPolyData];\n      inPolyData = _ref6[0];\n      outPolyData = _ref6[1];\n      outPolyData.initialize();\n    } // Get the line scalars\n\n\n    var scalars = inLineData.getScalars();\n\n    if (model.generateOutline) {\n      output.setLines(lines);\n    } else if (scalars) {\n      scalars.initialize();\n    }\n\n    if (model.generateFaces) {\n      output.setPolys(polys);\n\n      if (polys && scalars) {\n        var pScalars = inPolyData.getScalars();\n        var m = scalars.getNumberOfTuples();\n        var n = pScalars.getNumberOfTuples();\n\n        if (n > 0) {\n          var _color3 = [0, 0, 0]; // This is just to expand the array\n\n          scalars.insertTuple(n + m - 1, _color3); // Fill in the poly scalars\n\n          for (var _i2 = 0; _i2 < n; _i2++) {\n            pScalars.getTuple(_i2, _color3);\n            scalars.setTuple(_i2 + m, _color3);\n          }\n        }\n      }\n    }\n\n    if (scalars && model.scalarMode === ScalarMode.COLORS) {\n      scalars.setName('Colors');\n      output.getCellData().setScalars(scalars);\n    } else if (model.scalarMode === ScalarMode.LABELS) {\n      // Don't use VTK_UNSIGNED_CHAR or they will look like color scalars\n      // const categories = vtkSignedCharArray.newInstance();\n      // categories.deepCopy(scalars);\n      // categories.setName(\"Labels\");\n      // output.getCellData().setScalars(categories);\n      // categories.delete();\n      // TODO: Check\n      var categories = scalars.newClone();\n      categories.setData(scalars.getData().slice());\n      categories.setName('Labels');\n      output.getCellData().setScalars(categories);\n    } else {\n      output.getCellData().setScalars(null);\n    } // Finally, store the points in the output\n\n\n    squeezeOutputPoints(output, points, pointData, inputPointsType); // TODO: Check\n    // output.squeeze();\n\n    outData[0] = output;\n  };\n\n  Object.keys(ScalarMode).forEach(function (key) {\n    var name = capitalize(key.toLowerCase());\n\n    publicAPI[\"setScalarModeTo\".concat(name)] = function () {\n      model.scalarMode = ScalarMode[key];\n    };\n  });\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\n\nvar DEFAULT_VALUES = {\n  clippingPlanes: null,\n  tolerance: 1e-6,\n  passPointData: false,\n  triangulatePolys: false,\n  scalarMode: ScalarMode.NONE,\n  generateOutline: false,\n  generateFaces: true,\n  activePlaneId: -1,\n  baseColor: [255 / 255, 99 / 255, 71 / 255],\n  // Tomato\n  clipColor: [244 / 255, 164 / 255, 96 / 255],\n  // Sandy brown\n  activePlaneColor: [227 / 255, 207 / 255, 87 / 255],\n  // Banana\n  triangulationErrorDisplay: false // _idList: null,\n\n}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Make this a VTK object\n\n  macro.obj(publicAPI, model); // Also make it an algorithm with one input and one output\n\n  macro.algo(publicAPI, model, 1, 1);\n  macro.setGet(publicAPI, model, ['clippingPlanes', 'tolerance', 'passPointData', 'triangulatePolys', 'scalarMode', 'generateOutline', 'generateFaces', 'activePlaneId', 'triangulationErrorDisplay']);\n  macro.setGetArray(publicAPI, model, ['baseColor', 'clipColor', 'activePlaneColor'], 3); // Object specific methods\n\n  vtkClipClosedSurface(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = macro.newInstance(extend, 'vtkClipClosedSurface'); // ----------------------------------------------------------------------------\n\nvar vtkClipClosedSurface$1 = _objectSpread({\n  newInstance: newInstance,\n  extend: extend\n}, Constants);\n\nexport { vtkClipClosedSurface$1 as default, extend, newInstance };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}