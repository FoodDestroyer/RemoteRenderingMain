{"ast":null,"code":"import DataAccessHelper from '../Core/DataAccessHelper.js';\nimport macro from '../../macros.js';\nimport vtkCellArray from '../../Common/Core/CellArray.js';\nimport vtkDataArray from '../../Common/Core/DataArray.js';\nimport vtkPolyData from '../../Common/DataModel/PolyData.js';\nimport '../Core/DataAccessHelper/LiteHttpDataAccessHelper.js';\n\n// import 'vtk.js/Sources/IO/Core/DataAccessHelper/HttpDataAccessHelper'; // HTTP + zip\n// import 'vtk.js/Sources/IO/Core/DataAccessHelper/HtmlDataAccessHelper'; // html + base64 + zip\n// import 'vtk.js/Sources/IO/Core/DataAccessHelper/JSZipDataAccessHelper'; // zip\n\nvar vtkErrorMacro = macro.vtkErrorMacro;\nvar decoderModule = {}; // ----------------------------------------------------------------------------\n// static methods\n// ----------------------------------------------------------------------------\n\n/**\n * Load the WASM decoder from url and set the decoderModule\n * @param url\n * @param binaryName\n * @return {Promise<boolean>}\n */\n\nfunction setWasmBinary(url, binaryName) {\n  var dracoDecoderType = {};\n  return new Promise(function (resolve, reject) {\n    dracoDecoderType.wasmBinaryFile = binaryName;\n    var xhr = new XMLHttpRequest();\n    xhr.open('GET', url, true);\n    xhr.responseType = 'arraybuffer';\n    xhr.onload = function () {\n      if (xhr.status === 200) {\n        dracoDecoderType.wasmBinary = xhr.response; // Use Promise.resolve to be compatible with versions before Draco 1.4.0\n\n        Promise.resolve(window.DracoDecoderModule(dracoDecoderType)).then(function (module) {\n          decoderModule = module;\n          resolve(true);\n        }, reject);\n      } else {\n        reject(Error(\"WASM binary could not be loaded: \".concat(xhr.statusText)));\n      }\n    };\n    xhr.send(null);\n  });\n}\nfunction setDracoDecoder(createDracoModule) {\n  decoderModule = createDracoModule({});\n}\nfunction getDracoDecoder() {\n  return decoderModule;\n} // ----------------------------------------------------------------------------\n// vtkDracoReader methods\n// ----------------------------------------------------------------------------\n\nfunction decodeBuffer(buffer) {\n  var byteArray = new Int8Array(buffer);\n  var decoder = new decoderModule.Decoder();\n  var decoderBuffer = new decoderModule.DecoderBuffer();\n  decoderBuffer.Init(byteArray, byteArray.length);\n  var geometryType = decoder.GetEncodedGeometryType(decoderBuffer);\n  var dracoGeometry;\n  if (geometryType === decoderModule.TRIANGULAR_MESH) {\n    dracoGeometry = new decoderModule.Mesh();\n    var status = decoder.DecodeBufferToMesh(decoderBuffer, dracoGeometry);\n    if (!status.ok()) {\n      vtkErrorMacro(\"Could not decode Draco file: \".concat(status.error_msg()));\n    }\n  } else {\n    vtkErrorMacro('Wrong geometry type, expected mesh, got point cloud.');\n  }\n  decoderModule.destroy(decoderBuffer);\n  decoderModule.destroy(decoder);\n  return dracoGeometry;\n}\nfunction getDracoAttributeAsFloat32Array(dracoGeometry, attributeId) {\n  var decoder = new decoderModule.Decoder();\n  var attribute = decoder.GetAttribute(dracoGeometry, attributeId);\n  var numberOfComponents = attribute.num_components();\n  var numberOfPoints = dracoGeometry.num_points();\n  var attributeData = new decoderModule.DracoFloat32Array();\n  decoder.GetAttributeFloatForAllPoints(dracoGeometry, attribute, attributeData);\n  var i = numberOfPoints * numberOfComponents;\n  var attributeArray = new Float32Array(i);\n  while (i--) {\n    attributeArray[i] = attributeData.GetValue(i);\n  }\n  return attributeArray;\n}\nfunction getPolyDataFromDracoGeometry(dracoGeometry) {\n  var decoder = new decoderModule.Decoder(); // Get position attribute ID\n\n  var positionAttributeId = decoder.GetAttributeId(dracoGeometry, decoderModule.POSITION);\n  if (positionAttributeId === -1) {\n    console.error('No position attribute found in the decoded model.');\n    decoderModule.destroy(decoder);\n    decoderModule.destroy(dracoGeometry);\n    return null;\n  }\n  var positionArray = getDracoAttributeAsFloat32Array(dracoGeometry, positionAttributeId); // Read indices\n\n  var i = dracoGeometry.num_faces();\n  var indices = new Uint32Array(i * 4);\n  var indicesArray = new decoderModule.DracoInt32Array();\n  while (i--) {\n    decoder.GetFaceFromMesh(dracoGeometry, i, indicesArray);\n    var index = i * 4;\n    indices[index] = 3;\n    indices[index + 1] = indicesArray.GetValue(0);\n    indices[index + 2] = indicesArray.GetValue(1);\n    indices[index + 3] = indicesArray.GetValue(2);\n  } // Create polyData and add positions and indinces\n\n  var cellArray = vtkCellArray.newInstance({\n    values: indices\n  });\n  var polyData = vtkPolyData.newInstance({\n    polys: cellArray\n  });\n  polyData.getPoints().setData(positionArray); // Look for other attributes\n\n  var pointData = polyData.getPointData(); // Normals\n\n  var normalAttributeId = decoder.GetAttributeId(dracoGeometry, decoderModule.NORMAL);\n  if (normalAttributeId !== -1) {\n    var normalArray = getDracoAttributeAsFloat32Array(dracoGeometry, decoderModule.NORMAL);\n    var normals = vtkDataArray.newInstance({\n      numberOfComponents: 3,\n      values: normalArray,\n      name: 'Normals'\n    });\n    pointData.setNormals(normals);\n  } // Texture coordinates\n\n  var texCoordAttributeId = decoder.GetAttributeId(dracoGeometry, decoderModule.TEX_COORD);\n  if (texCoordAttributeId !== -1) {\n    var texCoordArray = getDracoAttributeAsFloat32Array(dracoGeometry, texCoordAttributeId);\n    var texCoords = vtkDataArray.newInstance({\n      numberOfComponents: 2,\n      values: texCoordArray,\n      name: 'TCoords'\n    });\n    pointData.setTCoords(texCoords);\n  } // Scalars\n\n  var colorAttributeId = decoder.GetAttributeId(dracoGeometry, decoderModule.COLOR);\n  if (colorAttributeId !== -1) {\n    var colorArray = getDracoAttributeAsFloat32Array(dracoGeometry, colorAttributeId);\n    var scalars = vtkDataArray.newInstance({\n      numberOfComponents: 3,\n      values: colorArray,\n      name: 'Scalars'\n    });\n    pointData.setScalars(scalars);\n  }\n  decoderModule.destroy(decoder);\n  return polyData;\n}\nfunction vtkDracoReader(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkDracoReader'); // Create default dataAccessHelper if not available\n\n  if (!model.dataAccessHelper) {\n    model.dataAccessHelper = DataAccessHelper.get('http');\n  } // Internal method to fetch Array\n\n  function fetchData(url) {\n    var option = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var compression = model.compression,\n      progressCallback = model.progressCallback;\n    if (option.binary) {\n      return model.dataAccessHelper.fetchBinary(url, {\n        compression: compression,\n        progressCallback: progressCallback\n      });\n    }\n    return model.dataAccessHelper.fetchText(publicAPI, url, {\n      compression: compression,\n      progressCallback: progressCallback\n    });\n  } // Set DataSet url\n\n  publicAPI.setUrl = function (url) {\n    var option = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n      binary: true\n    };\n    model.url = url; // Remove the file in the URL\n\n    var path = url.split('/');\n    path.pop();\n    model.baseURL = path.join('/');\n    model.compression = option.compression; // Fetch metadata\n\n    return publicAPI.loadData({\n      progressCallback: option.progressCallback,\n      binary: !!option.binary\n    });\n  }; // Fetch the actual data arrays\n\n  publicAPI.loadData = function () {\n    var option = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var promise = fetchData(model.url, option);\n    promise.then(publicAPI.parse);\n    return promise;\n  };\n  publicAPI.parse = function (content) {\n    publicAPI.parseAsArrayBuffer(content);\n  };\n  publicAPI.parseAsArrayBuffer = function (content) {\n    if (!content) {\n      return;\n    }\n    if (content !== model.parseData) {\n      publicAPI.modified();\n    } else {\n      return;\n    }\n    model.parseData = content;\n    var dracoGeometry = decodeBuffer(content);\n    var polyData = getPolyDataFromDracoGeometry(dracoGeometry);\n    decoderModule.destroy(dracoGeometry);\n    model.output[0] = polyData;\n  };\n  publicAPI.requestData = function () {\n    publicAPI.parse(model.parseData);\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nvar DEFAULT_VALUES = {// baseURL: null,\n  // dataAccessHelper: null,\n  // url: null,\n}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Build VTK API\n\n  macro.obj(publicAPI, model);\n  macro.get(publicAPI, model, ['url', 'baseURL']);\n  macro.setGet(publicAPI, model, ['dataAccessHelper']);\n  macro.algo(publicAPI, model, 0, 1); // vtkDracoReader methods\n\n  vtkDracoReader(publicAPI, model); // To support destructuring\n\n  if (!model.compression) {\n    model.compression = null;\n  }\n  if (!model.progressCallback) {\n    model.progressCallback = null;\n  }\n} // ----------------------------------------------------------------------------\n\nvar newInstance = macro.newInstance(extend, 'vtkDracoReader'); // ----------------------------------------------------------------------------\n\nvar vtkDracoReader$1 = {\n  extend: extend,\n  newInstance: newInstance,\n  setDracoDecoder: setDracoDecoder,\n  setWasmBinary: setWasmBinary,\n  getDracoDecoder: getDracoDecoder\n};\nexport { vtkDracoReader$1 as default, extend, newInstance };","map":{"version":3,"names":["DataAccessHelper","macro","vtkCellArray","vtkDataArray","vtkPolyData","vtkErrorMacro","decoderModule","setWasmBinary","url","binaryName","dracoDecoderType","Promise","resolve","reject","wasmBinaryFile","xhr","XMLHttpRequest","open","responseType","onload","status","wasmBinary","response","window","DracoDecoderModule","then","module","Error","concat","statusText","send","setDracoDecoder","createDracoModule","getDracoDecoder","decodeBuffer","buffer","byteArray","Int8Array","decoder","Decoder","decoderBuffer","DecoderBuffer","Init","length","geometryType","GetEncodedGeometryType","dracoGeometry","TRIANGULAR_MESH","Mesh","DecodeBufferToMesh","ok","error_msg","destroy","getDracoAttributeAsFloat32Array","attributeId","attribute","GetAttribute","numberOfComponents","num_components","numberOfPoints","num_points","attributeData","DracoFloat32Array","GetAttributeFloatForAllPoints","i","attributeArray","Float32Array","GetValue","getPolyDataFromDracoGeometry","positionAttributeId","GetAttributeId","POSITION","console","error","positionArray","num_faces","indices","Uint32Array","indicesArray","DracoInt32Array","GetFaceFromMesh","index","cellArray","newInstance","values","polyData","polys","getPoints","setData","pointData","getPointData","normalAttributeId","NORMAL","normalArray","normals","name","setNormals","texCoordAttributeId","TEX_COORD","texCoordArray","texCoords","setTCoords","colorAttributeId","COLOR","colorArray","scalars","setScalars","vtkDracoReader","publicAPI","model","classHierarchy","push","dataAccessHelper","get","fetchData","option","arguments","undefined","compression","progressCallback","binary","fetchBinary","fetchText","setUrl","path","split","pop","baseURL","join","loadData","promise","parse","content","parseAsArrayBuffer","parseData","modified","output","requestData","DEFAULT_VALUES","extend","initialValues","Object","assign","obj","setGet","algo","vtkDracoReader$1","default"],"sources":["/home/rakshith/Documents/RemoteRendering/vtk-js-react-app/node_modules/@kitware/vtk.js/IO/Geometry/DracoReader.js"],"sourcesContent":["import DataAccessHelper from '../Core/DataAccessHelper.js';\nimport macro from '../../macros.js';\nimport vtkCellArray from '../../Common/Core/CellArray.js';\nimport vtkDataArray from '../../Common/Core/DataArray.js';\nimport vtkPolyData from '../../Common/DataModel/PolyData.js';\nimport '../Core/DataAccessHelper/LiteHttpDataAccessHelper.js';\n\n// import 'vtk.js/Sources/IO/Core/DataAccessHelper/HttpDataAccessHelper'; // HTTP + zip\n// import 'vtk.js/Sources/IO/Core/DataAccessHelper/HtmlDataAccessHelper'; // html + base64 + zip\n// import 'vtk.js/Sources/IO/Core/DataAccessHelper/JSZipDataAccessHelper'; // zip\n\nvar vtkErrorMacro = macro.vtkErrorMacro;\nvar decoderModule = {}; // ----------------------------------------------------------------------------\n// static methods\n// ----------------------------------------------------------------------------\n\n/**\n * Load the WASM decoder from url and set the decoderModule\n * @param url\n * @param binaryName\n * @return {Promise<boolean>}\n */\n\nfunction setWasmBinary(url, binaryName) {\n  var dracoDecoderType = {};\n  return new Promise(function (resolve, reject) {\n    dracoDecoderType.wasmBinaryFile = binaryName;\n    var xhr = new XMLHttpRequest();\n    xhr.open('GET', url, true);\n    xhr.responseType = 'arraybuffer';\n\n    xhr.onload = function () {\n      if (xhr.status === 200) {\n        dracoDecoderType.wasmBinary = xhr.response; // Use Promise.resolve to be compatible with versions before Draco 1.4.0\n\n        Promise.resolve(window.DracoDecoderModule(dracoDecoderType)).then(function (module) {\n          decoderModule = module;\n          resolve(true);\n        }, reject);\n      } else {\n        reject(Error(\"WASM binary could not be loaded: \".concat(xhr.statusText)));\n      }\n    };\n\n    xhr.send(null);\n  });\n}\n\nfunction setDracoDecoder(createDracoModule) {\n  decoderModule = createDracoModule({});\n}\n\nfunction getDracoDecoder() {\n  return decoderModule;\n} // ----------------------------------------------------------------------------\n// vtkDracoReader methods\n// ----------------------------------------------------------------------------\n\n\nfunction decodeBuffer(buffer) {\n  var byteArray = new Int8Array(buffer);\n  var decoder = new decoderModule.Decoder();\n  var decoderBuffer = new decoderModule.DecoderBuffer();\n  decoderBuffer.Init(byteArray, byteArray.length);\n  var geometryType = decoder.GetEncodedGeometryType(decoderBuffer);\n  var dracoGeometry;\n\n  if (geometryType === decoderModule.TRIANGULAR_MESH) {\n    dracoGeometry = new decoderModule.Mesh();\n    var status = decoder.DecodeBufferToMesh(decoderBuffer, dracoGeometry);\n\n    if (!status.ok()) {\n      vtkErrorMacro(\"Could not decode Draco file: \".concat(status.error_msg()));\n    }\n  } else {\n    vtkErrorMacro('Wrong geometry type, expected mesh, got point cloud.');\n  }\n\n  decoderModule.destroy(decoderBuffer);\n  decoderModule.destroy(decoder);\n  return dracoGeometry;\n}\n\nfunction getDracoAttributeAsFloat32Array(dracoGeometry, attributeId) {\n  var decoder = new decoderModule.Decoder();\n  var attribute = decoder.GetAttribute(dracoGeometry, attributeId);\n  var numberOfComponents = attribute.num_components();\n  var numberOfPoints = dracoGeometry.num_points();\n  var attributeData = new decoderModule.DracoFloat32Array();\n  decoder.GetAttributeFloatForAllPoints(dracoGeometry, attribute, attributeData);\n  var i = numberOfPoints * numberOfComponents;\n  var attributeArray = new Float32Array(i);\n\n  while (i--) {\n    attributeArray[i] = attributeData.GetValue(i);\n  }\n\n  return attributeArray;\n}\n\nfunction getPolyDataFromDracoGeometry(dracoGeometry) {\n  var decoder = new decoderModule.Decoder(); // Get position attribute ID\n\n  var positionAttributeId = decoder.GetAttributeId(dracoGeometry, decoderModule.POSITION);\n\n  if (positionAttributeId === -1) {\n    console.error('No position attribute found in the decoded model.');\n    decoderModule.destroy(decoder);\n    decoderModule.destroy(dracoGeometry);\n    return null;\n  }\n\n  var positionArray = getDracoAttributeAsFloat32Array(dracoGeometry, positionAttributeId); // Read indices\n\n  var i = dracoGeometry.num_faces();\n  var indices = new Uint32Array(i * 4);\n  var indicesArray = new decoderModule.DracoInt32Array();\n\n  while (i--) {\n    decoder.GetFaceFromMesh(dracoGeometry, i, indicesArray);\n    var index = i * 4;\n    indices[index] = 3;\n    indices[index + 1] = indicesArray.GetValue(0);\n    indices[index + 2] = indicesArray.GetValue(1);\n    indices[index + 3] = indicesArray.GetValue(2);\n  } // Create polyData and add positions and indinces\n\n\n  var cellArray = vtkCellArray.newInstance({\n    values: indices\n  });\n  var polyData = vtkPolyData.newInstance({\n    polys: cellArray\n  });\n  polyData.getPoints().setData(positionArray); // Look for other attributes\n\n  var pointData = polyData.getPointData(); // Normals\n\n  var normalAttributeId = decoder.GetAttributeId(dracoGeometry, decoderModule.NORMAL);\n\n  if (normalAttributeId !== -1) {\n    var normalArray = getDracoAttributeAsFloat32Array(dracoGeometry, decoderModule.NORMAL);\n    var normals = vtkDataArray.newInstance({\n      numberOfComponents: 3,\n      values: normalArray,\n      name: 'Normals'\n    });\n    pointData.setNormals(normals);\n  } // Texture coordinates\n\n\n  var texCoordAttributeId = decoder.GetAttributeId(dracoGeometry, decoderModule.TEX_COORD);\n\n  if (texCoordAttributeId !== -1) {\n    var texCoordArray = getDracoAttributeAsFloat32Array(dracoGeometry, texCoordAttributeId);\n    var texCoords = vtkDataArray.newInstance({\n      numberOfComponents: 2,\n      values: texCoordArray,\n      name: 'TCoords'\n    });\n    pointData.setTCoords(texCoords);\n  } // Scalars\n\n\n  var colorAttributeId = decoder.GetAttributeId(dracoGeometry, decoderModule.COLOR);\n\n  if (colorAttributeId !== -1) {\n    var colorArray = getDracoAttributeAsFloat32Array(dracoGeometry, colorAttributeId);\n    var scalars = vtkDataArray.newInstance({\n      numberOfComponents: 3,\n      values: colorArray,\n      name: 'Scalars'\n    });\n    pointData.setScalars(scalars);\n  }\n\n  decoderModule.destroy(decoder);\n  return polyData;\n}\n\nfunction vtkDracoReader(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkDracoReader'); // Create default dataAccessHelper if not available\n\n  if (!model.dataAccessHelper) {\n    model.dataAccessHelper = DataAccessHelper.get('http');\n  } // Internal method to fetch Array\n\n\n  function fetchData(url) {\n    var option = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var compression = model.compression,\n        progressCallback = model.progressCallback;\n\n    if (option.binary) {\n      return model.dataAccessHelper.fetchBinary(url, {\n        compression: compression,\n        progressCallback: progressCallback\n      });\n    }\n\n    return model.dataAccessHelper.fetchText(publicAPI, url, {\n      compression: compression,\n      progressCallback: progressCallback\n    });\n  } // Set DataSet url\n\n\n  publicAPI.setUrl = function (url) {\n    var option = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n      binary: true\n    };\n    model.url = url; // Remove the file in the URL\n\n    var path = url.split('/');\n    path.pop();\n    model.baseURL = path.join('/');\n    model.compression = option.compression; // Fetch metadata\n\n    return publicAPI.loadData({\n      progressCallback: option.progressCallback,\n      binary: !!option.binary\n    });\n  }; // Fetch the actual data arrays\n\n\n  publicAPI.loadData = function () {\n    var option = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var promise = fetchData(model.url, option);\n    promise.then(publicAPI.parse);\n    return promise;\n  };\n\n  publicAPI.parse = function (content) {\n    publicAPI.parseAsArrayBuffer(content);\n  };\n\n  publicAPI.parseAsArrayBuffer = function (content) {\n    if (!content) {\n      return;\n    }\n\n    if (content !== model.parseData) {\n      publicAPI.modified();\n    } else {\n      return;\n    }\n\n    model.parseData = content;\n    var dracoGeometry = decodeBuffer(content);\n    var polyData = getPolyDataFromDracoGeometry(dracoGeometry);\n    decoderModule.destroy(dracoGeometry);\n    model.output[0] = polyData;\n  };\n\n  publicAPI.requestData = function () {\n    publicAPI.parse(model.parseData);\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\n\nvar DEFAULT_VALUES = {// baseURL: null,\n  // dataAccessHelper: null,\n  // url: null,\n}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Build VTK API\n\n  macro.obj(publicAPI, model);\n  macro.get(publicAPI, model, ['url', 'baseURL']);\n  macro.setGet(publicAPI, model, ['dataAccessHelper']);\n  macro.algo(publicAPI, model, 0, 1); // vtkDracoReader methods\n\n  vtkDracoReader(publicAPI, model); // To support destructuring\n\n  if (!model.compression) {\n    model.compression = null;\n  }\n\n  if (!model.progressCallback) {\n    model.progressCallback = null;\n  }\n} // ----------------------------------------------------------------------------\n\nvar newInstance = macro.newInstance(extend, 'vtkDracoReader'); // ----------------------------------------------------------------------------\n\nvar vtkDracoReader$1 = {\n  extend: extend,\n  newInstance: newInstance,\n  setDracoDecoder: setDracoDecoder,\n  setWasmBinary: setWasmBinary,\n  getDracoDecoder: getDracoDecoder\n};\n\nexport { vtkDracoReader$1 as default, extend, newInstance };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}