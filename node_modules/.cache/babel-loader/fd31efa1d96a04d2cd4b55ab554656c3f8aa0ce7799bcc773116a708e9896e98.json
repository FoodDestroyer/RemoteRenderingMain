{"ast":null,"code":"import _classCallCheck from '@babel/runtime/helpers/classCallCheck';\nimport _createClass from '@babel/runtime/helpers/createClass';\nvar EdgeLocator = /*#__PURE__*/function () {\n  function EdgeLocator() {\n    var oriented = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    _classCallCheck(this, EdgeLocator);\n    this.oriented = oriented;\n    this.edgeMap = new Map();\n  }\n  _createClass(EdgeLocator, [{\n    key: \"initialize\",\n    value: function initialize() {\n      this.edgeMap.clear();\n    }\n  }, {\n    key: \"computeEdgeKey\",\n    value: function computeEdgeKey(pointId0, pointId1) {\n      return this.oriented || pointId0 < pointId1 ?\n      // Cantor pairing function:\n      0.5 * (pointId0 * pointId1) * (pointId0 * pointId1 + 1) + pointId1 : 0.5 * (pointId1 * pointId0) * (pointId1 * pointId0 + 1) + pointId0;\n    }\n  }, {\n    key: \"insertUniqueEdge\",\n    value: function insertUniqueEdge(pointId0, pointId1, newEdgeValue) {\n      // Generate a unique key\n      var key = this.computeEdgeKey(pointId0, pointId1);\n      var node = this.edgeMap.get(key);\n      if (!node) {\n        // Didn't find key, so add a new edge entry\n        node = {\n          key: key,\n          edgeId: this.edgeMap.size,\n          value: newEdgeValue\n        };\n        this.edgeMap.set(key, node);\n      }\n      return node;\n    }\n  }, {\n    key: \"insertEdge\",\n    value: function insertEdge(pointId0, pointId1, newEdgeValue) {\n      // Generate a unique key\n      var key = this.computeEdgeKey(pointId0, pointId1);\n      var node = {\n        key: key,\n        edgeId: this.edgeMap.size,\n        value: newEdgeValue\n      };\n      this.edgeMap.set(key, node);\n      return node;\n    }\n  }, {\n    key: \"isInsertedEdge\",\n    value: function isInsertedEdge(pointId0, pointId1) {\n      var key = this.computeEdgeKey(pointId0, pointId1);\n      return this.edgeMap.get(key);\n    }\n  }], [{\n    key: \"getEdgePointIds\",\n    value: function getEdgePointIds(node) {\n      var n = 0.5 * (-1 + Math.sqrt(8 * node.key + 1));\n      var pointId0 = node.key - 0.5 * (n + 1) * n;\n      var pointId1 = n - pointId0;\n      return [pointId0, pointId1];\n    }\n  }]);\n  return EdgeLocator;\n}();\nfunction newInstance() {\n  var initialValues = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return new EdgeLocator(initialValues.oriented);\n}\nvar vtkEdgeLocator = {\n  newInstance: newInstance\n};\nexport { vtkEdgeLocator as default };","map":{"version":3,"names":["_classCallCheck","_createClass","EdgeLocator","oriented","arguments","length","undefined","edgeMap","Map","key","value","initialize","clear","computeEdgeKey","pointId0","pointId1","insertUniqueEdge","newEdgeValue","node","get","edgeId","size","set","insertEdge","isInsertedEdge","getEdgePointIds","n","Math","sqrt","newInstance","initialValues","vtkEdgeLocator","default"],"sources":["/home/rakshith/Documents/RemoteRendering/vtk-js-react-app/node_modules/@kitware/vtk.js/Common/DataModel/EdgeLocator.js"],"sourcesContent":["import _classCallCheck from '@babel/runtime/helpers/classCallCheck';\nimport _createClass from '@babel/runtime/helpers/createClass';\n\nvar EdgeLocator = /*#__PURE__*/function () {\n  function EdgeLocator() {\n    var oriented = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n    _classCallCheck(this, EdgeLocator);\n\n    this.oriented = oriented;\n    this.edgeMap = new Map();\n  }\n\n  _createClass(EdgeLocator, [{\n    key: \"initialize\",\n    value: function initialize() {\n      this.edgeMap.clear();\n    }\n  }, {\n    key: \"computeEdgeKey\",\n    value: function computeEdgeKey(pointId0, pointId1) {\n      return this.oriented || pointId0 < pointId1 ? // Cantor pairing function:\n      0.5 * (pointId0 * pointId1) * (pointId0 * pointId1 + 1) + pointId1 : 0.5 * (pointId1 * pointId0) * (pointId1 * pointId0 + 1) + pointId0;\n    }\n  }, {\n    key: \"insertUniqueEdge\",\n    value: function insertUniqueEdge(pointId0, pointId1, newEdgeValue) {\n      // Generate a unique key\n      var key = this.computeEdgeKey(pointId0, pointId1);\n      var node = this.edgeMap.get(key);\n\n      if (!node) {\n        // Didn't find key, so add a new edge entry\n        node = {\n          key: key,\n          edgeId: this.edgeMap.size,\n          value: newEdgeValue\n        };\n        this.edgeMap.set(key, node);\n      }\n\n      return node;\n    }\n  }, {\n    key: \"insertEdge\",\n    value: function insertEdge(pointId0, pointId1, newEdgeValue) {\n      // Generate a unique key\n      var key = this.computeEdgeKey(pointId0, pointId1);\n      var node = {\n        key: key,\n        edgeId: this.edgeMap.size,\n        value: newEdgeValue\n      };\n      this.edgeMap.set(key, node);\n      return node;\n    }\n  }, {\n    key: \"isInsertedEdge\",\n    value: function isInsertedEdge(pointId0, pointId1) {\n      var key = this.computeEdgeKey(pointId0, pointId1);\n      return this.edgeMap.get(key);\n    }\n  }], [{\n    key: \"getEdgePointIds\",\n    value: function getEdgePointIds(node) {\n      var n = 0.5 * (-1 + Math.sqrt(8 * node.key + 1));\n      var pointId0 = node.key - 0.5 * (n + 1) * n;\n      var pointId1 = n - pointId0;\n      return [pointId0, pointId1];\n    }\n  }]);\n\n  return EdgeLocator;\n}();\n\nfunction newInstance() {\n  var initialValues = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return new EdgeLocator(initialValues.oriented);\n}\n\nvar vtkEdgeLocator = {\n  newInstance: newInstance\n};\n\nexport { vtkEdgeLocator as default };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}