{"ast":null,"code":"import { mat4, vec4 } from 'gl-matrix';\nimport Constants from '../Core/ImageMapper/Constants.js';\nimport { newInstance as newInstance$1, obj } from '../../macros.js';\nimport vtkWebGPUShaderCache from './ShaderCache.js';\nimport vtkWebGPUFullScreenQuad from './FullScreenQuad.js';\nimport vtkWebGPUUniformBuffer from './UniformBuffer.js';\nimport vtkWebGPUSampler from './Sampler.js';\nimport { InterpolationType } from '../Core/ImageProperty/Constants.js';\nimport { registerOverride } from './ViewNodeFactory.js';\nvar SlicingMode = Constants.SlicingMode;\nvar imgFragTemplate = \"\\n//VTK::Renderer::Dec\\n\\n//VTK::Mapper::Dec\\n\\n//VTK::TCoord::Dec\\n\\n//VTK::Image::Dec\\n\\n//VTK::RenderEncoder::Dec\\n\\n//VTK::IOStructs::Dec\\n\\n@fragment\\nfn main(\\n//VTK::IOStructs::Input\\n)\\n//VTK::IOStructs::Output\\n{\\n  var output: fragmentOutput;\\n\\n  //VTK::Image::Sample\\n\\n  // var computedColor: vec4<f32> = vec4<f32>(1.0,0.7, 0.5, 1.0);\\n\\n//VTK::RenderEncoder::Impl\\n\\n  return output;\\n}\\n\"; // ----------------------------------------------------------------------------\n// helper methods\n// ----------------------------------------------------------------------------\n\nfunction computeFnToString(property, fn, numberOfComponents) {\n  var pwfun = fn.apply(property);\n  if (pwfun) {\n    var iComps = property.getIndependentComponents();\n    return \"\".concat(property.getMTime(), \"-\").concat(iComps, \"-\").concat(numberOfComponents);\n  }\n  return '0';\n} // ----------------------------------------------------------------------------\n// vtkWebGPUImageMapper methods\n// ----------------------------------------------------------------------------\n\nvar tmpMat4 = new Float64Array(16);\nvar tmp2Mat4 = new Float64Array(16);\nvar tmp3Mat4 = new Float64Array(16);\nvar ptsArray1 = new Float64Array(4);\nvar ptsArray2 = new Float64Array(4);\nfunction vtkWebGPUImageMapper(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkWebGPUImageMapper');\n  publicAPI.buildPass = function (prepass) {\n    if (prepass) {\n      model.WebGPUImageSlice = publicAPI.getFirstAncestorOfType('vtkWebGPUImageSlice');\n      model.WebGPURenderer = model.WebGPUImageSlice.getFirstAncestorOfType('vtkWebGPURenderer');\n      model.WebGPURenderWindow = model.WebGPURenderer.getParent();\n      model.device = model.WebGPURenderWindow.getDevice();\n      var ren = model.WebGPURenderer.getRenderable(); // is slice set by the camera\n\n      if (model.renderable.getSliceAtFocalPoint()) {\n        model.renderable.setSliceFromCamera(ren.getActiveCamera());\n      }\n    }\n  }; // Renders myself\n\n  publicAPI.translucentPass = function (prepass) {\n    if (prepass) {\n      publicAPI.render();\n    }\n  };\n  publicAPI.opaquePass = function (prepass) {\n    if (prepass) {\n      publicAPI.render();\n    }\n  };\n  publicAPI.render = function () {\n    model.renderable.update();\n    model.currentInput = model.renderable.getInputData();\n    publicAPI.prepareToDraw(model.WebGPURenderer.getRenderEncoder());\n    model.renderEncoder.registerDrawCallback(model.pipeline, publicAPI.draw);\n  };\n  publicAPI.computePipelineHash = function () {\n    var ext = model.currentInput.getExtent();\n    if (ext[0] === ext[1] || ext[2] === ext[3] || ext[4] === ext[5]) {\n      model.dimensions = 2;\n      model.pipelineHash = 'img2';\n    } else {\n      model.dimensions = 3;\n      model.pipelineHash = 'img3';\n    }\n  };\n  publicAPI.updateUBO = function () {\n    var utime = model.UBO.getSendTime();\n    var actor = model.WebGPUImageSlice.getRenderable();\n    var volMapr = actor.getMapper();\n    if (publicAPI.getMTime() > utime || model.renderable.getMTime() > utime || actor.getProperty().getMTime() > utime) {\n      // compute the SCTCMatrix\n      var image = volMapr.getInputData();\n      var center = model.WebGPURenderer.getStabilizedCenterByReference();\n      mat4.identity(tmpMat4);\n      mat4.translate(tmpMat4, tmpMat4, center); // tmpMat4 is now SC->World\n\n      var mcwcmat = actor.getMatrix();\n      mat4.transpose(tmp2Mat4, mcwcmat);\n      mat4.invert(tmp2Mat4, tmp2Mat4); // tmp2Mat4 is now world to model\n\n      mat4.multiply(tmpMat4, tmp2Mat4, tmpMat4); // tmp4Mat is now SC->Model\n      // the method on the data is world to index but the volume is in\n      // model coordinates so really in this context it is model to index\n\n      var modelToIndex = image.getWorldToIndex();\n      mat4.multiply(tmpMat4, modelToIndex, tmpMat4); // tmpMat4 is now SC -> Index, save this as we need it later\n\n      mat4.invert(tmp3Mat4, tmpMat4); // need translation and scale\n\n      mat4.fromTranslation(tmp2Mat4, [0.5, 0.5, 0.5]);\n      mat4.multiply(tmpMat4, tmp2Mat4, tmpMat4);\n      var dims = image.getDimensions();\n      mat4.identity(tmp2Mat4);\n      mat4.scale(tmp2Mat4, tmp2Mat4, [1.0 / dims[0], 1.0 / dims[1], 1.0 / dims[2]]);\n      mat4.multiply(tmpMat4, tmp2Mat4, tmpMat4); // tmpMat4 is now SC -> Tcoord\n\n      model.UBO.setArray('SCTCMatrix', tmpMat4); // need to compute the plane here in world coordinates\n      // then pass that down in the UBO\n\n      var ext = model.currentInput.getExtent(); // Find what IJK axis and what direction to slice along\n\n      var _model$renderable$get = model.renderable.getClosestIJKAxis(),\n        ijkMode = _model$renderable$get.ijkMode; // Find the IJK slice\n\n      var nSlice = model.renderable.getSlice();\n      if (ijkMode !== model.renderable.getSlicingMode()) {\n        // If not IJK slicing, get the IJK slice from the XYZ position/slice\n        nSlice = model.renderable.getSliceAtPosition(nSlice);\n      }\n      var axis0 = 2;\n      var axis1 = 0;\n      var axis2 = 1;\n      if (ijkMode === SlicingMode.I) {\n        axis0 = 0;\n        axis1 = 1;\n        axis2 = 2;\n      } else if (ijkMode === SlicingMode.J) {\n        axis0 = 1;\n        axis1 = 2;\n        axis2 = 0;\n      }\n      ptsArray1[axis0] = nSlice;\n      ptsArray1[axis1] = ext[axis1 * 2] - 0.5;\n      ptsArray1[axis2] = ext[axis2 * 2] - 0.5;\n      ptsArray1[3] = 1.0;\n      vec4.transformMat4(ptsArray1, ptsArray1, tmp3Mat4);\n      model.UBO.setArray('Origin', ptsArray1);\n      ptsArray2[axis0] = nSlice;\n      ptsArray2[axis1] = ext[axis1 * 2 + 1] + 0.5;\n      ptsArray2[axis2] = ext[axis2 * 2] - 0.5;\n      ptsArray2[3] = 1.0;\n      vec4.transformMat4(ptsArray2, ptsArray2, tmp3Mat4);\n      vec4.subtract(ptsArray2, ptsArray2, ptsArray1);\n      ptsArray2[3] = 1.0;\n      model.UBO.setArray('Axis1', ptsArray2);\n      ptsArray2[axis0] = nSlice;\n      ptsArray2[axis1] = ext[axis1 * 2] - 0.5;\n      ptsArray2[axis2] = ext[axis2 * 2 + 1] + 0.5;\n      ptsArray2[3] = 1.0;\n      vec4.transformMat4(ptsArray2, ptsArray2, tmp3Mat4);\n      vec4.subtract(ptsArray2, ptsArray2, ptsArray1);\n      ptsArray2[3] = 1.0;\n      model.UBO.setArray('Axis2', ptsArray2); // three levels of shift scale combined into one\n      // for performance in the fragment shader\n\n      var cScale = [1, 1, 1, 1];\n      var cShift = [0, 0, 0, 0];\n      var tView = model.textureViews[0];\n      var tScale = tView.getTexture().getScale();\n      var numComp = tView.getTexture().getNumberOfComponents();\n      var iComps = false; // todo handle independent?\n\n      for (var i = 0; i < numComp; i++) {\n        var cw = actor.getProperty().getColorWindow();\n        var cl = actor.getProperty().getColorLevel();\n        var target = iComps ? i : 0;\n        var cfun = actor.getProperty().getRGBTransferFunction(target);\n        if (cfun) {\n          var cRange = cfun.getRange();\n          cw = cRange[1] - cRange[0];\n          cl = 0.5 * (cRange[1] + cRange[0]);\n        }\n        cScale[i] = tScale / cw;\n        cShift[i] = -cl / cw + 0.5;\n      }\n      model.UBO.setArray('cScale', cScale);\n      model.UBO.setArray('cShift', cShift);\n      model.UBO.sendIfNeeded(model.device);\n    }\n  };\n  publicAPI.updateLUTImage = function () {\n    var actorProperty = model.WebGPUImageSlice.getRenderable().getProperty();\n    var tView = publicAPI.getTextureViews()[0];\n    tView.getTexture().getNumberOfComponents();\n    var numIComps = 1;\n    var cfunToString = computeFnToString(actorProperty, actorProperty.getRGBTransferFunction, numIComps);\n    if (model.colorTextureString !== cfunToString) {\n      model.numRows = numIComps;\n      var colorArray = new Uint8Array(model.numRows * 2 * model.rowLength * 4);\n      var cfun = actorProperty.getRGBTransferFunction();\n      if (cfun) {\n        var tmpTable = new Float32Array(model.rowLength * 3);\n        for (var c = 0; c < numIComps; c++) {\n          cfun = actorProperty.getRGBTransferFunction(c);\n          var cRange = cfun.getRange();\n          cfun.getTable(cRange[0], cRange[1], model.rowLength, tmpTable, 1);\n          {\n            for (var _i = 0; _i < model.rowLength; _i++) {\n              var _idx = c * model.rowLength * 8 + _i * 4;\n              colorArray[_idx] = 255.0 * tmpTable[_i * 3];\n              colorArray[_idx + 1] = 255.0 * tmpTable[_i * 3 + 1];\n              colorArray[_idx + 2] = 255.0 * tmpTable[_i * 3 + 2];\n              colorArray[_idx + 3] = 255.0;\n              for (var _j = 0; _j < 4; _j++) {\n                colorArray[_idx + model.rowLength * 4 + _j] = colorArray[_idx + _j];\n              }\n            }\n          }\n        }\n      } else {\n        for (var _i2 = 0; _i2 < model.rowLength; ++_i2) {\n          var grey = 255.0 * _i2 / (model.rowLength - 1);\n          colorArray[_i2 * 4] = grey;\n          colorArray[_i2 * 4 + 1] = grey;\n          colorArray[_i2 * 4 + 2] = grey;\n          colorArray[_i2 * 4 + 3] = 255.0;\n          for (var _j2 = 0; _j2 < 4; _j2++) {\n            colorArray[_i2 * 4 + model.rowLength * 4 + _j2] = colorArray[_i2 * 4 + _j2];\n          }\n        }\n      }\n      {\n        var treq = {\n          nativeArray: colorArray,\n          width: model.rowLength,\n          height: model.numRows * 2,\n          depth: 1,\n          format: 'rgba8unorm'\n        };\n        var newTex = model.device.getTextureManager().getTexture(treq);\n        var tview = newTex.createView('tfunTexture');\n        model.textureViews[1] = tview;\n      }\n      model.colorTextureString = cfunToString;\n    }\n  };\n  var superClassUpdateBuffers = publicAPI.updateBuffers;\n  publicAPI.updateBuffers = function () {\n    superClassUpdateBuffers();\n    var newTex = model.device.getTextureManager().getTextureForImageData(model.currentInput);\n    var tViews = model.textureViews;\n    if (!tViews[0] || tViews[0].getTexture() !== newTex) {\n      var tview = newTex.createView('imgTexture');\n      tViews[0] = tview;\n    }\n    publicAPI.updateLUTImage();\n    publicAPI.updateUBO(); // set interpolation on the texture based on property setting\n\n    var actorProperty = model.WebGPUImageSlice.getRenderable().getProperty();\n    var iType = actorProperty.getInterpolationType() === InterpolationType.NEAREST ? 'nearest' : 'linear';\n    if (!model.clampSampler || iType !== model.clampSampler.getOptions().minFilter) {\n      model.clampSampler = vtkWebGPUSampler.newInstance({\n        label: 'clampSampler'\n      });\n      model.clampSampler.create(model.device, {\n        minFilter: iType,\n        magFilter: iType\n      });\n      model.additionalBindables = [model.clampSampler];\n    }\n  };\n  var sr = publicAPI.getShaderReplacements();\n  publicAPI.replaceShaderPosition = function (hash, pipeline, vertexInput) {\n    var vDesc = pipeline.getShaderDescription('vertex');\n    vDesc.addBuiltinOutput('vec4<f32>', '@builtin(position) Position');\n    var code = vDesc.getCode();\n    var lines = ['var pos: vec4<f32> = mapperUBO.Origin +', '   (vertexBC.x * 0.5 + 0.5) * mapperUBO.Axis1 + (vertexBC.y * 0.5 + 0.5) * mapperUBO.Axis2;', 'pos.w = 1.0;'];\n    if (model.dimensions === 2) {\n      lines.push('var tcoord : vec2<f32> = (mapperUBO.SCTCMatrix * pos).xy;');\n    } else {\n      lines.push('var tcoord : vec3<f32> = (mapperUBO.SCTCMatrix * pos).xyz;');\n    }\n    lines.push('output.tcoordVS = tcoord;', 'output.Position = rendererUBO.SCPCMatrix * pos;');\n    code = vtkWebGPUShaderCache.substitute(code, '//VTK::Position::Impl', lines).result;\n    vDesc.setCode(code);\n  };\n  sr.set('replaceShaderPosition', publicAPI.replaceShaderPosition);\n  publicAPI.replaceShaderTCoord = function (hash, pipeline, vertexInput) {\n    var vDesc = pipeline.getShaderDescription('vertex');\n    if (model.dimensions === 2) {\n      vDesc.addOutput('vec2<f32>', 'tcoordVS');\n    } else {\n      vDesc.addOutput('vec3<f32>', 'tcoordVS');\n    }\n  };\n  sr.set('replaceShaderTCoord', publicAPI.replaceShaderTCoord);\n  publicAPI.replaceShaderImage = function (hash, pipeline, vertexInput) {\n    var fDesc = pipeline.getShaderDescription('fragment');\n    var code = fDesc.getCode();\n    if (model.dimensions === 3) {\n      code = vtkWebGPUShaderCache.substitute(code, '//VTK::Image::Sample', [\"    var computedColor: vec4<f32> =\", \"      textureSampleLevel(imgTexture, clampSampler, input.tcoordVS, 0.0);\", \"//VTK::Image::Sample\"]).result;\n    } else {\n      code = vtkWebGPUShaderCache.substitute(code, '//VTK::Image::Sample', [\"    var computedColor: vec4<f32> =\", \"      textureSampleLevel(imgTexture, clampSampler, input.tcoordVS, 0.0);\", \"//VTK::Image::Sample\"]).result;\n    }\n    code = vtkWebGPUShaderCache.substitute(code, '//VTK::Image::Sample', [\"    var coord: vec2<f32> =\", \"      vec2<f32>(computedColor.r * mapperUBO.cScale.r + mapperUBO.cShift.r, 0.5);\", \"    computedColor = textureSampleLevel(tfunTexture, clampSampler, coord, 0.0);\"]).result;\n    fDesc.setCode(code);\n  };\n  sr.set('replaceShaderImage', publicAPI.replaceShaderImage);\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nvar DEFAULT_VALUES = {\n  rowLength: 1024\n}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Inheritance\n\n  vtkWebGPUFullScreenQuad.extend(publicAPI, model, initialValues);\n  publicAPI.setFragmentShaderTemplate(imgFragTemplate);\n  model.UBO = vtkWebGPUUniformBuffer.newInstance({\n    label: 'mapperUBO'\n  });\n  model.UBO.addEntry('SCTCMatrix', 'mat4x4<f32>');\n  model.UBO.addEntry('Origin', 'vec4<f32>');\n  model.UBO.addEntry('Axis2', 'vec4<f32>');\n  model.UBO.addEntry('Axis1', 'vec4<f32>');\n  model.UBO.addEntry('cScale', 'vec4<f32>');\n  model.UBO.addEntry('cShift', 'vec4<f32>');\n  model.lutBuildTime = {};\n  obj(model.lutBuildTime, {\n    mtime: 0\n  });\n  model.imagemat = mat4.identity(new Float64Array(16));\n  model.imagematinv = mat4.identity(new Float64Array(16));\n  model.VBOBuildTime = {};\n  obj(model.VBOBuildTime); // Object methods\n\n  vtkWebGPUImageMapper(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = newInstance$1(extend, 'vtkWebGPUImageMapper'); // ----------------------------------------------------------------------------\n\nvar index = {\n  newInstance: newInstance,\n  extend: extend\n}; // Register ourself to WebGPU backend if imported\n\nregisterOverride('vtkImageMapper', newInstance);\nexport { index as default, extend, newInstance };","map":{"version":3,"names":["mat4","vec4","Constants","newInstance","newInstance$1","obj","vtkWebGPUShaderCache","vtkWebGPUFullScreenQuad","vtkWebGPUUniformBuffer","vtkWebGPUSampler","InterpolationType","registerOverride","SlicingMode","imgFragTemplate","computeFnToString","property","fn","numberOfComponents","pwfun","apply","iComps","getIndependentComponents","concat","getMTime","tmpMat4","Float64Array","tmp2Mat4","tmp3Mat4","ptsArray1","ptsArray2","vtkWebGPUImageMapper","publicAPI","model","classHierarchy","push","buildPass","prepass","WebGPUImageSlice","getFirstAncestorOfType","WebGPURenderer","WebGPURenderWindow","getParent","device","getDevice","ren","getRenderable","renderable","getSliceAtFocalPoint","setSliceFromCamera","getActiveCamera","translucentPass","render","opaquePass","update","currentInput","getInputData","prepareToDraw","getRenderEncoder","renderEncoder","registerDrawCallback","pipeline","draw","computePipelineHash","ext","getExtent","dimensions","pipelineHash","updateUBO","utime","UBO","getSendTime","actor","volMapr","getMapper","getProperty","image","center","getStabilizedCenterByReference","identity","translate","mcwcmat","getMatrix","transpose","invert","multiply","modelToIndex","getWorldToIndex","fromTranslation","dims","getDimensions","scale","setArray","_model$renderable$get","getClosestIJKAxis","ijkMode","nSlice","getSlice","getSlicingMode","getSliceAtPosition","axis0","axis1","axis2","I","J","transformMat4","subtract","cScale","cShift","tView","textureViews","tScale","getTexture","getScale","numComp","getNumberOfComponents","i","cw","getColorWindow","cl","getColorLevel","target","cfun","getRGBTransferFunction","cRange","getRange","sendIfNeeded","updateLUTImage","actorProperty","getTextureViews","numIComps","cfunToString","colorTextureString","numRows","colorArray","Uint8Array","rowLength","tmpTable","Float32Array","c","getTable","_i","_idx","_j","_i2","grey","_j2","treq","nativeArray","width","height","depth","format","newTex","getTextureManager","tview","createView","superClassUpdateBuffers","updateBuffers","getTextureForImageData","tViews","iType","getInterpolationType","NEAREST","clampSampler","getOptions","minFilter","label","create","magFilter","additionalBindables","sr","getShaderReplacements","replaceShaderPosition","hash","vertexInput","vDesc","getShaderDescription","addBuiltinOutput","code","getCode","lines","substitute","result","setCode","set","replaceShaderTCoord","addOutput","replaceShaderImage","fDesc","DEFAULT_VALUES","extend","initialValues","arguments","length","undefined","Object","assign","setFragmentShaderTemplate","addEntry","lutBuildTime","mtime","imagemat","imagematinv","VBOBuildTime","index","default"],"sources":["/home/rakshith/Documents/RemoteRendering/vtk-js-react-app/node_modules/@kitware/vtk.js/Rendering/WebGPU/ImageMapper.js"],"sourcesContent":["import { mat4, vec4 } from 'gl-matrix';\nimport Constants from '../Core/ImageMapper/Constants.js';\nimport { newInstance as newInstance$1, obj } from '../../macros.js';\nimport vtkWebGPUShaderCache from './ShaderCache.js';\nimport vtkWebGPUFullScreenQuad from './FullScreenQuad.js';\nimport vtkWebGPUUniformBuffer from './UniformBuffer.js';\nimport vtkWebGPUSampler from './Sampler.js';\nimport { InterpolationType } from '../Core/ImageProperty/Constants.js';\nimport { registerOverride } from './ViewNodeFactory.js';\n\nvar SlicingMode = Constants.SlicingMode;\nvar imgFragTemplate = \"\\n//VTK::Renderer::Dec\\n\\n//VTK::Mapper::Dec\\n\\n//VTK::TCoord::Dec\\n\\n//VTK::Image::Dec\\n\\n//VTK::RenderEncoder::Dec\\n\\n//VTK::IOStructs::Dec\\n\\n@fragment\\nfn main(\\n//VTK::IOStructs::Input\\n)\\n//VTK::IOStructs::Output\\n{\\n  var output: fragmentOutput;\\n\\n  //VTK::Image::Sample\\n\\n  // var computedColor: vec4<f32> = vec4<f32>(1.0,0.7, 0.5, 1.0);\\n\\n//VTK::RenderEncoder::Impl\\n\\n  return output;\\n}\\n\"; // ----------------------------------------------------------------------------\n// helper methods\n// ----------------------------------------------------------------------------\n\nfunction computeFnToString(property, fn, numberOfComponents) {\n  var pwfun = fn.apply(property);\n\n  if (pwfun) {\n    var iComps = property.getIndependentComponents();\n    return \"\".concat(property.getMTime(), \"-\").concat(iComps, \"-\").concat(numberOfComponents);\n  }\n\n  return '0';\n} // ----------------------------------------------------------------------------\n// vtkWebGPUImageMapper methods\n// ----------------------------------------------------------------------------\n\n\nvar tmpMat4 = new Float64Array(16);\nvar tmp2Mat4 = new Float64Array(16);\nvar tmp3Mat4 = new Float64Array(16);\nvar ptsArray1 = new Float64Array(4);\nvar ptsArray2 = new Float64Array(4);\n\nfunction vtkWebGPUImageMapper(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkWebGPUImageMapper');\n\n  publicAPI.buildPass = function (prepass) {\n    if (prepass) {\n      model.WebGPUImageSlice = publicAPI.getFirstAncestorOfType('vtkWebGPUImageSlice');\n      model.WebGPURenderer = model.WebGPUImageSlice.getFirstAncestorOfType('vtkWebGPURenderer');\n      model.WebGPURenderWindow = model.WebGPURenderer.getParent();\n      model.device = model.WebGPURenderWindow.getDevice();\n      var ren = model.WebGPURenderer.getRenderable(); // is slice set by the camera\n\n      if (model.renderable.getSliceAtFocalPoint()) {\n        model.renderable.setSliceFromCamera(ren.getActiveCamera());\n      }\n    }\n  }; // Renders myself\n\n\n  publicAPI.translucentPass = function (prepass) {\n    if (prepass) {\n      publicAPI.render();\n    }\n  };\n\n  publicAPI.opaquePass = function (prepass) {\n    if (prepass) {\n      publicAPI.render();\n    }\n  };\n\n  publicAPI.render = function () {\n    model.renderable.update();\n    model.currentInput = model.renderable.getInputData();\n    publicAPI.prepareToDraw(model.WebGPURenderer.getRenderEncoder());\n    model.renderEncoder.registerDrawCallback(model.pipeline, publicAPI.draw);\n  };\n\n  publicAPI.computePipelineHash = function () {\n    var ext = model.currentInput.getExtent();\n\n    if (ext[0] === ext[1] || ext[2] === ext[3] || ext[4] === ext[5]) {\n      model.dimensions = 2;\n      model.pipelineHash = 'img2';\n    } else {\n      model.dimensions = 3;\n      model.pipelineHash = 'img3';\n    }\n  };\n\n  publicAPI.updateUBO = function () {\n    var utime = model.UBO.getSendTime();\n    var actor = model.WebGPUImageSlice.getRenderable();\n    var volMapr = actor.getMapper();\n\n    if (publicAPI.getMTime() > utime || model.renderable.getMTime() > utime || actor.getProperty().getMTime() > utime) {\n      // compute the SCTCMatrix\n      var image = volMapr.getInputData();\n      var center = model.WebGPURenderer.getStabilizedCenterByReference();\n      mat4.identity(tmpMat4);\n      mat4.translate(tmpMat4, tmpMat4, center); // tmpMat4 is now SC->World\n\n      var mcwcmat = actor.getMatrix();\n      mat4.transpose(tmp2Mat4, mcwcmat);\n      mat4.invert(tmp2Mat4, tmp2Mat4); // tmp2Mat4 is now world to model\n\n      mat4.multiply(tmpMat4, tmp2Mat4, tmpMat4); // tmp4Mat is now SC->Model\n      // the method on the data is world to index but the volume is in\n      // model coordinates so really in this context it is model to index\n\n      var modelToIndex = image.getWorldToIndex();\n      mat4.multiply(tmpMat4, modelToIndex, tmpMat4); // tmpMat4 is now SC -> Index, save this as we need it later\n\n      mat4.invert(tmp3Mat4, tmpMat4); // need translation and scale\n\n      mat4.fromTranslation(tmp2Mat4, [0.5, 0.5, 0.5]);\n      mat4.multiply(tmpMat4, tmp2Mat4, tmpMat4);\n      var dims = image.getDimensions();\n      mat4.identity(tmp2Mat4);\n      mat4.scale(tmp2Mat4, tmp2Mat4, [1.0 / dims[0], 1.0 / dims[1], 1.0 / dims[2]]);\n      mat4.multiply(tmpMat4, tmp2Mat4, tmpMat4); // tmpMat4 is now SC -> Tcoord\n\n      model.UBO.setArray('SCTCMatrix', tmpMat4); // need to compute the plane here in world coordinates\n      // then pass that down in the UBO\n\n      var ext = model.currentInput.getExtent(); // Find what IJK axis and what direction to slice along\n\n      var _model$renderable$get = model.renderable.getClosestIJKAxis(),\n          ijkMode = _model$renderable$get.ijkMode; // Find the IJK slice\n\n\n      var nSlice = model.renderable.getSlice();\n\n      if (ijkMode !== model.renderable.getSlicingMode()) {\n        // If not IJK slicing, get the IJK slice from the XYZ position/slice\n        nSlice = model.renderable.getSliceAtPosition(nSlice);\n      }\n\n      var axis0 = 2;\n      var axis1 = 0;\n      var axis2 = 1;\n\n      if (ijkMode === SlicingMode.I) {\n        axis0 = 0;\n        axis1 = 1;\n        axis2 = 2;\n      } else if (ijkMode === SlicingMode.J) {\n        axis0 = 1;\n        axis1 = 2;\n        axis2 = 0;\n      }\n\n      ptsArray1[axis0] = nSlice;\n      ptsArray1[axis1] = ext[axis1 * 2] - 0.5;\n      ptsArray1[axis2] = ext[axis2 * 2] - 0.5;\n      ptsArray1[3] = 1.0;\n      vec4.transformMat4(ptsArray1, ptsArray1, tmp3Mat4);\n      model.UBO.setArray('Origin', ptsArray1);\n      ptsArray2[axis0] = nSlice;\n      ptsArray2[axis1] = ext[axis1 * 2 + 1] + 0.5;\n      ptsArray2[axis2] = ext[axis2 * 2] - 0.5;\n      ptsArray2[3] = 1.0;\n      vec4.transformMat4(ptsArray2, ptsArray2, tmp3Mat4);\n      vec4.subtract(ptsArray2, ptsArray2, ptsArray1);\n      ptsArray2[3] = 1.0;\n      model.UBO.setArray('Axis1', ptsArray2);\n      ptsArray2[axis0] = nSlice;\n      ptsArray2[axis1] = ext[axis1 * 2] - 0.5;\n      ptsArray2[axis2] = ext[axis2 * 2 + 1] + 0.5;\n      ptsArray2[3] = 1.0;\n      vec4.transformMat4(ptsArray2, ptsArray2, tmp3Mat4);\n      vec4.subtract(ptsArray2, ptsArray2, ptsArray1);\n      ptsArray2[3] = 1.0;\n      model.UBO.setArray('Axis2', ptsArray2); // three levels of shift scale combined into one\n      // for performance in the fragment shader\n\n      var cScale = [1, 1, 1, 1];\n      var cShift = [0, 0, 0, 0];\n      var tView = model.textureViews[0];\n      var tScale = tView.getTexture().getScale();\n      var numComp = tView.getTexture().getNumberOfComponents();\n      var iComps = false; // todo handle independent?\n\n      for (var i = 0; i < numComp; i++) {\n        var cw = actor.getProperty().getColorWindow();\n        var cl = actor.getProperty().getColorLevel();\n        var target = iComps ? i : 0;\n        var cfun = actor.getProperty().getRGBTransferFunction(target);\n\n        if (cfun) {\n          var cRange = cfun.getRange();\n          cw = cRange[1] - cRange[0];\n          cl = 0.5 * (cRange[1] + cRange[0]);\n        }\n\n        cScale[i] = tScale / cw;\n        cShift[i] = -cl / cw + 0.5;\n      }\n\n      model.UBO.setArray('cScale', cScale);\n      model.UBO.setArray('cShift', cShift);\n      model.UBO.sendIfNeeded(model.device);\n    }\n  };\n\n  publicAPI.updateLUTImage = function () {\n    var actorProperty = model.WebGPUImageSlice.getRenderable().getProperty();\n    var tView = publicAPI.getTextureViews()[0];\n    tView.getTexture().getNumberOfComponents();\n\n    var numIComps = 1;\n    var cfunToString = computeFnToString(actorProperty, actorProperty.getRGBTransferFunction, numIComps);\n\n    if (model.colorTextureString !== cfunToString) {\n      model.numRows = numIComps;\n      var colorArray = new Uint8Array(model.numRows * 2 * model.rowLength * 4);\n      var cfun = actorProperty.getRGBTransferFunction();\n\n      if (cfun) {\n        var tmpTable = new Float32Array(model.rowLength * 3);\n\n        for (var c = 0; c < numIComps; c++) {\n          cfun = actorProperty.getRGBTransferFunction(c);\n          var cRange = cfun.getRange();\n          cfun.getTable(cRange[0], cRange[1], model.rowLength, tmpTable, 1);\n\n          {\n            for (var _i = 0; _i < model.rowLength; _i++) {\n              var _idx = c * model.rowLength * 8 + _i * 4;\n\n              colorArray[_idx] = 255.0 * tmpTable[_i * 3];\n              colorArray[_idx + 1] = 255.0 * tmpTable[_i * 3 + 1];\n              colorArray[_idx + 2] = 255.0 * tmpTable[_i * 3 + 2];\n              colorArray[_idx + 3] = 255.0;\n\n              for (var _j = 0; _j < 4; _j++) {\n                colorArray[_idx + model.rowLength * 4 + _j] = colorArray[_idx + _j];\n              }\n            }\n          }\n        }\n      } else {\n        for (var _i2 = 0; _i2 < model.rowLength; ++_i2) {\n          var grey = 255.0 * _i2 / (model.rowLength - 1);\n          colorArray[_i2 * 4] = grey;\n          colorArray[_i2 * 4 + 1] = grey;\n          colorArray[_i2 * 4 + 2] = grey;\n          colorArray[_i2 * 4 + 3] = 255.0;\n\n          for (var _j2 = 0; _j2 < 4; _j2++) {\n            colorArray[_i2 * 4 + model.rowLength * 4 + _j2] = colorArray[_i2 * 4 + _j2];\n          }\n        }\n      }\n\n      {\n        var treq = {\n          nativeArray: colorArray,\n          width: model.rowLength,\n          height: model.numRows * 2,\n          depth: 1,\n          format: 'rgba8unorm'\n        };\n        var newTex = model.device.getTextureManager().getTexture(treq);\n        var tview = newTex.createView('tfunTexture');\n        model.textureViews[1] = tview;\n      }\n      model.colorTextureString = cfunToString;\n    }\n  };\n\n  var superClassUpdateBuffers = publicAPI.updateBuffers;\n\n  publicAPI.updateBuffers = function () {\n    superClassUpdateBuffers();\n    var newTex = model.device.getTextureManager().getTextureForImageData(model.currentInput);\n    var tViews = model.textureViews;\n\n    if (!tViews[0] || tViews[0].getTexture() !== newTex) {\n      var tview = newTex.createView('imgTexture');\n      tViews[0] = tview;\n    }\n\n    publicAPI.updateLUTImage();\n    publicAPI.updateUBO(); // set interpolation on the texture based on property setting\n\n    var actorProperty = model.WebGPUImageSlice.getRenderable().getProperty();\n    var iType = actorProperty.getInterpolationType() === InterpolationType.NEAREST ? 'nearest' : 'linear';\n\n    if (!model.clampSampler || iType !== model.clampSampler.getOptions().minFilter) {\n      model.clampSampler = vtkWebGPUSampler.newInstance({\n        label: 'clampSampler'\n      });\n      model.clampSampler.create(model.device, {\n        minFilter: iType,\n        magFilter: iType\n      });\n      model.additionalBindables = [model.clampSampler];\n    }\n  };\n\n  var sr = publicAPI.getShaderReplacements();\n\n  publicAPI.replaceShaderPosition = function (hash, pipeline, vertexInput) {\n    var vDesc = pipeline.getShaderDescription('vertex');\n    vDesc.addBuiltinOutput('vec4<f32>', '@builtin(position) Position');\n    var code = vDesc.getCode();\n    var lines = ['var pos: vec4<f32> = mapperUBO.Origin +', '   (vertexBC.x * 0.5 + 0.5) * mapperUBO.Axis1 + (vertexBC.y * 0.5 + 0.5) * mapperUBO.Axis2;', 'pos.w = 1.0;'];\n\n    if (model.dimensions === 2) {\n      lines.push('var tcoord : vec2<f32> = (mapperUBO.SCTCMatrix * pos).xy;');\n    } else {\n      lines.push('var tcoord : vec3<f32> = (mapperUBO.SCTCMatrix * pos).xyz;');\n    }\n\n    lines.push('output.tcoordVS = tcoord;', 'output.Position = rendererUBO.SCPCMatrix * pos;');\n    code = vtkWebGPUShaderCache.substitute(code, '//VTK::Position::Impl', lines).result;\n    vDesc.setCode(code);\n  };\n\n  sr.set('replaceShaderPosition', publicAPI.replaceShaderPosition);\n\n  publicAPI.replaceShaderTCoord = function (hash, pipeline, vertexInput) {\n    var vDesc = pipeline.getShaderDescription('vertex');\n\n    if (model.dimensions === 2) {\n      vDesc.addOutput('vec2<f32>', 'tcoordVS');\n    } else {\n      vDesc.addOutput('vec3<f32>', 'tcoordVS');\n    }\n  };\n\n  sr.set('replaceShaderTCoord', publicAPI.replaceShaderTCoord);\n\n  publicAPI.replaceShaderImage = function (hash, pipeline, vertexInput) {\n    var fDesc = pipeline.getShaderDescription('fragment');\n    var code = fDesc.getCode();\n\n    if (model.dimensions === 3) {\n      code = vtkWebGPUShaderCache.substitute(code, '//VTK::Image::Sample', [\"    var computedColor: vec4<f32> =\", \"      textureSampleLevel(imgTexture, clampSampler, input.tcoordVS, 0.0);\", \"//VTK::Image::Sample\"]).result;\n    } else {\n      code = vtkWebGPUShaderCache.substitute(code, '//VTK::Image::Sample', [\"    var computedColor: vec4<f32> =\", \"      textureSampleLevel(imgTexture, clampSampler, input.tcoordVS, 0.0);\", \"//VTK::Image::Sample\"]).result;\n    }\n\n    code = vtkWebGPUShaderCache.substitute(code, '//VTK::Image::Sample', [\"    var coord: vec2<f32> =\", \"      vec2<f32>(computedColor.r * mapperUBO.cScale.r + mapperUBO.cShift.r, 0.5);\", \"    computedColor = textureSampleLevel(tfunTexture, clampSampler, coord, 0.0);\"]).result;\n    fDesc.setCode(code);\n  };\n\n  sr.set('replaceShaderImage', publicAPI.replaceShaderImage);\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\n\nvar DEFAULT_VALUES = {\n  rowLength: 1024\n}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Inheritance\n\n  vtkWebGPUFullScreenQuad.extend(publicAPI, model, initialValues);\n  publicAPI.setFragmentShaderTemplate(imgFragTemplate);\n  model.UBO = vtkWebGPUUniformBuffer.newInstance({\n    label: 'mapperUBO'\n  });\n  model.UBO.addEntry('SCTCMatrix', 'mat4x4<f32>');\n  model.UBO.addEntry('Origin', 'vec4<f32>');\n  model.UBO.addEntry('Axis2', 'vec4<f32>');\n  model.UBO.addEntry('Axis1', 'vec4<f32>');\n  model.UBO.addEntry('cScale', 'vec4<f32>');\n  model.UBO.addEntry('cShift', 'vec4<f32>');\n  model.lutBuildTime = {};\n  obj(model.lutBuildTime, {\n    mtime: 0\n  });\n  model.imagemat = mat4.identity(new Float64Array(16));\n  model.imagematinv = mat4.identity(new Float64Array(16));\n  model.VBOBuildTime = {};\n  obj(model.VBOBuildTime); // Object methods\n\n  vtkWebGPUImageMapper(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = newInstance$1(extend, 'vtkWebGPUImageMapper'); // ----------------------------------------------------------------------------\n\nvar index = {\n  newInstance: newInstance,\n  extend: extend\n}; // Register ourself to WebGPU backend if imported\n\nregisterOverride('vtkImageMapper', newInstance);\n\nexport { index as default, extend, newInstance };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}