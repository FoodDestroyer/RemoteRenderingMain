{"ast":null,"code":"import macro from '../../macros.js';\nimport vtkOpenGLFramebuffer from './Framebuffer.js';\nimport vtkRenderPass from '../SceneGraph/RenderPass.js';\nimport vtkDataArray from '../../Common/Core/DataArray.js';\nimport vtkHelper from './Helper.js';\nimport vtkVertexArrayObject from './VertexArrayObject.js';\nimport { Representation } from '../Core/Property/Constants.js';\nvar vtkErrorMacro = macro.vtkErrorMacro; // ----------------------------------------------------------------------------\n\nfunction vtkConvolution2DPass(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkConvolution2DPass');\n  publicAPI.computeKernelWeight = function computeKernelWeight(kernel) {\n    var weight = kernel.reduce(function (prev, curr) {\n      return prev + curr;\n    });\n    return weight <= 0 ? 1 : weight;\n  }; // handles post-processing via convolution kernel and call delegate\n\n  publicAPI.traverse = function (viewNode) {\n    if (model.deleted) {\n      return;\n    } // check if kernel dimension is valid\n\n    if (model.kernelDimension % 2 !== 1) {\n      vtkErrorMacro('Invalid kernel dimension! Kernel dimension must be odd (e.g. 3, 5, 7, ...).');\n      return;\n    } // if no kernel is set, use the default kernel (no post-processing)\n\n    if (model.kernel === null) {\n      model.kernel = new Float32Array(model.kernelDimension);\n      model.kernel[Math.floor(model.kernelDimension / 2)] = 1;\n    }\n    var kernelLength = model.kernelDimension * model.kernelDimension;\n    if (model.kernel.length !== kernelLength) {\n      vtkErrorMacro(\"The given kernel is invalid. 2D convolution kernels have to be 1D arrays with \".concat(kernelLength, \" components representing the \").concat(model.kernelDimension, \"x\").concat(model.kernelDimension, \" kernel in row-major form.\"));\n      return;\n    } // prepare framebuffer // allocate framebuffer if needed and bind it\n\n    if (model.framebuffer === null) {\n      model.framebuffer = vtkOpenGLFramebuffer.newInstance();\n    }\n    var size = viewNode.getSize();\n    var gl = viewNode.getContext();\n    if (gl === null) {\n      // nothing to do -> no render context\n      // traverse delegate passes -> has to be done in order for the vtk render-pipeline to work correctly\n      model.delegates.forEach(function (val) {\n        val.traverse(viewNode, publicAPI);\n      });\n      return;\n    } // prepare rendering\n\n    if (model.VBOBuildTime.getMTime() < publicAPI.getMTime()) {\n      model.tris.setOpenGLRenderWindow(viewNode);\n      publicAPI.buildVertexBuffer();\n    } // store framebuffer bindings to restore them later\n\n    model.framebuffer.setOpenGLRenderWindow(viewNode);\n    model.framebuffer.saveCurrentBindingsAndBuffers();\n    var fbSize = model.framebuffer.getSize();\n    if (fbSize === null || fbSize[0] !== size[0] || fbSize[1] !== size[1]) {\n      // create post-processing framebuffer if not already existing\n      model.framebuffer.create(size[0], size[1]);\n      model.framebuffer.populateFramebuffer();\n    } // bind framebuffer to re-direct the render-output of the delegate passes to the buffer\n\n    model.framebuffer.bind(); // do the delegate rendering\n\n    model.delegates.forEach(function (val) {\n      val.traverse(viewNode, publicAPI);\n    }); // now draw the convolved values\n\n    model.framebuffer.restorePreviousBindingsAndBuffers(); // check if kernel dimension has changed and convolution shader needs to be re-compiled\n\n    if (model.convolutionShader !== null && model.oldKernelDimension !== model.kernelDimension) {\n      model.convolutionShader = null;\n      model.oldKernelDimension = model.kernelDimension;\n    } // make sure the convolution shader is ready\n\n    if (model.convolutionShader === null) {\n      model.convolutionShader = viewNode.getShaderCache().readyShaderProgramArray(['//VTK::System::Dec', 'attribute vec4 vertexDC;', 'attribute vec2 tcoordTC;', 'varying vec2 tcoord;', 'void main() { tcoord = tcoordTC; gl_Position = vertexDC; }'].join('\\n'), publicAPI.getFragmentShaderCode(model.kernelDimension), '');\n      var program = model.convolutionShader; // prepare the vertex and triangle data for the image plane to render to\n\n      model.copyVAO = vtkVertexArrayObject.newInstance();\n      model.copyVAO.setOpenGLRenderWindow(viewNode);\n      model.tris.getCABO().bind();\n      if (!model.copyVAO.addAttributeArray(program, model.tris.getCABO(), 'vertexDC', model.tris.getCABO().getVertexOffset(), model.tris.getCABO().getStride(), gl.FLOAT, 3, gl.FALSE)) {\n        vtkErrorMacro('Error setting vertexDC in copy shader VAO.');\n      }\n      if (!model.copyVAO.addAttributeArray(program, model.tris.getCABO(), 'tcoordTC', model.tris.getCABO().getTCoordOffset(), model.tris.getCABO().getStride(), gl.FLOAT, 2, gl.FALSE)) {\n        vtkErrorMacro('Error setting vertexDC in copy shader VAO.');\n      }\n    } else {\n      viewNode.getShaderCache().readyShaderProgram(model.convolutionShader);\n    }\n    gl.viewport(0, 0, size[0], size[1]);\n    gl.scissor(0, 0, size[0], size[1]); // activate texture\n\n    var tex = model.framebuffer.getColorTexture();\n    tex.activate();\n    model.convolutionShader.setUniformi('u_image', tex.getTextureUnit());\n    model.convolutionShader.setUniform2f('u_textureSize', tex.getWidth(), tex.getHeight());\n    model.convolutionShader.setUniformfv('u_kernel', model.kernel);\n    model.convolutionShader.setUniformf('u_kernelWeight', publicAPI.computeKernelWeight(model.kernel)); // render quad\n\n    gl.drawArrays(gl.TRIANGLES, 0, model.tris.getCABO().getElementCount());\n    tex.deactivate();\n  };\n  publicAPI.getFragmentShaderCode = function (kernelDimension) {\n    // generate new shader code\n    var kernelLength = kernelDimension * kernelDimension;\n    var shaderCode = ['//VTK::System::Dec', '//VTK::Output::Dec', 'uniform sampler2D u_image;', 'uniform vec2 u_textureSize;', \"uniform float u_kernel[\".concat(kernelLength, \"];\"), 'uniform float u_kernelWeight;', 'varying vec2 tcoord;', 'void main(){', '    vec2 onePixel = vec2(1.0, 1.0) / u_textureSize;', '    vec4 colorSum =\\n'].join('\\n');\n    var halfDim = Math.floor(kernelDimension / 2); // generate sum per pixel\n\n    var i = 0;\n    for (var y = -halfDim; y <= halfDim; ++y) {\n      for (var x = -halfDim; x <= halfDim; ++x) {\n        shaderCode += \"        texture2D(u_image, tcoord + onePixel * vec2(\".concat(x, \", \").concat(y, \")) * u_kernel[\").concat(i, \"]\");\n        ++i;\n        if (i !== kernelLength) {\n          shaderCode += ' +\\n';\n        }\n      }\n    } // finish code\n\n    shaderCode += [';', '    gl_FragData[0] = vec4((colorSum / u_kernelWeight).rgb, texture2D(u_image, tcoord).a);', '}'].join('\\n');\n    return shaderCode;\n  }; // build vertices etc\n\n  publicAPI.buildVertexBuffer = function () {\n    // 4 corner points in clipping space in order (x, y, z) where z is always set to -1\n    // prettier-ignore\n    var ptsArray = new Float32Array([-1, -1, -1, 1, -1, -1, -1, 1, -1, 1, 1, -1]); // 4 corresponding corner points in texture space in order (x, y)\n\n    var tcoordArray = new Float32Array([0, 0, 1, 0, 0, 1, 1, 1]); // a square defined as cell relation ship in order (cell_size, v1, v2, v3, v4)\n\n    var cellArray = new Uint16Array([4, 0, 1, 3, 2]);\n    var points = vtkDataArray.newInstance({\n      numberOfComponents: 3,\n      values: ptsArray\n    });\n    points.setName('points');\n    var tcoords = vtkDataArray.newInstance({\n      numberOfComponents: 2,\n      values: tcoordArray\n    });\n    tcoords.setName('tcoords');\n    var cells = vtkDataArray.newInstance({\n      numberOfComponents: 1,\n      values: cellArray\n    });\n    model.tris.getCABO().createVBO(cells, 'polys', Representation.SURFACE, {\n      points: points,\n      tcoords: tcoords,\n      cellOffset: 0\n    });\n    model.VBOBuildTime.modified();\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nvar DEFAULT_VALUES = {\n  framebuffer: null,\n  convolutionShader: null,\n  tris: null,\n  kernel: [0, 0, 0, 0, 1, 0, 0, 0, 0],\n  oldKernelDimension: 3,\n  kernelDimension: 3\n}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Build VTK API\n\n  vtkRenderPass.extend(publicAPI, model, initialValues);\n  model.VBOBuildTime = {};\n  macro.obj(model.VBOBuildTime, {\n    mtime: 0\n  });\n  model.tris = vtkHelper.newInstance();\n  macro.setGet(publicAPI, model, ['kernel', 'kernelDimension']);\n  macro.get(publicAPI, model, ['framebuffer']); // Object methods\n\n  vtkConvolution2DPass(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = macro.newInstance(extend, 'vtkConvolution2DPass'); // ----------------------------------------------------------------------------\n\nvar vtkConvolution2DPass$1 = {\n  newInstance: newInstance,\n  extend: extend\n};\nexport { vtkConvolution2DPass$1 as default, extend, newInstance };","map":{"version":3,"names":["macro","vtkOpenGLFramebuffer","vtkRenderPass","vtkDataArray","vtkHelper","vtkVertexArrayObject","Representation","vtkErrorMacro","vtkConvolution2DPass","publicAPI","model","classHierarchy","push","computeKernelWeight","kernel","weight","reduce","prev","curr","traverse","viewNode","deleted","kernelDimension","Float32Array","Math","floor","kernelLength","length","concat","framebuffer","newInstance","size","getSize","gl","getContext","delegates","forEach","val","VBOBuildTime","getMTime","tris","setOpenGLRenderWindow","buildVertexBuffer","saveCurrentBindingsAndBuffers","fbSize","create","populateFramebuffer","bind","restorePreviousBindingsAndBuffers","convolutionShader","oldKernelDimension","getShaderCache","readyShaderProgramArray","join","getFragmentShaderCode","program","copyVAO","getCABO","addAttributeArray","getVertexOffset","getStride","FLOAT","FALSE","getTCoordOffset","readyShaderProgram","viewport","scissor","tex","getColorTexture","activate","setUniformi","getTextureUnit","setUniform2f","getWidth","getHeight","setUniformfv","setUniformf","drawArrays","TRIANGLES","getElementCount","deactivate","shaderCode","halfDim","i","y","x","ptsArray","tcoordArray","cellArray","Uint16Array","points","numberOfComponents","values","setName","tcoords","cells","createVBO","SURFACE","cellOffset","modified","DEFAULT_VALUES","extend","initialValues","arguments","undefined","Object","assign","obj","mtime","setGet","get","vtkConvolution2DPass$1","default"],"sources":["/home/rakshith/Documents/RemoteRendering/vtk-js-react-app/node_modules/@kitware/vtk.js/Rendering/OpenGL/Convolution2DPass.js"],"sourcesContent":["import macro from '../../macros.js';\nimport vtkOpenGLFramebuffer from './Framebuffer.js';\nimport vtkRenderPass from '../SceneGraph/RenderPass.js';\nimport vtkDataArray from '../../Common/Core/DataArray.js';\nimport vtkHelper from './Helper.js';\nimport vtkVertexArrayObject from './VertexArrayObject.js';\nimport { Representation } from '../Core/Property/Constants.js';\n\nvar vtkErrorMacro = macro.vtkErrorMacro; // ----------------------------------------------------------------------------\n\nfunction vtkConvolution2DPass(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkConvolution2DPass');\n\n  publicAPI.computeKernelWeight = function computeKernelWeight(kernel) {\n    var weight = kernel.reduce(function (prev, curr) {\n      return prev + curr;\n    });\n    return weight <= 0 ? 1 : weight;\n  }; // handles post-processing via convolution kernel and call delegate\n\n\n  publicAPI.traverse = function (viewNode) {\n\n    if (model.deleted) {\n      return;\n    } // check if kernel dimension is valid\n\n\n    if (model.kernelDimension % 2 !== 1) {\n      vtkErrorMacro('Invalid kernel dimension! Kernel dimension must be odd (e.g. 3, 5, 7, ...).');\n      return;\n    } // if no kernel is set, use the default kernel (no post-processing)\n\n\n    if (model.kernel === null) {\n      model.kernel = new Float32Array(model.kernelDimension);\n      model.kernel[Math.floor(model.kernelDimension / 2)] = 1;\n    }\n\n    var kernelLength = model.kernelDimension * model.kernelDimension;\n\n    if (model.kernel.length !== kernelLength) {\n      vtkErrorMacro(\"The given kernel is invalid. 2D convolution kernels have to be 1D arrays with \".concat(kernelLength, \" components representing the \").concat(model.kernelDimension, \"x\").concat(model.kernelDimension, \" kernel in row-major form.\"));\n      return;\n    } // prepare framebuffer // allocate framebuffer if needed and bind it\n\n\n    if (model.framebuffer === null) {\n      model.framebuffer = vtkOpenGLFramebuffer.newInstance();\n    }\n\n    var size = viewNode.getSize();\n    var gl = viewNode.getContext();\n\n    if (gl === null) {\n      // nothing to do -> no render context\n      // traverse delegate passes -> has to be done in order for the vtk render-pipeline to work correctly\n      model.delegates.forEach(function (val) {\n        val.traverse(viewNode, publicAPI);\n      });\n      return;\n    } // prepare rendering\n\n\n    if (model.VBOBuildTime.getMTime() < publicAPI.getMTime()) {\n      model.tris.setOpenGLRenderWindow(viewNode);\n      publicAPI.buildVertexBuffer();\n    } // store framebuffer bindings to restore them later\n\n\n    model.framebuffer.setOpenGLRenderWindow(viewNode);\n    model.framebuffer.saveCurrentBindingsAndBuffers();\n    var fbSize = model.framebuffer.getSize();\n\n    if (fbSize === null || fbSize[0] !== size[0] || fbSize[1] !== size[1]) {\n      // create post-processing framebuffer if not already existing\n      model.framebuffer.create(size[0], size[1]);\n      model.framebuffer.populateFramebuffer();\n    } // bind framebuffer to re-direct the render-output of the delegate passes to the buffer\n\n\n    model.framebuffer.bind(); // do the delegate rendering\n\n    model.delegates.forEach(function (val) {\n      val.traverse(viewNode, publicAPI);\n    }); // now draw the convolved values\n\n    model.framebuffer.restorePreviousBindingsAndBuffers(); // check if kernel dimension has changed and convolution shader needs to be re-compiled\n\n    if (model.convolutionShader !== null && model.oldKernelDimension !== model.kernelDimension) {\n      model.convolutionShader = null;\n      model.oldKernelDimension = model.kernelDimension;\n    } // make sure the convolution shader is ready\n\n\n    if (model.convolutionShader === null) {\n      model.convolutionShader = viewNode.getShaderCache().readyShaderProgramArray(['//VTK::System::Dec', 'attribute vec4 vertexDC;', 'attribute vec2 tcoordTC;', 'varying vec2 tcoord;', 'void main() { tcoord = tcoordTC; gl_Position = vertexDC; }'].join('\\n'), publicAPI.getFragmentShaderCode(model.kernelDimension), '');\n      var program = model.convolutionShader; // prepare the vertex and triangle data for the image plane to render to\n\n      model.copyVAO = vtkVertexArrayObject.newInstance();\n      model.copyVAO.setOpenGLRenderWindow(viewNode);\n      model.tris.getCABO().bind();\n\n      if (!model.copyVAO.addAttributeArray(program, model.tris.getCABO(), 'vertexDC', model.tris.getCABO().getVertexOffset(), model.tris.getCABO().getStride(), gl.FLOAT, 3, gl.FALSE)) {\n        vtkErrorMacro('Error setting vertexDC in copy shader VAO.');\n      }\n\n      if (!model.copyVAO.addAttributeArray(program, model.tris.getCABO(), 'tcoordTC', model.tris.getCABO().getTCoordOffset(), model.tris.getCABO().getStride(), gl.FLOAT, 2, gl.FALSE)) {\n        vtkErrorMacro('Error setting vertexDC in copy shader VAO.');\n      }\n    } else {\n      viewNode.getShaderCache().readyShaderProgram(model.convolutionShader);\n    }\n\n    gl.viewport(0, 0, size[0], size[1]);\n    gl.scissor(0, 0, size[0], size[1]); // activate texture\n\n    var tex = model.framebuffer.getColorTexture();\n    tex.activate();\n    model.convolutionShader.setUniformi('u_image', tex.getTextureUnit());\n    model.convolutionShader.setUniform2f('u_textureSize', tex.getWidth(), tex.getHeight());\n    model.convolutionShader.setUniformfv('u_kernel', model.kernel);\n    model.convolutionShader.setUniformf('u_kernelWeight', publicAPI.computeKernelWeight(model.kernel)); // render quad\n\n    gl.drawArrays(gl.TRIANGLES, 0, model.tris.getCABO().getElementCount());\n    tex.deactivate();\n  };\n\n  publicAPI.getFragmentShaderCode = function (kernelDimension) {\n    // generate new shader code\n    var kernelLength = kernelDimension * kernelDimension;\n    var shaderCode = ['//VTK::System::Dec', '//VTK::Output::Dec', 'uniform sampler2D u_image;', 'uniform vec2 u_textureSize;', \"uniform float u_kernel[\".concat(kernelLength, \"];\"), 'uniform float u_kernelWeight;', 'varying vec2 tcoord;', 'void main(){', '    vec2 onePixel = vec2(1.0, 1.0) / u_textureSize;', '    vec4 colorSum =\\n'].join('\\n');\n    var halfDim = Math.floor(kernelDimension / 2); // generate sum per pixel\n\n    var i = 0;\n\n    for (var y = -halfDim; y <= halfDim; ++y) {\n      for (var x = -halfDim; x <= halfDim; ++x) {\n        shaderCode += \"        texture2D(u_image, tcoord + onePixel * vec2(\".concat(x, \", \").concat(y, \")) * u_kernel[\").concat(i, \"]\");\n        ++i;\n\n        if (i !== kernelLength) {\n          shaderCode += ' +\\n';\n        }\n      }\n    } // finish code\n\n\n    shaderCode += [';', '    gl_FragData[0] = vec4((colorSum / u_kernelWeight).rgb, texture2D(u_image, tcoord).a);', '}'].join('\\n');\n    return shaderCode;\n  }; // build vertices etc\n\n\n  publicAPI.buildVertexBuffer = function () {\n    // 4 corner points in clipping space in order (x, y, z) where z is always set to -1\n    // prettier-ignore\n    var ptsArray = new Float32Array([-1, -1, -1, 1, -1, -1, -1, 1, -1, 1, 1, -1]); // 4 corresponding corner points in texture space in order (x, y)\n\n    var tcoordArray = new Float32Array([0, 0, 1, 0, 0, 1, 1, 1]); // a square defined as cell relation ship in order (cell_size, v1, v2, v3, v4)\n\n    var cellArray = new Uint16Array([4, 0, 1, 3, 2]);\n    var points = vtkDataArray.newInstance({\n      numberOfComponents: 3,\n      values: ptsArray\n    });\n    points.setName('points');\n    var tcoords = vtkDataArray.newInstance({\n      numberOfComponents: 2,\n      values: tcoordArray\n    });\n    tcoords.setName('tcoords');\n    var cells = vtkDataArray.newInstance({\n      numberOfComponents: 1,\n      values: cellArray\n    });\n    model.tris.getCABO().createVBO(cells, 'polys', Representation.SURFACE, {\n      points: points,\n      tcoords: tcoords,\n      cellOffset: 0\n    });\n    model.VBOBuildTime.modified();\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\n\nvar DEFAULT_VALUES = {\n  framebuffer: null,\n  convolutionShader: null,\n  tris: null,\n  kernel: [0, 0, 0, 0, 1, 0, 0, 0, 0],\n  oldKernelDimension: 3,\n  kernelDimension: 3\n}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Build VTK API\n\n  vtkRenderPass.extend(publicAPI, model, initialValues);\n  model.VBOBuildTime = {};\n  macro.obj(model.VBOBuildTime, {\n    mtime: 0\n  });\n  model.tris = vtkHelper.newInstance();\n  macro.setGet(publicAPI, model, ['kernel', 'kernelDimension']);\n  macro.get(publicAPI, model, ['framebuffer']); // Object methods\n\n  vtkConvolution2DPass(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = macro.newInstance(extend, 'vtkConvolution2DPass'); // ----------------------------------------------------------------------------\n\nvar vtkConvolution2DPass$1 = {\n  newInstance: newInstance,\n  extend: extend\n};\n\nexport { vtkConvolution2DPass$1 as default, extend, newInstance };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}