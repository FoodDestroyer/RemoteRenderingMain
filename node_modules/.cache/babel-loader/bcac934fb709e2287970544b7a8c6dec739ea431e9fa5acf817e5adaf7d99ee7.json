{"ast":null,"code":"import { newInstance as newInstance$1, obj, setGet } from '../../macros.js';\nimport vtkWebGPUTypes from './Types.js';\nfunction arraysEqual(a, b) {\n  if (a === b) return true;\n  if (a == null || b == null) return false;\n  if (a.length !== b.length) return false;\n  for (var i = 0; i < a.length; ++i) {\n    if (!b.includes(a[i])) return false;\n  }\n  return true;\n} // ----------------------------------------------------------------------------\n// vtkWebGPUVertexInput methods\n// ----------------------------------------------------------------------------\n\nfunction vtkWebGPUVertexInput(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkWebGPUVertexInput');\n  publicAPI.addBuffer = function (buffer, inames) {\n    var stepMode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'vertex';\n    var names = inames;\n    if (!Array.isArray(names)) {\n      names = [names];\n    } // only add if it is a new setting\n\n    for (var i = 0; i < model.inputs.length; i++) {\n      if (arraysEqual(model.inputs[i].names, names)) {\n        if (model.inputs[i].buffer === buffer) {\n          return;\n        }\n        model.inputs[i].buffer = buffer;\n        return;\n      }\n    } // when adding a new entry, make sure we sort the array\n    // as the order is important to the shader and must always\n    // be the same, so alphabetical is an easy option\n\n    model.inputs.push({\n      buffer: buffer,\n      stepMode: stepMode,\n      names: names\n    });\n    model.inputs = model.inputs.sort(function (v1, v2) {\n      if (v1.names[0] < v2.names[0]) {\n        return -1;\n      }\n      if (v1.names[0] > v2.names[0]) {\n        return 1;\n      }\n      return 0;\n    });\n  };\n  publicAPI.removeBufferIfPresent = function (name) {\n    for (var i = 0; i < model.inputs.length; i++) {\n      if (model.inputs[i].names.includes(name)) {\n        model.inputs.splice(i, 1);\n      }\n    }\n  };\n  publicAPI.getBuffer = function (name) {\n    for (var i = 0; i < model.inputs.length; i++) {\n      if (model.inputs[i].names.includes(name)) {\n        return model.inputs[i].buffer;\n      }\n    }\n    return null;\n  };\n  publicAPI.hasAttribute = function (name) {\n    for (var i = 0; i < model.inputs.length; i++) {\n      if (model.inputs[i].names.includes(name)) {\n        return true;\n      }\n    }\n    return false;\n  };\n  publicAPI.getAttributeTime = function (name) {\n    for (var i = 0; i < model.inputs.length; i++) {\n      if (model.inputs[i].names.includes(name)) {\n        return model.inputs[i].buffer.getSourceTime();\n      }\n    }\n    return 0;\n  };\n  publicAPI.getShaderCode = function () {\n    var result = '';\n    var nameCount = 0;\n    for (var i = 0; i < model.inputs.length; i++) {\n      for (var nm = 0; nm < model.inputs[i].names.length; nm++) {\n        var arrayInfo = model.inputs[i].buffer.getArrayInformation()[nm];\n        var type = vtkWebGPUTypes.getShaderTypeFromBufferFormat(arrayInfo.format);\n        if (nameCount > 0) {\n          result += ',\\n';\n        }\n        result = \"\".concat(result, \"  @location(\").concat(nameCount, \") \").concat(model.inputs[i].names[nm], \" : \").concat(type);\n        nameCount++;\n      }\n    }\n    return result;\n  };\n  publicAPI.getVertexInputInformation = function () {\n    var info = {};\n    if (model.inputs.length) {\n      var vertexBuffers = [];\n      var nameCount = 0;\n      for (var i = 0; i < model.inputs.length; i++) {\n        var buf = model.inputs[i].buffer;\n        var buffer = {\n          arrayStride: buf.getStrideInBytes(),\n          stepMode: model.inputs[i].stepMode,\n          attributes: []\n        };\n        var arrayInfo = buf.getArrayInformation();\n        for (var nm = 0; nm < model.inputs[i].names.length; nm++) {\n          buffer.attributes.push({\n            shaderLocation: nameCount,\n            offset: arrayInfo[nm].offset,\n            format: arrayInfo[nm].format\n          });\n          nameCount++;\n        }\n        vertexBuffers.push(buffer);\n      }\n      info.buffers = vertexBuffers;\n    }\n    return info;\n  };\n  publicAPI.bindBuffers = function (renderEncoder) {\n    for (var i = 0; i < model.inputs.length; i++) {\n      renderEncoder.setVertexBuffer(i, model.inputs[i].buffer.getHandle());\n    }\n    if (model.indexBuffer) {\n      renderEncoder.setIndexBuffer(model.indexBuffer.getHandle(), model.indexBuffer.getArrayInformation()[0].format);\n    }\n  };\n  publicAPI.getReady = function () {};\n  publicAPI.releaseGraphicsResources = function () {\n    if (model.created) {\n      model.inputs = [];\n      model.bindingDescriptions = [];\n      model.attributeDescriptions = [];\n    }\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nvar DEFAULT_VALUES = {\n  inputs: null,\n  bindingDescriptions: false,\n  attributeDescriptions: null,\n  indexBuffer: null\n}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Build VTK API\n\n  obj(publicAPI, model);\n  model.bindingDescriptions = [];\n  model.attributeDescriptions = [];\n  model.inputs = [];\n  setGet(publicAPI, model, ['created', 'device', 'handle', 'indexBuffer']); // For more macro methods, see \"Sources/macros.js\"\n  // Object specific methods\n\n  vtkWebGPUVertexInput(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = newInstance$1(extend, 'vtkWebGPUVertexInput'); // ----------------------------------------------------------------------------\n\nvar vtkWebGPUVertexInput$1 = {\n  newInstance: newInstance,\n  extend: extend\n};\nexport { vtkWebGPUVertexInput$1 as default, extend, newInstance };","map":{"version":3,"names":["newInstance","newInstance$1","obj","setGet","vtkWebGPUTypes","arraysEqual","a","b","length","i","includes","vtkWebGPUVertexInput","publicAPI","model","classHierarchy","push","addBuffer","buffer","inames","stepMode","arguments","undefined","names","Array","isArray","inputs","sort","v1","v2","removeBufferIfPresent","name","splice","getBuffer","hasAttribute","getAttributeTime","getSourceTime","getShaderCode","result","nameCount","nm","arrayInfo","getArrayInformation","type","getShaderTypeFromBufferFormat","format","concat","getVertexInputInformation","info","vertexBuffers","buf","arrayStride","getStrideInBytes","attributes","shaderLocation","offset","buffers","bindBuffers","renderEncoder","setVertexBuffer","getHandle","indexBuffer","setIndexBuffer","getReady","releaseGraphicsResources","created","bindingDescriptions","attributeDescriptions","DEFAULT_VALUES","extend","initialValues","Object","assign","vtkWebGPUVertexInput$1","default"],"sources":["/home/rakshith/Documents/RemoteRendering/vtk-js-react-app/node_modules/@kitware/vtk.js/Rendering/WebGPU/VertexInput.js"],"sourcesContent":["import { newInstance as newInstance$1, obj, setGet } from '../../macros.js';\nimport vtkWebGPUTypes from './Types.js';\n\nfunction arraysEqual(a, b) {\n  if (a === b) return true;\n  if (a == null || b == null) return false;\n  if (a.length !== b.length) return false;\n\n  for (var i = 0; i < a.length; ++i) {\n    if (!b.includes(a[i])) return false;\n  }\n\n  return true;\n} // ----------------------------------------------------------------------------\n// vtkWebGPUVertexInput methods\n// ----------------------------------------------------------------------------\n\n\nfunction vtkWebGPUVertexInput(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkWebGPUVertexInput');\n\n  publicAPI.addBuffer = function (buffer, inames) {\n    var stepMode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'vertex';\n    var names = inames;\n\n    if (!Array.isArray(names)) {\n      names = [names];\n    } // only add if it is a new setting\n\n\n    for (var i = 0; i < model.inputs.length; i++) {\n      if (arraysEqual(model.inputs[i].names, names)) {\n        if (model.inputs[i].buffer === buffer) {\n          return;\n        }\n\n        model.inputs[i].buffer = buffer;\n        return;\n      }\n    } // when adding a new entry, make sure we sort the array\n    // as the order is important to the shader and must always\n    // be the same, so alphabetical is an easy option\n\n\n    model.inputs.push({\n      buffer: buffer,\n      stepMode: stepMode,\n      names: names\n    });\n    model.inputs = model.inputs.sort(function (v1, v2) {\n      if (v1.names[0] < v2.names[0]) {\n        return -1;\n      }\n\n      if (v1.names[0] > v2.names[0]) {\n        return 1;\n      }\n\n      return 0;\n    });\n  };\n\n  publicAPI.removeBufferIfPresent = function (name) {\n    for (var i = 0; i < model.inputs.length; i++) {\n      if (model.inputs[i].names.includes(name)) {\n        model.inputs.splice(i, 1);\n      }\n    }\n  };\n\n  publicAPI.getBuffer = function (name) {\n    for (var i = 0; i < model.inputs.length; i++) {\n      if (model.inputs[i].names.includes(name)) {\n        return model.inputs[i].buffer;\n      }\n    }\n\n    return null;\n  };\n\n  publicAPI.hasAttribute = function (name) {\n    for (var i = 0; i < model.inputs.length; i++) {\n      if (model.inputs[i].names.includes(name)) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n\n  publicAPI.getAttributeTime = function (name) {\n    for (var i = 0; i < model.inputs.length; i++) {\n      if (model.inputs[i].names.includes(name)) {\n        return model.inputs[i].buffer.getSourceTime();\n      }\n    }\n\n    return 0;\n  };\n\n  publicAPI.getShaderCode = function () {\n    var result = '';\n    var nameCount = 0;\n\n    for (var i = 0; i < model.inputs.length; i++) {\n      for (var nm = 0; nm < model.inputs[i].names.length; nm++) {\n        var arrayInfo = model.inputs[i].buffer.getArrayInformation()[nm];\n        var type = vtkWebGPUTypes.getShaderTypeFromBufferFormat(arrayInfo.format);\n\n        if (nameCount > 0) {\n          result += ',\\n';\n        }\n\n        result = \"\".concat(result, \"  @location(\").concat(nameCount, \") \").concat(model.inputs[i].names[nm], \" : \").concat(type);\n        nameCount++;\n      }\n    }\n\n    return result;\n  };\n\n  publicAPI.getVertexInputInformation = function () {\n    var info = {};\n\n    if (model.inputs.length) {\n      var vertexBuffers = [];\n      var nameCount = 0;\n\n      for (var i = 0; i < model.inputs.length; i++) {\n        var buf = model.inputs[i].buffer;\n        var buffer = {\n          arrayStride: buf.getStrideInBytes(),\n          stepMode: model.inputs[i].stepMode,\n          attributes: []\n        };\n        var arrayInfo = buf.getArrayInformation();\n\n        for (var nm = 0; nm < model.inputs[i].names.length; nm++) {\n          buffer.attributes.push({\n            shaderLocation: nameCount,\n            offset: arrayInfo[nm].offset,\n            format: arrayInfo[nm].format\n          });\n          nameCount++;\n        }\n\n        vertexBuffers.push(buffer);\n      }\n\n      info.buffers = vertexBuffers;\n    }\n\n    return info;\n  };\n\n  publicAPI.bindBuffers = function (renderEncoder) {\n    for (var i = 0; i < model.inputs.length; i++) {\n      renderEncoder.setVertexBuffer(i, model.inputs[i].buffer.getHandle());\n    }\n\n    if (model.indexBuffer) {\n      renderEncoder.setIndexBuffer(model.indexBuffer.getHandle(), model.indexBuffer.getArrayInformation()[0].format);\n    }\n  };\n\n  publicAPI.getReady = function () {};\n\n  publicAPI.releaseGraphicsResources = function () {\n    if (model.created) {\n      model.inputs = [];\n      model.bindingDescriptions = [];\n      model.attributeDescriptions = [];\n    }\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\n\nvar DEFAULT_VALUES = {\n  inputs: null,\n  bindingDescriptions: false,\n  attributeDescriptions: null,\n  indexBuffer: null\n}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Build VTK API\n\n  obj(publicAPI, model);\n  model.bindingDescriptions = [];\n  model.attributeDescriptions = [];\n  model.inputs = [];\n  setGet(publicAPI, model, ['created', 'device', 'handle', 'indexBuffer']); // For more macro methods, see \"Sources/macros.js\"\n  // Object specific methods\n\n  vtkWebGPUVertexInput(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = newInstance$1(extend, 'vtkWebGPUVertexInput'); // ----------------------------------------------------------------------------\n\nvar vtkWebGPUVertexInput$1 = {\n  newInstance: newInstance,\n  extend: extend\n};\n\nexport { vtkWebGPUVertexInput$1 as default, extend, newInstance };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}