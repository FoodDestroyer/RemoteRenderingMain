{"ast":null,"code":"import { mat3, mat4 } from 'gl-matrix';\nimport { newInstance as newInstance$1, setGet } from '../../macros.js';\nimport vtkMapper from '../Core/Mapper.js';\nimport vtkProp from '../Core/Prop.js';\nimport vtkProperty from '../Core/Property.js';\nimport vtkProperty2D from '../Core/Property2D.js';\nimport vtkTexture from '../Core/Texture.js';\nimport vtkWebGPUBufferManager from './BufferManager.js';\nimport vtkWebGPUShaderCache from './ShaderCache.js';\nimport vtkWebGPUUniformBuffer from './UniformBuffer.js';\nimport vtkWebGPUSimpleMapper from './SimpleMapper.js';\nimport vtkWebGPUTypes from './Types.js';\nvar BufferUsage = vtkWebGPUBufferManager.BufferUsage,\n  PrimitiveTypes = vtkWebGPUBufferManager.PrimitiveTypes;\nvar Representation = vtkProperty.Representation;\nvar ScalarMode = vtkMapper.ScalarMode;\nvar CoordinateSystem = vtkProp.CoordinateSystem;\nvar DisplayLocation = vtkProperty2D.DisplayLocation;\nvar vtkWebGPUPolyDataVS = \"\\n//VTK::Renderer::Dec\\n\\n//VTK::Color::Dec\\n\\n//VTK::Normal::Dec\\n\\n//VTK::TCoord::Dec\\n\\n//VTK::Select::Dec\\n\\n//VTK::Mapper::Dec\\n\\n//VTK::IOStructs::Dec\\n\\n@vertex\\nfn main(\\n//VTK::IOStructs::Input\\n)\\n//VTK::IOStructs::Output\\n{\\n  var output : vertexOutput;\\n\\n  var vertex: vec4<f32> = vertexBC;\\n\\n  //VTK::Color::Impl\\n\\n  //VTK::Normal::Impl\\n\\n  //VTK::TCoord::Impl\\n\\n  //VTK::Select::Impl\\n\\n  //VTK::Position::Impl\\n\\n  return output;\\n}\\n\";\nvar vtkWebGPUPolyDataFS = \"\\nstruct PBRData {\\n  diffuse: vec3<f32>,\\n  specular: vec3<f32>,\\n}\\n\\n// Dot product with the max already in it\\nfn mdot(a: vec3<f32>, b: vec3<f32>) -> f32 {\\n  return max(0.0, dot(a, b));\\n}\\n// Dot product with a max in it that does not allow for negative values\\n// Physically based rendering is accurate as long as normals are accurate,\\n// however this is pretty often not the case. In order to prevent negative\\n// values from ruining light calculations and creating zones of zero light,\\n// this remapping is used, which smoothly clamps the dot product between\\n// zero and one while still maintaining a good amount of accuracy.\\nfn cdot(a: vec3<f32>, b: vec3<f32>) -> f32 {\\n  var d: f32 = max(0.0, dot(a, b));\\n  d = pow((d + 1) / 2.0, 2.6);\\n  return d;\\n}\\n\\n// Lambertian diffuse model\\nfn lambertDiffuse(base: vec3<f32>, N: vec3<f32>, L: vec3<f32>) -> vec3<f32> {\\n  var pi: f32 = 3.14159265359; \\n  var NdotL: f32 = mdot(N, L);\\n  NdotL = pow(NdotL, 1.5);\\n  return (base/pi)*NdotL;\\n}\\n\\n// Yasuhiro Fujii improvement on the Oren-Nayar model\\n// https://mimosa-pudica.net/improved-oren-nayar.html\\n// p is surface color, o is roughness\\nfn fujiiOrenNayar(p: vec3<f32>, o: f32, N: vec3<f32>, L: vec3<f32>, V: vec3<f32>) -> vec3<f32> {\\n  var invpi: f32 = 0.31830988618; // 1/pi\\n\\n  var o2 = o*o;\\n  var NdotL: f32 = mdot(N, L);\\n  NdotL = pow(NdotL, 1.5); // Less physically accurate, but hides the \\\"seams\\\" between lights better\\n\\n  var NdotV: f32 = mdot(N, V);\\n  var LdotV: f32 = mdot(L, V);\\n\\n  var s: f32 = LdotV - NdotL*NdotV;\\n  var t: f32 = mix(1, max(NdotL, NdotV), step(0, s)); // Mix with step is the equivalent of an if statement\\n  var A: vec3<f32> = 0.5*(o2 / (o2 + 0.33)) + 0.17*p*(o2 / (o2 + 0.13));\\n  A = invpi*(1 - A);\\n  var B: f32 = 0.45*(o2 / (o2 + 0.09));\\n  B = invpi*B;\\n\\n  return p*NdotL*(A + B*(s/t));\\n}\\n\\n// Fresnel portion of BRDF (IOR only, simplified)\\nfn schlickFresnelIOR(V: vec3<f32>, N: vec3<f32>, ior: f32, k: f32) -> f32 {\\n  var NdotV: f32 = mdot(V, N);\\n  var F0: f32 = (pow((ior - 1.0), 2) + k*k) / (pow((ior + 1.0), 2) + k*k); // This takes into account the roughness, which the other one does not\\n  return F0 + (1 - F0) * pow((1-NdotV), 5); \\n}\\n\\n// Fresnel portion of BRDF (Color ior, better)\\nfn schlickFresnelRGB(V: vec3<f32>, N: vec3<f32>, F0: vec3<f32>) -> vec3<f32> {\\n  var NdotV: f32 = mdot(V, N);\\n  return F0 + (1 - F0) * pow((1-NdotV), 5); \\n}\\n\\n// Normal portion of BRDF\\n// https://learnopengl.com/PBR/Theory\\n// Trowbridge-Reitz GGX functions: normal, halfway, roughness^2\\nfn trGGX(N: vec3<f32>, H: vec3<f32>, a: f32) -> f32 {\\n  var pi: f32 = 3.14159265359; \\n\\n  var a2: f32 = a*a;\\n  var NdotH = mdot(N, H);\\n  var NdotH2 = NdotH*NdotH;\\n  \\n  var denom: f32 = NdotH2 * (a2 - 1.0) + 1.0;\\n\\n  return a2 / max((pi*denom*denom), 0.000001);\\n}\\n\\n// A VERY bad approximation of anisotropy. Real anisotropic calculations require tangent and bitangent\\nfn anisotrophicTrGGX(N: vec3<f32>, H: vec3<f32>, O: vec3<f32>, s: f32, a: f32) -> f32 {\\n  var Op: vec3<f32> = (rendererUBO.WCVCNormals * vec4<f32>(normalize(O) * s, 0.)).xyz;\\n\\n  var ggx1: f32 = trGGX(N + Op*s, H, a);\\n  var ggx2: f32 = trGGX(N - Op*s, H, a);\\n  return (0.5 * ggx1 + 0.5 * ggx2);\\n}\\n\\n// Geometry portion of BRDF\\nfn schlickGGX(N: vec3<f32>, X: vec3<f32>, k: f32) -> f32 {\\n  var NdotX = cdot(N, X);\\n  return NdotX / max(0.000001, (NdotX*(1-k) + k));\\n}\\n\\nfn smithSurfaceRoughness(N: vec3<f32>, V: vec3<f32>, L: vec3<f32>, k: f32) -> f32 {\\n  var ggx1: f32 = min(1, schlickGGX(N, V, k));\\n  var ggx2: f32 = min(1, schlickGGX(N, L, k));\\n  return ggx1*ggx2;\\n}\\n\\n// BRDF Combination\\nfn cookTorrance(D: f32, F: f32, G: f32, N: vec3<f32>, V: vec3<f32>, L: vec3<f32>) -> f32 {\\n  var num: f32 = D*F*G;\\n  var denom: f32 = 4*cdot(V, N)*cdot(L, N);\\n\\n  return num / max(denom, 0.000001);\\n}\\n\\n// Different lighting calculations for different light sources\\nfn calcDirectionalLight(N: vec3<f32>, V: vec3<f32>, ior: f32, roughness: f32, metallic: f32, direction: vec3<f32>, color: vec3<f32>, base: vec3<f32>) -> PBRData {  \\n  var L: vec3<f32> = normalize(direction); // Light Vector\\n  var H: vec3<f32> = normalize(L + V); // Halfway Vector\\n\\n  var alpha = roughness*roughness;\\n  var k: f32 = alpha*alpha / 2;\\n\\n  var D: f32 = trGGX(N, H, alpha); // Distribution\\n  // var F: f32 = schlickFresnelIOR(V, N, ior, k); // Fresnel\\n  var G: f32 = smithSurfaceRoughness(N, V, L, k); // Geometry\\n\\n  var brdf: f32 = cookTorrance(D, 1, G, N, V, L); // Fresnel term is replaced with 1 because it is added later\\n  var incoming: vec3<f32> = color;\\n  var angle: f32 = mdot(L, N);\\n  angle = pow(angle, 1.5);\\n\\n  var specular: vec3<f32> = brdf*incoming*angle;\\n  // Oren-Nayar gives a clay-like effect when fully rough which some people may not want, so it might be better to give a separate\\n  // control property for the diffuse vs specular roughness\\n  var diffuse: vec3<f32> = incoming*fujiiOrenNayar(base, roughness, N, L, V); \\n  // Stores the specular and diffuse separately to allow for finer post processing\\n  var out = PBRData(diffuse, specular);\\n  \\n  return out; // Returns angle along with color of light so the final color can be multiplied by angle as well (creates black areas)\\n}\\n\\n// TODO: find some way to reduce the number of arguments going in here\\nfn calcPointLight(N: vec3<f32>, V: vec3<f32>, fragPos: vec3<f32>, ior: f32, roughness: f32, metallic: f32, position: vec3<f32>, color: vec3<f32>, base: vec3<f32>) -> PBRData {\\n  var L: vec3<f32> = normalize(position - fragPos); // Light Vector\\n  var H: vec3<f32> = normalize(L + V); // Halfway Vector\\n  var dist = distance(position, fragPos);\\n\\n  var alpha = roughness*roughness;\\n  var k: f32 = alpha*alpha / 2; // could also be pow(alpha + 1.0, 2) / 8\\n\\n  var D: f32 = trGGX(N, H, alpha); // Distribution\\n  // var F: f32 = schlickFresnelIOR(V, N, ior, k); // Fresnel\\n  var G: f32 = smithSurfaceRoughness(N, V, L, k); // Geometry\\n\\n  var brdf: f32 = cookTorrance(D, 1, G, N, V, L);  \\n  var incoming: vec3<f32> = color * (1. / (dist*dist));\\n  var angle: f32 = mdot(L, N);\\n  angle = pow(angle, 1.5); // Smoothing factor makes it less accurate, but reduces ugly \\\"seams\\\" bewteen light sources\\n\\n  var specular: vec3<f32> = brdf*incoming*angle;\\n  var diffuse: vec3<f32> = incoming*fujiiOrenNayar(base, roughness, N, L, V);\\n\\n  // Stores the specular and diffuse separately to allow for finer post processing\\n  // Could also be done (propably more properly) with a struct\\n  var out = PBRData(diffuse, specular);\\n  \\n  return out; // Returns angle along with color of light so the final color can be multiplied by angle as well (creates black areas)\\n}\\n\\n// For a reason unknown to me, spheres dont seem to behave propperly with head-on spot lights\\nfn calcSpotLight(N: vec3<f32>, V: vec3<f32>, fragPos: vec3<f32>, ior: f32, roughness: f32, metallic: f32, position: vec3<f32>, direction: vec3<f32>, cones: vec2<f32>, color: vec3<f32>, base: vec3<f32>) -> PBRData {\\n  var L: vec3<f32> = normalize(position - fragPos);\\n  var H: vec3<f32> = normalize(L + V); // Halfway Vector\\n  var dist = distance(position, fragPos);\\n\\n  var alpha = roughness*roughness;\\n  var k: f32 = alpha*alpha / 2; // could also be pow(alpha + 1.0, 2) / 8\\n\\n  var D: f32 = trGGX(N, H, alpha); // Distribution\\n  // var F: f32 = schlickFresnelIOR(V, N, ior, k); // Fresnel\\n  var G: f32 = smithSurfaceRoughness(N, V, L, k); // Geometry\\n\\n  var brdf: f32 = cookTorrance(D, 1, G, N, V, L);  \\n  \\n  // Cones.x is the inner phi and cones.y is the outer phi\\n  var theta: f32 = mdot(normalize(direction), L);\\n  var epsilon: f32 = cones.x - cones.y;\\n  var intensity: f32 = (theta - cones.y) / epsilon;\\n  intensity = clamp(intensity, 0.0, 1.0);\\n  intensity /= dist*dist;\\n\\n  var incoming: vec3<f32> = color * intensity;\\n\\n  var angle: f32 = mdot(L, N);\\n  angle = pow(angle, 1.5); // Smoothing factor makes it less accurate, but reduces ugly \\\"seams\\\" bewteen light sources\\n\\n  var specular: vec3<f32> = brdf*incoming*angle;\\n  var diffuse: vec3<f32> = incoming*fujiiOrenNayar(base, roughness, N, L, V);\\n\\n  // Stores the specular and diffuse separately to allow for finer post processing\\n  // Could also be done (propably more properly) with a struct\\n  var out = PBRData(diffuse, specular);\\n  \\n  return out; // Returns angle along with color of light so the final color can be multiplied by angle as well (creates black areas)\\n}\\n\\n// Environment mapping stuff\\n// Takes in a vector and converts it to an equivalent coordinate in a rectilinear texture. Should be replaced with cubemaps at some point\\nfn vecToRectCoord(dir: vec3<f32>) -> vec2<f32> {\\n  var tau: f32 = 6.28318530718;\\n  var pi: f32 = 3.14159265359;\\n  var out: vec2<f32> = vec2<f32>(0.0);\\n\\n  out.x = atan2(dir.z, dir.x) / tau;\\n  out.x += 0.5;\\n\\n  var phix: f32 = length(vec2(dir.x, dir.z));\\n  out.y = atan2(dir.y, phix) / pi + 0.5;\\n\\n  return out;\\n}\\n\\n//VTK::Renderer::Dec\\n\\n//VTK::Color::Dec\\n\\n//VTK::TCoord::Dec\\n\\n// optional surface normal declaration\\n//VTK::Normal::Dec\\n\\n//VTK::Select::Dec\\n\\n//VTK::RenderEncoder::Dec\\n\\n//VTK::Mapper::Dec\\n\\n//VTK::IOStructs::Dec\\n\\n@fragment\\nfn main(\\n//VTK::IOStructs::Input\\n)\\n//VTK::IOStructs::Output\\n{\\n  var output : fragmentOutput;\\n\\n  // Temporary ambient, diffuse, and opacity\\n  var ambientColor: vec4<f32> = mapperUBO.AmbientColor;\\n  var diffuseColor: vec4<f32> = mapperUBO.DiffuseColor;\\n  var opacity: f32 = mapperUBO.Opacity;\\n\\n  // This should be declared somewhere else\\n  var _diffuseMap: vec4<f32> = vec4<f32>(1);\\n  var _roughnessMap: vec4<f32> = vec4<f32>(1);\\n  var _metallicMap: vec4<f32> = vec4<f32>(1);\\n  var _normalMap: vec4<f32> = vec4<f32>(0, 0, 1, 0); // normal map was setting off the normal vector detection in fragment\\n  var _ambientOcclusionMap: vec4<f32> = vec4<f32>(1);\\n  var _emissionMap: vec4<f32> = vec4<f32>(0);\\n\\n  //VTK::Color::Impl\\n\\n  //VTK::TCoord::Impl\\n\\n  //VTK::Normal::Impl\\n\\n  var computedColor: vec4<f32> = vec4<f32>(diffuseColor.rgb, 1.0);\\n\\n  //VTK::Light::Impl\\n\\n  //VTK::Select::Impl\\n\\n  if (computedColor.a == 0.0) { discard; };\\n\\n  //VTK::Position::Impl\\n\\n  //VTK::RenderEncoder::Impl\\n\\n  return output;\\n}\\n\";\nfunction isEdges(hash) {\n  // edge pipelines have \"edge\" in them\n  return hash.indexOf('edge') >= 0;\n} // ----------------------------------------------------------------------------\n// vtkWebGPUCellArrayMapper methods\n// ----------------------------------------------------------------------------\n\nfunction vtkWebGPUCellArrayMapper(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkWebGPUCellArrayMapper');\n  publicAPI.buildPass = function (prepass) {\n    if (prepass) {\n      if (model.is2D) {\n        model.WebGPUActor = publicAPI.getFirstAncestorOfType('vtkWebGPUActor2D');\n        model.forceZValue = true;\n      } else {\n        model.WebGPUActor = publicAPI.getFirstAncestorOfType('vtkWebGPUActor');\n        model.forceZValue = false;\n      }\n      model.coordinateSystem = model.WebGPUActor.getRenderable().getCoordinateSystem();\n      model.useRendererMatrix = model.coordinateSystem !== CoordinateSystem.DISPLAY;\n      model.WebGPURenderer = model.WebGPUActor.getFirstAncestorOfType('vtkWebGPURenderer');\n      model.WebGPURenderWindow = model.WebGPURenderer.getParent();\n      model.device = model.WebGPURenderWindow.getDevice();\n    }\n  }; // Renders myself\n\n  publicAPI.translucentPass = function (prepass) {\n    if (prepass) {\n      publicAPI.prepareToDraw(model.WebGPURenderer.getRenderEncoder());\n      model.renderEncoder.registerDrawCallback(model.pipeline, publicAPI.draw);\n    }\n  };\n  publicAPI.opaquePass = function (prepass) {\n    if (prepass) {\n      publicAPI.prepareToDraw(model.WebGPURenderer.getRenderEncoder());\n      model.renderEncoder.registerDrawCallback(model.pipeline, publicAPI.draw);\n    }\n  };\n  publicAPI.updateUBO = function () {\n    // make sure the data is up to date\n    var actor = model.WebGPUActor.getRenderable();\n    var ppty = actor.getProperty();\n    var utime = model.UBO.getSendTime();\n    if (publicAPI.getMTime() > utime || ppty.getMTime() > utime || model.renderable.getMTime() > utime) {\n      var _ppty$getEdgeColorByR;\n\n      // Matricies\n      var keyMats = model.WebGPUActor.getKeyMatrices(model.WebGPURenderer);\n      model.UBO.setArray('BCWCMatrix', keyMats.bcwc);\n      model.UBO.setArray('BCSCMatrix', keyMats.bcsc);\n      model.UBO.setArray('MCWCNormals', keyMats.normalMatrix);\n      if (model.is2D) {\n        model.UBO.setValue('ZValue', model.WebGPUActor.getRenderable().getProperty().getDisplayLocation() === DisplayLocation.FOREGROUND ? 1.0 : 0.0);\n        var _aColor = ppty.getColorByReference();\n        model.UBO.setValue('AmbientIntensity', 1.0);\n        model.UBO.setArray('DiffuseColor', [_aColor[0], _aColor[1], _aColor[2], 1.0]);\n        model.UBO.setValue('DiffuseIntensity', 0.0);\n        model.UBO.setValue('SpecularIntensity', 0.0);\n      } else {\n        // Base Colors\n        var _aColor2 = ppty.getAmbientColorByReference();\n        model.UBO.setValue('AmbientIntensity', ppty.getAmbient());\n        model.UBO.setArray('AmbientColor', [_aColor2[0], _aColor2[1], _aColor2[2], 1.0]);\n        model.UBO.setValue('DiffuseIntensity', ppty.getDiffuse());\n        _aColor2 = ppty.getDiffuseColorByReference();\n        model.UBO.setArray('DiffuseColor', [_aColor2[0], _aColor2[1], _aColor2[2], 1.0]); // Roughness\n\n        model.UBO.setValue('Roughness', ppty.getRoughness());\n        model.UBO.setValue('BaseIOR', ppty.getBaseIOR()); // Metallic\n\n        model.UBO.setValue('Metallic', ppty.getMetallic()); // Normal\n\n        model.UBO.setValue('NormalStrength', ppty.getNormalStrength()); // Emission\n\n        model.UBO.setValue('Emission', ppty.getEmission()); // Specular\n\n        model.UBO.setValue('SpecularIntensity', ppty.getSpecular());\n        _aColor2 = ppty.getSpecularColorByReference();\n        model.UBO.setArray('SpecularColor', [_aColor2[0], _aColor2[1], _aColor2[2], 1.0]);\n      } // Edge and line rendering\n\n      var aColor = (_ppty$getEdgeColorByR = ppty.getEdgeColorByReference) === null || _ppty$getEdgeColorByR === void 0 ? void 0 : _ppty$getEdgeColorByR.call(ppty);\n      if (aColor) {\n        model.UBO.setArray('EdgeColor', [aColor[0], aColor[1], aColor[2], 1.0]);\n      }\n      model.UBO.setValue('LineWidth', ppty.getLineWidth());\n      model.UBO.setValue('Opacity', ppty.getOpacity());\n      model.UBO.setValue('PropID', model.WebGPUActor.getPropID());\n      var device = model.WebGPURenderWindow.getDevice();\n      model.UBO.sendIfNeeded(device);\n    }\n  };\n  publicAPI.haveWideLines = function () {\n    var actor = model.WebGPUActor.getRenderable();\n    var representation = actor.getProperty().getRepresentation();\n    if (actor.getProperty().getLineWidth() <= 1.0) {\n      return false;\n    }\n    if (model.primitiveType === PrimitiveTypes.Verts) {\n      return false;\n    }\n    if (model.primitiveType === PrimitiveTypes.Triangles || model.primitiveType === PrimitiveTypes.TriangleStrips) {\n      return representation === Representation.WIREFRAME;\n    }\n    return true;\n  };\n  publicAPI.replaceShaderPosition = function (hash, pipeline, vertexInput) {\n    var vDesc = pipeline.getShaderDescription('vertex');\n    vDesc.addBuiltinOutput('vec4<f32>', '@builtin(position) Position');\n    if (!vDesc.hasOutput('vertexVC')) vDesc.addOutput('vec4<f32>', 'vertexVC');\n    var code = vDesc.getCode();\n    if (model.useRendererMatrix) {\n      code = vtkWebGPUShaderCache.substitute(code, '//VTK::Position::Impl', ['    var pCoord: vec4<f32> = rendererUBO.SCPCMatrix*mapperUBO.BCSCMatrix*vertexBC;', '    output.vertexVC = rendererUBO.SCVCMatrix * mapperUBO.BCSCMatrix * vec4<f32>(vertexBC.xyz, 1.0);', '//VTK::Position::Impl']).result;\n      if (model.forceZValue) {\n        code = vtkWebGPUShaderCache.substitute(code, '//VTK::Position::Impl', ['pCoord = vec4<f32>(pCoord.xyz/pCoord.w, 1.0);', 'pCoord.z = mapperUBO.ZValue;', '//VTK::Position::Impl']).result;\n      }\n    } else {\n      code = vtkWebGPUShaderCache.substitute(code, '//VTK::Position::Impl', ['    var pCoord: vec4<f32> = mapperUBO.BCSCMatrix*vertexBC;', '    pCoord.x = 2.0* pCoord.x / rendererUBO.viewportSize.x - 1.0;', '    pCoord.y = 2.0* pCoord.y / rendererUBO.viewportSize.y - 1.0;', '    pCoord.z = 0.5 - 0.5 * pCoord.z;', '//VTK::Position::Impl']).result;\n      if (model.forceZValue) {\n        code = vtkWebGPUShaderCache.substitute(code, '//VTK::Position::Impl', ['    pCoord.z = mapperUBO.ZValue;', '//VTK::Position::Impl']).result;\n      }\n    }\n    if (publicAPI.haveWideLines()) {\n      vDesc.addBuiltinInput('u32', '@builtin(instance_index) instanceIndex'); // widen the edge\n\n      code = vtkWebGPUShaderCache.substitute(code, '//VTK::Position::Impl', ['    var tmpPos: vec4<f32> = pCoord;', '    var numSteps: f32 = ceil(mapperUBO.LineWidth - 1.0);', '    var offset: f32 = (mapperUBO.LineWidth - 1.0) * (f32(input.instanceIndex / 2u) - numSteps/2.0) / numSteps;', '    var tmpPos2: vec3<f32> = tmpPos.xyz / tmpPos.w;', '    tmpPos2.x = tmpPos2.x + 2.0 * (f32(input.instanceIndex) % 2.0) * offset / rendererUBO.viewportSize.x;', '    tmpPos2.y = tmpPos2.y + 2.0 * (f32(input.instanceIndex + 1u) % 2.0) * offset / rendererUBO.viewportSize.y;', '    tmpPos2.z = min(1.0, tmpPos2.z + 0.00001);',\n      // could become a setting\n      '    pCoord = vec4<f32>(tmpPos2.xyz * tmpPos.w, tmpPos.w);', '//VTK::Position::Impl']).result;\n    }\n    code = vtkWebGPUShaderCache.substitute(code, '//VTK::Position::Impl', ['    output.Position = pCoord;']).result;\n    vDesc.setCode(code);\n  };\n  model.shaderReplacements.set('replaceShaderPosition', publicAPI.replaceShaderPosition);\n  publicAPI.replaceShaderNormal = function (hash, pipeline, vertexInput) {\n    var normalBuffer = vertexInput.getBuffer('normalMC');\n    var actor = model.WebGPUActor.getRenderable();\n    if (normalBuffer) {\n      var vDesc = pipeline.getShaderDescription('vertex');\n      if (!vDesc.hasOutput('normalVC')) {\n        vDesc.addOutput('vec3<f32>', 'normalVC', normalBuffer.getArrayInformation()[0].interpolation);\n      }\n      if (!vDesc.hasOutput('tangentVC')) {\n        vDesc.addOutput('vec3<f32>', 'tangentVC', normalBuffer.getArrayInformation()[0].interpolation);\n      }\n      if (!vDesc.hasOutput('bitangentVC')) {\n        vDesc.addOutput('vec3<f32>', 'bitangentVC', normalBuffer.getArrayInformation()[0].interpolation);\n      }\n      var code = vDesc.getCode();\n      code = vtkWebGPUShaderCache.substitute(code, '//VTK::Normal::Impl', ['  output.normalVC = normalize((rendererUBO.WCVCNormals * mapperUBO.MCWCNormals * normalMC).xyz);',\n      // This is just an approximation, but it happens to work extremely well\n      // It only works well for normals that are head on and not super angled though\n      // Definitely needs to be replaced\n      '  var c1: vec3<f32> = cross(output.normalVC, vec3<f32>(0, 0, 1));', '  var c2: vec3<f32> = cross(output.normalVC, vec3<f32>(0, 1, 0));', '  var tangent: vec3<f32> = mix(c1, c2, distance(c1, c2));', '  output.tangentVC = normalize(tangent);', '  output.bitangentVC = normalize(cross(output.normalVC, tangent));']).result;\n      vDesc.setCode(code);\n      var fDesc = pipeline.getShaderDescription('fragment');\n      code = fDesc.getCode();\n      if (actor.getProperty().getNormalTexture()) {\n        code = vtkWebGPUShaderCache.substitute(code, '//VTK::Normal::Impl', ['  var normal: vec3<f32> = input.normalVC;', '  if (!input.frontFacing) { normal = -normal; }', '  var tangent: vec3<f32> = input.tangentVC;', '  var bitangent: vec3<f32> = input.bitangentVC;', '  var TCVCMatrix: mat3x3<f32> = mat3x3<f32>(', '    tangent.x, bitangent.x, normal.x,', '    tangent.y, bitangent.y, normal.y,', '    tangent.z, bitangent.z, normal.z,', '  );', '  var mappedNormal: vec3<f32> = TCVCMatrix * (_normalMap.xyz * 2 - 1);', '  normal = mix(normal, mappedNormal, mapperUBO.NormalStrength);', '  normal = normalize(normal);']).result;\n      } else {\n        code = vtkWebGPUShaderCache.substitute(code, '//VTK::Normal::Impl', ['  var normal: vec3<f32> = input.normalVC;', '  if (!input.frontFacing) { normal = -normal; }', '  normal = normalize(normal);']).result;\n      }\n      fDesc.setCode(code);\n    }\n  };\n  model.shaderReplacements.set('replaceShaderNormal', publicAPI.replaceShaderNormal); // we only apply lighting when there is a \"var normal\" declaration in the\n  // fragment shader code. That is the lighting trigger.\n\n  publicAPI.replaceShaderLight = function (hash, pipeline, vertexInput) {\n    if (hash.includes('sel')) return;\n    var vDesc = pipeline.getShaderDescription('vertex');\n    if (!vDesc.hasOutput('vertexVC')) vDesc.addOutput('vec4<f32>', 'vertexVC');\n    var renderer = model.WebGPURenderer.getRenderable();\n    var fDesc = pipeline.getShaderDescription('fragment');\n    var code = fDesc.getCode(); // Code that runs if the fragment shader includes normals\n\n    if (code.includes('var normal:') && model.useRendererMatrix && !isEdges(hash) && !model.is2D && !hash.includes('sel')) {\n      var _renderer$getEnvironm;\n      var lightingCode = [\n      // Constants\n      '  var pi: f32 = 3.14159265359;',\n      // Vectors needed for light calculations\n      '  var fragPos: vec3<f32> = vec3<f32>(input.vertexVC.xyz);', '  var V: vec3<f32> = mix(normalize(-fragPos), vec3<f32>(0, 0, 1), f32(rendererUBO.cameraParallel)); // View Vector',\n      // Values needed for light calculations\n      '  var baseColor: vec3<f32> = _diffuseMap.rgb * diffuseColor.rgb;', '  var roughness: f32 = max(0.000001, mapperUBO.Roughness * _roughnessMap.r);',\n      // Need to have a different way of sampling greyscale values aside from .r\n      '  var metallic: f32 = mapperUBO.Metallic * _metallicMap.r;', '  var alpha: f32 = roughness*roughness;', '  var ior: f32 = mapperUBO.BaseIOR;', '  var k: f32 = alpha*alpha / 2;',\n      // Split diffuse and specular components\n      '  var diffuse: vec3<f32> = vec3<f32>(0.);', '  var specular: vec3<f32> = vec3<f32>(0.);', '  var emission: vec3<f32> = _emissionMap.rgb * mapperUBO.Emission;',\n      // Summing diffuse and specular components of directional lights\n      '  {', '    var i: i32 = 0;', '    loop {', '      if !(i < rendererUBO.LightCount) { break; }', '      switch (i32(rendererLightSSBO.values[i].LightData.x)) {', '         // Point Light', '         case 0 {', '           var color: vec3<f32> = rendererLightSSBO.values[i].LightColor.rgb * rendererLightSSBO.values[i].LightColor.w;', '           var pos: vec3<f32> = (rendererLightSSBO.values[i].LightPos).xyz;', '           var calculated: PBRData = calcPointLight(normal, V, fragPos, ior, roughness, metallic, pos, color, baseColor);', '           diffuse += max(vec3<f32>(0), calculated.diffuse);', '           specular += max(vec3<f32>(0), calculated.specular);', '          }', '         // Directional light', '         case 1 {', '           var dir: vec3<f32> = (rendererUBO.WCVCNormals * vec4<f32>(normalize(rendererLightSSBO.values[i].LightDir.xyz), 0.)).xyz;', '           dir = normalize(dir);', '           var color: vec3<f32> = rendererLightSSBO.values[i].LightColor.rgb * rendererLightSSBO.values[i].LightColor.w;', '           var calculated: PBRData = calcDirectionalLight(normal, V, ior, roughness, metallic, dir, color, baseColor); // diffuseColor.rgb needs to be fixed with a more dynamic diffuse color', '           diffuse += max(vec3<f32>(0), calculated.diffuse);', '           specular += max(vec3<f32>(0), calculated.specular);', '         }', '         // Spot Light', '         case 2 {', '           var color: vec3<f32> = rendererLightSSBO.values[i].LightColor.rgb * rendererLightSSBO.values[i].LightColor.w;', '           var pos: vec3<f32> = (rendererLightSSBO.values[i].LightPos).xyz;', '           var dir: vec3<f32> = (rendererUBO.WCVCNormals * vec4<f32>(normalize(rendererLightSSBO.values[i].LightDir.xyz), 0.)).xyz;', '           dir = normalize(dir);', '           var cones: vec2<f32> = vec2<f32>(rendererLightSSBO.values[i].LightData.y, rendererLightSSBO.values[i].LightData.z);', '           var calculated: PBRData = calcSpotLight(normal, V, fragPos, ior, roughness, metallic, pos, dir, cones, color, baseColor);', '           diffuse += max(vec3<f32>(0), calculated.diffuse);', '           specular += max(vec3<f32>(0), calculated.specular);', '         }', '         default { continue; }', '       }', '      continuing { i++; }', '    }', '  }',\n      // Final variables for combining specular and diffuse\n      '  var fresnel: f32 = schlickFresnelIOR(V, normal, ior, k); // Fresnel', '  fresnel = min(1, fresnel);', '  // This could be controlled with its own variable (that isnt base color) for better artistic control', '  var fresnelMetallic: vec3<f32> = schlickFresnelRGB(V, normal, baseColor); // Fresnel for metal, takes color into account', '  var kS: vec3<f32> = mix(vec3<f32>(fresnel), fresnelMetallic, metallic);', '  kS = min(vec3<f32>(1), kS);', '  var kD: vec3<f32> = (1.0 - kS) * (1.0 - metallic);', '  var PBR: vec3<f32> = mapperUBO.DiffuseIntensity*kD*diffuse + kS*specular;', '  PBR += emission;', '  computedColor = vec4<f32>(PBR, mapperUBO.Opacity);'];\n      if ((_renderer$getEnvironm = renderer.getEnvironmentTexture()) !== null && _renderer$getEnvironm !== void 0 && _renderer$getEnvironm.getImageLoaded()) {\n        lightingCode.push('  // To get diffuse IBL, the texture is sampled with normals in worldspace', '  var diffuseIBLCoords: vec3<f32> = (transpose(rendererUBO.WCVCNormals) * vec4<f32>(normal, 1.)).xyz;', '  var diffuseCoords: vec2<f32> = vecToRectCoord(diffuseIBLCoords);', '  // To get specular IBL, the texture is sampled as the worldspace reflection between the normal and view vectors', '  // Reflections are first calculated in viewspace, then converted to worldspace to sample the environment', '  var VreflN: vec3<f32> = normalize(reflect(-V, normal));', '  var reflectionIBLCoords = (transpose(rendererUBO.WCVCNormals) * vec4<f32>(VreflN, 1.)).xyz;', '  var specularCoords: vec2<f32> = vecToRectCoord(reflectionIBLCoords);', '  var diffuseIBL = textureSampleLevel(EnvironmentTexture, EnvironmentTextureSampler, diffuseCoords, rendererUBO.MaxEnvironmentMipLevel);',\n        // Level multiplier should be set by UBO\n        '  var level = roughness * rendererUBO.MaxEnvironmentMipLevel;', '  var specularIBL = textureSampleLevel(EnvironmentTexture, EnvironmentTextureSampler, specularCoords, level);',\n        // Manual mip smoothing since not all formats support smooth level sampling\n        '  var specularIBLContribution: vec3<f32> = specularIBL.rgb*rendererUBO.BackgroundSpecularStrength;', '  computedColor += vec4<f32>(specularIBLContribution*kS, 0);', '  var diffuseIBLContribution: vec3<f32> = diffuseIBL.rgb*rendererUBO.BackgroundDiffuseStrength;', '  diffuseIBLContribution *= baseColor * _ambientOcclusionMap.rgb;',\n        // Multipy by baseColor may be changed\n        '  computedColor += vec4<f32>(diffuseIBLContribution*kD, 0);');\n      }\n      code = vtkWebGPUShaderCache.substitute(code, '//VTK::Light::Impl', lightingCode).result;\n      fDesc.setCode(code); // If theres no normals, just set the specular color to be flat\n    } else {\n      code = vtkWebGPUShaderCache.substitute(code, '//VTK::Light::Impl', ['  var diffuse: vec3<f32> = diffuseColor.rgb;', '  var specular: vec3<f32> = mapperUBO.SpecularColor.rgb * mapperUBO.SpecularColor.a;', '  computedColor = vec4<f32>(diffuse * _diffuseMap.rgb, mapperUBO.Opacity);']).result;\n      fDesc.setCode(code);\n    }\n  };\n  model.shaderReplacements.set('replaceShaderLight', publicAPI.replaceShaderLight);\n  publicAPI.replaceShaderColor = function (hash, pipeline, vertexInput) {\n    // By default, set the colors to be flat\n    if (isEdges(hash)) {\n      var _fDesc = pipeline.getShaderDescription('fragment');\n      var _code = _fDesc.getCode();\n      _code = vtkWebGPUShaderCache.substitute(_code, '//VTK::Color::Impl', ['ambientColor = mapperUBO.EdgeColor;', 'diffuseColor = mapperUBO.EdgeColor;']).result;\n      _fDesc.setCode(_code);\n      return;\n    } // If there's no vertex color buffer return the shader as is\n\n    var colorBuffer = vertexInput.getBuffer('colorVI');\n    if (!colorBuffer) return; // Modifies the vertex shader to include the vertex colors and interpolation in the outputs\n\n    var vDesc = pipeline.getShaderDescription('vertex');\n    vDesc.addOutput('vec4<f32>', 'color', colorBuffer.getArrayInformation()[0].interpolation);\n    var code = vDesc.getCode();\n    code = vtkWebGPUShaderCache.substitute(code, '//VTK::Color::Impl', ['  output.color = colorVI;']).result;\n    vDesc.setCode(code); // Sets the fragment shader to accept the color inputs from the vertex shader\n\n    var fDesc = pipeline.getShaderDescription('fragment');\n    code = fDesc.getCode();\n    code = vtkWebGPUShaderCache.substitute(code, '//VTK::Color::Impl', ['ambientColor = input.color;', 'diffuseColor = input.color;', 'opacity = mapperUBO.Opacity * input.color.a;']).result;\n    fDesc.setCode(code);\n  };\n  model.shaderReplacements.set('replaceShaderColor', publicAPI.replaceShaderColor);\n  publicAPI.replaceShaderTCoord = function (hash, pipeline, vertexInput) {\n    var _actor$getProperty$ge, _actor$getProperty, _actor$getProperty$ge2, _actor$getProperty$ge4, _actor$getProperty3, _actor$getProperty$ge5, _actor$getProperty$ge6, _actor$getProperty4, _actor$getProperty$ge7, _actor$getProperty$ge8, _actor$getProperty5, _actor$getProperty$ge9, _actor$getProperty$ge10, _actor$getProperty6, _actor$getProperty$ge11, _actor$getProperty$ge12, _actor$getProperty7, _actor$getProperty$ge13;\n    if (!vertexInput.hasAttribute('tcoord')) return;\n    var vDesc = pipeline.getShaderDescription('vertex');\n    var tcoords = vertexInput.getBuffer('tcoord');\n    var numComp = vtkWebGPUTypes.getNumberOfComponentsFromBufferFormat(tcoords.getArrayInformation()[0].format);\n    var code = vDesc.getCode();\n    vDesc.addOutput(\"vec\".concat(numComp, \"<f32>\"), 'tcoordVS');\n    code = vtkWebGPUShaderCache.substitute(code, '//VTK::TCoord::Impl', ['  output.tcoordVS = tcoord;']).result;\n    vDesc.setCode(code);\n    var fDesc = pipeline.getShaderDescription('fragment');\n    code = fDesc.getCode();\n    var actor = model.WebGPUActor.getRenderable();\n    var checkDims = function checkDims(texture) {\n      if (!texture) return false;\n      var dims = texture.getDimensionality();\n      return dims === numComp;\n    };\n    var usedTextures = [];\n    if ((_actor$getProperty$ge = (_actor$getProperty = actor.getProperty()).getDiffuseTexture) !== null && _actor$getProperty$ge !== void 0 && (_actor$getProperty$ge2 = _actor$getProperty$ge.call(_actor$getProperty)) !== null && _actor$getProperty$ge2 !== void 0 && _actor$getProperty$ge2.getImageLoaded() || actor.getTextures()[0] || model.colorTexture) {\n      var _actor$getProperty$ge3, _actor$getProperty2;\n      if (\n      // Chained or statements here are questionable\n      checkDims((_actor$getProperty$ge3 = (_actor$getProperty2 = actor.getProperty()).getDiffuseTexture) === null || _actor$getProperty$ge3 === void 0 ? void 0 : _actor$getProperty$ge3.call(_actor$getProperty2)) || checkDims(actor.getTextures()[0]) || checkDims(model.colorTexture)) {\n        usedTextures.push('_diffuseMap = textureSample(DiffuseTexture, DiffuseTextureSampler, input.tcoordVS);');\n      }\n    }\n    if ((_actor$getProperty$ge4 = (_actor$getProperty3 = actor.getProperty()).getRoughnessTexture) !== null && _actor$getProperty$ge4 !== void 0 && (_actor$getProperty$ge5 = _actor$getProperty$ge4.call(_actor$getProperty3)) !== null && _actor$getProperty$ge5 !== void 0 && _actor$getProperty$ge5.getImageLoaded()) {\n      if (checkDims(actor.getProperty().getRoughnessTexture())) {\n        usedTextures.push('_roughnessMap = textureSample(RoughnessTexture, RoughnessTextureSampler, input.tcoordVS);');\n      }\n    }\n    if ((_actor$getProperty$ge6 = (_actor$getProperty4 = actor.getProperty()).getMetallicTexture) !== null && _actor$getProperty$ge6 !== void 0 && (_actor$getProperty$ge7 = _actor$getProperty$ge6.call(_actor$getProperty4)) !== null && _actor$getProperty$ge7 !== void 0 && _actor$getProperty$ge7.getImageLoaded()) {\n      if (checkDims(actor.getProperty().getMetallicTexture())) {\n        usedTextures.push('_metallicMap = textureSample(MetallicTexture, MetallicTextureSampler, input.tcoordVS);');\n      }\n    }\n    if ((_actor$getProperty$ge8 = (_actor$getProperty5 = actor.getProperty()).getNormalTexture) !== null && _actor$getProperty$ge8 !== void 0 && (_actor$getProperty$ge9 = _actor$getProperty$ge8.call(_actor$getProperty5)) !== null && _actor$getProperty$ge9 !== void 0 && _actor$getProperty$ge9.getImageLoaded()) {\n      if (checkDims(actor.getProperty().getNormalTexture())) {\n        usedTextures.push('_normalMap = textureSample(NormalTexture, NormalTextureSampler, input.tcoordVS);');\n      }\n    }\n    if ((_actor$getProperty$ge10 = (_actor$getProperty6 = actor.getProperty()).getAmbientOcclusionTexture) !== null && _actor$getProperty$ge10 !== void 0 && (_actor$getProperty$ge11 = _actor$getProperty$ge10.call(_actor$getProperty6)) !== null && _actor$getProperty$ge11 !== void 0 && _actor$getProperty$ge11.getImageLoaded()) {\n      if (checkDims(actor.getProperty().getAmbientOcclusionTexture())) {\n        usedTextures.push('_ambientOcclusionMap = textureSample(AmbientOcclusionTexture, AmbientOcclusionTextureSampler, input.tcoordVS);');\n      }\n    }\n    if ((_actor$getProperty$ge12 = (_actor$getProperty7 = actor.getProperty()).getEmissionTexture) !== null && _actor$getProperty$ge12 !== void 0 && (_actor$getProperty$ge13 = _actor$getProperty$ge12.call(_actor$getProperty7)) !== null && _actor$getProperty$ge13 !== void 0 && _actor$getProperty$ge13.getImageLoaded()) {\n      if (checkDims(actor.getProperty().getEmissionTexture())) {\n        usedTextures.push('_emissionMap = textureSample(EmissionTexture, EmissionTextureSampler, input.tcoordVS);');\n      }\n    }\n    code = vtkWebGPUShaderCache.substitute(code, '//VTK::TCoord::Impl', usedTextures).result;\n    fDesc.setCode(code);\n  };\n  model.shaderReplacements.set('replaceShaderTCoord', publicAPI.replaceShaderTCoord);\n  publicAPI.replaceShaderSelect = function (hash, pipeline, vertexInput) {\n    if (hash.includes('sel')) {\n      var fDesc = pipeline.getShaderDescription('fragment');\n      var code = fDesc.getCode(); // by default there are no composites, so just 0\n\n      code = vtkWebGPUShaderCache.substitute(code, '//VTK::Select::Impl', ['  var compositeID: u32 = 0u;']).result;\n      fDesc.setCode(code);\n    }\n  };\n  model.shaderReplacements.set('replaceShaderSelect', publicAPI.replaceShaderSelect);\n  publicAPI.getUsage = function (rep, i) {\n    if (rep === Representation.POINTS || i === PrimitiveTypes.Points) {\n      return BufferUsage.Verts;\n    }\n    if (i === PrimitiveTypes.Lines) {\n      return BufferUsage.Lines;\n    }\n    if (rep === Representation.WIREFRAME) {\n      if (i === PrimitiveTypes.Triangles) {\n        return BufferUsage.LinesFromTriangles;\n      }\n      return BufferUsage.LinesFromStrips;\n    }\n    if (i === PrimitiveTypes.Triangles) {\n      return BufferUsage.Triangles;\n    }\n    if (i === PrimitiveTypes.TriangleStrips) {\n      return BufferUsage.Strips;\n    }\n    if (i === PrimitiveTypes.TriangleEdges) {\n      return BufferUsage.LinesFromTriangles;\n    } // only strip edges left which are lines\n\n    return BufferUsage.LinesFromStrips;\n  };\n  publicAPI.getHashFromUsage = function (usage) {\n    return \"pt\".concat(usage);\n  };\n  publicAPI.getTopologyFromUsage = function (usage) {\n    switch (usage) {\n      case BufferUsage.Triangles:\n        return 'triangle-list';\n      case BufferUsage.Verts:\n        return 'point-list';\n      case BufferUsage.Lines:\n      default:\n        return 'line-list';\n    }\n  }; // TODO: calculate tangents\n\n  publicAPI.buildVertexInput = function () {\n    var _model$renderable$get, _model$renderable;\n    var pd = model.currentInput;\n    var cells = model.cellArray;\n    var primType = model.primitiveType;\n    var actor = model.WebGPUActor.getRenderable();\n    var representation = actor.getProperty().getRepresentation();\n    var device = model.WebGPURenderWindow.getDevice();\n    var edges = false;\n    if (primType === PrimitiveTypes.TriangleEdges) {\n      edges = true;\n      representation = Representation.WIREFRAME;\n    }\n    var vertexInput = model.vertexInput;\n    var points = pd.getPoints();\n    var indexBuffer; // get the flat mapping indexBuffer for the cells\n\n    if (cells) {\n      var buffRequest = {\n        hash: \"R\".concat(representation, \"P\").concat(primType).concat(cells.getMTime()),\n        usage: BufferUsage.Index,\n        cells: cells,\n        numberOfPoints: points.getNumberOfPoints(),\n        primitiveType: primType,\n        representation: representation\n      };\n      indexBuffer = device.getBufferManager().getBuffer(buffRequest);\n      vertexInput.setIndexBuffer(indexBuffer);\n    } else {\n      vertexInput.setIndexBuffer(null);\n    } // hash = all things that can change the values on the buffer\n    // since mtimes are unique we can use\n    // - indexBuffer mtime - because cells drive how we pack\n    // - relevant dataArray mtime - the source data\n    // - shift - not currently captured\n    // - scale - not currently captured\n    // - format\n    // - usage\n    // - packExtra - covered by format\n    // points\n\n    if (points) {\n      var shift = model.WebGPUActor.getBufferShift(model.WebGPURenderer);\n      var _buffRequest = {\n        hash: \"\".concat(points.getMTime(), \"I\").concat(indexBuffer.getMTime()).concat(shift.join(), \"float32x4\"),\n        usage: BufferUsage.PointArray,\n        format: 'float32x4',\n        dataArray: points,\n        indexBuffer: indexBuffer,\n        shift: shift,\n        packExtra: true\n      };\n      var buff = device.getBufferManager().getBuffer(_buffRequest);\n      vertexInput.addBuffer(buff, ['vertexBC']);\n    } else {\n      vertexInput.removeBufferIfPresent('vertexBC');\n    } // normals, only used for surface rendering\n\n    var usage = publicAPI.getUsage(representation, primType);\n    model._usesCellNormals = false;\n    if (!model.is2D && (\n    // no lighting on Property2D\n    usage === BufferUsage.Triangles || usage === BufferUsage.Strips)) {\n      var normals = pd.getPointData().getNormals(); // https://vtk.org/doc/nightly/html/classvtkPolyDataTangents.html\n      // Need to find some way of using precomputed tangents (or computing new ones)\n\n      var _buffRequest2 = {\n        format: 'snorm8x4',\n        indexBuffer: indexBuffer,\n        packExtra: true,\n        shift: 0,\n        scale: 127\n      };\n      if (normals) {\n        _buffRequest2.hash = \"\".concat(normals.getMTime(), \"I\").concat(indexBuffer.getMTime(), \"snorm8x4\");\n        _buffRequest2.dataArray = normals;\n        _buffRequest2.usage = BufferUsage.PointArray;\n        var _buff = device.getBufferManager().getBuffer(_buffRequest2);\n        vertexInput.addBuffer(_buff, ['normalMC']);\n      } else if (primType === PrimitiveTypes.Triangles) {\n        model._usesCellNormals = true;\n        _buffRequest2.hash = \"PFN\".concat(points.getMTime(), \"I\").concat(indexBuffer.getMTime(), \"snorm8x4\");\n        _buffRequest2.dataArray = points;\n        _buffRequest2.cells = cells;\n        _buffRequest2.usage = BufferUsage.NormalsFromPoints;\n        var _buff2 = device.getBufferManager().getBuffer(_buffRequest2);\n        vertexInput.addBuffer(_buff2, ['normalMC']);\n      } else {\n        vertexInput.removeBufferIfPresent('normalMC');\n      }\n    } else {\n      vertexInput.removeBufferIfPresent('normalMC');\n    } // deal with colors but only if modified\n\n    var haveColors = false;\n    if (model.renderable.getScalarVisibility()) {\n      var c = model.renderable.getColorMapColors();\n      if (c && !edges) {\n        var scalarMode = model.renderable.getScalarMode();\n        var haveCellScalars = false; // We must figure out how the scalars should be mapped to the polydata.\n\n        if ((scalarMode === ScalarMode.USE_CELL_DATA || scalarMode === ScalarMode.USE_CELL_FIELD_DATA || scalarMode === ScalarMode.USE_FIELD_DATA || !pd.getPointData().getScalars()) && scalarMode !== ScalarMode.USE_POINT_FIELD_DATA && c) {\n          haveCellScalars = true;\n        }\n        var _buffRequest3 = {\n          usage: BufferUsage.PointArray,\n          format: 'unorm8x4',\n          hash: \"\".concat(haveCellScalars).concat(c.getMTime(), \"I\").concat(indexBuffer.getMTime(), \"unorm8x4\"),\n          dataArray: c,\n          indexBuffer: indexBuffer,\n          cellData: haveCellScalars,\n          cellOffset: 0\n        };\n        var _buff3 = device.getBufferManager().getBuffer(_buffRequest3);\n        vertexInput.addBuffer(_buff3, ['colorVI']);\n        haveColors = true;\n      }\n    }\n    if (!haveColors) {\n      vertexInput.removeBufferIfPresent('colorVI');\n    }\n    var tcoords = null;\n    if ((_model$renderable$get = (_model$renderable = model.renderable).getInterpolateScalarsBeforeMapping) !== null && _model$renderable$get !== void 0 && _model$renderable$get.call(_model$renderable) && model.renderable.getColorCoordinates()) {\n      tcoords = model.renderable.getColorCoordinates();\n    } else {\n      tcoords = pd.getPointData().getTCoords();\n    }\n    if (tcoords && !edges) {\n      var _buff4 = device.getBufferManager().getBufferForPointArray(tcoords, vertexInput.getIndexBuffer());\n      vertexInput.addBuffer(_buff4, ['tcoord']);\n    } else {\n      vertexInput.removeBufferIfPresent('tcoord');\n    }\n  };\n  publicAPI.updateTextures = function () {\n    var _model$renderable$get2, _model$renderable2, _actor$getProperty$ge14, _actor$getProperty8, _actor$getProperty$ge15, _actor$getProperty9, _actor$getProperty$ge16, _actor$getProperty10, _actor$getProperty$ge17, _actor$getProperty11, _actor$getProperty$ge18, _actor$getProperty12, _actor$getProperty$ge19, _actor$getProperty13, _renderer$getEnvironm2;\n\n    // we keep track of new and used textures so\n    // that we can clean up any unused textures so we don't hold onto them\n    var usedTextures = [];\n    var newTextures = []; // do we have a scalar color texture\n\n    var idata = (_model$renderable$get2 = (_model$renderable2 = model.renderable).getColorTextureMap) === null || _model$renderable$get2 === void 0 ? void 0 : _model$renderable$get2.call(_model$renderable2);\n    if (idata) {\n      if (!model.colorTexture) {\n        model.colorTexture = vtkTexture.newInstance({\n          label: 'polyDataColor'\n        });\n      }\n      model.colorTexture.setInputData(idata);\n      newTextures.push(['Diffuse', model.colorTexture]);\n    } // actor textures?\n\n    var actor = model.WebGPUActor.getRenderable();\n    var renderer = model.WebGPURenderer.getRenderable(); // Reusing the old code for new and old textures, just loading in from properties instead of actor.getTextures()\n\n    var textures = []; // Feels like there should be a better way than individually adding all\n\n    if ((_actor$getProperty$ge14 = (_actor$getProperty8 = actor.getProperty()).getDiffuseTexture) !== null && _actor$getProperty$ge14 !== void 0 && _actor$getProperty$ge14.call(_actor$getProperty8)) {\n      var pair = ['Diffuse', actor.getProperty().getDiffuseTexture()];\n      textures.push(pair);\n    }\n    if (actor.getTextures()[0]) {\n      var _pair = ['Diffuse', actor.getTextures()[0]];\n      textures.push(_pair);\n    }\n    if (model.colorTexture) {\n      var _pair2 = ['Diffuse', model.colorTexture];\n      textures.push(_pair2);\n    }\n    if ((_actor$getProperty$ge15 = (_actor$getProperty9 = actor.getProperty()).getRoughnessTexture) !== null && _actor$getProperty$ge15 !== void 0 && _actor$getProperty$ge15.call(_actor$getProperty9)) {\n      var _pair3 = ['Roughness', actor.getProperty().getRoughnessTexture()];\n      textures.push(_pair3);\n    }\n    if ((_actor$getProperty$ge16 = (_actor$getProperty10 = actor.getProperty()).getMetallicTexture) !== null && _actor$getProperty$ge16 !== void 0 && _actor$getProperty$ge16.call(_actor$getProperty10)) {\n      var _pair4 = ['Metallic', actor.getProperty().getMetallicTexture()];\n      textures.push(_pair4);\n    }\n    if ((_actor$getProperty$ge17 = (_actor$getProperty11 = actor.getProperty()).getNormalTexture) !== null && _actor$getProperty$ge17 !== void 0 && _actor$getProperty$ge17.call(_actor$getProperty11)) {\n      var _pair5 = ['Normal', actor.getProperty().getNormalTexture()];\n      textures.push(_pair5);\n    }\n    if ((_actor$getProperty$ge18 = (_actor$getProperty12 = actor.getProperty()).getAmbientOcclusionTexture) !== null && _actor$getProperty$ge18 !== void 0 && _actor$getProperty$ge18.call(_actor$getProperty12)) {\n      var _pair6 = ['AmbientOcclusion', actor.getProperty().getAmbientOcclusionTexture()];\n      textures.push(_pair6);\n    }\n    if ((_actor$getProperty$ge19 = (_actor$getProperty13 = actor.getProperty()).getEmissionTexture) !== null && _actor$getProperty$ge19 !== void 0 && _actor$getProperty$ge19.call(_actor$getProperty13)) {\n      var _pair7 = ['Emission', actor.getProperty().getEmissionTexture()];\n      textures.push(_pair7);\n    }\n    if ((_renderer$getEnvironm2 = renderer.getEnvironmentTexture) !== null && _renderer$getEnvironm2 !== void 0 && _renderer$getEnvironm2.call(renderer)) {\n      var _pair8 = ['Environment', renderer.getEnvironmentTexture()];\n      textures.push(_pair8);\n    }\n    for (var i = 0; i < textures.length; i++) {\n      if (textures[i][1].getInputData() || textures[i][1].getJsImageData() || textures[i][1].getCanvas()) {\n        newTextures.push(textures[i]);\n      }\n      if (textures[i][1].getImage() && textures[i][1].getImageLoaded()) {\n        newTextures.push(textures[i]);\n      }\n    }\n    for (var _i = 0; _i < newTextures.length; _i++) {\n      var srcTexture = newTextures[_i][1];\n      var textureName = newTextures[_i][0];\n      var newTex = model.device.getTextureManager().getTextureForVTKTexture(srcTexture); // Generates hash\n\n      if (newTex.getReady()) {\n        // is this a new texture\n        var found = false;\n        for (var t = 0; t < model.textures.length; t++) {\n          if (model.textures[t] === newTex) {\n            found = true;\n            usedTextures[t] = true;\n          }\n        }\n        if (!found) {\n          usedTextures[model.textures.length] = true;\n          var tview = newTex.createView(\"\".concat(textureName, \"Texture\"));\n          model.textures.push(newTex);\n          model.textureViews.push(tview);\n          var interpolate = srcTexture.getInterpolate() ? 'linear' : 'nearest';\n          var addressMode = null;\n          if (!addressMode && srcTexture.getEdgeClamp() && srcTexture.getRepeat()) addressMode = 'mirror-repeat';\n          if (!addressMode && srcTexture.getEdgeClamp()) addressMode = 'clamp-to-edge';\n          if (!addressMode && srcTexture.getRepeat()) addressMode = 'repeat';\n          if (textureName !== 'Environment') {\n            tview.addSampler(model.device, {\n              addressModeU: addressMode,\n              addressModeV: addressMode,\n              addressModeW: addressMode,\n              minFilter: interpolate,\n              magFilter: interpolate\n            });\n          } else {\n            tview.addSampler(model.device, {\n              addressModeU: 'repeat',\n              addressModeV: 'clamp-to-edge',\n              addressModeW: 'repeat',\n              minFilter: interpolate,\n              magFilter: interpolate,\n              mipmapFilter: 'linear'\n            });\n          }\n        }\n      }\n    } // remove unused textures\n\n    for (var _i2 = model.textures.length - 1; _i2 >= 0; _i2--) {\n      if (!usedTextures[_i2]) {\n        model.textures.splice(_i2, 1);\n        model.textureViews.splice(_i2, 1);\n      }\n    }\n  }; // compute a unique hash for a pipeline, this needs to be unique enough to\n  // capture any pipeline code changes (which includes shader changes)\n  // or vertex input changes/ bind groups/ etc\n\n  publicAPI.computePipelineHash = function () {\n    var pipelineHash = \"pd\".concat(model.useRendererMatrix ? 'r' : '').concat(model.forceZValue ? 'z' : '');\n    if (model.primitiveType === PrimitiveTypes.TriangleEdges || model.primitiveType === PrimitiveTypes.TriangleStripEdges) {\n      pipelineHash += 'edge';\n    } else {\n      if (model.vertexInput.hasAttribute(\"normalMC\")) {\n        pipelineHash += \"n\";\n      }\n      if (model.vertexInput.hasAttribute(\"colorVI\")) {\n        pipelineHash += \"c\";\n      }\n      if (model.vertexInput.hasAttribute(\"tcoord\")) {\n        var tcoords = model.vertexInput.getBuffer('tcoord');\n        var numComp = vtkWebGPUTypes.getNumberOfComponentsFromBufferFormat(tcoords.getArrayInformation()[0].format);\n        pipelineHash += \"t\".concat(numComp);\n      }\n      if (model.textures.length) {\n        pipelineHash += \"tx\".concat(model.textures.length);\n      }\n    }\n    if (model._usesCellNormals) {\n      pipelineHash += \"cn\";\n    }\n    if (model.SSBO) {\n      pipelineHash += \"ssbo\";\n    }\n    var uhash = publicAPI.getHashFromUsage(model.usage);\n    pipelineHash += uhash;\n    pipelineHash += model.renderEncoder.getPipelineHash();\n    model.pipelineHash = pipelineHash;\n  };\n  publicAPI.updateBuffers = function () {\n    // handle textures if not edges\n    if (model.primitiveType !== PrimitiveTypes.TriangleEdges && model.primitiveType !== PrimitiveTypes.TriangleStripEdges) {\n      publicAPI.updateTextures();\n    }\n    var actor = model.WebGPUActor.getRenderable();\n    var rep = actor.getProperty().getRepresentation(); // handle per primitive type\n\n    model.usage = publicAPI.getUsage(rep, model.primitiveType);\n    publicAPI.buildVertexInput();\n    var vbo = model.vertexInput.getBuffer('vertexBC');\n    publicAPI.setNumberOfVertices(vbo.getSizeInBytes() / vbo.getStrideInBytes());\n    publicAPI.setTopology(publicAPI.getTopologyFromUsage(model.usage));\n    publicAPI.updateUBO();\n    if (publicAPI.haveWideLines()) {\n      var ppty = actor.getProperty();\n      publicAPI.setNumberOfInstances(Math.ceil(ppty.getLineWidth() * 2.0));\n    } else {\n      publicAPI.setNumberOfInstances(1);\n    }\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nvar DEFAULT_VALUES = {\n  is2D: false,\n  cellArray: null,\n  currentInput: null,\n  cellOffset: 0,\n  primitiveType: 0,\n  colorTexture: null,\n  renderEncoder: null,\n  textures: null\n}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initiaLalues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initiaLalues); // Inheritance\n\n  vtkWebGPUSimpleMapper.extend(publicAPI, model, initiaLalues);\n  model.fragmentShaderTemplate = vtkWebGPUPolyDataFS;\n  model.vertexShaderTemplate = vtkWebGPUPolyDataVS;\n  model._tmpMat3 = mat3.identity(new Float64Array(9));\n  model._tmpMat4 = mat4.identity(new Float64Array(16)); // UBO\n\n  model.UBO = vtkWebGPUUniformBuffer.newInstance({\n    label: 'mapperUBO'\n  });\n  model.UBO.addEntry('BCWCMatrix', 'mat4x4<f32>');\n  model.UBO.addEntry('BCSCMatrix', 'mat4x4<f32>');\n  model.UBO.addEntry('MCWCNormals', 'mat4x4<f32>');\n  model.UBO.addEntry('AmbientColor', 'vec4<f32>');\n  model.UBO.addEntry('DiffuseColor', 'vec4<f32>');\n  model.UBO.addEntry('EdgeColor', 'vec4<f32>');\n  model.UBO.addEntry('SpecularColor', 'vec4<f32>');\n  model.UBO.addEntry('AmbientIntensity', 'f32');\n  model.UBO.addEntry('DiffuseIntensity', 'f32');\n  model.UBO.addEntry('Roughness', 'f32');\n  model.UBO.addEntry('Metallic', 'f32');\n  model.UBO.addEntry('Ambient', 'f32');\n  model.UBO.addEntry('Normal', 'f32');\n  model.UBO.addEntry('Emission', 'f32');\n  model.UBO.addEntry('NormalStrength', 'f32');\n  model.UBO.addEntry('BaseIOR', 'f32');\n  model.UBO.addEntry('SpecularIntensity', 'f32');\n  model.UBO.addEntry('LineWidth', 'f32');\n  model.UBO.addEntry('Opacity', 'f32');\n  model.UBO.addEntry('ZValue', 'f32');\n  model.UBO.addEntry('PropID', 'u32');\n  model.UBO.addEntry('ClipNear', 'f32');\n  model.UBO.addEntry('ClipFar', 'f32');\n  model.UBO.addEntry('Time', 'u32'); // Build VTK API\n\n  setGet(publicAPI, model, ['cellArray', 'currentInput', 'cellOffset', 'is2D', 'primitiveType', 'renderEncoder']);\n  model.textures = []; // Object methods\n\n  vtkWebGPUCellArrayMapper(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = newInstance$1(extend, 'vtkWebGPUCellArrayMapper'); // ----------------------------------------------------------------------------\n\nvar vtkWebGPUCellArrayMapper$1 = {\n  newInstance: newInstance,\n  extend: extend\n};\nexport { vtkWebGPUCellArrayMapper$1 as default, extend, newInstance };","map":{"version":3,"names":["mat3","mat4","newInstance","newInstance$1","setGet","vtkMapper","vtkProp","vtkProperty","vtkProperty2D","vtkTexture","vtkWebGPUBufferManager","vtkWebGPUShaderCache","vtkWebGPUUniformBuffer","vtkWebGPUSimpleMapper","vtkWebGPUTypes","BufferUsage","PrimitiveTypes","Representation","ScalarMode","CoordinateSystem","DisplayLocation","vtkWebGPUPolyDataVS","vtkWebGPUPolyDataFS","isEdges","hash","indexOf","vtkWebGPUCellArrayMapper","publicAPI","model","classHierarchy","push","buildPass","prepass","is2D","WebGPUActor","getFirstAncestorOfType","forceZValue","coordinateSystem","getRenderable","getCoordinateSystem","useRendererMatrix","DISPLAY","WebGPURenderer","WebGPURenderWindow","getParent","device","getDevice","translucentPass","prepareToDraw","getRenderEncoder","renderEncoder","registerDrawCallback","pipeline","draw","opaquePass","updateUBO","actor","ppty","getProperty","utime","UBO","getSendTime","getMTime","renderable","_ppty$getEdgeColorByR","keyMats","getKeyMatrices","setArray","bcwc","bcsc","normalMatrix","setValue","getDisplayLocation","FOREGROUND","_aColor","getColorByReference","_aColor2","getAmbientColorByReference","getAmbient","getDiffuse","getDiffuseColorByReference","getRoughness","getBaseIOR","getMetallic","getNormalStrength","getEmission","getSpecular","getSpecularColorByReference","aColor","getEdgeColorByReference","call","getLineWidth","getOpacity","getPropID","sendIfNeeded","haveWideLines","representation","getRepresentation","primitiveType","Verts","Triangles","TriangleStrips","WIREFRAME","replaceShaderPosition","vertexInput","vDesc","getShaderDescription","addBuiltinOutput","hasOutput","addOutput","code","getCode","substitute","result","addBuiltinInput","setCode","shaderReplacements","set","replaceShaderNormal","normalBuffer","getBuffer","getArrayInformation","interpolation","fDesc","getNormalTexture","replaceShaderLight","includes","renderer","_renderer$getEnvironm","lightingCode","getEnvironmentTexture","getImageLoaded","replaceShaderColor","_fDesc","_code","colorBuffer","replaceShaderTCoord","_actor$getProperty$ge","_actor$getProperty","_actor$getProperty$ge2","_actor$getProperty$ge4","_actor$getProperty3","_actor$getProperty$ge5","_actor$getProperty$ge6","_actor$getProperty4","_actor$getProperty$ge7","_actor$getProperty$ge8","_actor$getProperty5","_actor$getProperty$ge9","_actor$getProperty$ge10","_actor$getProperty6","_actor$getProperty$ge11","_actor$getProperty$ge12","_actor$getProperty7","_actor$getProperty$ge13","hasAttribute","tcoords","numComp","getNumberOfComponentsFromBufferFormat","format","concat","checkDims","texture","dims","getDimensionality","usedTextures","getDiffuseTexture","getTextures","colorTexture","_actor$getProperty$ge3","_actor$getProperty2","getRoughnessTexture","getMetallicTexture","getAmbientOcclusionTexture","getEmissionTexture","replaceShaderSelect","getUsage","rep","i","POINTS","Points","Lines","LinesFromTriangles","LinesFromStrips","Strips","TriangleEdges","getHashFromUsage","usage","getTopologyFromUsage","buildVertexInput","_model$renderable$get","_model$renderable","pd","currentInput","cells","cellArray","primType","edges","points","getPoints","indexBuffer","buffRequest","Index","numberOfPoints","getNumberOfPoints","getBufferManager","setIndexBuffer","shift","getBufferShift","_buffRequest","join","PointArray","dataArray","packExtra","buff","addBuffer","removeBufferIfPresent","_usesCellNormals","normals","getPointData","getNormals","_buffRequest2","scale","_buff","NormalsFromPoints","_buff2","haveColors","getScalarVisibility","c","getColorMapColors","scalarMode","getScalarMode","haveCellScalars","USE_CELL_DATA","USE_CELL_FIELD_DATA","USE_FIELD_DATA","getScalars","USE_POINT_FIELD_DATA","_buffRequest3","cellData","cellOffset","_buff3","getInterpolateScalarsBeforeMapping","getColorCoordinates","getTCoords","_buff4","getBufferForPointArray","getIndexBuffer","updateTextures","_model$renderable$get2","_model$renderable2","_actor$getProperty$ge14","_actor$getProperty8","_actor$getProperty$ge15","_actor$getProperty9","_actor$getProperty$ge16","_actor$getProperty10","_actor$getProperty$ge17","_actor$getProperty11","_actor$getProperty$ge18","_actor$getProperty12","_actor$getProperty$ge19","_actor$getProperty13","_renderer$getEnvironm2","newTextures","idata","getColorTextureMap","label","setInputData","textures","pair","_pair","_pair2","_pair3","_pair4","_pair5","_pair6","_pair7","_pair8","length","getInputData","getJsImageData","getCanvas","getImage","_i","srcTexture","textureName","newTex","getTextureManager","getTextureForVTKTexture","getReady","found","t","tview","createView","textureViews","interpolate","getInterpolate","addressMode","getEdgeClamp","getRepeat","addSampler","addressModeU","addressModeV","addressModeW","minFilter","magFilter","mipmapFilter","_i2","splice","computePipelineHash","pipelineHash","TriangleStripEdges","SSBO","uhash","getPipelineHash","updateBuffers","vbo","setNumberOfVertices","getSizeInBytes","getStrideInBytes","setTopology","setNumberOfInstances","Math","ceil","DEFAULT_VALUES","extend","initiaLalues","arguments","undefined","Object","assign","fragmentShaderTemplate","vertexShaderTemplate","_tmpMat3","identity","Float64Array","_tmpMat4","addEntry","vtkWebGPUCellArrayMapper$1","default"],"sources":["/home/rakshith/Documents/RemoteRendering/vtk-js-react-app/node_modules/@kitware/vtk.js/Rendering/WebGPU/CellArrayMapper.js"],"sourcesContent":["import { mat3, mat4 } from 'gl-matrix';\nimport { newInstance as newInstance$1, setGet } from '../../macros.js';\nimport vtkMapper from '../Core/Mapper.js';\nimport vtkProp from '../Core/Prop.js';\nimport vtkProperty from '../Core/Property.js';\nimport vtkProperty2D from '../Core/Property2D.js';\nimport vtkTexture from '../Core/Texture.js';\nimport vtkWebGPUBufferManager from './BufferManager.js';\nimport vtkWebGPUShaderCache from './ShaderCache.js';\nimport vtkWebGPUUniformBuffer from './UniformBuffer.js';\nimport vtkWebGPUSimpleMapper from './SimpleMapper.js';\nimport vtkWebGPUTypes from './Types.js';\n\nvar BufferUsage = vtkWebGPUBufferManager.BufferUsage,\n    PrimitiveTypes = vtkWebGPUBufferManager.PrimitiveTypes;\nvar Representation = vtkProperty.Representation;\nvar ScalarMode = vtkMapper.ScalarMode;\nvar CoordinateSystem = vtkProp.CoordinateSystem;\nvar DisplayLocation = vtkProperty2D.DisplayLocation;\nvar vtkWebGPUPolyDataVS = \"\\n//VTK::Renderer::Dec\\n\\n//VTK::Color::Dec\\n\\n//VTK::Normal::Dec\\n\\n//VTK::TCoord::Dec\\n\\n//VTK::Select::Dec\\n\\n//VTK::Mapper::Dec\\n\\n//VTK::IOStructs::Dec\\n\\n@vertex\\nfn main(\\n//VTK::IOStructs::Input\\n)\\n//VTK::IOStructs::Output\\n{\\n  var output : vertexOutput;\\n\\n  var vertex: vec4<f32> = vertexBC;\\n\\n  //VTK::Color::Impl\\n\\n  //VTK::Normal::Impl\\n\\n  //VTK::TCoord::Impl\\n\\n  //VTK::Select::Impl\\n\\n  //VTK::Position::Impl\\n\\n  return output;\\n}\\n\";\nvar vtkWebGPUPolyDataFS = \"\\nstruct PBRData {\\n  diffuse: vec3<f32>,\\n  specular: vec3<f32>,\\n}\\n\\n// Dot product with the max already in it\\nfn mdot(a: vec3<f32>, b: vec3<f32>) -> f32 {\\n  return max(0.0, dot(a, b));\\n}\\n// Dot product with a max in it that does not allow for negative values\\n// Physically based rendering is accurate as long as normals are accurate,\\n// however this is pretty often not the case. In order to prevent negative\\n// values from ruining light calculations and creating zones of zero light,\\n// this remapping is used, which smoothly clamps the dot product between\\n// zero and one while still maintaining a good amount of accuracy.\\nfn cdot(a: vec3<f32>, b: vec3<f32>) -> f32 {\\n  var d: f32 = max(0.0, dot(a, b));\\n  d = pow((d + 1) / 2.0, 2.6);\\n  return d;\\n}\\n\\n// Lambertian diffuse model\\nfn lambertDiffuse(base: vec3<f32>, N: vec3<f32>, L: vec3<f32>) -> vec3<f32> {\\n  var pi: f32 = 3.14159265359; \\n  var NdotL: f32 = mdot(N, L);\\n  NdotL = pow(NdotL, 1.5);\\n  return (base/pi)*NdotL;\\n}\\n\\n// Yasuhiro Fujii improvement on the Oren-Nayar model\\n// https://mimosa-pudica.net/improved-oren-nayar.html\\n// p is surface color, o is roughness\\nfn fujiiOrenNayar(p: vec3<f32>, o: f32, N: vec3<f32>, L: vec3<f32>, V: vec3<f32>) -> vec3<f32> {\\n  var invpi: f32 = 0.31830988618; // 1/pi\\n\\n  var o2 = o*o;\\n  var NdotL: f32 = mdot(N, L);\\n  NdotL = pow(NdotL, 1.5); // Less physically accurate, but hides the \\\"seams\\\" between lights better\\n\\n  var NdotV: f32 = mdot(N, V);\\n  var LdotV: f32 = mdot(L, V);\\n\\n  var s: f32 = LdotV - NdotL*NdotV;\\n  var t: f32 = mix(1, max(NdotL, NdotV), step(0, s)); // Mix with step is the equivalent of an if statement\\n  var A: vec3<f32> = 0.5*(o2 / (o2 + 0.33)) + 0.17*p*(o2 / (o2 + 0.13));\\n  A = invpi*(1 - A);\\n  var B: f32 = 0.45*(o2 / (o2 + 0.09));\\n  B = invpi*B;\\n\\n  return p*NdotL*(A + B*(s/t));\\n}\\n\\n// Fresnel portion of BRDF (IOR only, simplified)\\nfn schlickFresnelIOR(V: vec3<f32>, N: vec3<f32>, ior: f32, k: f32) -> f32 {\\n  var NdotV: f32 = mdot(V, N);\\n  var F0: f32 = (pow((ior - 1.0), 2) + k*k) / (pow((ior + 1.0), 2) + k*k); // This takes into account the roughness, which the other one does not\\n  return F0 + (1 - F0) * pow((1-NdotV), 5); \\n}\\n\\n// Fresnel portion of BRDF (Color ior, better)\\nfn schlickFresnelRGB(V: vec3<f32>, N: vec3<f32>, F0: vec3<f32>) -> vec3<f32> {\\n  var NdotV: f32 = mdot(V, N);\\n  return F0 + (1 - F0) * pow((1-NdotV), 5); \\n}\\n\\n// Normal portion of BRDF\\n// https://learnopengl.com/PBR/Theory\\n// Trowbridge-Reitz GGX functions: normal, halfway, roughness^2\\nfn trGGX(N: vec3<f32>, H: vec3<f32>, a: f32) -> f32 {\\n  var pi: f32 = 3.14159265359; \\n\\n  var a2: f32 = a*a;\\n  var NdotH = mdot(N, H);\\n  var NdotH2 = NdotH*NdotH;\\n  \\n  var denom: f32 = NdotH2 * (a2 - 1.0) + 1.0;\\n\\n  return a2 / max((pi*denom*denom), 0.000001);\\n}\\n\\n// A VERY bad approximation of anisotropy. Real anisotropic calculations require tangent and bitangent\\nfn anisotrophicTrGGX(N: vec3<f32>, H: vec3<f32>, O: vec3<f32>, s: f32, a: f32) -> f32 {\\n  var Op: vec3<f32> = (rendererUBO.WCVCNormals * vec4<f32>(normalize(O) * s, 0.)).xyz;\\n\\n  var ggx1: f32 = trGGX(N + Op*s, H, a);\\n  var ggx2: f32 = trGGX(N - Op*s, H, a);\\n  return (0.5 * ggx1 + 0.5 * ggx2);\\n}\\n\\n// Geometry portion of BRDF\\nfn schlickGGX(N: vec3<f32>, X: vec3<f32>, k: f32) -> f32 {\\n  var NdotX = cdot(N, X);\\n  return NdotX / max(0.000001, (NdotX*(1-k) + k));\\n}\\n\\nfn smithSurfaceRoughness(N: vec3<f32>, V: vec3<f32>, L: vec3<f32>, k: f32) -> f32 {\\n  var ggx1: f32 = min(1, schlickGGX(N, V, k));\\n  var ggx2: f32 = min(1, schlickGGX(N, L, k));\\n  return ggx1*ggx2;\\n}\\n\\n// BRDF Combination\\nfn cookTorrance(D: f32, F: f32, G: f32, N: vec3<f32>, V: vec3<f32>, L: vec3<f32>) -> f32 {\\n  var num: f32 = D*F*G;\\n  var denom: f32 = 4*cdot(V, N)*cdot(L, N);\\n\\n  return num / max(denom, 0.000001);\\n}\\n\\n// Different lighting calculations for different light sources\\nfn calcDirectionalLight(N: vec3<f32>, V: vec3<f32>, ior: f32, roughness: f32, metallic: f32, direction: vec3<f32>, color: vec3<f32>, base: vec3<f32>) -> PBRData {  \\n  var L: vec3<f32> = normalize(direction); // Light Vector\\n  var H: vec3<f32> = normalize(L + V); // Halfway Vector\\n\\n  var alpha = roughness*roughness;\\n  var k: f32 = alpha*alpha / 2;\\n\\n  var D: f32 = trGGX(N, H, alpha); // Distribution\\n  // var F: f32 = schlickFresnelIOR(V, N, ior, k); // Fresnel\\n  var G: f32 = smithSurfaceRoughness(N, V, L, k); // Geometry\\n\\n  var brdf: f32 = cookTorrance(D, 1, G, N, V, L); // Fresnel term is replaced with 1 because it is added later\\n  var incoming: vec3<f32> = color;\\n  var angle: f32 = mdot(L, N);\\n  angle = pow(angle, 1.5);\\n\\n  var specular: vec3<f32> = brdf*incoming*angle;\\n  // Oren-Nayar gives a clay-like effect when fully rough which some people may not want, so it might be better to give a separate\\n  // control property for the diffuse vs specular roughness\\n  var diffuse: vec3<f32> = incoming*fujiiOrenNayar(base, roughness, N, L, V); \\n  // Stores the specular and diffuse separately to allow for finer post processing\\n  var out = PBRData(diffuse, specular);\\n  \\n  return out; // Returns angle along with color of light so the final color can be multiplied by angle as well (creates black areas)\\n}\\n\\n// TODO: find some way to reduce the number of arguments going in here\\nfn calcPointLight(N: vec3<f32>, V: vec3<f32>, fragPos: vec3<f32>, ior: f32, roughness: f32, metallic: f32, position: vec3<f32>, color: vec3<f32>, base: vec3<f32>) -> PBRData {\\n  var L: vec3<f32> = normalize(position - fragPos); // Light Vector\\n  var H: vec3<f32> = normalize(L + V); // Halfway Vector\\n  var dist = distance(position, fragPos);\\n\\n  var alpha = roughness*roughness;\\n  var k: f32 = alpha*alpha / 2; // could also be pow(alpha + 1.0, 2) / 8\\n\\n  var D: f32 = trGGX(N, H, alpha); // Distribution\\n  // var F: f32 = schlickFresnelIOR(V, N, ior, k); // Fresnel\\n  var G: f32 = smithSurfaceRoughness(N, V, L, k); // Geometry\\n\\n  var brdf: f32 = cookTorrance(D, 1, G, N, V, L);  \\n  var incoming: vec3<f32> = color * (1. / (dist*dist));\\n  var angle: f32 = mdot(L, N);\\n  angle = pow(angle, 1.5); // Smoothing factor makes it less accurate, but reduces ugly \\\"seams\\\" bewteen light sources\\n\\n  var specular: vec3<f32> = brdf*incoming*angle;\\n  var diffuse: vec3<f32> = incoming*fujiiOrenNayar(base, roughness, N, L, V);\\n\\n  // Stores the specular and diffuse separately to allow for finer post processing\\n  // Could also be done (propably more properly) with a struct\\n  var out = PBRData(diffuse, specular);\\n  \\n  return out; // Returns angle along with color of light so the final color can be multiplied by angle as well (creates black areas)\\n}\\n\\n// For a reason unknown to me, spheres dont seem to behave propperly with head-on spot lights\\nfn calcSpotLight(N: vec3<f32>, V: vec3<f32>, fragPos: vec3<f32>, ior: f32, roughness: f32, metallic: f32, position: vec3<f32>, direction: vec3<f32>, cones: vec2<f32>, color: vec3<f32>, base: vec3<f32>) -> PBRData {\\n  var L: vec3<f32> = normalize(position - fragPos);\\n  var H: vec3<f32> = normalize(L + V); // Halfway Vector\\n  var dist = distance(position, fragPos);\\n\\n  var alpha = roughness*roughness;\\n  var k: f32 = alpha*alpha / 2; // could also be pow(alpha + 1.0, 2) / 8\\n\\n  var D: f32 = trGGX(N, H, alpha); // Distribution\\n  // var F: f32 = schlickFresnelIOR(V, N, ior, k); // Fresnel\\n  var G: f32 = smithSurfaceRoughness(N, V, L, k); // Geometry\\n\\n  var brdf: f32 = cookTorrance(D, 1, G, N, V, L);  \\n  \\n  // Cones.x is the inner phi and cones.y is the outer phi\\n  var theta: f32 = mdot(normalize(direction), L);\\n  var epsilon: f32 = cones.x - cones.y;\\n  var intensity: f32 = (theta - cones.y) / epsilon;\\n  intensity = clamp(intensity, 0.0, 1.0);\\n  intensity /= dist*dist;\\n\\n  var incoming: vec3<f32> = color * intensity;\\n\\n  var angle: f32 = mdot(L, N);\\n  angle = pow(angle, 1.5); // Smoothing factor makes it less accurate, but reduces ugly \\\"seams\\\" bewteen light sources\\n\\n  var specular: vec3<f32> = brdf*incoming*angle;\\n  var diffuse: vec3<f32> = incoming*fujiiOrenNayar(base, roughness, N, L, V);\\n\\n  // Stores the specular and diffuse separately to allow for finer post processing\\n  // Could also be done (propably more properly) with a struct\\n  var out = PBRData(diffuse, specular);\\n  \\n  return out; // Returns angle along with color of light so the final color can be multiplied by angle as well (creates black areas)\\n}\\n\\n// Environment mapping stuff\\n// Takes in a vector and converts it to an equivalent coordinate in a rectilinear texture. Should be replaced with cubemaps at some point\\nfn vecToRectCoord(dir: vec3<f32>) -> vec2<f32> {\\n  var tau: f32 = 6.28318530718;\\n  var pi: f32 = 3.14159265359;\\n  var out: vec2<f32> = vec2<f32>(0.0);\\n\\n  out.x = atan2(dir.z, dir.x) / tau;\\n  out.x += 0.5;\\n\\n  var phix: f32 = length(vec2(dir.x, dir.z));\\n  out.y = atan2(dir.y, phix) / pi + 0.5;\\n\\n  return out;\\n}\\n\\n//VTK::Renderer::Dec\\n\\n//VTK::Color::Dec\\n\\n//VTK::TCoord::Dec\\n\\n// optional surface normal declaration\\n//VTK::Normal::Dec\\n\\n//VTK::Select::Dec\\n\\n//VTK::RenderEncoder::Dec\\n\\n//VTK::Mapper::Dec\\n\\n//VTK::IOStructs::Dec\\n\\n@fragment\\nfn main(\\n//VTK::IOStructs::Input\\n)\\n//VTK::IOStructs::Output\\n{\\n  var output : fragmentOutput;\\n\\n  // Temporary ambient, diffuse, and opacity\\n  var ambientColor: vec4<f32> = mapperUBO.AmbientColor;\\n  var diffuseColor: vec4<f32> = mapperUBO.DiffuseColor;\\n  var opacity: f32 = mapperUBO.Opacity;\\n\\n  // This should be declared somewhere else\\n  var _diffuseMap: vec4<f32> = vec4<f32>(1);\\n  var _roughnessMap: vec4<f32> = vec4<f32>(1);\\n  var _metallicMap: vec4<f32> = vec4<f32>(1);\\n  var _normalMap: vec4<f32> = vec4<f32>(0, 0, 1, 0); // normal map was setting off the normal vector detection in fragment\\n  var _ambientOcclusionMap: vec4<f32> = vec4<f32>(1);\\n  var _emissionMap: vec4<f32> = vec4<f32>(0);\\n\\n  //VTK::Color::Impl\\n\\n  //VTK::TCoord::Impl\\n\\n  //VTK::Normal::Impl\\n\\n  var computedColor: vec4<f32> = vec4<f32>(diffuseColor.rgb, 1.0);\\n\\n  //VTK::Light::Impl\\n\\n  //VTK::Select::Impl\\n\\n  if (computedColor.a == 0.0) { discard; };\\n\\n  //VTK::Position::Impl\\n\\n  //VTK::RenderEncoder::Impl\\n\\n  return output;\\n}\\n\";\n\nfunction isEdges(hash) {\n  // edge pipelines have \"edge\" in them\n  return hash.indexOf('edge') >= 0;\n} // ----------------------------------------------------------------------------\n// vtkWebGPUCellArrayMapper methods\n// ----------------------------------------------------------------------------\n\n\nfunction vtkWebGPUCellArrayMapper(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkWebGPUCellArrayMapper');\n\n  publicAPI.buildPass = function (prepass) {\n    if (prepass) {\n      if (model.is2D) {\n        model.WebGPUActor = publicAPI.getFirstAncestorOfType('vtkWebGPUActor2D');\n        model.forceZValue = true;\n      } else {\n        model.WebGPUActor = publicAPI.getFirstAncestorOfType('vtkWebGPUActor');\n        model.forceZValue = false;\n      }\n\n      model.coordinateSystem = model.WebGPUActor.getRenderable().getCoordinateSystem();\n      model.useRendererMatrix = model.coordinateSystem !== CoordinateSystem.DISPLAY;\n      model.WebGPURenderer = model.WebGPUActor.getFirstAncestorOfType('vtkWebGPURenderer');\n      model.WebGPURenderWindow = model.WebGPURenderer.getParent();\n      model.device = model.WebGPURenderWindow.getDevice();\n    }\n  }; // Renders myself\n\n\n  publicAPI.translucentPass = function (prepass) {\n    if (prepass) {\n      publicAPI.prepareToDraw(model.WebGPURenderer.getRenderEncoder());\n      model.renderEncoder.registerDrawCallback(model.pipeline, publicAPI.draw);\n    }\n  };\n\n  publicAPI.opaquePass = function (prepass) {\n    if (prepass) {\n      publicAPI.prepareToDraw(model.WebGPURenderer.getRenderEncoder());\n      model.renderEncoder.registerDrawCallback(model.pipeline, publicAPI.draw);\n    }\n  };\n\n  publicAPI.updateUBO = function () {\n    // make sure the data is up to date\n    var actor = model.WebGPUActor.getRenderable();\n    var ppty = actor.getProperty();\n    var utime = model.UBO.getSendTime();\n\n    if (publicAPI.getMTime() > utime || ppty.getMTime() > utime || model.renderable.getMTime() > utime) {\n      var _ppty$getEdgeColorByR;\n\n      // Matricies\n      var keyMats = model.WebGPUActor.getKeyMatrices(model.WebGPURenderer);\n      model.UBO.setArray('BCWCMatrix', keyMats.bcwc);\n      model.UBO.setArray('BCSCMatrix', keyMats.bcsc);\n      model.UBO.setArray('MCWCNormals', keyMats.normalMatrix);\n\n      if (model.is2D) {\n        model.UBO.setValue('ZValue', model.WebGPUActor.getRenderable().getProperty().getDisplayLocation() === DisplayLocation.FOREGROUND ? 1.0 : 0.0);\n\n        var _aColor = ppty.getColorByReference();\n\n        model.UBO.setValue('AmbientIntensity', 1.0);\n        model.UBO.setArray('DiffuseColor', [_aColor[0], _aColor[1], _aColor[2], 1.0]);\n        model.UBO.setValue('DiffuseIntensity', 0.0);\n        model.UBO.setValue('SpecularIntensity', 0.0);\n      } else {\n        // Base Colors\n        var _aColor2 = ppty.getAmbientColorByReference();\n\n        model.UBO.setValue('AmbientIntensity', ppty.getAmbient());\n        model.UBO.setArray('AmbientColor', [_aColor2[0], _aColor2[1], _aColor2[2], 1.0]);\n        model.UBO.setValue('DiffuseIntensity', ppty.getDiffuse());\n        _aColor2 = ppty.getDiffuseColorByReference();\n        model.UBO.setArray('DiffuseColor', [_aColor2[0], _aColor2[1], _aColor2[2], 1.0]); // Roughness\n\n        model.UBO.setValue('Roughness', ppty.getRoughness());\n        model.UBO.setValue('BaseIOR', ppty.getBaseIOR()); // Metallic\n\n        model.UBO.setValue('Metallic', ppty.getMetallic()); // Normal\n\n        model.UBO.setValue('NormalStrength', ppty.getNormalStrength()); // Emission\n\n        model.UBO.setValue('Emission', ppty.getEmission()); // Specular\n\n        model.UBO.setValue('SpecularIntensity', ppty.getSpecular());\n        _aColor2 = ppty.getSpecularColorByReference();\n        model.UBO.setArray('SpecularColor', [_aColor2[0], _aColor2[1], _aColor2[2], 1.0]);\n      } // Edge and line rendering\n\n\n      var aColor = (_ppty$getEdgeColorByR = ppty.getEdgeColorByReference) === null || _ppty$getEdgeColorByR === void 0 ? void 0 : _ppty$getEdgeColorByR.call(ppty);\n\n      if (aColor) {\n        model.UBO.setArray('EdgeColor', [aColor[0], aColor[1], aColor[2], 1.0]);\n      }\n\n      model.UBO.setValue('LineWidth', ppty.getLineWidth());\n      model.UBO.setValue('Opacity', ppty.getOpacity());\n      model.UBO.setValue('PropID', model.WebGPUActor.getPropID());\n      var device = model.WebGPURenderWindow.getDevice();\n      model.UBO.sendIfNeeded(device);\n    }\n  };\n\n  publicAPI.haveWideLines = function () {\n    var actor = model.WebGPUActor.getRenderable();\n    var representation = actor.getProperty().getRepresentation();\n\n    if (actor.getProperty().getLineWidth() <= 1.0) {\n      return false;\n    }\n\n    if (model.primitiveType === PrimitiveTypes.Verts) {\n      return false;\n    }\n\n    if (model.primitiveType === PrimitiveTypes.Triangles || model.primitiveType === PrimitiveTypes.TriangleStrips) {\n      return representation === Representation.WIREFRAME;\n    }\n\n    return true;\n  };\n\n  publicAPI.replaceShaderPosition = function (hash, pipeline, vertexInput) {\n    var vDesc = pipeline.getShaderDescription('vertex');\n    vDesc.addBuiltinOutput('vec4<f32>', '@builtin(position) Position');\n    if (!vDesc.hasOutput('vertexVC')) vDesc.addOutput('vec4<f32>', 'vertexVC');\n    var code = vDesc.getCode();\n\n    if (model.useRendererMatrix) {\n      code = vtkWebGPUShaderCache.substitute(code, '//VTK::Position::Impl', ['    var pCoord: vec4<f32> = rendererUBO.SCPCMatrix*mapperUBO.BCSCMatrix*vertexBC;', '    output.vertexVC = rendererUBO.SCVCMatrix * mapperUBO.BCSCMatrix * vec4<f32>(vertexBC.xyz, 1.0);', '//VTK::Position::Impl']).result;\n\n      if (model.forceZValue) {\n        code = vtkWebGPUShaderCache.substitute(code, '//VTK::Position::Impl', ['pCoord = vec4<f32>(pCoord.xyz/pCoord.w, 1.0);', 'pCoord.z = mapperUBO.ZValue;', '//VTK::Position::Impl']).result;\n      }\n    } else {\n      code = vtkWebGPUShaderCache.substitute(code, '//VTK::Position::Impl', ['    var pCoord: vec4<f32> = mapperUBO.BCSCMatrix*vertexBC;', '    pCoord.x = 2.0* pCoord.x / rendererUBO.viewportSize.x - 1.0;', '    pCoord.y = 2.0* pCoord.y / rendererUBO.viewportSize.y - 1.0;', '    pCoord.z = 0.5 - 0.5 * pCoord.z;', '//VTK::Position::Impl']).result;\n\n      if (model.forceZValue) {\n        code = vtkWebGPUShaderCache.substitute(code, '//VTK::Position::Impl', ['    pCoord.z = mapperUBO.ZValue;', '//VTK::Position::Impl']).result;\n      }\n    }\n\n    if (publicAPI.haveWideLines()) {\n      vDesc.addBuiltinInput('u32', '@builtin(instance_index) instanceIndex'); // widen the edge\n\n      code = vtkWebGPUShaderCache.substitute(code, '//VTK::Position::Impl', ['    var tmpPos: vec4<f32> = pCoord;', '    var numSteps: f32 = ceil(mapperUBO.LineWidth - 1.0);', '    var offset: f32 = (mapperUBO.LineWidth - 1.0) * (f32(input.instanceIndex / 2u) - numSteps/2.0) / numSteps;', '    var tmpPos2: vec3<f32> = tmpPos.xyz / tmpPos.w;', '    tmpPos2.x = tmpPos2.x + 2.0 * (f32(input.instanceIndex) % 2.0) * offset / rendererUBO.viewportSize.x;', '    tmpPos2.y = tmpPos2.y + 2.0 * (f32(input.instanceIndex + 1u) % 2.0) * offset / rendererUBO.viewportSize.y;', '    tmpPos2.z = min(1.0, tmpPos2.z + 0.00001);', // could become a setting\n      '    pCoord = vec4<f32>(tmpPos2.xyz * tmpPos.w, tmpPos.w);', '//VTK::Position::Impl']).result;\n    }\n\n    code = vtkWebGPUShaderCache.substitute(code, '//VTK::Position::Impl', ['    output.Position = pCoord;']).result;\n    vDesc.setCode(code);\n  };\n\n  model.shaderReplacements.set('replaceShaderPosition', publicAPI.replaceShaderPosition);\n\n  publicAPI.replaceShaderNormal = function (hash, pipeline, vertexInput) {\n    var normalBuffer = vertexInput.getBuffer('normalMC');\n    var actor = model.WebGPUActor.getRenderable();\n\n    if (normalBuffer) {\n      var vDesc = pipeline.getShaderDescription('vertex');\n\n      if (!vDesc.hasOutput('normalVC')) {\n        vDesc.addOutput('vec3<f32>', 'normalVC', normalBuffer.getArrayInformation()[0].interpolation);\n      }\n\n      if (!vDesc.hasOutput('tangentVC')) {\n        vDesc.addOutput('vec3<f32>', 'tangentVC', normalBuffer.getArrayInformation()[0].interpolation);\n      }\n\n      if (!vDesc.hasOutput('bitangentVC')) {\n        vDesc.addOutput('vec3<f32>', 'bitangentVC', normalBuffer.getArrayInformation()[0].interpolation);\n      }\n\n      var code = vDesc.getCode();\n      code = vtkWebGPUShaderCache.substitute(code, '//VTK::Normal::Impl', ['  output.normalVC = normalize((rendererUBO.WCVCNormals * mapperUBO.MCWCNormals * normalMC).xyz);', // This is just an approximation, but it happens to work extremely well\n      // It only works well for normals that are head on and not super angled though\n      // Definitely needs to be replaced\n      '  var c1: vec3<f32> = cross(output.normalVC, vec3<f32>(0, 0, 1));', '  var c2: vec3<f32> = cross(output.normalVC, vec3<f32>(0, 1, 0));', '  var tangent: vec3<f32> = mix(c1, c2, distance(c1, c2));', '  output.tangentVC = normalize(tangent);', '  output.bitangentVC = normalize(cross(output.normalVC, tangent));']).result;\n      vDesc.setCode(code);\n      var fDesc = pipeline.getShaderDescription('fragment');\n      code = fDesc.getCode();\n\n      if (actor.getProperty().getNormalTexture()) {\n        code = vtkWebGPUShaderCache.substitute(code, '//VTK::Normal::Impl', ['  var normal: vec3<f32> = input.normalVC;', '  if (!input.frontFacing) { normal = -normal; }', '  var tangent: vec3<f32> = input.tangentVC;', '  var bitangent: vec3<f32> = input.bitangentVC;', '  var TCVCMatrix: mat3x3<f32> = mat3x3<f32>(', '    tangent.x, bitangent.x, normal.x,', '    tangent.y, bitangent.y, normal.y,', '    tangent.z, bitangent.z, normal.z,', '  );', '  var mappedNormal: vec3<f32> = TCVCMatrix * (_normalMap.xyz * 2 - 1);', '  normal = mix(normal, mappedNormal, mapperUBO.NormalStrength);', '  normal = normalize(normal);']).result;\n      } else {\n        code = vtkWebGPUShaderCache.substitute(code, '//VTK::Normal::Impl', ['  var normal: vec3<f32> = input.normalVC;', '  if (!input.frontFacing) { normal = -normal; }', '  normal = normalize(normal);']).result;\n      }\n\n      fDesc.setCode(code);\n    }\n  };\n\n  model.shaderReplacements.set('replaceShaderNormal', publicAPI.replaceShaderNormal); // we only apply lighting when there is a \"var normal\" declaration in the\n  // fragment shader code. That is the lighting trigger.\n\n  publicAPI.replaceShaderLight = function (hash, pipeline, vertexInput) {\n    if (hash.includes('sel')) return;\n    var vDesc = pipeline.getShaderDescription('vertex');\n    if (!vDesc.hasOutput('vertexVC')) vDesc.addOutput('vec4<f32>', 'vertexVC');\n    var renderer = model.WebGPURenderer.getRenderable();\n    var fDesc = pipeline.getShaderDescription('fragment');\n    var code = fDesc.getCode(); // Code that runs if the fragment shader includes normals\n\n    if (code.includes('var normal:') && model.useRendererMatrix && !isEdges(hash) && !model.is2D && !hash.includes('sel')) {\n      var _renderer$getEnvironm;\n\n      var lightingCode = [// Constants\n      '  var pi: f32 = 3.14159265359;', // Vectors needed for light calculations\n      '  var fragPos: vec3<f32> = vec3<f32>(input.vertexVC.xyz);', '  var V: vec3<f32> = mix(normalize(-fragPos), vec3<f32>(0, 0, 1), f32(rendererUBO.cameraParallel)); // View Vector', // Values needed for light calculations\n      '  var baseColor: vec3<f32> = _diffuseMap.rgb * diffuseColor.rgb;', '  var roughness: f32 = max(0.000001, mapperUBO.Roughness * _roughnessMap.r);', // Need to have a different way of sampling greyscale values aside from .r\n      '  var metallic: f32 = mapperUBO.Metallic * _metallicMap.r;', '  var alpha: f32 = roughness*roughness;', '  var ior: f32 = mapperUBO.BaseIOR;', '  var k: f32 = alpha*alpha / 2;', // Split diffuse and specular components\n      '  var diffuse: vec3<f32> = vec3<f32>(0.);', '  var specular: vec3<f32> = vec3<f32>(0.);', '  var emission: vec3<f32> = _emissionMap.rgb * mapperUBO.Emission;', // Summing diffuse and specular components of directional lights\n      '  {', '    var i: i32 = 0;', '    loop {', '      if !(i < rendererUBO.LightCount) { break; }', '      switch (i32(rendererLightSSBO.values[i].LightData.x)) {', '         // Point Light', '         case 0 {', '           var color: vec3<f32> = rendererLightSSBO.values[i].LightColor.rgb * rendererLightSSBO.values[i].LightColor.w;', '           var pos: vec3<f32> = (rendererLightSSBO.values[i].LightPos).xyz;', '           var calculated: PBRData = calcPointLight(normal, V, fragPos, ior, roughness, metallic, pos, color, baseColor);', '           diffuse += max(vec3<f32>(0), calculated.diffuse);', '           specular += max(vec3<f32>(0), calculated.specular);', '          }', '         // Directional light', '         case 1 {', '           var dir: vec3<f32> = (rendererUBO.WCVCNormals * vec4<f32>(normalize(rendererLightSSBO.values[i].LightDir.xyz), 0.)).xyz;', '           dir = normalize(dir);', '           var color: vec3<f32> = rendererLightSSBO.values[i].LightColor.rgb * rendererLightSSBO.values[i].LightColor.w;', '           var calculated: PBRData = calcDirectionalLight(normal, V, ior, roughness, metallic, dir, color, baseColor); // diffuseColor.rgb needs to be fixed with a more dynamic diffuse color', '           diffuse += max(vec3<f32>(0), calculated.diffuse);', '           specular += max(vec3<f32>(0), calculated.specular);', '         }', '         // Spot Light', '         case 2 {', '           var color: vec3<f32> = rendererLightSSBO.values[i].LightColor.rgb * rendererLightSSBO.values[i].LightColor.w;', '           var pos: vec3<f32> = (rendererLightSSBO.values[i].LightPos).xyz;', '           var dir: vec3<f32> = (rendererUBO.WCVCNormals * vec4<f32>(normalize(rendererLightSSBO.values[i].LightDir.xyz), 0.)).xyz;', '           dir = normalize(dir);', '           var cones: vec2<f32> = vec2<f32>(rendererLightSSBO.values[i].LightData.y, rendererLightSSBO.values[i].LightData.z);', '           var calculated: PBRData = calcSpotLight(normal, V, fragPos, ior, roughness, metallic, pos, dir, cones, color, baseColor);', '           diffuse += max(vec3<f32>(0), calculated.diffuse);', '           specular += max(vec3<f32>(0), calculated.specular);', '         }', '         default { continue; }', '       }', '      continuing { i++; }', '    }', '  }', // Final variables for combining specular and diffuse\n      '  var fresnel: f32 = schlickFresnelIOR(V, normal, ior, k); // Fresnel', '  fresnel = min(1, fresnel);', '  // This could be controlled with its own variable (that isnt base color) for better artistic control', '  var fresnelMetallic: vec3<f32> = schlickFresnelRGB(V, normal, baseColor); // Fresnel for metal, takes color into account', '  var kS: vec3<f32> = mix(vec3<f32>(fresnel), fresnelMetallic, metallic);', '  kS = min(vec3<f32>(1), kS);', '  var kD: vec3<f32> = (1.0 - kS) * (1.0 - metallic);', '  var PBR: vec3<f32> = mapperUBO.DiffuseIntensity*kD*diffuse + kS*specular;', '  PBR += emission;', '  computedColor = vec4<f32>(PBR, mapperUBO.Opacity);'];\n\n      if ((_renderer$getEnvironm = renderer.getEnvironmentTexture()) !== null && _renderer$getEnvironm !== void 0 && _renderer$getEnvironm.getImageLoaded()) {\n        lightingCode.push('  // To get diffuse IBL, the texture is sampled with normals in worldspace', '  var diffuseIBLCoords: vec3<f32> = (transpose(rendererUBO.WCVCNormals) * vec4<f32>(normal, 1.)).xyz;', '  var diffuseCoords: vec2<f32> = vecToRectCoord(diffuseIBLCoords);', '  // To get specular IBL, the texture is sampled as the worldspace reflection between the normal and view vectors', '  // Reflections are first calculated in viewspace, then converted to worldspace to sample the environment', '  var VreflN: vec3<f32> = normalize(reflect(-V, normal));', '  var reflectionIBLCoords = (transpose(rendererUBO.WCVCNormals) * vec4<f32>(VreflN, 1.)).xyz;', '  var specularCoords: vec2<f32> = vecToRectCoord(reflectionIBLCoords);', '  var diffuseIBL = textureSampleLevel(EnvironmentTexture, EnvironmentTextureSampler, diffuseCoords, rendererUBO.MaxEnvironmentMipLevel);', // Level multiplier should be set by UBO\n        '  var level = roughness * rendererUBO.MaxEnvironmentMipLevel;', '  var specularIBL = textureSampleLevel(EnvironmentTexture, EnvironmentTextureSampler, specularCoords, level);', // Manual mip smoothing since not all formats support smooth level sampling\n        '  var specularIBLContribution: vec3<f32> = specularIBL.rgb*rendererUBO.BackgroundSpecularStrength;', '  computedColor += vec4<f32>(specularIBLContribution*kS, 0);', '  var diffuseIBLContribution: vec3<f32> = diffuseIBL.rgb*rendererUBO.BackgroundDiffuseStrength;', '  diffuseIBLContribution *= baseColor * _ambientOcclusionMap.rgb;', // Multipy by baseColor may be changed\n        '  computedColor += vec4<f32>(diffuseIBLContribution*kD, 0);');\n      }\n\n      code = vtkWebGPUShaderCache.substitute(code, '//VTK::Light::Impl', lightingCode).result;\n      fDesc.setCode(code); // If theres no normals, just set the specular color to be flat\n    } else {\n      code = vtkWebGPUShaderCache.substitute(code, '//VTK::Light::Impl', ['  var diffuse: vec3<f32> = diffuseColor.rgb;', '  var specular: vec3<f32> = mapperUBO.SpecularColor.rgb * mapperUBO.SpecularColor.a;', '  computedColor = vec4<f32>(diffuse * _diffuseMap.rgb, mapperUBO.Opacity);']).result;\n      fDesc.setCode(code);\n    }\n  };\n\n  model.shaderReplacements.set('replaceShaderLight', publicAPI.replaceShaderLight);\n\n  publicAPI.replaceShaderColor = function (hash, pipeline, vertexInput) {\n    // By default, set the colors to be flat\n    if (isEdges(hash)) {\n      var _fDesc = pipeline.getShaderDescription('fragment');\n\n      var _code = _fDesc.getCode();\n\n      _code = vtkWebGPUShaderCache.substitute(_code, '//VTK::Color::Impl', ['ambientColor = mapperUBO.EdgeColor;', 'diffuseColor = mapperUBO.EdgeColor;']).result;\n\n      _fDesc.setCode(_code);\n\n      return;\n    } // If there's no vertex color buffer return the shader as is\n\n\n    var colorBuffer = vertexInput.getBuffer('colorVI');\n    if (!colorBuffer) return; // Modifies the vertex shader to include the vertex colors and interpolation in the outputs\n\n    var vDesc = pipeline.getShaderDescription('vertex');\n    vDesc.addOutput('vec4<f32>', 'color', colorBuffer.getArrayInformation()[0].interpolation);\n    var code = vDesc.getCode();\n    code = vtkWebGPUShaderCache.substitute(code, '//VTK::Color::Impl', ['  output.color = colorVI;']).result;\n    vDesc.setCode(code); // Sets the fragment shader to accept the color inputs from the vertex shader\n\n    var fDesc = pipeline.getShaderDescription('fragment');\n    code = fDesc.getCode();\n    code = vtkWebGPUShaderCache.substitute(code, '//VTK::Color::Impl', ['ambientColor = input.color;', 'diffuseColor = input.color;', 'opacity = mapperUBO.Opacity * input.color.a;']).result;\n    fDesc.setCode(code);\n  };\n\n  model.shaderReplacements.set('replaceShaderColor', publicAPI.replaceShaderColor);\n\n  publicAPI.replaceShaderTCoord = function (hash, pipeline, vertexInput) {\n    var _actor$getProperty$ge, _actor$getProperty, _actor$getProperty$ge2, _actor$getProperty$ge4, _actor$getProperty3, _actor$getProperty$ge5, _actor$getProperty$ge6, _actor$getProperty4, _actor$getProperty$ge7, _actor$getProperty$ge8, _actor$getProperty5, _actor$getProperty$ge9, _actor$getProperty$ge10, _actor$getProperty6, _actor$getProperty$ge11, _actor$getProperty$ge12, _actor$getProperty7, _actor$getProperty$ge13;\n\n    if (!vertexInput.hasAttribute('tcoord')) return;\n    var vDesc = pipeline.getShaderDescription('vertex');\n    var tcoords = vertexInput.getBuffer('tcoord');\n    var numComp = vtkWebGPUTypes.getNumberOfComponentsFromBufferFormat(tcoords.getArrayInformation()[0].format);\n    var code = vDesc.getCode();\n    vDesc.addOutput(\"vec\".concat(numComp, \"<f32>\"), 'tcoordVS');\n    code = vtkWebGPUShaderCache.substitute(code, '//VTK::TCoord::Impl', ['  output.tcoordVS = tcoord;']).result;\n    vDesc.setCode(code);\n    var fDesc = pipeline.getShaderDescription('fragment');\n    code = fDesc.getCode();\n    var actor = model.WebGPUActor.getRenderable();\n\n    var checkDims = function checkDims(texture) {\n      if (!texture) return false;\n      var dims = texture.getDimensionality();\n      return dims === numComp;\n    };\n\n    var usedTextures = [];\n\n    if ((_actor$getProperty$ge = (_actor$getProperty = actor.getProperty()).getDiffuseTexture) !== null && _actor$getProperty$ge !== void 0 && (_actor$getProperty$ge2 = _actor$getProperty$ge.call(_actor$getProperty)) !== null && _actor$getProperty$ge2 !== void 0 && _actor$getProperty$ge2.getImageLoaded() || actor.getTextures()[0] || model.colorTexture) {\n      var _actor$getProperty$ge3, _actor$getProperty2;\n\n      if ( // Chained or statements here are questionable\n      checkDims((_actor$getProperty$ge3 = (_actor$getProperty2 = actor.getProperty()).getDiffuseTexture) === null || _actor$getProperty$ge3 === void 0 ? void 0 : _actor$getProperty$ge3.call(_actor$getProperty2)) || checkDims(actor.getTextures()[0]) || checkDims(model.colorTexture)) {\n        usedTextures.push('_diffuseMap = textureSample(DiffuseTexture, DiffuseTextureSampler, input.tcoordVS);');\n      }\n    }\n\n    if ((_actor$getProperty$ge4 = (_actor$getProperty3 = actor.getProperty()).getRoughnessTexture) !== null && _actor$getProperty$ge4 !== void 0 && (_actor$getProperty$ge5 = _actor$getProperty$ge4.call(_actor$getProperty3)) !== null && _actor$getProperty$ge5 !== void 0 && _actor$getProperty$ge5.getImageLoaded()) {\n      if (checkDims(actor.getProperty().getRoughnessTexture())) {\n        usedTextures.push('_roughnessMap = textureSample(RoughnessTexture, RoughnessTextureSampler, input.tcoordVS);');\n      }\n    }\n\n    if ((_actor$getProperty$ge6 = (_actor$getProperty4 = actor.getProperty()).getMetallicTexture) !== null && _actor$getProperty$ge6 !== void 0 && (_actor$getProperty$ge7 = _actor$getProperty$ge6.call(_actor$getProperty4)) !== null && _actor$getProperty$ge7 !== void 0 && _actor$getProperty$ge7.getImageLoaded()) {\n      if (checkDims(actor.getProperty().getMetallicTexture())) {\n        usedTextures.push('_metallicMap = textureSample(MetallicTexture, MetallicTextureSampler, input.tcoordVS);');\n      }\n    }\n\n    if ((_actor$getProperty$ge8 = (_actor$getProperty5 = actor.getProperty()).getNormalTexture) !== null && _actor$getProperty$ge8 !== void 0 && (_actor$getProperty$ge9 = _actor$getProperty$ge8.call(_actor$getProperty5)) !== null && _actor$getProperty$ge9 !== void 0 && _actor$getProperty$ge9.getImageLoaded()) {\n      if (checkDims(actor.getProperty().getNormalTexture())) {\n        usedTextures.push('_normalMap = textureSample(NormalTexture, NormalTextureSampler, input.tcoordVS);');\n      }\n    }\n\n    if ((_actor$getProperty$ge10 = (_actor$getProperty6 = actor.getProperty()).getAmbientOcclusionTexture) !== null && _actor$getProperty$ge10 !== void 0 && (_actor$getProperty$ge11 = _actor$getProperty$ge10.call(_actor$getProperty6)) !== null && _actor$getProperty$ge11 !== void 0 && _actor$getProperty$ge11.getImageLoaded()) {\n      if (checkDims(actor.getProperty().getAmbientOcclusionTexture())) {\n        usedTextures.push('_ambientOcclusionMap = textureSample(AmbientOcclusionTexture, AmbientOcclusionTextureSampler, input.tcoordVS);');\n      }\n    }\n\n    if ((_actor$getProperty$ge12 = (_actor$getProperty7 = actor.getProperty()).getEmissionTexture) !== null && _actor$getProperty$ge12 !== void 0 && (_actor$getProperty$ge13 = _actor$getProperty$ge12.call(_actor$getProperty7)) !== null && _actor$getProperty$ge13 !== void 0 && _actor$getProperty$ge13.getImageLoaded()) {\n      if (checkDims(actor.getProperty().getEmissionTexture())) {\n        usedTextures.push('_emissionMap = textureSample(EmissionTexture, EmissionTextureSampler, input.tcoordVS);');\n      }\n    }\n\n    code = vtkWebGPUShaderCache.substitute(code, '//VTK::TCoord::Impl', usedTextures).result;\n    fDesc.setCode(code);\n  };\n\n  model.shaderReplacements.set('replaceShaderTCoord', publicAPI.replaceShaderTCoord);\n\n  publicAPI.replaceShaderSelect = function (hash, pipeline, vertexInput) {\n    if (hash.includes('sel')) {\n      var fDesc = pipeline.getShaderDescription('fragment');\n      var code = fDesc.getCode(); // by default there are no composites, so just 0\n\n      code = vtkWebGPUShaderCache.substitute(code, '//VTK::Select::Impl', ['  var compositeID: u32 = 0u;']).result;\n      fDesc.setCode(code);\n    }\n  };\n\n  model.shaderReplacements.set('replaceShaderSelect', publicAPI.replaceShaderSelect);\n\n  publicAPI.getUsage = function (rep, i) {\n    if (rep === Representation.POINTS || i === PrimitiveTypes.Points) {\n      return BufferUsage.Verts;\n    }\n\n    if (i === PrimitiveTypes.Lines) {\n      return BufferUsage.Lines;\n    }\n\n    if (rep === Representation.WIREFRAME) {\n      if (i === PrimitiveTypes.Triangles) {\n        return BufferUsage.LinesFromTriangles;\n      }\n\n      return BufferUsage.LinesFromStrips;\n    }\n\n    if (i === PrimitiveTypes.Triangles) {\n      return BufferUsage.Triangles;\n    }\n\n    if (i === PrimitiveTypes.TriangleStrips) {\n      return BufferUsage.Strips;\n    }\n\n    if (i === PrimitiveTypes.TriangleEdges) {\n      return BufferUsage.LinesFromTriangles;\n    } // only strip edges left which are lines\n\n\n    return BufferUsage.LinesFromStrips;\n  };\n\n  publicAPI.getHashFromUsage = function (usage) {\n    return \"pt\".concat(usage);\n  };\n\n  publicAPI.getTopologyFromUsage = function (usage) {\n    switch (usage) {\n      case BufferUsage.Triangles:\n        return 'triangle-list';\n\n      case BufferUsage.Verts:\n        return 'point-list';\n\n      case BufferUsage.Lines:\n      default:\n        return 'line-list';\n    }\n  }; // TODO: calculate tangents\n\n\n  publicAPI.buildVertexInput = function () {\n    var _model$renderable$get, _model$renderable;\n\n    var pd = model.currentInput;\n    var cells = model.cellArray;\n    var primType = model.primitiveType;\n    var actor = model.WebGPUActor.getRenderable();\n    var representation = actor.getProperty().getRepresentation();\n    var device = model.WebGPURenderWindow.getDevice();\n    var edges = false;\n\n    if (primType === PrimitiveTypes.TriangleEdges) {\n      edges = true;\n      representation = Representation.WIREFRAME;\n    }\n\n    var vertexInput = model.vertexInput;\n    var points = pd.getPoints();\n    var indexBuffer; // get the flat mapping indexBuffer for the cells\n\n    if (cells) {\n      var buffRequest = {\n        hash: \"R\".concat(representation, \"P\").concat(primType).concat(cells.getMTime()),\n        usage: BufferUsage.Index,\n        cells: cells,\n        numberOfPoints: points.getNumberOfPoints(),\n        primitiveType: primType,\n        representation: representation\n      };\n      indexBuffer = device.getBufferManager().getBuffer(buffRequest);\n      vertexInput.setIndexBuffer(indexBuffer);\n    } else {\n      vertexInput.setIndexBuffer(null);\n    } // hash = all things that can change the values on the buffer\n    // since mtimes are unique we can use\n    // - indexBuffer mtime - because cells drive how we pack\n    // - relevant dataArray mtime - the source data\n    // - shift - not currently captured\n    // - scale - not currently captured\n    // - format\n    // - usage\n    // - packExtra - covered by format\n    // points\n\n\n    if (points) {\n      var shift = model.WebGPUActor.getBufferShift(model.WebGPURenderer);\n      var _buffRequest = {\n        hash: \"\".concat(points.getMTime(), \"I\").concat(indexBuffer.getMTime()).concat(shift.join(), \"float32x4\"),\n        usage: BufferUsage.PointArray,\n        format: 'float32x4',\n        dataArray: points,\n        indexBuffer: indexBuffer,\n        shift: shift,\n        packExtra: true\n      };\n      var buff = device.getBufferManager().getBuffer(_buffRequest);\n      vertexInput.addBuffer(buff, ['vertexBC']);\n    } else {\n      vertexInput.removeBufferIfPresent('vertexBC');\n    } // normals, only used for surface rendering\n\n\n    var usage = publicAPI.getUsage(representation, primType);\n    model._usesCellNormals = false;\n\n    if (!model.is2D && ( // no lighting on Property2D\n    usage === BufferUsage.Triangles || usage === BufferUsage.Strips)) {\n      var normals = pd.getPointData().getNormals(); // https://vtk.org/doc/nightly/html/classvtkPolyDataTangents.html\n      // Need to find some way of using precomputed tangents (or computing new ones)\n\n      var _buffRequest2 = {\n        format: 'snorm8x4',\n        indexBuffer: indexBuffer,\n        packExtra: true,\n        shift: 0,\n        scale: 127\n      };\n\n      if (normals) {\n        _buffRequest2.hash = \"\".concat(normals.getMTime(), \"I\").concat(indexBuffer.getMTime(), \"snorm8x4\");\n        _buffRequest2.dataArray = normals;\n        _buffRequest2.usage = BufferUsage.PointArray;\n\n        var _buff = device.getBufferManager().getBuffer(_buffRequest2);\n\n        vertexInput.addBuffer(_buff, ['normalMC']);\n      } else if (primType === PrimitiveTypes.Triangles) {\n        model._usesCellNormals = true;\n        _buffRequest2.hash = \"PFN\".concat(points.getMTime(), \"I\").concat(indexBuffer.getMTime(), \"snorm8x4\");\n        _buffRequest2.dataArray = points;\n        _buffRequest2.cells = cells;\n        _buffRequest2.usage = BufferUsage.NormalsFromPoints;\n\n        var _buff2 = device.getBufferManager().getBuffer(_buffRequest2);\n\n        vertexInput.addBuffer(_buff2, ['normalMC']);\n      } else {\n        vertexInput.removeBufferIfPresent('normalMC');\n      }\n    } else {\n      vertexInput.removeBufferIfPresent('normalMC');\n    } // deal with colors but only if modified\n\n\n    var haveColors = false;\n\n    if (model.renderable.getScalarVisibility()) {\n      var c = model.renderable.getColorMapColors();\n\n      if (c && !edges) {\n        var scalarMode = model.renderable.getScalarMode();\n        var haveCellScalars = false; // We must figure out how the scalars should be mapped to the polydata.\n\n        if ((scalarMode === ScalarMode.USE_CELL_DATA || scalarMode === ScalarMode.USE_CELL_FIELD_DATA || scalarMode === ScalarMode.USE_FIELD_DATA || !pd.getPointData().getScalars()) && scalarMode !== ScalarMode.USE_POINT_FIELD_DATA && c) {\n          haveCellScalars = true;\n        }\n\n        var _buffRequest3 = {\n          usage: BufferUsage.PointArray,\n          format: 'unorm8x4',\n          hash: \"\".concat(haveCellScalars).concat(c.getMTime(), \"I\").concat(indexBuffer.getMTime(), \"unorm8x4\"),\n          dataArray: c,\n          indexBuffer: indexBuffer,\n          cellData: haveCellScalars,\n          cellOffset: 0\n        };\n\n        var _buff3 = device.getBufferManager().getBuffer(_buffRequest3);\n\n        vertexInput.addBuffer(_buff3, ['colorVI']);\n        haveColors = true;\n      }\n    }\n\n    if (!haveColors) {\n      vertexInput.removeBufferIfPresent('colorVI');\n    }\n\n    var tcoords = null;\n\n    if ((_model$renderable$get = (_model$renderable = model.renderable).getInterpolateScalarsBeforeMapping) !== null && _model$renderable$get !== void 0 && _model$renderable$get.call(_model$renderable) && model.renderable.getColorCoordinates()) {\n      tcoords = model.renderable.getColorCoordinates();\n    } else {\n      tcoords = pd.getPointData().getTCoords();\n    }\n\n    if (tcoords && !edges) {\n      var _buff4 = device.getBufferManager().getBufferForPointArray(tcoords, vertexInput.getIndexBuffer());\n\n      vertexInput.addBuffer(_buff4, ['tcoord']);\n    } else {\n      vertexInput.removeBufferIfPresent('tcoord');\n    }\n  };\n\n  publicAPI.updateTextures = function () {\n    var _model$renderable$get2, _model$renderable2, _actor$getProperty$ge14, _actor$getProperty8, _actor$getProperty$ge15, _actor$getProperty9, _actor$getProperty$ge16, _actor$getProperty10, _actor$getProperty$ge17, _actor$getProperty11, _actor$getProperty$ge18, _actor$getProperty12, _actor$getProperty$ge19, _actor$getProperty13, _renderer$getEnvironm2;\n\n    // we keep track of new and used textures so\n    // that we can clean up any unused textures so we don't hold onto them\n    var usedTextures = [];\n    var newTextures = []; // do we have a scalar color texture\n\n    var idata = (_model$renderable$get2 = (_model$renderable2 = model.renderable).getColorTextureMap) === null || _model$renderable$get2 === void 0 ? void 0 : _model$renderable$get2.call(_model$renderable2);\n\n    if (idata) {\n      if (!model.colorTexture) {\n        model.colorTexture = vtkTexture.newInstance({\n          label: 'polyDataColor'\n        });\n      }\n\n      model.colorTexture.setInputData(idata);\n      newTextures.push(['Diffuse', model.colorTexture]);\n    } // actor textures?\n\n\n    var actor = model.WebGPUActor.getRenderable();\n    var renderer = model.WebGPURenderer.getRenderable(); // Reusing the old code for new and old textures, just loading in from properties instead of actor.getTextures()\n\n    var textures = []; // Feels like there should be a better way than individually adding all\n\n    if ((_actor$getProperty$ge14 = (_actor$getProperty8 = actor.getProperty()).getDiffuseTexture) !== null && _actor$getProperty$ge14 !== void 0 && _actor$getProperty$ge14.call(_actor$getProperty8)) {\n      var pair = ['Diffuse', actor.getProperty().getDiffuseTexture()];\n      textures.push(pair);\n    }\n\n    if (actor.getTextures()[0]) {\n      var _pair = ['Diffuse', actor.getTextures()[0]];\n      textures.push(_pair);\n    }\n\n    if (model.colorTexture) {\n      var _pair2 = ['Diffuse', model.colorTexture];\n      textures.push(_pair2);\n    }\n\n    if ((_actor$getProperty$ge15 = (_actor$getProperty9 = actor.getProperty()).getRoughnessTexture) !== null && _actor$getProperty$ge15 !== void 0 && _actor$getProperty$ge15.call(_actor$getProperty9)) {\n      var _pair3 = ['Roughness', actor.getProperty().getRoughnessTexture()];\n      textures.push(_pair3);\n    }\n\n    if ((_actor$getProperty$ge16 = (_actor$getProperty10 = actor.getProperty()).getMetallicTexture) !== null && _actor$getProperty$ge16 !== void 0 && _actor$getProperty$ge16.call(_actor$getProperty10)) {\n      var _pair4 = ['Metallic', actor.getProperty().getMetallicTexture()];\n      textures.push(_pair4);\n    }\n\n    if ((_actor$getProperty$ge17 = (_actor$getProperty11 = actor.getProperty()).getNormalTexture) !== null && _actor$getProperty$ge17 !== void 0 && _actor$getProperty$ge17.call(_actor$getProperty11)) {\n      var _pair5 = ['Normal', actor.getProperty().getNormalTexture()];\n      textures.push(_pair5);\n    }\n\n    if ((_actor$getProperty$ge18 = (_actor$getProperty12 = actor.getProperty()).getAmbientOcclusionTexture) !== null && _actor$getProperty$ge18 !== void 0 && _actor$getProperty$ge18.call(_actor$getProperty12)) {\n      var _pair6 = ['AmbientOcclusion', actor.getProperty().getAmbientOcclusionTexture()];\n      textures.push(_pair6);\n    }\n\n    if ((_actor$getProperty$ge19 = (_actor$getProperty13 = actor.getProperty()).getEmissionTexture) !== null && _actor$getProperty$ge19 !== void 0 && _actor$getProperty$ge19.call(_actor$getProperty13)) {\n      var _pair7 = ['Emission', actor.getProperty().getEmissionTexture()];\n      textures.push(_pair7);\n    }\n\n    if ((_renderer$getEnvironm2 = renderer.getEnvironmentTexture) !== null && _renderer$getEnvironm2 !== void 0 && _renderer$getEnvironm2.call(renderer)) {\n      var _pair8 = ['Environment', renderer.getEnvironmentTexture()];\n      textures.push(_pair8);\n    }\n\n    for (var i = 0; i < textures.length; i++) {\n      if (textures[i][1].getInputData() || textures[i][1].getJsImageData() || textures[i][1].getCanvas()) {\n        newTextures.push(textures[i]);\n      }\n\n      if (textures[i][1].getImage() && textures[i][1].getImageLoaded()) {\n        newTextures.push(textures[i]);\n      }\n    }\n\n    for (var _i = 0; _i < newTextures.length; _i++) {\n      var srcTexture = newTextures[_i][1];\n      var textureName = newTextures[_i][0];\n      var newTex = model.device.getTextureManager().getTextureForVTKTexture(srcTexture); // Generates hash\n\n      if (newTex.getReady()) {\n        // is this a new texture\n        var found = false;\n\n        for (var t = 0; t < model.textures.length; t++) {\n          if (model.textures[t] === newTex) {\n            found = true;\n            usedTextures[t] = true;\n          }\n        }\n\n        if (!found) {\n          usedTextures[model.textures.length] = true;\n          var tview = newTex.createView(\"\".concat(textureName, \"Texture\"));\n          model.textures.push(newTex);\n          model.textureViews.push(tview);\n          var interpolate = srcTexture.getInterpolate() ? 'linear' : 'nearest';\n          var addressMode = null;\n          if (!addressMode && srcTexture.getEdgeClamp() && srcTexture.getRepeat()) addressMode = 'mirror-repeat';\n          if (!addressMode && srcTexture.getEdgeClamp()) addressMode = 'clamp-to-edge';\n          if (!addressMode && srcTexture.getRepeat()) addressMode = 'repeat';\n\n          if (textureName !== 'Environment') {\n            tview.addSampler(model.device, {\n              addressModeU: addressMode,\n              addressModeV: addressMode,\n              addressModeW: addressMode,\n              minFilter: interpolate,\n              magFilter: interpolate\n            });\n          } else {\n            tview.addSampler(model.device, {\n              addressModeU: 'repeat',\n              addressModeV: 'clamp-to-edge',\n              addressModeW: 'repeat',\n              minFilter: interpolate,\n              magFilter: interpolate,\n              mipmapFilter: 'linear'\n            });\n          }\n        }\n      }\n    } // remove unused textures\n\n\n    for (var _i2 = model.textures.length - 1; _i2 >= 0; _i2--) {\n      if (!usedTextures[_i2]) {\n        model.textures.splice(_i2, 1);\n        model.textureViews.splice(_i2, 1);\n      }\n    }\n  }; // compute a unique hash for a pipeline, this needs to be unique enough to\n  // capture any pipeline code changes (which includes shader changes)\n  // or vertex input changes/ bind groups/ etc\n\n\n  publicAPI.computePipelineHash = function () {\n    var pipelineHash = \"pd\".concat(model.useRendererMatrix ? 'r' : '').concat(model.forceZValue ? 'z' : '');\n\n    if (model.primitiveType === PrimitiveTypes.TriangleEdges || model.primitiveType === PrimitiveTypes.TriangleStripEdges) {\n      pipelineHash += 'edge';\n    } else {\n      if (model.vertexInput.hasAttribute(\"normalMC\")) {\n        pipelineHash += \"n\";\n      }\n\n      if (model.vertexInput.hasAttribute(\"colorVI\")) {\n        pipelineHash += \"c\";\n      }\n\n      if (model.vertexInput.hasAttribute(\"tcoord\")) {\n        var tcoords = model.vertexInput.getBuffer('tcoord');\n        var numComp = vtkWebGPUTypes.getNumberOfComponentsFromBufferFormat(tcoords.getArrayInformation()[0].format);\n        pipelineHash += \"t\".concat(numComp);\n      }\n\n      if (model.textures.length) {\n        pipelineHash += \"tx\".concat(model.textures.length);\n      }\n    }\n\n    if (model._usesCellNormals) {\n      pipelineHash += \"cn\";\n    }\n\n    if (model.SSBO) {\n      pipelineHash += \"ssbo\";\n    }\n\n    var uhash = publicAPI.getHashFromUsage(model.usage);\n    pipelineHash += uhash;\n    pipelineHash += model.renderEncoder.getPipelineHash();\n    model.pipelineHash = pipelineHash;\n  };\n\n  publicAPI.updateBuffers = function () {\n    // handle textures if not edges\n    if (model.primitiveType !== PrimitiveTypes.TriangleEdges && model.primitiveType !== PrimitiveTypes.TriangleStripEdges) {\n      publicAPI.updateTextures();\n    }\n\n    var actor = model.WebGPUActor.getRenderable();\n    var rep = actor.getProperty().getRepresentation(); // handle per primitive type\n\n    model.usage = publicAPI.getUsage(rep, model.primitiveType);\n    publicAPI.buildVertexInput();\n    var vbo = model.vertexInput.getBuffer('vertexBC');\n    publicAPI.setNumberOfVertices(vbo.getSizeInBytes() / vbo.getStrideInBytes());\n    publicAPI.setTopology(publicAPI.getTopologyFromUsage(model.usage));\n    publicAPI.updateUBO();\n\n    if (publicAPI.haveWideLines()) {\n      var ppty = actor.getProperty();\n      publicAPI.setNumberOfInstances(Math.ceil(ppty.getLineWidth() * 2.0));\n    } else {\n      publicAPI.setNumberOfInstances(1);\n    }\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\n\nvar DEFAULT_VALUES = {\n  is2D: false,\n  cellArray: null,\n  currentInput: null,\n  cellOffset: 0,\n  primitiveType: 0,\n  colorTexture: null,\n  renderEncoder: null,\n  textures: null\n}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initiaLalues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initiaLalues); // Inheritance\n\n  vtkWebGPUSimpleMapper.extend(publicAPI, model, initiaLalues);\n  model.fragmentShaderTemplate = vtkWebGPUPolyDataFS;\n  model.vertexShaderTemplate = vtkWebGPUPolyDataVS;\n  model._tmpMat3 = mat3.identity(new Float64Array(9));\n  model._tmpMat4 = mat4.identity(new Float64Array(16)); // UBO\n\n  model.UBO = vtkWebGPUUniformBuffer.newInstance({\n    label: 'mapperUBO'\n  });\n  model.UBO.addEntry('BCWCMatrix', 'mat4x4<f32>');\n  model.UBO.addEntry('BCSCMatrix', 'mat4x4<f32>');\n  model.UBO.addEntry('MCWCNormals', 'mat4x4<f32>');\n  model.UBO.addEntry('AmbientColor', 'vec4<f32>');\n  model.UBO.addEntry('DiffuseColor', 'vec4<f32>');\n  model.UBO.addEntry('EdgeColor', 'vec4<f32>');\n  model.UBO.addEntry('SpecularColor', 'vec4<f32>');\n  model.UBO.addEntry('AmbientIntensity', 'f32');\n  model.UBO.addEntry('DiffuseIntensity', 'f32');\n  model.UBO.addEntry('Roughness', 'f32');\n  model.UBO.addEntry('Metallic', 'f32');\n  model.UBO.addEntry('Ambient', 'f32');\n  model.UBO.addEntry('Normal', 'f32');\n  model.UBO.addEntry('Emission', 'f32');\n  model.UBO.addEntry('NormalStrength', 'f32');\n  model.UBO.addEntry('BaseIOR', 'f32');\n  model.UBO.addEntry('SpecularIntensity', 'f32');\n  model.UBO.addEntry('LineWidth', 'f32');\n  model.UBO.addEntry('Opacity', 'f32');\n  model.UBO.addEntry('ZValue', 'f32');\n  model.UBO.addEntry('PropID', 'u32');\n  model.UBO.addEntry('ClipNear', 'f32');\n  model.UBO.addEntry('ClipFar', 'f32');\n  model.UBO.addEntry('Time', 'u32'); // Build VTK API\n\n  setGet(publicAPI, model, ['cellArray', 'currentInput', 'cellOffset', 'is2D', 'primitiveType', 'renderEncoder']);\n  model.textures = []; // Object methods\n\n  vtkWebGPUCellArrayMapper(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = newInstance$1(extend, 'vtkWebGPUCellArrayMapper'); // ----------------------------------------------------------------------------\n\nvar vtkWebGPUCellArrayMapper$1 = {\n  newInstance: newInstance,\n  extend: extend\n};\n\nexport { vtkWebGPUCellArrayMapper$1 as default, extend, newInstance };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}