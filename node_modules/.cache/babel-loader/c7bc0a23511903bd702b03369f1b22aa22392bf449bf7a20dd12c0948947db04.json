{"ast":null,"code":"import macro from '../../macros.js';\nimport vtkDataArray from '../../Common/Core/DataArray.js';\nimport { l as normalize, d as dot, j as cross, e as distance2BetweenPoints, y as determinant3x3, z as rowsToMat3 } from '../../Common/Core/Math/index.js';\nimport vtkPolyData from '../../Common/DataModel/PolyData.js';\nvar vtkErrorMacro = macro.vtkErrorMacro; // ----------------------------------------------------------------------------\n// vtkTextureMapToPlane methods\n// ----------------------------------------------------------------------------\n\nfunction vtkTextureMapToPlane(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkTextureMapToPlane');\n  function computeNormal(output) {\n    var VTK_TOLERANCE = 0.001; //  First thing to do is to get an initial normal and point to define\n    //  the plane.  Then, use this information to construct better\n    //  matrices.  If problem occurs, then the point and plane becomes the\n    //  fallback value\n\n    var nbPoints = output.getPoints().getNumberOfPoints();\n    var dir = 0;\n    var m = [0, 0, 0, 0, 0, 0, 0, 0, 0];\n    var x = [0, 0, 0];\n    var v = [0, 0, 0]; //  Get minimum width of bounding box.\n\n    var bounds = output.getBounds();\n    var minBounds = [bounds[0], bounds[2], bounds[4]];\n    var maxBounds = [bounds[1], bounds[3], bounds[5]];\n    var length = Math.sqrt(distance2BetweenPoints(minBounds, maxBounds));\n    var w = length;\n    var i = 0;\n    for (; i < 3; i++) {\n      model.normal[i] = 0.0;\n      if (bounds[2 * i + 1] - bounds[2 * i] < w) {\n        dir = i;\n        w = bounds[2 * i + 1] - bounds[2 * i];\n      }\n    } //  If the bounds is perpendicular to one of the axes, then can\n    //  quickly compute normal.\n    //\n\n    model.normal[dir] = 1.0;\n    if (w <= length * VTK_TOLERANCE) {\n      return;\n    } //  Need to compute least squares approximation.  Depending on major\n    //  normal direction (dir), construct matrices appropriately.\n    //\n    //  Compute 3x3 least squares matrix\n\n    v[0] = 0.0;\n    v[1] = 0.0;\n    v[2] = 0.0;\n    for (var ptId = 0; ptId < nbPoints; ptId++) {\n      output.getPoints().getPoint(ptId, x);\n      v[0] += x[0] * x[2];\n      v[1] += x[1] * x[2];\n      v[2] += x[2];\n      m[0] += x[0] * x[0];\n      m[1] += x[0] * x[1];\n      m[2] += x[0];\n      m[3] += x[0] * x[1];\n      m[4] += x[1] * x[1];\n      m[5] += x[1];\n      m[6] += x[0];\n      m[7] += x[1];\n    }\n    m[8] = nbPoints; //  Solve linear system using Kramers rule\n\n    var c1 = [m[0], m[1], m[2]];\n    var c2 = [m[3], m[4], m[5]];\n    var c3 = [m[6], m[7], m[8]];\n    var det = determinant3x3(m);\n    if (det <= VTK_TOLERANCE) {\n      return;\n    }\n    m = rowsToMat3(v, c2, c3, []);\n    model.normal[0] = determinant3x3(m) / det;\n    m = rowsToMat3(c1, v, c3, []);\n    model.normal[1] = determinant3x3(m) / det; // because of the formulation\n\n    model.normal[2] = -1.0;\n  }\n  publicAPI.requestData = function (inData, outData) {\n    if (model.deleted) {\n      return;\n    }\n    var input = inData[0];\n    var nbPoints = input.getPoints().getNumberOfPoints();\n    if (nbPoints < 3 && model.automaticPlaneGeneration) {\n      vtkErrorMacro(\"Can't generate texture coordinates without points\");\n      return;\n    }\n    var output = vtkPolyData.newInstance();\n    output.getPoints().setData(new Float32Array(input.getPoints().getData()), 3);\n    output.getPolys().setData(new Uint32Array(input.getPolys().getData()));\n    var tcoordsData = [];\n    var minProj = 0;\n    var i = 0;\n    var j = 0;\n    var proj = 0;\n    var axis = [0, 0, 0];\n    var dir = 0;\n    var tAxis = [0, 0, 0];\n    var sAxis = [0, 0, 0];\n    var s = 0;\n    var t = 0;\n    var sSf = 0;\n    var tSf = 0;\n    var p = [0, 0, 0]; //  Compute least squares plane if on automatic mode; otherwise use\n    //  normal specified or plane specified\n\n    if (model.automaticPlaneGeneration && model.origin[0] === 0 && model.origin[1] === 0 && model.origin[2] === 0 && model.point1[0] === 0 && model.point1[1] === 0 && model.point2[0] === 0 && model.point2[1] === 0) {\n      if (model.automaticPlaneGeneration) {\n        computeNormal(output);\n      }\n      normalize(model.normal); //  Now project each point onto plane generating s,t texture coordinates\n      //\n      //  Create local s-t coordinate system.  Need to find the two axes on\n      //  the plane and encompassing all the points.  Hence use the bounding\n      //  box as a reference.\n\n      minProj = 1.0;\n      i = 0;\n      for (; i < 3; i++) {\n        axis[0] = 0.0;\n        axis[1] = 0.0;\n        axis[2] = 0.0;\n        axis[i] = 1.0;\n        proj = Math.abs(dot(model.normal, axis));\n        if (proj < minProj) {\n          minProj = proj;\n          dir = i;\n        }\n      }\n      axis[0] = 0.0;\n      axis[1] = 0.0;\n      axis[2] = 0.0;\n      axis[dir] = 1.0;\n      cross(model.normal, axis, tAxis);\n      normalize(tAxis);\n      cross(tAxis, model.normal, sAxis); //  Construct projection matrices\n      //\n      //  Arrange s-t axes so that parametric location of points will fall\n      //  between s_range and t_range.  Simplest to do by projecting maximum\n      //  corner of bounding box unto plane and backing out scale factors.\n      //\n\n      var bounds = output.getBounds();\n      for (i = 0; i < 3; i++) {\n        axis[i] = bounds[2 * i + 1] - bounds[2 * i];\n      }\n      s = dot(sAxis, axis);\n      t = dot(tAxis, axis);\n      sSf = (model.sRange[1] - model.sRange[0]) / s;\n      tSf = (model.tRange[1] - model.tRange[0]) / t; //  Now can loop over all points, computing parametric coordinates.\n\n      for (i = 0; i < nbPoints; i++) {\n        output.getPoints().getPoint(i, p);\n        for (j = 0; j < 3; j++) {\n          axis[j] = p[j] - bounds[2 * j];\n        }\n        tcoordsData.push(model.sRange[0] + dot(sAxis, axis) * sSf);\n        tcoordsData.push(model.tRange[0] + dot(tAxis, axis) * tSf);\n      }\n    } else {\n      var num = 0; // compute axes\n\n      for (i = 0; i < 3; i++) {\n        sAxis[i] = model.point1[i] - model.origin[i];\n        tAxis[i] = model.point2[i] - model.origin[i];\n      }\n      var sDenom = dot(sAxis, sAxis);\n      var tDenom = dot(tAxis, tAxis);\n      if (sDenom === 0.0 || tDenom === 0.0) {\n        vtkErrorMacro('Bad plane definition');\n        sDenom = 1.0;\n        tDenom = 1.0;\n      } // compute s-t coordinates\n\n      for (i = 0; i < nbPoints; i++) {\n        output.getPoints().getPoint(i, p);\n        for (j = 0; j < 3; j++) {\n          axis[j] = p[j] - model.origin[j];\n        } // s-coordinate\n\n        num = sAxis[0] * axis[0] + sAxis[1] * axis[1] + sAxis[2] * axis[2];\n        tcoordsData.push(num / sDenom); // t-coordinate\n\n        num = tAxis[0] * axis[0] + tAxis[1] * axis[1] + tAxis[2] * axis[2];\n        tcoordsData.push(num / tDenom);\n      }\n    }\n    var tCoords = vtkDataArray.newInstance({\n      name: 'Texture Coordinates',\n      numberOfComponents: 2,\n      size: nbPoints,\n      values: tcoordsData\n    });\n    output.getPointData().setTCoords(tCoords); // Update output\n\n    outData[0] = output;\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nvar DEFAULT_VALUES = {\n  origin: [0, 0, 0],\n  point1: [0, 0, 0],\n  point2: [0, 0, 0],\n  normal: [0, 0, 0],\n  sRange: [0, 1],\n  tRange: [0, 1],\n  automaticPlaneGeneration: 1\n}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Build VTK API\n\n  macro.obj(publicAPI, model);\n  macro.setGetArray(publicAPI, model, ['origin', 'point1', 'point2', 'normal'], 3);\n  macro.setGetArray(publicAPI, model, ['sRange', 'tRange'], 2);\n  macro.setGet(publicAPI, model, ['automaticPlaneGeneration']);\n  macro.algo(publicAPI, model, 1, 1);\n  vtkTextureMapToPlane(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = macro.newInstance(extend, 'vtkTextureMapToPlane'); // ----------------------------------------------------------------------------\n\nvar vtkTextureMapToPlane$1 = {\n  newInstance: newInstance,\n  extend: extend\n};\nexport { vtkTextureMapToPlane$1 as default, extend, newInstance };","map":{"version":3,"names":["macro","vtkDataArray","l","normalize","d","dot","j","cross","e","distance2BetweenPoints","y","determinant3x3","z","rowsToMat3","vtkPolyData","vtkErrorMacro","vtkTextureMapToPlane","publicAPI","model","classHierarchy","push","computeNormal","output","VTK_TOLERANCE","nbPoints","getPoints","getNumberOfPoints","dir","m","x","v","bounds","getBounds","minBounds","maxBounds","length","Math","sqrt","w","i","normal","ptId","getPoint","c1","c2","c3","det","requestData","inData","outData","deleted","input","automaticPlaneGeneration","newInstance","setData","Float32Array","getData","getPolys","Uint32Array","tcoordsData","minProj","proj","axis","tAxis","sAxis","s","t","sSf","tSf","p","origin","point1","point2","abs","sRange","tRange","num","sDenom","tDenom","tCoords","name","numberOfComponents","size","values","getPointData","setTCoords","DEFAULT_VALUES","extend","initialValues","arguments","undefined","Object","assign","obj","setGetArray","setGet","algo","vtkTextureMapToPlane$1","default"],"sources":["/home/rakshith/Documents/RemoteRendering/vtk-js-react-app/node_modules/@kitware/vtk.js/Filters/Texture/TextureMapToPlane.js"],"sourcesContent":["import macro from '../../macros.js';\nimport vtkDataArray from '../../Common/Core/DataArray.js';\nimport { l as normalize, d as dot, j as cross, e as distance2BetweenPoints, y as determinant3x3, z as rowsToMat3 } from '../../Common/Core/Math/index.js';\nimport vtkPolyData from '../../Common/DataModel/PolyData.js';\n\nvar vtkErrorMacro = macro.vtkErrorMacro; // ----------------------------------------------------------------------------\n// vtkTextureMapToPlane methods\n// ----------------------------------------------------------------------------\n\nfunction vtkTextureMapToPlane(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkTextureMapToPlane');\n\n  function computeNormal(output) {\n    var VTK_TOLERANCE = 0.001; //  First thing to do is to get an initial normal and point to define\n    //  the plane.  Then, use this information to construct better\n    //  matrices.  If problem occurs, then the point and plane becomes the\n    //  fallback value\n\n    var nbPoints = output.getPoints().getNumberOfPoints();\n    var dir = 0;\n    var m = [0, 0, 0, 0, 0, 0, 0, 0, 0];\n    var x = [0, 0, 0];\n    var v = [0, 0, 0]; //  Get minimum width of bounding box.\n\n    var bounds = output.getBounds();\n    var minBounds = [bounds[0], bounds[2], bounds[4]];\n    var maxBounds = [bounds[1], bounds[3], bounds[5]];\n    var length = Math.sqrt(distance2BetweenPoints(minBounds, maxBounds));\n    var w = length;\n    var i = 0;\n\n    for (; i < 3; i++) {\n      model.normal[i] = 0.0;\n\n      if (bounds[2 * i + 1] - bounds[2 * i] < w) {\n        dir = i;\n        w = bounds[2 * i + 1] - bounds[2 * i];\n      }\n    } //  If the bounds is perpendicular to one of the axes, then can\n    //  quickly compute normal.\n    //\n\n\n    model.normal[dir] = 1.0;\n\n    if (w <= length * VTK_TOLERANCE) {\n      return;\n    } //  Need to compute least squares approximation.  Depending on major\n    //  normal direction (dir), construct matrices appropriately.\n    //\n    //  Compute 3x3 least squares matrix\n\n\n    v[0] = 0.0;\n    v[1] = 0.0;\n    v[2] = 0.0;\n\n    for (var ptId = 0; ptId < nbPoints; ptId++) {\n      output.getPoints().getPoint(ptId, x);\n      v[0] += x[0] * x[2];\n      v[1] += x[1] * x[2];\n      v[2] += x[2];\n      m[0] += x[0] * x[0];\n      m[1] += x[0] * x[1];\n      m[2] += x[0];\n      m[3] += x[0] * x[1];\n      m[4] += x[1] * x[1];\n      m[5] += x[1];\n      m[6] += x[0];\n      m[7] += x[1];\n    }\n\n    m[8] = nbPoints; //  Solve linear system using Kramers rule\n\n    var c1 = [m[0], m[1], m[2]];\n    var c2 = [m[3], m[4], m[5]];\n    var c3 = [m[6], m[7], m[8]];\n    var det = determinant3x3(m);\n\n    if (det <= VTK_TOLERANCE) {\n      return;\n    }\n\n    m = rowsToMat3(v, c2, c3, []);\n    model.normal[0] = determinant3x3(m) / det;\n    m = rowsToMat3(c1, v, c3, []);\n    model.normal[1] = determinant3x3(m) / det; // because of the formulation\n\n    model.normal[2] = -1.0;\n  }\n\n  publicAPI.requestData = function (inData, outData) {\n    if (model.deleted) {\n      return;\n    }\n\n    var input = inData[0];\n    var nbPoints = input.getPoints().getNumberOfPoints();\n\n    if (nbPoints < 3 && model.automaticPlaneGeneration) {\n      vtkErrorMacro(\"Can't generate texture coordinates without points\");\n      return;\n    }\n\n    var output = vtkPolyData.newInstance();\n    output.getPoints().setData(new Float32Array(input.getPoints().getData()), 3);\n    output.getPolys().setData(new Uint32Array(input.getPolys().getData()));\n    var tcoordsData = [];\n    var minProj = 0;\n    var i = 0;\n    var j = 0;\n    var proj = 0;\n    var axis = [0, 0, 0];\n    var dir = 0;\n    var tAxis = [0, 0, 0];\n    var sAxis = [0, 0, 0];\n    var s = 0;\n    var t = 0;\n    var sSf = 0;\n    var tSf = 0;\n    var p = [0, 0, 0]; //  Compute least squares plane if on automatic mode; otherwise use\n    //  normal specified or plane specified\n\n    if (model.automaticPlaneGeneration && model.origin[0] === 0 && model.origin[1] === 0 && model.origin[2] === 0 && model.point1[0] === 0 && model.point1[1] === 0 && model.point2[0] === 0 && model.point2[1] === 0) {\n      if (model.automaticPlaneGeneration) {\n        computeNormal(output);\n      }\n\n      normalize(model.normal); //  Now project each point onto plane generating s,t texture coordinates\n      //\n      //  Create local s-t coordinate system.  Need to find the two axes on\n      //  the plane and encompassing all the points.  Hence use the bounding\n      //  box as a reference.\n\n      minProj = 1.0;\n      i = 0;\n\n      for (; i < 3; i++) {\n        axis[0] = 0.0;\n        axis[1] = 0.0;\n        axis[2] = 0.0;\n        axis[i] = 1.0;\n        proj = Math.abs(dot(model.normal, axis));\n\n        if (proj < minProj) {\n          minProj = proj;\n          dir = i;\n        }\n      }\n\n      axis[0] = 0.0;\n      axis[1] = 0.0;\n      axis[2] = 0.0;\n      axis[dir] = 1.0;\n      cross(model.normal, axis, tAxis);\n      normalize(tAxis);\n      cross(tAxis, model.normal, sAxis); //  Construct projection matrices\n      //\n      //  Arrange s-t axes so that parametric location of points will fall\n      //  between s_range and t_range.  Simplest to do by projecting maximum\n      //  corner of bounding box unto plane and backing out scale factors.\n      //\n\n      var bounds = output.getBounds();\n\n      for (i = 0; i < 3; i++) {\n        axis[i] = bounds[2 * i + 1] - bounds[2 * i];\n      }\n\n      s = dot(sAxis, axis);\n      t = dot(tAxis, axis);\n      sSf = (model.sRange[1] - model.sRange[0]) / s;\n      tSf = (model.tRange[1] - model.tRange[0]) / t; //  Now can loop over all points, computing parametric coordinates.\n\n      for (i = 0; i < nbPoints; i++) {\n        output.getPoints().getPoint(i, p);\n\n        for (j = 0; j < 3; j++) {\n          axis[j] = p[j] - bounds[2 * j];\n        }\n\n        tcoordsData.push(model.sRange[0] + dot(sAxis, axis) * sSf);\n        tcoordsData.push(model.tRange[0] + dot(tAxis, axis) * tSf);\n      }\n    } else {\n      var num = 0; // compute axes\n\n      for (i = 0; i < 3; i++) {\n        sAxis[i] = model.point1[i] - model.origin[i];\n        tAxis[i] = model.point2[i] - model.origin[i];\n      }\n\n      var sDenom = dot(sAxis, sAxis);\n      var tDenom = dot(tAxis, tAxis);\n\n      if (sDenom === 0.0 || tDenom === 0.0) {\n        vtkErrorMacro('Bad plane definition');\n        sDenom = 1.0;\n        tDenom = 1.0;\n      } // compute s-t coordinates\n\n\n      for (i = 0; i < nbPoints; i++) {\n        output.getPoints().getPoint(i, p);\n\n        for (j = 0; j < 3; j++) {\n          axis[j] = p[j] - model.origin[j];\n        } // s-coordinate\n\n\n        num = sAxis[0] * axis[0] + sAxis[1] * axis[1] + sAxis[2] * axis[2];\n        tcoordsData.push(num / sDenom); // t-coordinate\n\n        num = tAxis[0] * axis[0] + tAxis[1] * axis[1] + tAxis[2] * axis[2];\n        tcoordsData.push(num / tDenom);\n      }\n    }\n\n    var tCoords = vtkDataArray.newInstance({\n      name: 'Texture Coordinates',\n      numberOfComponents: 2,\n      size: nbPoints,\n      values: tcoordsData\n    });\n    output.getPointData().setTCoords(tCoords); // Update output\n\n    outData[0] = output;\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\n\nvar DEFAULT_VALUES = {\n  origin: [0, 0, 0],\n  point1: [0, 0, 0],\n  point2: [0, 0, 0],\n  normal: [0, 0, 0],\n  sRange: [0, 1],\n  tRange: [0, 1],\n  automaticPlaneGeneration: 1\n}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Build VTK API\n\n  macro.obj(publicAPI, model);\n  macro.setGetArray(publicAPI, model, ['origin', 'point1', 'point2', 'normal'], 3);\n  macro.setGetArray(publicAPI, model, ['sRange', 'tRange'], 2);\n  macro.setGet(publicAPI, model, ['automaticPlaneGeneration']);\n  macro.algo(publicAPI, model, 1, 1);\n  vtkTextureMapToPlane(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = macro.newInstance(extend, 'vtkTextureMapToPlane'); // ----------------------------------------------------------------------------\n\nvar vtkTextureMapToPlane$1 = {\n  newInstance: newInstance,\n  extend: extend\n};\n\nexport { vtkTextureMapToPlane$1 as default, extend, newInstance };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}