{"ast":null,"code":"import _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport macro from '../../macros.js';\nimport { h as hsv2rgb, i as isNan, G as isInf, H as rgb2hsv, I as rgb2lab, J as lab2rgb, K as floor } from '../../Common/Core/Math/index.js';\nimport vtkScalarsToColors from '../../Common/Core/ScalarsToColors.js';\nimport Constants from './ColorTransferFunction/Constants.js';\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n  return target;\n}\nvar ColorSpace = Constants.ColorSpace,\n  Scale = Constants.Scale;\nvar ScalarMappingTarget = vtkScalarsToColors.ScalarMappingTarget;\nvar vtkDebugMacro = macro.vtkDebugMacro,\n  vtkErrorMacro = macro.vtkErrorMacro,\n  vtkWarningMacro = macro.vtkWarningMacro; // ----------------------------------------------------------------------------\n// Global methods\n// ----------------------------------------------------------------------------\n\n/* eslint-disable no-continue                                                */\n// Convert to and from a special polar version of CIELAB (useful for creating\n// continuous diverging color maps).\n\nfunction vtkColorTransferFunctionLabToMsh(lab, msh) {\n  var L = lab[0];\n  var a = lab[1];\n  var b = lab[2];\n  var M = Math.sqrt(L * L + a * a + b * b);\n  var s = M > 0.001 ? Math.acos(L / M) : 0.0;\n  var h = s > 0.001 ? Math.atan2(b, a) : 0.0;\n  msh[0] = M;\n  msh[1] = s;\n  msh[2] = h;\n}\nfunction vtkColorTransferFunctionMshToLab(msh, lab) {\n  var M = msh[0];\n  var s = msh[1];\n  var h = msh[2];\n  lab[0] = M * Math.cos(s);\n  lab[1] = M * Math.sin(s) * Math.cos(h);\n  lab[2] = M * Math.sin(s) * Math.sin(h);\n} // For the case when interpolating from a saturated color to an unsaturated\n// color, find a hue for the unsaturated color that makes sense.\n\nfunction vtkColorTransferFunctionAdjustHue(msh, unsatM) {\n  if (msh[0] >= unsatM - 0.1) {\n    // The best we can do is hold hue constant.\n    return msh[2];\n  } // This equation is designed to make the perceptual change of the\n  // interpolation to be close to constant.\n\n  var hueSpin = msh[1] * Math.sqrt(unsatM * unsatM - msh[0] * msh[0]) / (msh[0] * Math.sin(msh[1])); // Spin hue away from 0 except in purple hues.\n\n  if (msh[2] > -0.3 * Math.PI) {\n    return msh[2] + hueSpin;\n  }\n  return msh[2] - hueSpin;\n}\nfunction vtkColorTransferFunctionAngleDiff(a1, a2) {\n  var adiff = a1 - a2;\n  if (adiff < 0.0) {\n    adiff = -adiff;\n  }\n  while (adiff >= 2.0 * Math.PI) {\n    adiff -= 2.0 * Math.PI;\n  }\n  if (adiff > Math.PI) {\n    adiff = 2.0 * Math.PI - adiff;\n  }\n  return adiff;\n} // Interpolate a diverging color map.\n\nfunction vtkColorTransferFunctionInterpolateDiverging(s, rgb1, rgb2, result) {\n  var lab1 = [];\n  var lab2 = [];\n  rgb2lab(rgb1, lab1);\n  rgb2lab(rgb2, lab2);\n  var msh1 = [];\n  var msh2 = [];\n  vtkColorTransferFunctionLabToMsh(lab1, msh1);\n  vtkColorTransferFunctionLabToMsh(lab2, msh2); // If the endpoints are distinct saturated colors, then place white in between\n  // them.\n\n  var localS = s;\n  if (msh1[1] > 0.05 && msh2[1] > 0.05 && vtkColorTransferFunctionAngleDiff(msh1[2], msh2[2]) > 0.33 * Math.PI) {\n    // Insert the white midpoint by setting one end to white and adjusting the\n    // scalar value.\n    var Mmid = Math.max(msh1[0], msh2[0]);\n    Mmid = Math.max(88.0, Mmid);\n    if (s < 0.5) {\n      msh2[0] = Mmid;\n      msh2[1] = 0.0;\n      msh2[2] = 0.0;\n      localS *= 2.0;\n    } else {\n      msh1[0] = Mmid;\n      msh1[1] = 0.0;\n      msh1[2] = 0.0;\n      localS = 2.0 * localS - 1.0;\n    }\n  } // If one color has no saturation, then its hue value is invalid.  In this\n  // case, we want to set it to something logical so that the interpolation of\n  // hue makes sense.\n\n  if (msh1[1] < 0.05 && msh2[1] > 0.05) {\n    msh1[2] = vtkColorTransferFunctionAdjustHue(msh2, msh1[0]);\n  } else if (msh2[1] < 0.05 && msh1[1] > 0.05) {\n    msh2[2] = vtkColorTransferFunctionAdjustHue(msh1, msh2[0]);\n  }\n  var mshTmp = [];\n  mshTmp[0] = (1 - localS) * msh1[0] + localS * msh2[0];\n  mshTmp[1] = (1 - localS) * msh1[1] + localS * msh2[1];\n  mshTmp[2] = (1 - localS) * msh1[2] + localS * msh2[2]; // Now convert back to RGB\n\n  var labTmp = [];\n  vtkColorTransferFunctionMshToLab(mshTmp, labTmp);\n  lab2rgb(labTmp, result);\n} // ----------------------------------------------------------------------------\n// vtkColorTransferFunction methods\n// ----------------------------------------------------------------------------\n\nfunction vtkColorTransferFunction(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkColorTransferFunction'); // Return the number of points which specify this function\n\n  publicAPI.getSize = function () {\n    return model.nodes.length;\n  }; //----------------------------------------------------------------------------\n  // Add a point defined in RGB\n\n  publicAPI.addRGBPoint = function (x, r, g, b) {\n    return publicAPI.addRGBPointLong(x, r, g, b, 0.5, 0.0);\n  }; //----------------------------------------------------------------------------\n  // Add a point defined in RGB\n\n  publicAPI.addRGBPointLong = function (x, r, g, b) {\n    var midpoint = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0.5;\n    var sharpness = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0.0;\n\n    // Error check\n    if (midpoint < 0.0 || midpoint > 1.0) {\n      vtkErrorMacro('Midpoint outside range [0.0, 1.0]');\n      return -1;\n    }\n    if (sharpness < 0.0 || sharpness > 1.0) {\n      vtkErrorMacro('Sharpness outside range [0.0, 1.0]');\n      return -1;\n    } // remove any node already at this X location\n\n    if (!model.allowDuplicateScalars) {\n      publicAPI.removePoint(x);\n    } // Create the new node\n\n    var node = {\n      x: x,\n      r: r,\n      g: g,\n      b: b,\n      midpoint: midpoint,\n      sharpness: sharpness\n    }; // Add it, then sort to get everything in order\n\n    model.nodes.push(node);\n    publicAPI.sortAndUpdateRange(); // We need to find the index of the node we just added in order\n    // to return this value\n\n    var i = 0;\n    for (; i < model.nodes.length; i++) {\n      if (model.nodes[i].x === x) {\n        break;\n      }\n    } // If we didn't find it, something went horribly wrong so\n    // return -1\n\n    if (i < model.nodes.length) {\n      return i;\n    }\n    return -1;\n  }; //----------------------------------------------------------------------------\n  // Add a point defined in HSV\n\n  publicAPI.addHSVPoint = function (x, h, s, v) {\n    return publicAPI.addHSVPointLong(x, h, s, v, 0.5, 0.0);\n  }; //----------------------------------------------------------------------------\n  // Add a point defined in HSV\n\n  publicAPI.addHSVPointLong = function (x, h, s, v) {\n    var midpoint = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0.5;\n    var sharpness = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0.0;\n    var rgb = [];\n    var hsv = [h, s, v];\n    hsv2rgb(hsv, rgb);\n    return publicAPI.addRGBPoint(x, rgb[0], rgb[1], rgb[2], midpoint, sharpness);\n  }; //----------------------------------------------------------------------------\n  // Set nodes directly\n\n  publicAPI.setNodes = function (nodes) {\n    if (model.nodes !== nodes) {\n      var before = JSON.stringify(model.nodes);\n      model.nodes = nodes;\n      var after = JSON.stringify(model.nodes);\n      if (publicAPI.sortAndUpdateRange() || before !== after) {\n        publicAPI.modified();\n        return true;\n      }\n    }\n    return false;\n  }; //----------------------------------------------------------------------------\n  // Sort the vector in increasing order, then fill in\n  // the Range\n\n  publicAPI.sortAndUpdateRange = function () {\n    var before = JSON.stringify(model.nodes);\n    model.nodes.sort(function (a, b) {\n      return a.x - b.x;\n    });\n    var after = JSON.stringify(model.nodes);\n    var modifiedInvoked = publicAPI.updateRange(); // If range is updated, Modified() has been called, don't call it again.\n\n    if (!modifiedInvoked && before !== after) {\n      publicAPI.modified();\n      return true;\n    }\n    return modifiedInvoked;\n  }; //----------------------------------------------------------------------------\n\n  publicAPI.updateRange = function () {\n    var oldRange = [2];\n    oldRange[0] = model.mappingRange[0];\n    oldRange[1] = model.mappingRange[1];\n    var size = model.nodes.length;\n    if (size) {\n      model.mappingRange[0] = model.nodes[0].x;\n      model.mappingRange[1] = model.nodes[size - 1].x;\n    } else {\n      model.mappingRange[0] = 0;\n      model.mappingRange[1] = 0;\n    } // If the range is the same, then no need to call Modified()\n\n    if (oldRange[0] === model.mappingRange[0] && oldRange[1] === model.mappingRange[1]) {\n      return false;\n    }\n    publicAPI.modified();\n    return true;\n  }; //----------------------------------------------------------------------------\n  // Remove a point\n\n  publicAPI.removePoint = function (x) {\n    // First find the node since we need to know its\n    // index as our return value\n    var i = 0;\n    for (; i < model.nodes.length; i++) {\n      if (model.nodes[i].x === x) {\n        break;\n      }\n    }\n    var retVal = i; // If the node doesn't exist, we return -1\n\n    if (i >= model.nodes.length) {\n      return -1;\n    } // If the first or last point has been removed, then we update the range\n    // No need to sort here as the order of points hasn't changed.\n\n    var modifiedInvoked = false;\n    model.nodes.splice(i, 1);\n    if (i === 0 || i === model.nodes.length) {\n      modifiedInvoked = publicAPI.updateRange();\n    }\n    if (!modifiedInvoked) {\n      publicAPI.modified();\n    }\n    return retVal;\n  }; //----------------------------------------------------------------------------\n\n  publicAPI.movePoint = function (oldX, newX) {\n    if (oldX === newX) {\n      // Nothing to do.\n      return;\n    }\n    publicAPI.removePoint(newX);\n    for (var i = 0; i < model.nodes.length; i++) {\n      if (model.nodes[i].x === oldX) {\n        model.nodes[i].x = newX;\n        publicAPI.sortAndUpdateRange();\n        break;\n      }\n    }\n  }; //----------------------------------------------------------------------------\n  // Remove all points\n\n  publicAPI.removeAllPoints = function () {\n    model.nodes = [];\n    publicAPI.sortAndUpdateRange();\n  }; //----------------------------------------------------------------------------\n  // Add a line defined in RGB\n\n  publicAPI.addRGBSegment = function (x1, r1, g1, b1, x2, r2, g2, b2) {\n    // First, find all points in this range and remove them\n    publicAPI.sortAndUpdateRange();\n    for (var i = 0; i < model.nodes.length;) {\n      if (model.nodes[i].x >= x1 && model.nodes[i].x <= x2) {\n        model.nodes.splice(i, 1);\n      } else {\n        i++;\n      }\n    } // Now add the points\n\n    publicAPI.addRGBPointLong(x1, r1, g1, b1, 0.5, 0.0);\n    publicAPI.addRGBPointLong(x2, r2, g2, b2, 0.5, 0.0);\n    publicAPI.modified();\n  }; //----------------------------------------------------------------------------\n  // Add a line defined in HSV\n\n  publicAPI.addHSVSegment = function (x1, h1, s1, v1, x2, h2, s2, v2) {\n    var hsv1 = [h1, s1, v1];\n    var hsv2 = [h2, s2, v2];\n    var rgb1 = [];\n    var rgb2 = [];\n    hsv2rgb(hsv1, rgb1);\n    hsv2rgb(hsv2, rgb2);\n    publicAPI.addRGBSegment(x1, rgb1[0], rgb1[1], rgb1[2], x2, rgb2[0], rgb2[1], rgb2[2]);\n  }; //----------------------------------------------------------------------------\n  // Returns the RGBA color evaluated at the specified location\n\n  publicAPI.mapValue = function (x) {\n    var rgb = [];\n    publicAPI.getColor(x, rgb);\n    return [Math.floor(255.0 * rgb[0] + 0.5), Math.floor(255.0 * rgb[1] + 0.5), Math.floor(255.0 * rgb[2] + 0.5), 255];\n  }; //----------------------------------------------------------------------------\n  // Returns the RGB color evaluated at the specified location\n\n  publicAPI.getColor = function (x, rgb) {\n    if (model.indexedLookup) {\n      var numNodes = publicAPI.getSize(); // todo\n\n      var idx = publicAPI.getAnnotatedValueIndexInternal(x);\n      if (idx < 0 || numNodes === 0) {\n        var nanColor = publicAPI.getNanColorByReference();\n        rgb[0] = nanColor[0];\n        rgb[1] = nanColor[1];\n        rgb[2] = nanColor[2];\n      } else {\n        var nodeVal = [];\n        publicAPI.getNodeValue(idx % numNodes, nodeVal); // nodeVal[0] is the x value. nodeVal[1...3] is rgb.\n\n        rgb[0] = nodeVal[1];\n        rgb[1] = nodeVal[2];\n        rgb[2] = nodeVal[3];\n      }\n      return;\n    }\n    publicAPI.getTable(x, x, 1, rgb);\n  }; //----------------------------------------------------------------------------\n  // Returns the red color evaluated at the specified location\n\n  publicAPI.getRedValue = function (x) {\n    var rgb = [];\n    publicAPI.getColor(x, rgb);\n    return rgb[0];\n  }; //----------------------------------------------------------------------------\n  // Returns the green color evaluated at the specified location\n\n  publicAPI.getGreenValue = function (x) {\n    var rgb = [];\n    publicAPI.getColor(x, rgb);\n    return rgb[1];\n  }; //----------------------------------------------------------------------------\n  // Returns the blue color evaluated at the specified location\n\n  publicAPI.getBlueValue = function (x) {\n    var rgb = [];\n    publicAPI.getColor(x, rgb);\n    return rgb[2];\n  }; //----------------------------------------------------------------------------\n  // Returns a table of RGB colors at regular intervals along the function\n\n  publicAPI.getTable = function (xStart_, xEnd_, size, table) {\n    // To handle BigInt limitation\n    var xStart = Number(xStart_);\n    var xEnd = Number(xEnd_); // Special case: If either the start or end is a NaN, then all any\n    // interpolation done on them is also a NaN.  Therefore, fill the table with\n    // the NaN color.\n\n    if (isNan(xStart) || isNan(xEnd)) {\n      for (var i = 0; i < size; i++) {\n        table[i * 3 + 0] = model.nanColor[0];\n        table[i * 3 + 1] = model.nanColor[1];\n        table[i * 3 + 2] = model.nanColor[2];\n      }\n      return;\n    }\n    var idx = 0;\n    var numNodes = model.nodes.length; // Need to keep track of the last value so that\n    // we can fill in table locations past this with\n    // this value if Clamping is On.\n\n    var lastR = 0.0;\n    var lastG = 0.0;\n    var lastB = 0.0;\n    if (numNodes !== 0) {\n      lastR = model.nodes[numNodes - 1].r;\n      lastG = model.nodes[numNodes - 1].g;\n      lastB = model.nodes[numNodes - 1].b;\n    }\n    var x = 0.0;\n    var x1 = 0.0;\n    var x2 = 0.0;\n    var rgb1 = [0.0, 0.0, 0.0];\n    var rgb2 = [0.0, 0.0, 0.0];\n    var midpoint = 0.0;\n    var sharpness = 0.0;\n    var tmpVec = []; // If the scale is logarithmic, make sure the range is valid.\n\n    var usingLogScale = model.scale === Scale.LOG10;\n    if (usingLogScale) {\n      // Note: This requires range[0] <= range[1].\n      usingLogScale = model.mappingRange[0] > 0.0;\n    }\n    var logStart = 0.0;\n    var logEnd = 0.0;\n    var logX = 0.0;\n    if (usingLogScale) {\n      logStart = Math.log10(xStart);\n      logEnd = Math.log10(xEnd);\n    } // For each table entry\n\n    for (var _i = 0; _i < size; _i++) {\n      // Find our location in the table\n      var tidx = 3 * _i; // Find our X location. If we are taking only 1 sample, make\n      // it halfway between start and end (usually start and end will\n      // be the same in this case)\n\n      if (size > 1) {\n        if (usingLogScale) {\n          logX = logStart + _i / (size - 1.0) * (logEnd - logStart);\n          x = Math.pow(10.0, logX);\n        } else {\n          x = xStart + _i / (size - 1.0) * (xEnd - xStart);\n        }\n      } else if (usingLogScale) {\n        logX = 0.5 * (logStart + logEnd);\n        x = Math.pow(10.0, logX);\n      } else {\n        x = 0.5 * (xStart + xEnd);\n      } // Linearly map x from mappingRange to [0, numberOfValues-1],\n      // discretize (round down to the closest integer),\n      // then map back to mappingRange\n\n      if (model.discretize) {\n        var range = model.mappingRange;\n        if (x >= range[0] && x <= range[1]) {\n          var numberOfValues = model.numberOfValues;\n          var deltaRange = range[1] - range[0];\n          if (numberOfValues <= 1) {\n            x = range[0] + deltaRange / 2.0;\n          } else {\n            // normalize x\n            var xn = (x - range[0]) / deltaRange; // discretize\n\n            var discretizeIndex = floor(numberOfValues * xn); // get discretized x\n\n            x = range[0] + discretizeIndex / (numberOfValues - 1) * deltaRange;\n          }\n        }\n      } // Do we need to move to the next node?\n\n      while (idx < numNodes && x > model.nodes[idx].x) {\n        idx++; // If we are at a valid point index, fill in\n        // the value at this node, and the one before (the\n        // two that surround our current sample location)\n        // idx cannot be 0 since we just incremented it.\n\n        if (idx < numNodes) {\n          x1 = model.nodes[idx - 1].x;\n          x2 = model.nodes[idx].x;\n          if (usingLogScale) {\n            x1 = Math.log10(x1);\n            x2 = Math.log10(x2);\n          }\n          rgb1[0] = model.nodes[idx - 1].r;\n          rgb2[0] = model.nodes[idx].r;\n          rgb1[1] = model.nodes[idx - 1].g;\n          rgb2[1] = model.nodes[idx].g;\n          rgb1[2] = model.nodes[idx - 1].b;\n          rgb2[2] = model.nodes[idx].b; // We only need the previous midpoint and sharpness\n          // since these control this region\n\n          midpoint = model.nodes[idx - 1].midpoint;\n          sharpness = model.nodes[idx - 1].sharpness; // Move midpoint away from extreme ends of range to avoid\n          // degenerate math\n\n          if (midpoint < 0.00001) {\n            midpoint = 0.00001;\n          }\n          if (midpoint > 0.99999) {\n            midpoint = 0.99999;\n          }\n        }\n      } // Are we at or past the end? If so, just use the last value\n\n      if (x > model.mappingRange[1]) {\n        table[tidx] = 0.0;\n        table[tidx + 1] = 0.0;\n        table[tidx + 2] = 0.0;\n        if (model.clamping) {\n          if (publicAPI.getUseAboveRangeColor()) {\n            table[tidx] = model.aboveRangeColor[0];\n            table[tidx + 1] = model.aboveRangeColor[1];\n            table[tidx + 2] = model.aboveRangeColor[2];\n          } else {\n            table[tidx] = lastR;\n            table[tidx + 1] = lastG;\n            table[tidx + 2] = lastB;\n          }\n        }\n      } else if (x < model.mappingRange[0] || isInf(x) && x < 0) {\n        // we are before the first node? If so, duplicate this node's values.\n        // We have to deal with -inf here\n        table[tidx] = 0.0;\n        table[tidx + 1] = 0.0;\n        table[tidx + 2] = 0.0;\n        if (model.clamping) {\n          if (publicAPI.getUseBelowRangeColor()) {\n            table[tidx] = model.belowRangeColor[0];\n            table[tidx + 1] = model.belowRangeColor[1];\n            table[tidx + 2] = model.belowRangeColor[2];\n          } else if (numNodes > 0) {\n            table[tidx] = model.nodes[0].r;\n            table[tidx + 1] = model.nodes[0].g;\n            table[tidx + 2] = model.nodes[0].b;\n          }\n        }\n      } else if (idx === 0 && (Math.abs(x - xStart) < 1e-6 || model.discretize)) {\n        if (numNodes > 0) {\n          table[tidx] = model.nodes[0].r;\n          table[tidx + 1] = model.nodes[0].g;\n          table[tidx + 2] = model.nodes[0].b;\n        } else {\n          table[tidx] = 0.0;\n          table[tidx + 1] = 0.0;\n          table[tidx + 2] = 0.0;\n        }\n      } else {\n        // OK, we are between two nodes - interpolate\n        // Our first attempt at a normalized location [0,1] -\n        // we will be modifying this based on midpoint and\n        // sharpness to get the curve shape we want and to have\n        // it pass through (y1+y2)/2 at the midpoint.\n        var s = 0.0;\n        if (usingLogScale) {\n          s = (logX - x1) / (x2 - x1);\n        } else {\n          s = (x - x1) / (x2 - x1);\n        } // Readjust based on the midpoint - linear adjustment\n\n        if (s < midpoint) {\n          s = 0.5 * s / midpoint;\n        } else {\n          s = 0.5 + 0.5 * (s - midpoint) / (1.0 - midpoint);\n        } // override for sharpness > 0.99\n        // In this case we just want piecewise constant\n\n        if (sharpness > 0.99) {\n          // Use the first value since we are below the midpoint\n          if (s < 0.5) {\n            table[tidx] = rgb1[0];\n            table[tidx + 1] = rgb1[1];\n            table[tidx + 2] = rgb1[2];\n            continue;\n          } else {\n            // Use the second value at or above the midpoint\n            table[tidx] = rgb2[0];\n            table[tidx + 1] = rgb2[1];\n            table[tidx + 2] = rgb2[2];\n            continue;\n          }\n        } // Override for sharpness < 0.01\n        // In this case we want piecewise linear\n\n        if (sharpness < 0.01) {\n          // Simple linear interpolation\n          if (model.colorSpace === ColorSpace.RGB) {\n            table[tidx] = (1 - s) * rgb1[0] + s * rgb2[0];\n            table[tidx + 1] = (1 - s) * rgb1[1] + s * rgb2[1];\n            table[tidx + 2] = (1 - s) * rgb1[2] + s * rgb2[2];\n          } else if (model.colorSpace === ColorSpace.HSV) {\n            var hsv1 = [];\n            var hsv2 = [];\n            rgb2hsv(rgb1, hsv1);\n            rgb2hsv(rgb2, hsv2);\n            if (model.hSVWrap && (hsv1[0] - hsv2[0] > 0.5 || hsv2[0] - hsv1[0] > 0.5)) {\n              if (hsv1[0] > hsv2[0]) {\n                hsv1[0] -= 1.0;\n              } else {\n                hsv2[0] -= 1.0;\n              }\n            }\n            var hsvTmp = [];\n            hsvTmp[0] = (1.0 - s) * hsv1[0] + s * hsv2[0];\n            if (hsvTmp[0] < 0.0) {\n              hsvTmp[0] += 1.0;\n            }\n            hsvTmp[1] = (1.0 - s) * hsv1[1] + s * hsv2[1];\n            hsvTmp[2] = (1.0 - s) * hsv1[2] + s * hsv2[2]; // Now convert this back to RGB\n\n            hsv2rgb(hsvTmp, tmpVec);\n            table[tidx] = tmpVec[0];\n            table[tidx + 1] = tmpVec[1];\n            table[tidx + 2] = tmpVec[2];\n          } else if (model.colorSpace === ColorSpace.LAB) {\n            var lab1 = [];\n            var lab2 = [];\n            rgb2lab(rgb1, lab1);\n            rgb2lab(rgb2, lab2);\n            var labTmp = [];\n            labTmp[0] = (1 - s) * lab1[0] + s * lab2[0];\n            labTmp[1] = (1 - s) * lab1[1] + s * lab2[1];\n            labTmp[2] = (1 - s) * lab1[2] + s * lab2[2]; // Now convert back to RGB\n\n            lab2rgb(labTmp, tmpVec);\n            table[tidx] = tmpVec[0];\n            table[tidx + 1] = tmpVec[1];\n            table[tidx + 2] = tmpVec[2];\n          } else if (model.colorSpace === ColorSpace.DIVERGING) {\n            vtkColorTransferFunctionInterpolateDiverging(s, rgb1, rgb2, tmpVec);\n            table[tidx] = tmpVec[0];\n            table[tidx + 1] = tmpVec[1];\n            table[tidx + 2] = tmpVec[2];\n          } else {\n            vtkErrorMacro('ColorSpace set to invalid value.', model.colorSpace);\n          }\n          continue;\n        } // We have a sharpness between [0.01, 0.99] - we will\n        // used a modified hermite curve interpolation where we\n        // derive the slope based on the sharpness, and we compress\n        // the curve non-linearly based on the sharpness\n        // First, we will adjust our position based on sharpness in\n        // order to make the curve sharper (closer to piecewise constant)\n\n        if (s < 0.5) {\n          s = 0.5 * Math.pow(s * 2.0, 1.0 + 10.0 * sharpness);\n        } else if (s > 0.5) {\n          s = 1.0 - 0.5 * Math.pow((1.0 - s) * 2, 1 + 10.0 * sharpness);\n        } // Compute some coefficients we will need for the hermite curve\n\n        var ss = s * s;\n        var sss = ss * s;\n        var h1 = 2.0 * sss - 3 * ss + 1;\n        var h2 = -2 * sss + 3 * ss;\n        var h3 = sss - 2 * ss + s;\n        var h4 = sss - ss;\n        var slope = void 0;\n        var t = void 0;\n        if (model.colorSpace === ColorSpace.RGB) {\n          for (var j = 0; j < 3; j++) {\n            // Use one slope for both end points\n            slope = rgb2[j] - rgb1[j];\n            t = (1.0 - sharpness) * slope; // Compute the value\n\n            table[tidx + j] = h1 * rgb1[j] + h2 * rgb2[j] + h3 * t + h4 * t;\n          }\n        } else if (model.colorSpace === ColorSpace.HSV) {\n          var _hsv = [];\n          var _hsv2 = [];\n          rgb2hsv(rgb1, _hsv);\n          rgb2hsv(rgb2, _hsv2);\n          if (model.hSVWrap && (_hsv[0] - _hsv2[0] > 0.5 || _hsv2[0] - _hsv[0] > 0.5)) {\n            if (_hsv[0] > _hsv2[0]) {\n              _hsv[0] -= 1.0;\n            } else {\n              _hsv2[0] -= 1.0;\n            }\n          }\n          var _hsvTmp = [];\n          for (var _j = 0; _j < 3; _j++) {\n            // Use one slope for both end points\n            slope = _hsv2[_j] - _hsv[_j];\n            t = (1.0 - sharpness) * slope; // Compute the value\n\n            _hsvTmp[_j] = h1 * _hsv[_j] + h2 * _hsv2[_j] + h3 * t + h4 * t;\n            if (_j === 0 && _hsvTmp[_j] < 0.0) {\n              _hsvTmp[_j] += 1.0;\n            }\n          } // Now convert this back to RGB\n\n          hsv2rgb(_hsvTmp, tmpVec);\n          table[tidx] = tmpVec[0];\n          table[tidx + 1] = tmpVec[1];\n          table[tidx + 2] = tmpVec[2];\n        } else if (model.colorSpace === ColorSpace.LAB) {\n          var _lab = [];\n          var _lab2 = [];\n          rgb2lab(rgb1, _lab);\n          rgb2lab(rgb2, _lab2);\n          var _labTmp = [];\n          for (var _j2 = 0; _j2 < 3; _j2++) {\n            // Use one slope for both end points\n            slope = _lab2[_j2] - _lab[_j2];\n            t = (1.0 - sharpness) * slope; // Compute the value\n\n            _labTmp[_j2] = h1 * _lab[_j2] + h2 * _lab2[_j2] + h3 * t + h4 * t;\n          } // Now convert this back to RGB\n\n          lab2rgb(_labTmp, tmpVec);\n          table[tidx] = tmpVec[0];\n          table[tidx + 1] = tmpVec[1];\n          table[tidx + 2] = tmpVec[2];\n        } else if (model.colorSpace === ColorSpace.DIVERGING) {\n          // I have not implemented proper interpolation by a hermite curve for\n          // the diverging color map, but I cannot think of a good use case for\n          // that anyway.\n          vtkColorTransferFunctionInterpolateDiverging(s, rgb1, rgb2, tmpVec);\n          table[tidx] = tmpVec[0];\n          table[tidx + 1] = tmpVec[1];\n          table[tidx + 2] = tmpVec[2];\n        } else {\n          vtkErrorMacro('ColorSpace set to invalid value.');\n        } // Final error check to make sure we don't go outside [0,1]\n\n        for (var _j3 = 0; _j3 < 3; _j3++) {\n          table[tidx + _j3] = table[tidx + _j3] < 0.0 ? 0.0 : table[tidx + _j3];\n          table[tidx + _j3] = table[tidx + _j3] > 1.0 ? 1.0 : table[tidx + _j3];\n        }\n      }\n    }\n  }; //----------------------------------------------------------------------------\n\n  publicAPI.getUint8Table = function (xStart, xEnd, size) {\n    var withAlpha = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    if (publicAPI.getMTime() <= model.buildTime && model.tableSize === size && model.tableWithAlpha !== withAlpha) {\n      return model.table;\n    }\n    if (model.nodes.length === 0) {\n      vtkErrorMacro('Attempting to lookup a value with no points in the function');\n      return model.table;\n    }\n    var nbChannels = withAlpha ? 4 : 3;\n    if (model.tableSize !== size || model.tableWithAlpha !== withAlpha) {\n      model.table = new Uint8Array(size * nbChannels);\n      model.tableSize = size;\n      model.tableWithAlpha = withAlpha;\n    }\n    var tmpTable = [];\n    publicAPI.getTable(xStart, xEnd, size, tmpTable);\n    for (var i = 0; i < size; i++) {\n      model.table[i * nbChannels + 0] = Math.floor(tmpTable[i * 3 + 0] * 255.0 + 0.5);\n      model.table[i * nbChannels + 1] = Math.floor(tmpTable[i * 3 + 1] * 255.0 + 0.5);\n      model.table[i * nbChannels + 2] = Math.floor(tmpTable[i * 3 + 2] * 255.0 + 0.5);\n      if (withAlpha) {\n        model.table[i * nbChannels + 3] = 255;\n      }\n    }\n    model.buildTime.modified();\n    return model.table;\n  };\n  publicAPI.buildFunctionFromArray = function (array) {\n    publicAPI.removeAllPoints();\n    var numComponents = array.getNumberOfComponents();\n    for (var i = 0; i < array.getNumberOfTuples(); i++) {\n      switch (numComponents) {\n        case 3:\n          {\n            model.nodes.push({\n              x: i,\n              r: array.getComponent(i, 0),\n              g: array.getComponent(i, 1),\n              b: array.getComponent(i, 2),\n              midpoint: 0.5,\n              sharpness: 0.0\n            });\n            break;\n          }\n        case 4:\n          {\n            model.nodes.push({\n              x: array.getComponent(i, 0),\n              r: array.getComponent(i, 1),\n              g: array.getComponent(i, 2),\n              b: array.getComponent(i, 3),\n              midpoint: 0.5,\n              sharpness: 0.0\n            });\n            break;\n          }\n        case 5:\n          {\n            model.nodes.push({\n              x: i,\n              r: array.getComponent(i, 0),\n              g: array.getComponent(i, 1),\n              b: array.getComponent(i, 2),\n              midpoint: array.getComponent(i, 4),\n              sharpness: array.getComponent(i, 5)\n            });\n            break;\n          }\n        case 6:\n          {\n            model.nodes.push({\n              x: array.getComponent(i, 0),\n              r: array.getComponent(i, 1),\n              g: array.getComponent(i, 2),\n              b: array.getComponent(i, 3),\n              midpoint: array.getComponent(i, 4),\n              sharpness: array.getComponent(i, 5)\n            });\n            break;\n          }\n      }\n    }\n    publicAPI.sortAndUpdateRange();\n  }; //----------------------------------------------------------------------------\n\n  publicAPI.buildFunctionFromTable = function (xStart, xEnd, size, table) {\n    var inc = 0.0;\n    publicAPI.removeAllPoints();\n    if (size > 1) {\n      inc = (xEnd - xStart) / (size - 1.0);\n    }\n    for (var i = 0; i < size; i++) {\n      var node = {\n        x: xStart + inc * i,\n        r: table[i * 3],\n        g: table[i * 3 + 1],\n        b: table[i * 3 + 2],\n        sharpness: 0.0,\n        midpoint: 0.5\n      };\n      model.nodes.push(node);\n    }\n    publicAPI.sortAndUpdateRange();\n  }; //----------------------------------------------------------------------------\n  // For a specified index value, get the node parameters\n\n  publicAPI.getNodeValue = function (index, val) {\n    if (index < 0 || index >= model.nodes.length) {\n      vtkErrorMacro('Index out of range!');\n      return -1;\n    }\n    val[0] = model.nodes[index].x;\n    val[1] = model.nodes[index].r;\n    val[2] = model.nodes[index].g;\n    val[3] = model.nodes[index].b;\n    val[4] = model.nodes[index].midpoint;\n    val[5] = model.nodes[index].sharpness;\n    return 1;\n  }; //----------------------------------------------------------------------------\n  // For a specified index value, get the node parameters\n\n  publicAPI.setNodeValue = function (index, val) {\n    if (index < 0 || index >= model.nodes.length) {\n      vtkErrorMacro('Index out of range!');\n      return -1;\n    }\n    var oldX = model.nodes[index].x;\n    model.nodes[index].x = val[0];\n    model.nodes[index].r = val[1];\n    model.nodes[index].g = val[2];\n    model.nodes[index].b = val[3];\n    model.nodes[index].midpoint = val[4];\n    model.nodes[index].sharpness = val[5];\n    if (oldX !== val[0]) {\n      // The point has been moved, the order of points or the range might have\n      // been modified.\n      publicAPI.sortAndUpdateRange(); // No need to call Modified() here because SortAndUpdateRange() has done it\n      // already.\n    } else {\n      publicAPI.modified();\n    }\n    return 1;\n  }; //----------------------------------------------------------------------------\n\n  publicAPI.getNumberOfAvailableColors = function () {\n    if (model.indexedLookup && publicAPI.getSize()) {\n      return publicAPI.getSize();\n    }\n    if (model.tableSize) {\n      // Not sure if this is correct since it is only set if\n      // \"const unsigned char *::GetTable(double xStart, double xEnd,int size)\"\n      // has been called.\n      return model.tableSize;\n    }\n    return 16777216; // 2^24\n  }; //----------------------------------------------------------------------------\n\n  publicAPI.getIndexedColor = function (idx, rgba) {\n    var n = publicAPI.getSize();\n    if (n > 0 && idx >= 0) {\n      var nodeValue = [];\n      publicAPI.getNodeValue(idx % n, nodeValue);\n      for (var j = 0; j < 3; ++j) {\n        rgba[j] = nodeValue[j + 1];\n      }\n      rgba[3] = 1.0; // NodeColor is RGB-only.\n\n      return;\n    }\n    var nanColor = publicAPI.getNanColorByReference();\n    rgba[0] = nanColor[0];\n    rgba[1] = nanColor[1];\n    rgba[2] = nanColor[2];\n    rgba[3] = 1.0; // NanColor is RGB-only.\n  }; //----------------------------------------------------------------------------\n\n  publicAPI.fillFromDataPointer = function (nb, ptr) {\n    if (nb <= 0 || !ptr) {\n      return;\n    }\n    publicAPI.removeAllPoints();\n    for (var i = 0; i < nb; i++) {\n      publicAPI.addRGBPoint(ptr[i * 4], ptr[i * 4 + 1], ptr[i * 4 + 2], ptr[i * 4 + 3]);\n    }\n  }; //----------------------------------------------------------------------------\n\n  publicAPI.setMappingRange = function (min, max) {\n    var range = [min, max];\n    var originalRange = publicAPI.getRange();\n    if (originalRange[1] === range[1] && originalRange[0] === range[0]) {\n      return;\n    }\n    if (range[1] === range[0]) {\n      vtkErrorMacro('attempt to set zero width color range');\n      return;\n    }\n    var scale = (range[1] - range[0]) / (originalRange[1] - originalRange[0]);\n    var shift = range[0] - originalRange[0] * scale;\n    for (var i = 0; i < model.nodes.length; ++i) {\n      model.nodes[i].x = model.nodes[i].x * scale + shift;\n    }\n    model.mappingRange[0] = range[0];\n    model.mappingRange[1] = range[1];\n    publicAPI.modified();\n  }; //----------------------------------------------------------------------------\n\n  publicAPI.adjustRange = function (range) {\n    var functionRange = publicAPI.getRange(); // Make sure we have points at each end of the range\n\n    var rgb = [];\n    if (functionRange[0] < range[0]) {\n      publicAPI.getColor(range[0], rgb);\n      publicAPI.addRGBPoint(range[0], rgb[0], rgb[1], rgb[2]);\n    } else {\n      publicAPI.getColor(functionRange[0], rgb);\n      publicAPI.addRGBPoint(range[0], rgb[0], rgb[1], rgb[2]);\n    }\n    if (functionRange[1] > range[1]) {\n      publicAPI.getColor(range[1], rgb);\n      publicAPI.addRGBPoint(range[1], rgb[0], rgb[1], rgb[2]);\n    } else {\n      publicAPI.getColor(functionRange[1], rgb);\n      publicAPI.addRGBPoint(range[1], rgb[0], rgb[1], rgb[2]);\n    } // Remove all points out-of-range\n\n    publicAPI.sortAndUpdateRange();\n    for (var i = 0; i < model.nodes.length;) {\n      if (model.nodes[i].x >= range[0] && model.nodes[i].x <= range[1]) {\n        model.nodes.splice(i, 1);\n      } else {\n        ++i;\n      }\n    }\n    return 1;\n  }; //--------------------------------------------------------------------------\n\n  publicAPI.estimateMinNumberOfSamples = function (x1, x2) {\n    var d = publicAPI.findMinimumXDistance();\n    return Math.ceil((x2 - x1) / d);\n  }; //----------------------------------------------------------------------------\n\n  publicAPI.findMinimumXDistance = function () {\n    if (model.nodes.length < 2) {\n      return -1.0;\n    }\n    var distance = Number.MAX_VALUE;\n    for (var i = 0; i < model.nodes.length - 1; i++) {\n      var currentDist = model.nodes[i + 1].x - model.nodes[i].x;\n      if (currentDist < distance) {\n        distance = currentDist;\n      }\n    }\n    return distance;\n  };\n  publicAPI.mapScalarsThroughTable = function (input, output, outFormat, inputOffset) {\n    if (publicAPI.getSize() === 0) {\n      vtkDebugMacro('Transfer Function Has No Points!');\n      return;\n    }\n    if (model.indexedLookup) {\n      publicAPI.mapDataIndexed(input, output, outFormat, inputOffset);\n    } else {\n      publicAPI.mapData(input, output, outFormat, inputOffset);\n    }\n  }; //----------------------------------------------------------------------------\n\n  publicAPI.mapData = function (input, output, outFormat, inputOffset) {\n    if (publicAPI.getSize() === 0) {\n      vtkWarningMacro('Transfer Function Has No Points!');\n      return;\n    }\n    var alpha = Math.floor(publicAPI.getAlpha() * 255.0 + 0.5);\n    var length = input.getNumberOfTuples();\n    var inIncr = input.getNumberOfComponents();\n    var outputV = output.getData();\n    var inputV = input.getData();\n    var rgb = [];\n    if (outFormat === ScalarMappingTarget.RGBA) {\n      for (var i = 0; i < length; i++) {\n        var x = inputV[i * inIncr + inputOffset];\n        publicAPI.getColor(x, rgb);\n        outputV[i * 4] = Math.floor(rgb[0] * 255.0 + 0.5);\n        outputV[i * 4 + 1] = Math.floor(rgb[1] * 255.0 + 0.5);\n        outputV[i * 4 + 2] = Math.floor(rgb[2] * 255.0 + 0.5);\n        outputV[i * 4 + 3] = alpha;\n      }\n    }\n    if (outFormat === ScalarMappingTarget.RGB) {\n      for (var _i2 = 0; _i2 < length; _i2++) {\n        var _x = inputV[_i2 * inIncr + inputOffset];\n        publicAPI.getColor(_x, rgb);\n        outputV[_i2 * 3] = Math.floor(rgb[0] * 255.0 + 0.5);\n        outputV[_i2 * 3 + 1] = Math.floor(rgb[1] * 255.0 + 0.5);\n        outputV[_i2 * 3 + 2] = Math.floor(rgb[2] * 255.0 + 0.5);\n      }\n    }\n    if (outFormat === ScalarMappingTarget.LUMINANCE) {\n      for (var _i3 = 0; _i3 < length; _i3++) {\n        var _x2 = inputV[_i3 * inIncr + inputOffset];\n        publicAPI.getColor(_x2, rgb);\n        outputV[_i3] = Math.floor(rgb[0] * 76.5 + rgb[1] * 150.45 + rgb[2] * 28.05 + 0.5);\n      }\n    }\n    if (outFormat === ScalarMappingTarget.LUMINANCE_ALPHA) {\n      for (var _i4 = 0; _i4 < length; _i4++) {\n        var _x3 = inputV[_i4 * inIncr + inputOffset];\n        publicAPI.getColor(_x3, rgb);\n        outputV[_i4 * 2] = Math.floor(rgb[0] * 76.5 + rgb[1] * 150.45 + rgb[2] * 28.05 + 0.5);\n        outputV[_i4 * 2 + 1] = alpha;\n      }\n    }\n  }; //----------------------------------------------------------------------------\n\n  publicAPI.applyColorMap = function (colorMap) {\n    var oldColorSpace = JSON.stringify(model.colorSpace);\n    if (colorMap.ColorSpace) {\n      model.colorSpace = ColorSpace[colorMap.ColorSpace.toUpperCase()];\n      if (model.colorSpace === undefined) {\n        vtkErrorMacro(\"ColorSpace \".concat(colorMap.ColorSpace, \" not supported, using RGB instead\"));\n        model.colorSpace = ColorSpace.RGB;\n      }\n    }\n    var isModified = oldColorSpace !== JSON.stringify(model.colorSpace);\n    var oldNanColor = isModified || JSON.stringify(model.nanColor);\n    if (colorMap.NanColor) {\n      model.nanColor = [].concat(colorMap.NanColor);\n      while (model.nanColor.length < 4) {\n        model.nanColor.push(1.0);\n      }\n    }\n    isModified = isModified || oldNanColor !== JSON.stringify(model.nanColor);\n    var oldNodes = isModified || JSON.stringify(model.nodes);\n    if (colorMap.RGBPoints) {\n      var size = colorMap.RGBPoints.length;\n      model.nodes = [];\n      var midpoint = 0.5;\n      var sharpness = 0.0;\n      for (var i = 0; i < size; i += 4) {\n        model.nodes.push({\n          x: colorMap.RGBPoints[i],\n          r: colorMap.RGBPoints[i + 1],\n          g: colorMap.RGBPoints[i + 2],\n          b: colorMap.RGBPoints[i + 3],\n          midpoint: midpoint,\n          sharpness: sharpness\n        });\n      }\n    }\n    var modifiedInvoked = publicAPI.sortAndUpdateRange();\n    var callModified = !modifiedInvoked && (isModified || oldNodes !== JSON.stringify(model.nodes));\n    if (callModified) publicAPI.modified();\n    return modifiedInvoked || callModified;\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nvar DEFAULT_VALUES = {\n  clamping: true,\n  colorSpace: ColorSpace.RGB,\n  hSVWrap: true,\n  scale: Scale.LINEAR,\n  nanColor: null,\n  belowRangeColor: null,\n  aboveRangeColor: null,\n  useAboveRangeColor: false,\n  useBelowRangeColor: false,\n  allowDuplicateScalars: false,\n  table: null,\n  tableSize: 0,\n  buildTime: null,\n  nodes: null,\n  discretize: false,\n  numberOfValues: 256\n}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Inheritance\n\n  vtkScalarsToColors.extend(publicAPI, model, initialValues); // Internal objects initialization\n\n  model.table = [];\n  model.nodes = [];\n  model.nanColor = [0.5, 0.0, 0.0, 1.0];\n  model.belowRangeColor = [0.0, 0.0, 0.0, 1.0];\n  model.aboveRangeColor = [1.0, 1.0, 1.0, 1.0];\n  model.buildTime = {};\n  macro.obj(model.buildTime); // Create get-only macros\n\n  macro.get(publicAPI, model, ['buildTime', 'mappingRange']); // Create get-set macros\n\n  macro.setGet(publicAPI, model, ['useAboveRangeColor', 'useBelowRangeColor', 'colorSpace', 'discretize', 'numberOfValues']);\n  macro.setArray(publicAPI, model, ['nanColor', 'belowRangeColor', 'aboveRangeColor'], 4); // Create get macros for array\n\n  macro.getArray(publicAPI, model, ['nanColor', 'belowRangeColor', 'aboveRangeColor']); // For more macro methods, see \"Sources/macros.js\"\n  // Object specific methods\n\n  vtkColorTransferFunction(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = macro.newInstance(extend, 'vtkColorTransferFunction'); // ----------------------------------------------------------------------------\n\nvar vtkColorTransferFunction$1 = _objectSpread({\n  newInstance: newInstance,\n  extend: extend\n}, Constants);\nexport { vtkColorTransferFunction$1 as default, extend, newInstance };","map":{"version":3,"names":["_defineProperty","macro","h","hsv2rgb","i","isNan","G","isInf","H","rgb2hsv","I","rgb2lab","J","lab2rgb","K","floor","vtkScalarsToColors","Constants","ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","arguments","length","source","forEach","key","getOwnPropertyDescriptors","defineProperties","defineProperty","ColorSpace","Scale","ScalarMappingTarget","vtkDebugMacro","vtkErrorMacro","vtkWarningMacro","vtkColorTransferFunctionLabToMsh","lab","msh","L","a","b","M","Math","sqrt","s","acos","atan2","vtkColorTransferFunctionMshToLab","cos","sin","vtkColorTransferFunctionAdjustHue","unsatM","hueSpin","PI","vtkColorTransferFunctionAngleDiff","a1","a2","adiff","vtkColorTransferFunctionInterpolateDiverging","rgb1","rgb2","result","lab1","lab2","msh1","msh2","localS","Mmid","max","mshTmp","labTmp","vtkColorTransferFunction","publicAPI","model","classHierarchy","getSize","nodes","addRGBPoint","x","r","g","addRGBPointLong","midpoint","undefined","sharpness","allowDuplicateScalars","removePoint","node","sortAndUpdateRange","addHSVPoint","v","addHSVPointLong","rgb","hsv","setNodes","before","JSON","stringify","after","modified","sort","modifiedInvoked","updateRange","oldRange","mappingRange","size","retVal","splice","movePoint","oldX","newX","removeAllPoints","addRGBSegment","x1","r1","g1","b1","x2","r2","g2","b2","addHSVSegment","h1","s1","v1","h2","s2","v2","hsv1","hsv2","mapValue","getColor","indexedLookup","numNodes","idx","getAnnotatedValueIndexInternal","nanColor","getNanColorByReference","nodeVal","getNodeValue","getTable","getRedValue","getGreenValue","getBlueValue","xStart_","xEnd_","table","xStart","Number","xEnd","lastR","lastG","lastB","tmpVec","usingLogScale","scale","LOG10","logStart","logEnd","logX","log10","_i","tidx","pow","discretize","range","numberOfValues","deltaRange","xn","discretizeIndex","clamping","getUseAboveRangeColor","aboveRangeColor","getUseBelowRangeColor","belowRangeColor","abs","colorSpace","RGB","HSV","hSVWrap","hsvTmp","LAB","DIVERGING","ss","sss","h3","h4","slope","t","j","_hsv","_hsv2","_hsvTmp","_j","_lab","_lab2","_labTmp","_j2","_j3","getUint8Table","withAlpha","getMTime","buildTime","tableSize","tableWithAlpha","nbChannels","Uint8Array","tmpTable","buildFunctionFromArray","array","numComponents","getNumberOfComponents","getNumberOfTuples","getComponent","buildFunctionFromTable","inc","index","val","setNodeValue","getNumberOfAvailableColors","getIndexedColor","rgba","n","nodeValue","fillFromDataPointer","nb","ptr","setMappingRange","min","originalRange","getRange","shift","adjustRange","functionRange","estimateMinNumberOfSamples","d","findMinimumXDistance","ceil","distance","MAX_VALUE","currentDist","mapScalarsThroughTable","input","output","outFormat","inputOffset","mapDataIndexed","mapData","alpha","getAlpha","inIncr","outputV","getData","inputV","RGBA","_i2","_x","LUMINANCE","_i3","_x2","LUMINANCE_ALPHA","_i4","_x3","applyColorMap","colorMap","oldColorSpace","toUpperCase","concat","isModified","oldNanColor","NanColor","oldNodes","RGBPoints","callModified","DEFAULT_VALUES","LINEAR","useAboveRangeColor","useBelowRangeColor","extend","initialValues","assign","obj","get","setGet","setArray","getArray","newInstance","vtkColorTransferFunction$1","default"],"sources":["/home/rakshith/Documents/RemoteRendering/vtk-js-react-app/node_modules/@kitware/vtk.js/Rendering/Core/ColorTransferFunction.js"],"sourcesContent":["import _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport macro from '../../macros.js';\nimport { h as hsv2rgb, i as isNan, G as isInf, H as rgb2hsv, I as rgb2lab, J as lab2rgb, K as floor } from '../../Common/Core/Math/index.js';\nimport vtkScalarsToColors from '../../Common/Core/ScalarsToColors.js';\nimport Constants from './ColorTransferFunction/Constants.js';\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nvar ColorSpace = Constants.ColorSpace,\n    Scale = Constants.Scale;\nvar ScalarMappingTarget = vtkScalarsToColors.ScalarMappingTarget;\nvar vtkDebugMacro = macro.vtkDebugMacro,\n    vtkErrorMacro = macro.vtkErrorMacro,\n    vtkWarningMacro = macro.vtkWarningMacro; // ----------------------------------------------------------------------------\n// Global methods\n// ----------------------------------------------------------------------------\n\n/* eslint-disable no-continue                                                */\n// Convert to and from a special polar version of CIELAB (useful for creating\n// continuous diverging color maps).\n\nfunction vtkColorTransferFunctionLabToMsh(lab, msh) {\n  var L = lab[0];\n  var a = lab[1];\n  var b = lab[2];\n  var M = Math.sqrt(L * L + a * a + b * b);\n  var s = M > 0.001 ? Math.acos(L / M) : 0.0;\n  var h = s > 0.001 ? Math.atan2(b, a) : 0.0;\n  msh[0] = M;\n  msh[1] = s;\n  msh[2] = h;\n}\n\nfunction vtkColorTransferFunctionMshToLab(msh, lab) {\n  var M = msh[0];\n  var s = msh[1];\n  var h = msh[2];\n  lab[0] = M * Math.cos(s);\n  lab[1] = M * Math.sin(s) * Math.cos(h);\n  lab[2] = M * Math.sin(s) * Math.sin(h);\n} // For the case when interpolating from a saturated color to an unsaturated\n// color, find a hue for the unsaturated color that makes sense.\n\n\nfunction vtkColorTransferFunctionAdjustHue(msh, unsatM) {\n  if (msh[0] >= unsatM - 0.1) {\n    // The best we can do is hold hue constant.\n    return msh[2];\n  } // This equation is designed to make the perceptual change of the\n  // interpolation to be close to constant.\n\n\n  var hueSpin = msh[1] * Math.sqrt(unsatM * unsatM - msh[0] * msh[0]) / (msh[0] * Math.sin(msh[1])); // Spin hue away from 0 except in purple hues.\n\n  if (msh[2] > -0.3 * Math.PI) {\n    return msh[2] + hueSpin;\n  }\n\n  return msh[2] - hueSpin;\n}\n\nfunction vtkColorTransferFunctionAngleDiff(a1, a2) {\n  var adiff = a1 - a2;\n\n  if (adiff < 0.0) {\n    adiff = -adiff;\n  }\n\n  while (adiff >= 2.0 * Math.PI) {\n    adiff -= 2.0 * Math.PI;\n  }\n\n  if (adiff > Math.PI) {\n    adiff = 2.0 * Math.PI - adiff;\n  }\n\n  return adiff;\n} // Interpolate a diverging color map.\n\n\nfunction vtkColorTransferFunctionInterpolateDiverging(s, rgb1, rgb2, result) {\n  var lab1 = [];\n  var lab2 = [];\n  rgb2lab(rgb1, lab1);\n  rgb2lab(rgb2, lab2);\n  var msh1 = [];\n  var msh2 = [];\n  vtkColorTransferFunctionLabToMsh(lab1, msh1);\n  vtkColorTransferFunctionLabToMsh(lab2, msh2); // If the endpoints are distinct saturated colors, then place white in between\n  // them.\n\n  var localS = s;\n\n  if (msh1[1] > 0.05 && msh2[1] > 0.05 && vtkColorTransferFunctionAngleDiff(msh1[2], msh2[2]) > 0.33 * Math.PI) {\n    // Insert the white midpoint by setting one end to white and adjusting the\n    // scalar value.\n    var Mmid = Math.max(msh1[0], msh2[0]);\n    Mmid = Math.max(88.0, Mmid);\n\n    if (s < 0.5) {\n      msh2[0] = Mmid;\n      msh2[1] = 0.0;\n      msh2[2] = 0.0;\n      localS *= 2.0;\n    } else {\n      msh1[0] = Mmid;\n      msh1[1] = 0.0;\n      msh1[2] = 0.0;\n      localS = 2.0 * localS - 1.0;\n    }\n  } // If one color has no saturation, then its hue value is invalid.  In this\n  // case, we want to set it to something logical so that the interpolation of\n  // hue makes sense.\n\n\n  if (msh1[1] < 0.05 && msh2[1] > 0.05) {\n    msh1[2] = vtkColorTransferFunctionAdjustHue(msh2, msh1[0]);\n  } else if (msh2[1] < 0.05 && msh1[1] > 0.05) {\n    msh2[2] = vtkColorTransferFunctionAdjustHue(msh1, msh2[0]);\n  }\n\n  var mshTmp = [];\n  mshTmp[0] = (1 - localS) * msh1[0] + localS * msh2[0];\n  mshTmp[1] = (1 - localS) * msh1[1] + localS * msh2[1];\n  mshTmp[2] = (1 - localS) * msh1[2] + localS * msh2[2]; // Now convert back to RGB\n\n  var labTmp = [];\n  vtkColorTransferFunctionMshToLab(mshTmp, labTmp);\n  lab2rgb(labTmp, result);\n} // ----------------------------------------------------------------------------\n// vtkColorTransferFunction methods\n// ----------------------------------------------------------------------------\n\n\nfunction vtkColorTransferFunction(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkColorTransferFunction'); // Return the number of points which specify this function\n\n  publicAPI.getSize = function () {\n    return model.nodes.length;\n  }; //----------------------------------------------------------------------------\n  // Add a point defined in RGB\n\n\n  publicAPI.addRGBPoint = function (x, r, g, b) {\n    return publicAPI.addRGBPointLong(x, r, g, b, 0.5, 0.0);\n  }; //----------------------------------------------------------------------------\n  // Add a point defined in RGB\n\n\n  publicAPI.addRGBPointLong = function (x, r, g, b) {\n    var midpoint = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0.5;\n    var sharpness = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0.0;\n\n    // Error check\n    if (midpoint < 0.0 || midpoint > 1.0) {\n      vtkErrorMacro('Midpoint outside range [0.0, 1.0]');\n      return -1;\n    }\n\n    if (sharpness < 0.0 || sharpness > 1.0) {\n      vtkErrorMacro('Sharpness outside range [0.0, 1.0]');\n      return -1;\n    } // remove any node already at this X location\n\n\n    if (!model.allowDuplicateScalars) {\n      publicAPI.removePoint(x);\n    } // Create the new node\n\n\n    var node = {\n      x: x,\n      r: r,\n      g: g,\n      b: b,\n      midpoint: midpoint,\n      sharpness: sharpness\n    }; // Add it, then sort to get everything in order\n\n    model.nodes.push(node);\n    publicAPI.sortAndUpdateRange(); // We need to find the index of the node we just added in order\n    // to return this value\n\n    var i = 0;\n\n    for (; i < model.nodes.length; i++) {\n      if (model.nodes[i].x === x) {\n        break;\n      }\n    } // If we didn't find it, something went horribly wrong so\n    // return -1\n\n\n    if (i < model.nodes.length) {\n      return i;\n    }\n\n    return -1;\n  }; //----------------------------------------------------------------------------\n  // Add a point defined in HSV\n\n\n  publicAPI.addHSVPoint = function (x, h, s, v) {\n    return publicAPI.addHSVPointLong(x, h, s, v, 0.5, 0.0);\n  }; //----------------------------------------------------------------------------\n  // Add a point defined in HSV\n\n\n  publicAPI.addHSVPointLong = function (x, h, s, v) {\n    var midpoint = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0.5;\n    var sharpness = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0.0;\n    var rgb = [];\n    var hsv = [h, s, v];\n    hsv2rgb(hsv, rgb);\n    return publicAPI.addRGBPoint(x, rgb[0], rgb[1], rgb[2], midpoint, sharpness);\n  }; //----------------------------------------------------------------------------\n  // Set nodes directly\n\n\n  publicAPI.setNodes = function (nodes) {\n    if (model.nodes !== nodes) {\n      var before = JSON.stringify(model.nodes);\n      model.nodes = nodes;\n      var after = JSON.stringify(model.nodes);\n\n      if (publicAPI.sortAndUpdateRange() || before !== after) {\n        publicAPI.modified();\n        return true;\n      }\n    }\n\n    return false;\n  }; //----------------------------------------------------------------------------\n  // Sort the vector in increasing order, then fill in\n  // the Range\n\n\n  publicAPI.sortAndUpdateRange = function () {\n    var before = JSON.stringify(model.nodes);\n    model.nodes.sort(function (a, b) {\n      return a.x - b.x;\n    });\n    var after = JSON.stringify(model.nodes);\n    var modifiedInvoked = publicAPI.updateRange(); // If range is updated, Modified() has been called, don't call it again.\n\n    if (!modifiedInvoked && before !== after) {\n      publicAPI.modified();\n      return true;\n    }\n\n    return modifiedInvoked;\n  }; //----------------------------------------------------------------------------\n\n\n  publicAPI.updateRange = function () {\n    var oldRange = [2];\n    oldRange[0] = model.mappingRange[0];\n    oldRange[1] = model.mappingRange[1];\n    var size = model.nodes.length;\n\n    if (size) {\n      model.mappingRange[0] = model.nodes[0].x;\n      model.mappingRange[1] = model.nodes[size - 1].x;\n    } else {\n      model.mappingRange[0] = 0;\n      model.mappingRange[1] = 0;\n    } // If the range is the same, then no need to call Modified()\n\n\n    if (oldRange[0] === model.mappingRange[0] && oldRange[1] === model.mappingRange[1]) {\n      return false;\n    }\n\n    publicAPI.modified();\n    return true;\n  }; //----------------------------------------------------------------------------\n  // Remove a point\n\n\n  publicAPI.removePoint = function (x) {\n    // First find the node since we need to know its\n    // index as our return value\n    var i = 0;\n\n    for (; i < model.nodes.length; i++) {\n      if (model.nodes[i].x === x) {\n        break;\n      }\n    }\n\n    var retVal = i; // If the node doesn't exist, we return -1\n\n    if (i >= model.nodes.length) {\n      return -1;\n    } // If the first or last point has been removed, then we update the range\n    // No need to sort here as the order of points hasn't changed.\n\n\n    var modifiedInvoked = false;\n    model.nodes.splice(i, 1);\n\n    if (i === 0 || i === model.nodes.length) {\n      modifiedInvoked = publicAPI.updateRange();\n    }\n\n    if (!modifiedInvoked) {\n      publicAPI.modified();\n    }\n\n    return retVal;\n  }; //----------------------------------------------------------------------------\n\n\n  publicAPI.movePoint = function (oldX, newX) {\n    if (oldX === newX) {\n      // Nothing to do.\n      return;\n    }\n\n    publicAPI.removePoint(newX);\n\n    for (var i = 0; i < model.nodes.length; i++) {\n      if (model.nodes[i].x === oldX) {\n        model.nodes[i].x = newX;\n        publicAPI.sortAndUpdateRange();\n        break;\n      }\n    }\n  }; //----------------------------------------------------------------------------\n  // Remove all points\n\n\n  publicAPI.removeAllPoints = function () {\n    model.nodes = [];\n    publicAPI.sortAndUpdateRange();\n  }; //----------------------------------------------------------------------------\n  // Add a line defined in RGB\n\n\n  publicAPI.addRGBSegment = function (x1, r1, g1, b1, x2, r2, g2, b2) {\n    // First, find all points in this range and remove them\n    publicAPI.sortAndUpdateRange();\n\n    for (var i = 0; i < model.nodes.length;) {\n      if (model.nodes[i].x >= x1 && model.nodes[i].x <= x2) {\n        model.nodes.splice(i, 1);\n      } else {\n        i++;\n      }\n    } // Now add the points\n\n\n    publicAPI.addRGBPointLong(x1, r1, g1, b1, 0.5, 0.0);\n    publicAPI.addRGBPointLong(x2, r2, g2, b2, 0.5, 0.0);\n    publicAPI.modified();\n  }; //----------------------------------------------------------------------------\n  // Add a line defined in HSV\n\n\n  publicAPI.addHSVSegment = function (x1, h1, s1, v1, x2, h2, s2, v2) {\n    var hsv1 = [h1, s1, v1];\n    var hsv2 = [h2, s2, v2];\n    var rgb1 = [];\n    var rgb2 = [];\n    hsv2rgb(hsv1, rgb1);\n    hsv2rgb(hsv2, rgb2);\n    publicAPI.addRGBSegment(x1, rgb1[0], rgb1[1], rgb1[2], x2, rgb2[0], rgb2[1], rgb2[2]);\n  }; //----------------------------------------------------------------------------\n  // Returns the RGBA color evaluated at the specified location\n\n\n  publicAPI.mapValue = function (x) {\n    var rgb = [];\n    publicAPI.getColor(x, rgb);\n    return [Math.floor(255.0 * rgb[0] + 0.5), Math.floor(255.0 * rgb[1] + 0.5), Math.floor(255.0 * rgb[2] + 0.5), 255];\n  }; //----------------------------------------------------------------------------\n  // Returns the RGB color evaluated at the specified location\n\n\n  publicAPI.getColor = function (x, rgb) {\n    if (model.indexedLookup) {\n      var numNodes = publicAPI.getSize(); // todo\n\n      var idx = publicAPI.getAnnotatedValueIndexInternal(x);\n\n      if (idx < 0 || numNodes === 0) {\n        var nanColor = publicAPI.getNanColorByReference();\n        rgb[0] = nanColor[0];\n        rgb[1] = nanColor[1];\n        rgb[2] = nanColor[2];\n      } else {\n        var nodeVal = [];\n        publicAPI.getNodeValue(idx % numNodes, nodeVal); // nodeVal[0] is the x value. nodeVal[1...3] is rgb.\n\n        rgb[0] = nodeVal[1];\n        rgb[1] = nodeVal[2];\n        rgb[2] = nodeVal[3];\n      }\n\n      return;\n    }\n\n    publicAPI.getTable(x, x, 1, rgb);\n  }; //----------------------------------------------------------------------------\n  // Returns the red color evaluated at the specified location\n\n\n  publicAPI.getRedValue = function (x) {\n    var rgb = [];\n    publicAPI.getColor(x, rgb);\n    return rgb[0];\n  }; //----------------------------------------------------------------------------\n  // Returns the green color evaluated at the specified location\n\n\n  publicAPI.getGreenValue = function (x) {\n    var rgb = [];\n    publicAPI.getColor(x, rgb);\n    return rgb[1];\n  }; //----------------------------------------------------------------------------\n  // Returns the blue color evaluated at the specified location\n\n\n  publicAPI.getBlueValue = function (x) {\n    var rgb = [];\n    publicAPI.getColor(x, rgb);\n    return rgb[2];\n  }; //----------------------------------------------------------------------------\n  // Returns a table of RGB colors at regular intervals along the function\n\n\n  publicAPI.getTable = function (xStart_, xEnd_, size, table) {\n    // To handle BigInt limitation\n    var xStart = Number(xStart_);\n    var xEnd = Number(xEnd_); // Special case: If either the start or end is a NaN, then all any\n    // interpolation done on them is also a NaN.  Therefore, fill the table with\n    // the NaN color.\n\n    if (isNan(xStart) || isNan(xEnd)) {\n      for (var i = 0; i < size; i++) {\n        table[i * 3 + 0] = model.nanColor[0];\n        table[i * 3 + 1] = model.nanColor[1];\n        table[i * 3 + 2] = model.nanColor[2];\n      }\n\n      return;\n    }\n\n    var idx = 0;\n    var numNodes = model.nodes.length; // Need to keep track of the last value so that\n    // we can fill in table locations past this with\n    // this value if Clamping is On.\n\n    var lastR = 0.0;\n    var lastG = 0.0;\n    var lastB = 0.0;\n\n    if (numNodes !== 0) {\n      lastR = model.nodes[numNodes - 1].r;\n      lastG = model.nodes[numNodes - 1].g;\n      lastB = model.nodes[numNodes - 1].b;\n    }\n\n    var x = 0.0;\n    var x1 = 0.0;\n    var x2 = 0.0;\n    var rgb1 = [0.0, 0.0, 0.0];\n    var rgb2 = [0.0, 0.0, 0.0];\n    var midpoint = 0.0;\n    var sharpness = 0.0;\n    var tmpVec = []; // If the scale is logarithmic, make sure the range is valid.\n\n    var usingLogScale = model.scale === Scale.LOG10;\n\n    if (usingLogScale) {\n      // Note: This requires range[0] <= range[1].\n      usingLogScale = model.mappingRange[0] > 0.0;\n    }\n\n    var logStart = 0.0;\n    var logEnd = 0.0;\n    var logX = 0.0;\n\n    if (usingLogScale) {\n      logStart = Math.log10(xStart);\n      logEnd = Math.log10(xEnd);\n    } // For each table entry\n\n\n    for (var _i = 0; _i < size; _i++) {\n      // Find our location in the table\n      var tidx = 3 * _i; // Find our X location. If we are taking only 1 sample, make\n      // it halfway between start and end (usually start and end will\n      // be the same in this case)\n\n      if (size > 1) {\n        if (usingLogScale) {\n          logX = logStart + _i / (size - 1.0) * (logEnd - logStart);\n          x = Math.pow(10.0, logX);\n        } else {\n          x = xStart + _i / (size - 1.0) * (xEnd - xStart);\n        }\n      } else if (usingLogScale) {\n        logX = 0.5 * (logStart + logEnd);\n        x = Math.pow(10.0, logX);\n      } else {\n        x = 0.5 * (xStart + xEnd);\n      } // Linearly map x from mappingRange to [0, numberOfValues-1],\n      // discretize (round down to the closest integer),\n      // then map back to mappingRange\n\n\n      if (model.discretize) {\n        var range = model.mappingRange;\n\n        if (x >= range[0] && x <= range[1]) {\n          var numberOfValues = model.numberOfValues;\n          var deltaRange = range[1] - range[0];\n\n          if (numberOfValues <= 1) {\n            x = range[0] + deltaRange / 2.0;\n          } else {\n            // normalize x\n            var xn = (x - range[0]) / deltaRange; // discretize\n\n            var discretizeIndex = floor(numberOfValues * xn); // get discretized x\n\n            x = range[0] + discretizeIndex / (numberOfValues - 1) * deltaRange;\n          }\n        }\n      } // Do we need to move to the next node?\n\n\n      while (idx < numNodes && x > model.nodes[idx].x) {\n        idx++; // If we are at a valid point index, fill in\n        // the value at this node, and the one before (the\n        // two that surround our current sample location)\n        // idx cannot be 0 since we just incremented it.\n\n        if (idx < numNodes) {\n          x1 = model.nodes[idx - 1].x;\n          x2 = model.nodes[idx].x;\n\n          if (usingLogScale) {\n            x1 = Math.log10(x1);\n            x2 = Math.log10(x2);\n          }\n\n          rgb1[0] = model.nodes[idx - 1].r;\n          rgb2[0] = model.nodes[idx].r;\n          rgb1[1] = model.nodes[idx - 1].g;\n          rgb2[1] = model.nodes[idx].g;\n          rgb1[2] = model.nodes[idx - 1].b;\n          rgb2[2] = model.nodes[idx].b; // We only need the previous midpoint and sharpness\n          // since these control this region\n\n          midpoint = model.nodes[idx - 1].midpoint;\n          sharpness = model.nodes[idx - 1].sharpness; // Move midpoint away from extreme ends of range to avoid\n          // degenerate math\n\n          if (midpoint < 0.00001) {\n            midpoint = 0.00001;\n          }\n\n          if (midpoint > 0.99999) {\n            midpoint = 0.99999;\n          }\n        }\n      } // Are we at or past the end? If so, just use the last value\n\n\n      if (x > model.mappingRange[1]) {\n        table[tidx] = 0.0;\n        table[tidx + 1] = 0.0;\n        table[tidx + 2] = 0.0;\n\n        if (model.clamping) {\n          if (publicAPI.getUseAboveRangeColor()) {\n            table[tidx] = model.aboveRangeColor[0];\n            table[tidx + 1] = model.aboveRangeColor[1];\n            table[tidx + 2] = model.aboveRangeColor[2];\n          } else {\n            table[tidx] = lastR;\n            table[tidx + 1] = lastG;\n            table[tidx + 2] = lastB;\n          }\n        }\n      } else if (x < model.mappingRange[0] || isInf(x) && x < 0) {\n        // we are before the first node? If so, duplicate this node's values.\n        // We have to deal with -inf here\n        table[tidx] = 0.0;\n        table[tidx + 1] = 0.0;\n        table[tidx + 2] = 0.0;\n\n        if (model.clamping) {\n          if (publicAPI.getUseBelowRangeColor()) {\n            table[tidx] = model.belowRangeColor[0];\n            table[tidx + 1] = model.belowRangeColor[1];\n            table[tidx + 2] = model.belowRangeColor[2];\n          } else if (numNodes > 0) {\n            table[tidx] = model.nodes[0].r;\n            table[tidx + 1] = model.nodes[0].g;\n            table[tidx + 2] = model.nodes[0].b;\n          }\n        }\n      } else if (idx === 0 && (Math.abs(x - xStart) < 1e-6 || model.discretize)) {\n        if (numNodes > 0) {\n          table[tidx] = model.nodes[0].r;\n          table[tidx + 1] = model.nodes[0].g;\n          table[tidx + 2] = model.nodes[0].b;\n        } else {\n          table[tidx] = 0.0;\n          table[tidx + 1] = 0.0;\n          table[tidx + 2] = 0.0;\n        }\n      } else {\n        // OK, we are between two nodes - interpolate\n        // Our first attempt at a normalized location [0,1] -\n        // we will be modifying this based on midpoint and\n        // sharpness to get the curve shape we want and to have\n        // it pass through (y1+y2)/2 at the midpoint.\n        var s = 0.0;\n\n        if (usingLogScale) {\n          s = (logX - x1) / (x2 - x1);\n        } else {\n          s = (x - x1) / (x2 - x1);\n        } // Readjust based on the midpoint - linear adjustment\n\n\n        if (s < midpoint) {\n          s = 0.5 * s / midpoint;\n        } else {\n          s = 0.5 + 0.5 * (s - midpoint) / (1.0 - midpoint);\n        } // override for sharpness > 0.99\n        // In this case we just want piecewise constant\n\n\n        if (sharpness > 0.99) {\n          // Use the first value since we are below the midpoint\n          if (s < 0.5) {\n            table[tidx] = rgb1[0];\n            table[tidx + 1] = rgb1[1];\n            table[tidx + 2] = rgb1[2];\n            continue;\n          } else {\n            // Use the second value at or above the midpoint\n            table[tidx] = rgb2[0];\n            table[tidx + 1] = rgb2[1];\n            table[tidx + 2] = rgb2[2];\n            continue;\n          }\n        } // Override for sharpness < 0.01\n        // In this case we want piecewise linear\n\n\n        if (sharpness < 0.01) {\n          // Simple linear interpolation\n          if (model.colorSpace === ColorSpace.RGB) {\n            table[tidx] = (1 - s) * rgb1[0] + s * rgb2[0];\n            table[tidx + 1] = (1 - s) * rgb1[1] + s * rgb2[1];\n            table[tidx + 2] = (1 - s) * rgb1[2] + s * rgb2[2];\n          } else if (model.colorSpace === ColorSpace.HSV) {\n            var hsv1 = [];\n            var hsv2 = [];\n            rgb2hsv(rgb1, hsv1);\n            rgb2hsv(rgb2, hsv2);\n\n            if (model.hSVWrap && (hsv1[0] - hsv2[0] > 0.5 || hsv2[0] - hsv1[0] > 0.5)) {\n              if (hsv1[0] > hsv2[0]) {\n                hsv1[0] -= 1.0;\n              } else {\n                hsv2[0] -= 1.0;\n              }\n            }\n\n            var hsvTmp = [];\n            hsvTmp[0] = (1.0 - s) * hsv1[0] + s * hsv2[0];\n\n            if (hsvTmp[0] < 0.0) {\n              hsvTmp[0] += 1.0;\n            }\n\n            hsvTmp[1] = (1.0 - s) * hsv1[1] + s * hsv2[1];\n            hsvTmp[2] = (1.0 - s) * hsv1[2] + s * hsv2[2]; // Now convert this back to RGB\n\n            hsv2rgb(hsvTmp, tmpVec);\n            table[tidx] = tmpVec[0];\n            table[tidx + 1] = tmpVec[1];\n            table[tidx + 2] = tmpVec[2];\n          } else if (model.colorSpace === ColorSpace.LAB) {\n            var lab1 = [];\n            var lab2 = [];\n            rgb2lab(rgb1, lab1);\n            rgb2lab(rgb2, lab2);\n            var labTmp = [];\n            labTmp[0] = (1 - s) * lab1[0] + s * lab2[0];\n            labTmp[1] = (1 - s) * lab1[1] + s * lab2[1];\n            labTmp[2] = (1 - s) * lab1[2] + s * lab2[2]; // Now convert back to RGB\n\n            lab2rgb(labTmp, tmpVec);\n            table[tidx] = tmpVec[0];\n            table[tidx + 1] = tmpVec[1];\n            table[tidx + 2] = tmpVec[2];\n          } else if (model.colorSpace === ColorSpace.DIVERGING) {\n            vtkColorTransferFunctionInterpolateDiverging(s, rgb1, rgb2, tmpVec);\n            table[tidx] = tmpVec[0];\n            table[tidx + 1] = tmpVec[1];\n            table[tidx + 2] = tmpVec[2];\n          } else {\n            vtkErrorMacro('ColorSpace set to invalid value.', model.colorSpace);\n          }\n\n          continue;\n        } // We have a sharpness between [0.01, 0.99] - we will\n        // used a modified hermite curve interpolation where we\n        // derive the slope based on the sharpness, and we compress\n        // the curve non-linearly based on the sharpness\n        // First, we will adjust our position based on sharpness in\n        // order to make the curve sharper (closer to piecewise constant)\n\n\n        if (s < 0.5) {\n          s = 0.5 * Math.pow(s * 2.0, 1.0 + 10.0 * sharpness);\n        } else if (s > 0.5) {\n          s = 1.0 - 0.5 * Math.pow((1.0 - s) * 2, 1 + 10.0 * sharpness);\n        } // Compute some coefficients we will need for the hermite curve\n\n\n        var ss = s * s;\n        var sss = ss * s;\n        var h1 = 2.0 * sss - 3 * ss + 1;\n        var h2 = -2 * sss + 3 * ss;\n        var h3 = sss - 2 * ss + s;\n        var h4 = sss - ss;\n        var slope = void 0;\n        var t = void 0;\n\n        if (model.colorSpace === ColorSpace.RGB) {\n          for (var j = 0; j < 3; j++) {\n            // Use one slope for both end points\n            slope = rgb2[j] - rgb1[j];\n            t = (1.0 - sharpness) * slope; // Compute the value\n\n            table[tidx + j] = h1 * rgb1[j] + h2 * rgb2[j] + h3 * t + h4 * t;\n          }\n        } else if (model.colorSpace === ColorSpace.HSV) {\n          var _hsv = [];\n          var _hsv2 = [];\n          rgb2hsv(rgb1, _hsv);\n          rgb2hsv(rgb2, _hsv2);\n\n          if (model.hSVWrap && (_hsv[0] - _hsv2[0] > 0.5 || _hsv2[0] - _hsv[0] > 0.5)) {\n            if (_hsv[0] > _hsv2[0]) {\n              _hsv[0] -= 1.0;\n            } else {\n              _hsv2[0] -= 1.0;\n            }\n          }\n\n          var _hsvTmp = [];\n\n          for (var _j = 0; _j < 3; _j++) {\n            // Use one slope for both end points\n            slope = _hsv2[_j] - _hsv[_j];\n            t = (1.0 - sharpness) * slope; // Compute the value\n\n            _hsvTmp[_j] = h1 * _hsv[_j] + h2 * _hsv2[_j] + h3 * t + h4 * t;\n\n            if (_j === 0 && _hsvTmp[_j] < 0.0) {\n              _hsvTmp[_j] += 1.0;\n            }\n          } // Now convert this back to RGB\n\n\n          hsv2rgb(_hsvTmp, tmpVec);\n          table[tidx] = tmpVec[0];\n          table[tidx + 1] = tmpVec[1];\n          table[tidx + 2] = tmpVec[2];\n        } else if (model.colorSpace === ColorSpace.LAB) {\n          var _lab = [];\n          var _lab2 = [];\n          rgb2lab(rgb1, _lab);\n          rgb2lab(rgb2, _lab2);\n          var _labTmp = [];\n\n          for (var _j2 = 0; _j2 < 3; _j2++) {\n            // Use one slope for both end points\n            slope = _lab2[_j2] - _lab[_j2];\n            t = (1.0 - sharpness) * slope; // Compute the value\n\n            _labTmp[_j2] = h1 * _lab[_j2] + h2 * _lab2[_j2] + h3 * t + h4 * t;\n          } // Now convert this back to RGB\n\n\n          lab2rgb(_labTmp, tmpVec);\n          table[tidx] = tmpVec[0];\n          table[tidx + 1] = tmpVec[1];\n          table[tidx + 2] = tmpVec[2];\n        } else if (model.colorSpace === ColorSpace.DIVERGING) {\n          // I have not implemented proper interpolation by a hermite curve for\n          // the diverging color map, but I cannot think of a good use case for\n          // that anyway.\n          vtkColorTransferFunctionInterpolateDiverging(s, rgb1, rgb2, tmpVec);\n          table[tidx] = tmpVec[0];\n          table[tidx + 1] = tmpVec[1];\n          table[tidx + 2] = tmpVec[2];\n        } else {\n          vtkErrorMacro('ColorSpace set to invalid value.');\n        } // Final error check to make sure we don't go outside [0,1]\n\n\n        for (var _j3 = 0; _j3 < 3; _j3++) {\n          table[tidx + _j3] = table[tidx + _j3] < 0.0 ? 0.0 : table[tidx + _j3];\n          table[tidx + _j3] = table[tidx + _j3] > 1.0 ? 1.0 : table[tidx + _j3];\n        }\n      }\n    }\n  }; //----------------------------------------------------------------------------\n\n\n  publicAPI.getUint8Table = function (xStart, xEnd, size) {\n    var withAlpha = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n    if (publicAPI.getMTime() <= model.buildTime && model.tableSize === size && model.tableWithAlpha !== withAlpha) {\n      return model.table;\n    }\n\n    if (model.nodes.length === 0) {\n      vtkErrorMacro('Attempting to lookup a value with no points in the function');\n      return model.table;\n    }\n\n    var nbChannels = withAlpha ? 4 : 3;\n\n    if (model.tableSize !== size || model.tableWithAlpha !== withAlpha) {\n      model.table = new Uint8Array(size * nbChannels);\n      model.tableSize = size;\n      model.tableWithAlpha = withAlpha;\n    }\n\n    var tmpTable = [];\n    publicAPI.getTable(xStart, xEnd, size, tmpTable);\n\n    for (var i = 0; i < size; i++) {\n      model.table[i * nbChannels + 0] = Math.floor(tmpTable[i * 3 + 0] * 255.0 + 0.5);\n      model.table[i * nbChannels + 1] = Math.floor(tmpTable[i * 3 + 1] * 255.0 + 0.5);\n      model.table[i * nbChannels + 2] = Math.floor(tmpTable[i * 3 + 2] * 255.0 + 0.5);\n\n      if (withAlpha) {\n        model.table[i * nbChannels + 3] = 255;\n      }\n    }\n\n    model.buildTime.modified();\n    return model.table;\n  };\n\n  publicAPI.buildFunctionFromArray = function (array) {\n    publicAPI.removeAllPoints();\n    var numComponents = array.getNumberOfComponents();\n\n    for (var i = 0; i < array.getNumberOfTuples(); i++) {\n      switch (numComponents) {\n        case 3:\n          {\n            model.nodes.push({\n              x: i,\n              r: array.getComponent(i, 0),\n              g: array.getComponent(i, 1),\n              b: array.getComponent(i, 2),\n              midpoint: 0.5,\n              sharpness: 0.0\n            });\n            break;\n          }\n\n        case 4:\n          {\n            model.nodes.push({\n              x: array.getComponent(i, 0),\n              r: array.getComponent(i, 1),\n              g: array.getComponent(i, 2),\n              b: array.getComponent(i, 3),\n              midpoint: 0.5,\n              sharpness: 0.0\n            });\n            break;\n          }\n\n        case 5:\n          {\n            model.nodes.push({\n              x: i,\n              r: array.getComponent(i, 0),\n              g: array.getComponent(i, 1),\n              b: array.getComponent(i, 2),\n              midpoint: array.getComponent(i, 4),\n              sharpness: array.getComponent(i, 5)\n            });\n            break;\n          }\n\n        case 6:\n          {\n            model.nodes.push({\n              x: array.getComponent(i, 0),\n              r: array.getComponent(i, 1),\n              g: array.getComponent(i, 2),\n              b: array.getComponent(i, 3),\n              midpoint: array.getComponent(i, 4),\n              sharpness: array.getComponent(i, 5)\n            });\n            break;\n          }\n      }\n    }\n\n    publicAPI.sortAndUpdateRange();\n  }; //----------------------------------------------------------------------------\n\n\n  publicAPI.buildFunctionFromTable = function (xStart, xEnd, size, table) {\n    var inc = 0.0;\n    publicAPI.removeAllPoints();\n\n    if (size > 1) {\n      inc = (xEnd - xStart) / (size - 1.0);\n    }\n\n    for (var i = 0; i < size; i++) {\n      var node = {\n        x: xStart + inc * i,\n        r: table[i * 3],\n        g: table[i * 3 + 1],\n        b: table[i * 3 + 2],\n        sharpness: 0.0,\n        midpoint: 0.5\n      };\n      model.nodes.push(node);\n    }\n\n    publicAPI.sortAndUpdateRange();\n  }; //----------------------------------------------------------------------------\n  // For a specified index value, get the node parameters\n\n\n  publicAPI.getNodeValue = function (index, val) {\n    if (index < 0 || index >= model.nodes.length) {\n      vtkErrorMacro('Index out of range!');\n      return -1;\n    }\n\n    val[0] = model.nodes[index].x;\n    val[1] = model.nodes[index].r;\n    val[2] = model.nodes[index].g;\n    val[3] = model.nodes[index].b;\n    val[4] = model.nodes[index].midpoint;\n    val[5] = model.nodes[index].sharpness;\n    return 1;\n  }; //----------------------------------------------------------------------------\n  // For a specified index value, get the node parameters\n\n\n  publicAPI.setNodeValue = function (index, val) {\n    if (index < 0 || index >= model.nodes.length) {\n      vtkErrorMacro('Index out of range!');\n      return -1;\n    }\n\n    var oldX = model.nodes[index].x;\n    model.nodes[index].x = val[0];\n    model.nodes[index].r = val[1];\n    model.nodes[index].g = val[2];\n    model.nodes[index].b = val[3];\n    model.nodes[index].midpoint = val[4];\n    model.nodes[index].sharpness = val[5];\n\n    if (oldX !== val[0]) {\n      // The point has been moved, the order of points or the range might have\n      // been modified.\n      publicAPI.sortAndUpdateRange(); // No need to call Modified() here because SortAndUpdateRange() has done it\n      // already.\n    } else {\n      publicAPI.modified();\n    }\n\n    return 1;\n  }; //----------------------------------------------------------------------------\n\n\n  publicAPI.getNumberOfAvailableColors = function () {\n    if (model.indexedLookup && publicAPI.getSize()) {\n      return publicAPI.getSize();\n    }\n\n    if (model.tableSize) {\n      // Not sure if this is correct since it is only set if\n      // \"const unsigned char *::GetTable(double xStart, double xEnd,int size)\"\n      // has been called.\n      return model.tableSize;\n    }\n\n    return 16777216; // 2^24\n  }; //----------------------------------------------------------------------------\n\n\n  publicAPI.getIndexedColor = function (idx, rgba) {\n    var n = publicAPI.getSize();\n\n    if (n > 0 && idx >= 0) {\n      var nodeValue = [];\n      publicAPI.getNodeValue(idx % n, nodeValue);\n\n      for (var j = 0; j < 3; ++j) {\n        rgba[j] = nodeValue[j + 1];\n      }\n\n      rgba[3] = 1.0; // NodeColor is RGB-only.\n\n      return;\n    }\n\n    var nanColor = publicAPI.getNanColorByReference();\n    rgba[0] = nanColor[0];\n    rgba[1] = nanColor[1];\n    rgba[2] = nanColor[2];\n    rgba[3] = 1.0; // NanColor is RGB-only.\n  }; //----------------------------------------------------------------------------\n\n\n  publicAPI.fillFromDataPointer = function (nb, ptr) {\n    if (nb <= 0 || !ptr) {\n      return;\n    }\n\n    publicAPI.removeAllPoints();\n\n    for (var i = 0; i < nb; i++) {\n      publicAPI.addRGBPoint(ptr[i * 4], ptr[i * 4 + 1], ptr[i * 4 + 2], ptr[i * 4 + 3]);\n    }\n  }; //----------------------------------------------------------------------------\n\n\n  publicAPI.setMappingRange = function (min, max) {\n    var range = [min, max];\n    var originalRange = publicAPI.getRange();\n\n    if (originalRange[1] === range[1] && originalRange[0] === range[0]) {\n      return;\n    }\n\n    if (range[1] === range[0]) {\n      vtkErrorMacro('attempt to set zero width color range');\n      return;\n    }\n\n    var scale = (range[1] - range[0]) / (originalRange[1] - originalRange[0]);\n    var shift = range[0] - originalRange[0] * scale;\n\n    for (var i = 0; i < model.nodes.length; ++i) {\n      model.nodes[i].x = model.nodes[i].x * scale + shift;\n    }\n\n    model.mappingRange[0] = range[0];\n    model.mappingRange[1] = range[1];\n    publicAPI.modified();\n  }; //----------------------------------------------------------------------------\n\n\n  publicAPI.adjustRange = function (range) {\n    var functionRange = publicAPI.getRange(); // Make sure we have points at each end of the range\n\n    var rgb = [];\n\n    if (functionRange[0] < range[0]) {\n      publicAPI.getColor(range[0], rgb);\n      publicAPI.addRGBPoint(range[0], rgb[0], rgb[1], rgb[2]);\n    } else {\n      publicAPI.getColor(functionRange[0], rgb);\n      publicAPI.addRGBPoint(range[0], rgb[0], rgb[1], rgb[2]);\n    }\n\n    if (functionRange[1] > range[1]) {\n      publicAPI.getColor(range[1], rgb);\n      publicAPI.addRGBPoint(range[1], rgb[0], rgb[1], rgb[2]);\n    } else {\n      publicAPI.getColor(functionRange[1], rgb);\n      publicAPI.addRGBPoint(range[1], rgb[0], rgb[1], rgb[2]);\n    } // Remove all points out-of-range\n\n\n    publicAPI.sortAndUpdateRange();\n\n    for (var i = 0; i < model.nodes.length;) {\n      if (model.nodes[i].x >= range[0] && model.nodes[i].x <= range[1]) {\n        model.nodes.splice(i, 1);\n      } else {\n        ++i;\n      }\n    }\n\n    return 1;\n  }; //--------------------------------------------------------------------------\n\n\n  publicAPI.estimateMinNumberOfSamples = function (x1, x2) {\n    var d = publicAPI.findMinimumXDistance();\n    return Math.ceil((x2 - x1) / d);\n  }; //----------------------------------------------------------------------------\n\n\n  publicAPI.findMinimumXDistance = function () {\n    if (model.nodes.length < 2) {\n      return -1.0;\n    }\n\n    var distance = Number.MAX_VALUE;\n\n    for (var i = 0; i < model.nodes.length - 1; i++) {\n      var currentDist = model.nodes[i + 1].x - model.nodes[i].x;\n\n      if (currentDist < distance) {\n        distance = currentDist;\n      }\n    }\n\n    return distance;\n  };\n\n  publicAPI.mapScalarsThroughTable = function (input, output, outFormat, inputOffset) {\n    if (publicAPI.getSize() === 0) {\n      vtkDebugMacro('Transfer Function Has No Points!');\n      return;\n    }\n\n    if (model.indexedLookup) {\n      publicAPI.mapDataIndexed(input, output, outFormat, inputOffset);\n    } else {\n      publicAPI.mapData(input, output, outFormat, inputOffset);\n    }\n  }; //----------------------------------------------------------------------------\n\n\n  publicAPI.mapData = function (input, output, outFormat, inputOffset) {\n    if (publicAPI.getSize() === 0) {\n      vtkWarningMacro('Transfer Function Has No Points!');\n      return;\n    }\n\n    var alpha = Math.floor(publicAPI.getAlpha() * 255.0 + 0.5);\n    var length = input.getNumberOfTuples();\n    var inIncr = input.getNumberOfComponents();\n    var outputV = output.getData();\n    var inputV = input.getData();\n    var rgb = [];\n\n    if (outFormat === ScalarMappingTarget.RGBA) {\n      for (var i = 0; i < length; i++) {\n        var x = inputV[i * inIncr + inputOffset];\n        publicAPI.getColor(x, rgb);\n        outputV[i * 4] = Math.floor(rgb[0] * 255.0 + 0.5);\n        outputV[i * 4 + 1] = Math.floor(rgb[1] * 255.0 + 0.5);\n        outputV[i * 4 + 2] = Math.floor(rgb[2] * 255.0 + 0.5);\n        outputV[i * 4 + 3] = alpha;\n      }\n    }\n\n    if (outFormat === ScalarMappingTarget.RGB) {\n      for (var _i2 = 0; _i2 < length; _i2++) {\n        var _x = inputV[_i2 * inIncr + inputOffset];\n        publicAPI.getColor(_x, rgb);\n        outputV[_i2 * 3] = Math.floor(rgb[0] * 255.0 + 0.5);\n        outputV[_i2 * 3 + 1] = Math.floor(rgb[1] * 255.0 + 0.5);\n        outputV[_i2 * 3 + 2] = Math.floor(rgb[2] * 255.0 + 0.5);\n      }\n    }\n\n    if (outFormat === ScalarMappingTarget.LUMINANCE) {\n      for (var _i3 = 0; _i3 < length; _i3++) {\n        var _x2 = inputV[_i3 * inIncr + inputOffset];\n        publicAPI.getColor(_x2, rgb);\n        outputV[_i3] = Math.floor(rgb[0] * 76.5 + rgb[1] * 150.45 + rgb[2] * 28.05 + 0.5);\n      }\n    }\n\n    if (outFormat === ScalarMappingTarget.LUMINANCE_ALPHA) {\n      for (var _i4 = 0; _i4 < length; _i4++) {\n        var _x3 = inputV[_i4 * inIncr + inputOffset];\n        publicAPI.getColor(_x3, rgb);\n        outputV[_i4 * 2] = Math.floor(rgb[0] * 76.5 + rgb[1] * 150.45 + rgb[2] * 28.05 + 0.5);\n        outputV[_i4 * 2 + 1] = alpha;\n      }\n    }\n  }; //----------------------------------------------------------------------------\n\n\n  publicAPI.applyColorMap = function (colorMap) {\n    var oldColorSpace = JSON.stringify(model.colorSpace);\n\n    if (colorMap.ColorSpace) {\n      model.colorSpace = ColorSpace[colorMap.ColorSpace.toUpperCase()];\n\n      if (model.colorSpace === undefined) {\n        vtkErrorMacro(\"ColorSpace \".concat(colorMap.ColorSpace, \" not supported, using RGB instead\"));\n        model.colorSpace = ColorSpace.RGB;\n      }\n    }\n\n    var isModified = oldColorSpace !== JSON.stringify(model.colorSpace);\n    var oldNanColor = isModified || JSON.stringify(model.nanColor);\n\n    if (colorMap.NanColor) {\n      model.nanColor = [].concat(colorMap.NanColor);\n\n      while (model.nanColor.length < 4) {\n        model.nanColor.push(1.0);\n      }\n    }\n\n    isModified = isModified || oldNanColor !== JSON.stringify(model.nanColor);\n    var oldNodes = isModified || JSON.stringify(model.nodes);\n\n    if (colorMap.RGBPoints) {\n      var size = colorMap.RGBPoints.length;\n      model.nodes = [];\n      var midpoint = 0.5;\n      var sharpness = 0.0;\n\n      for (var i = 0; i < size; i += 4) {\n        model.nodes.push({\n          x: colorMap.RGBPoints[i],\n          r: colorMap.RGBPoints[i + 1],\n          g: colorMap.RGBPoints[i + 2],\n          b: colorMap.RGBPoints[i + 3],\n          midpoint: midpoint,\n          sharpness: sharpness\n        });\n      }\n    }\n\n    var modifiedInvoked = publicAPI.sortAndUpdateRange();\n    var callModified = !modifiedInvoked && (isModified || oldNodes !== JSON.stringify(model.nodes));\n    if (callModified) publicAPI.modified();\n    return modifiedInvoked || callModified;\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\n\nvar DEFAULT_VALUES = {\n  clamping: true,\n  colorSpace: ColorSpace.RGB,\n  hSVWrap: true,\n  scale: Scale.LINEAR,\n  nanColor: null,\n  belowRangeColor: null,\n  aboveRangeColor: null,\n  useAboveRangeColor: false,\n  useBelowRangeColor: false,\n  allowDuplicateScalars: false,\n  table: null,\n  tableSize: 0,\n  buildTime: null,\n  nodes: null,\n  discretize: false,\n  numberOfValues: 256\n}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Inheritance\n\n  vtkScalarsToColors.extend(publicAPI, model, initialValues); // Internal objects initialization\n\n  model.table = [];\n  model.nodes = [];\n  model.nanColor = [0.5, 0.0, 0.0, 1.0];\n  model.belowRangeColor = [0.0, 0.0, 0.0, 1.0];\n  model.aboveRangeColor = [1.0, 1.0, 1.0, 1.0];\n  model.buildTime = {};\n  macro.obj(model.buildTime); // Create get-only macros\n\n  macro.get(publicAPI, model, ['buildTime', 'mappingRange']); // Create get-set macros\n\n  macro.setGet(publicAPI, model, ['useAboveRangeColor', 'useBelowRangeColor', 'colorSpace', 'discretize', 'numberOfValues']);\n  macro.setArray(publicAPI, model, ['nanColor', 'belowRangeColor', 'aboveRangeColor'], 4); // Create get macros for array\n\n  macro.getArray(publicAPI, model, ['nanColor', 'belowRangeColor', 'aboveRangeColor']); // For more macro methods, see \"Sources/macros.js\"\n  // Object specific methods\n\n  vtkColorTransferFunction(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = macro.newInstance(extend, 'vtkColorTransferFunction'); // ----------------------------------------------------------------------------\n\nvar vtkColorTransferFunction$1 = _objectSpread({\n  newInstance: newInstance,\n  extend: extend\n}, Constants);\n\nexport { vtkColorTransferFunction$1 as default, extend, newInstance };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}