{"ast":null,"code":"import _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport macro from '../../macros.js';\nimport vtkActor from '../../Rendering/Core/Actor.js';\nimport vtkArrow2DSource from '../../Filters/Sources/Arrow2DSource.js';\nimport vtkGlyphRepresentation from './GlyphRepresentation.js';\nimport vtkMatrixBuilder from '../../Common/Core/MatrixBuilder.js';\nimport vtkPixelSpaceCallbackMapper from '../../Rendering/Core/PixelSpaceCallbackMapper.js';\nimport vtkConeSource from '../../Filters/Sources/ConeSource.js';\nimport vtkSphereSource from '../../Filters/Sources/SphereSource.js';\nimport vtkCircleSource from '../../Filters/Sources/CircleSource.js';\nimport vtkCubeSource from '../../Filters/Sources/CubeSource.js';\nimport vtkViewFinderSource from '../../Filters/Sources/ViewFinderSource.js';\nimport Constants from '../Widgets3D/LineWidget/Constants.js';\nimport { mat4, mat3, vec3 } from 'gl-matrix';\nimport { RenderingTypes } from '../Core/WidgetManager/Constants.js';\nimport { OrientationModes } from '../../Rendering/Core/Glyph3DMapper/Constants.js';\nimport { allocateArray } from './WidgetRepresentation.js';\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n  return target;\n}\nvar ShapeType = Constants.ShapeType,\n  Shapes2D = Constants.Shapes2D,\n  ShapesOrientable = Constants.ShapesOrientable; // ----------------------------------------------------------------------------\n// vtkArrowHandleRepresentation methods\n// ----------------------------------------------------------------------------\n\nfunction vtkArrowHandleRepresentation(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkArrowHandleRepresentation');\n  var superClass = _objectSpread({}, publicAPI); // --------------------------------------------------------------------------\n  // Internal polydata dataset\n  // --------------------------------------------------------------------------\n\n  /**\n   * Set the shape for the glyph according to lineWidget state inputs\n   */\n\n  function createGlyph(shape) {\n    var _representationToSour;\n    var representationToSource = (_representationToSour = {}, _defineProperty(_representationToSour, ShapeType.STAR, {\n      builder: vtkArrow2DSource,\n      initialValues: {\n        shape: 'star',\n        height: 0.6\n      }\n    }), _defineProperty(_representationToSour, ShapeType.ARROWHEAD3, {\n      builder: vtkArrow2DSource,\n      initialValues: {\n        shape: 'triangle'\n      }\n    }), _defineProperty(_representationToSour, ShapeType.ARROWHEAD4, {\n      builder: vtkArrow2DSource,\n      initialValues: {\n        shape: 'arrow4points'\n      }\n    }), _defineProperty(_representationToSour, ShapeType.ARROWHEAD6, {\n      builder: vtkArrow2DSource,\n      initialValues: {\n        shape: 'arrow6points'\n      }\n    }), _defineProperty(_representationToSour, ShapeType.CONE, {\n      builder: vtkConeSource,\n      initialValues: {\n        direction: [0, 1, 0]\n      }\n    }), _defineProperty(_representationToSour, ShapeType.SPHERE, {\n      builder: vtkSphereSource\n    }), _defineProperty(_representationToSour, ShapeType.CUBE, {\n      builder: vtkCubeSource,\n      initialValues: {\n        xLength: 0.8,\n        yLength: 0.8,\n        zLength: 0.8\n      }\n    }), _defineProperty(_representationToSour, ShapeType.DISK, {\n      builder: vtkCircleSource,\n      initialValues: {\n        resolution: 30,\n        radius: 0.5,\n        direction: [0, 0, 1],\n        lines: false,\n        face: true\n      }\n    }), _defineProperty(_representationToSour, ShapeType.CIRCLE, {\n      builder: vtkCircleSource,\n      initialValues: {\n        resolution: 30,\n        radius: 0.5,\n        direction: [0, 0, 1],\n        lines: true,\n        face: false\n      }\n    }), _defineProperty(_representationToSour, ShapeType.VIEWFINDER, {\n      builder: vtkViewFinderSource,\n      initialValues: {\n        radius: 0.1,\n        spacing: 0.3,\n        width: 1.4\n      }\n    }), _defineProperty(_representationToSour, ShapeType.NONE, {\n      builder: vtkSphereSource\n    }), _representationToSour);\n    var rep = representationToSource[shape];\n    return rep.builder.newInstance(rep.initialValues);\n  } // --------------------------------------------------------------------------\n  // Generic rendering pipeline\n  // --------------------------------------------------------------------------\n  // displayActors and displayMappers are used to render objects in HTML,\n  // allowing objects to be 'rendered' internally in a VTK scene without\n  // being visible on the final output.\n\n  model.displayMapper = vtkPixelSpaceCallbackMapper.newInstance();\n  model.displayActor = vtkActor.newInstance({\n    parentProp: publicAPI\n  }); // model.displayActor.getProperty().setOpacity(0); // don't show in 3D\n\n  model.displayActor.setMapper(model.displayMapper);\n  model.displayMapper.setInputConnection(publicAPI.getOutputPort());\n  publicAPI.addActor(model.displayActor);\n  model.alwaysVisibleActors = [model.displayActor]; // --------------------------------------------------------------------------\n\n  publicAPI.setGlyphResolution = macro.chain(publicAPI.setGlyphResolution, function (r) {\n    return model._pipeline.glyph.setPhiResolution(r);\n  }, function (r) {\n    return model._pipeline.glyph.setThetaResolution(r);\n  }); // --------------------------------------------------------------------------\n\n  function callbackProxy(coords) {\n    if (model.displayCallback) {\n      var filteredList = [];\n      var states = publicAPI.getRepresentationStates();\n      for (var i = 0; i < states.length; i++) {\n        if (states[i].getActive()) {\n          filteredList.push(coords[i]);\n        }\n      }\n      if (filteredList.length) {\n        model.displayCallback(filteredList);\n        return;\n      }\n    }\n    model.displayCallback();\n  }\n  publicAPI.setDisplayCallback = function (callback) {\n    model.displayCallback = callback;\n    model.displayMapper.setCallback(callback ? callbackProxy : null);\n  }; // --------------------------------------------------------------------------\n\n  publicAPI.is2DShape = function () {\n    return Shapes2D.includes(model.shape);\n  };\n  publicAPI.isOrientableShape = function () {\n    return ShapesOrientable.includes(model.shape);\n  };\n  /**\n   * Returns the orientation matrix to align glyph on model.orientation.\n   * */\n\n  function getOrientationRotation(viewMatrixInv) {\n    var displayOrientation = new Float64Array(3);\n    var baseDir = [0, 1, 0];\n    vec3.transformMat3(displayOrientation, model.orientation, viewMatrixInv);\n    displayOrientation[2] = 0;\n    var displayMatrix = vtkMatrixBuilder.buildFromDegree().rotateFromDirections(baseDir, displayOrientation).getMatrix();\n    var displayRotation = new Float64Array(9);\n    mat3.fromMat4(displayRotation, displayMatrix);\n    return displayRotation;\n  }\n  function getCameraFacingRotation(scale3, displayRotation, viewMatrix) {\n    var rotation = new Float64Array(9);\n    mat3.multiply(rotation, viewMatrix, displayRotation);\n    vec3.transformMat3(scale3, scale3, rotation);\n    return rotation;\n  }\n  /**\n   * Computes the rotation matrix of the glyph. There are 2 rotations:\n   *  - a first rotation to be oriented along model.rotation\n   *  - an optional second rotation to face the camera\n   * @param {vec3} scale3 Scale of the glyph, rotated when glyph is rotated.\n   */\n\n  function getGlyphRotation(scale3) {\n    var shouldFaceCamera = model.faceCamera === true || model.faceCamera == null && publicAPI.is2DShape();\n    var viewMatrix = new Float64Array(9);\n    mat3.fromMat4(viewMatrix, model.viewMatrix);\n    var viewMatrixInv = mat3.identity(new Float64Array(9));\n    if (shouldFaceCamera) {\n      mat3.invert(viewMatrixInv, viewMatrix);\n    }\n    var orientationRotation = null;\n    if (publicAPI.isOrientableShape()) {\n      orientationRotation = getOrientationRotation(viewMatrixInv);\n    } else {\n      orientationRotation = mat3.identity(new Float64Array(9));\n    }\n    if (shouldFaceCamera) {\n      orientationRotation = getCameraFacingRotation(scale3, orientationRotation, viewMatrix);\n    }\n    return orientationRotation;\n  }\n  function applyOrientation(polyData, states) {\n    model._pipeline.mapper.setOrientationArray('orientation');\n    model._pipeline.mapper.setOrientationMode(OrientationModes.MATRIX);\n    var orientation = allocateArray(polyData, 'orientation', states.length, 'Float32Array', 9).getData();\n    var defaultScale3 = [1, 1, 1];\n    for (var i = 0; i < states.length; ++i) {\n      var _states$i$getScale, _states$i$getScale2, _states$i;\n      var scale3 = (_states$i$getScale = (_states$i$getScale2 = (_states$i = states[i]).getScale3) === null || _states$i$getScale2 === void 0 ? void 0 : _states$i$getScale2.call(_states$i)) !== null && _states$i$getScale !== void 0 ? _states$i$getScale : defaultScale3;\n      var rotation = getGlyphRotation(scale3);\n      orientation.set(rotation, 9 * i);\n    }\n  }\n  publicAPI.setDirection(applyOrientation);\n  publicAPI.setNoOrientation(applyOrientation);\n  publicAPI.requestData = function (inData, outData) {\n    var _publicAPI$getReprese;\n\n    // FIXME: shape should NOT be mixin, but a representation property.\n    var shape = (_publicAPI$getReprese = publicAPI.getRepresentationStates(inData[0])[0]) === null || _publicAPI$getReprese === void 0 ? void 0 : _publicAPI$getReprese.getShape();\n    var shouldCreateGlyph = model._pipeline.glyph == null;\n    if (model.shape !== shape && Object.values(ShapeType).includes(shape)) {\n      model.shape = shape;\n      shouldCreateGlyph = true;\n    }\n    if (shouldCreateGlyph && model.shape) {\n      model._pipeline.glyph = createGlyph(model.shape);\n      model._pipeline.mapper.setInputConnection(model._pipeline.glyph.getOutputPort(), 1);\n    }\n    return superClass.requestData(inData, outData);\n  };\n  publicAPI.updateActorVisibility = function () {\n    var renderingType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : RenderingTypes.FRONT_BUFFER;\n    var ctxVisible = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    var handleVisible = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    var hasValidState = publicAPI.getRepresentationStates().length > 0;\n    superClass.updateActorVisibility(renderingType, ctxVisible, handleVisible && hasValidState);\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\n/**\n *  'shape' default value is used first time 'shape' mixin is invalid.\n *  'faceCamera' controls wether the glyph should face camera or not:\n *    - null or undefined to leave it to shape type (i.e. 2D are facing camera,\n *    3D are not)\n *    - true to face camera\n *    - false to not face camera\n */\n\nfunction defaultValues(initialValues) {\n  return _objectSpread({\n    faceCamera: null,\n    orientation: [1, 0, 0],\n    shape: ShapeType.SPHERE,\n    viewMatrix: mat4.identity(new Float64Array(16))\n  }, initialValues);\n} // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, defaultValues(initialValues));\n  vtkGlyphRepresentation.extend(publicAPI, model, initialValues);\n  macro.setGetArray(publicAPI, model, ['visibilityFlagArray'], 2);\n  macro.setGetArray(publicAPI, model, ['orientation'], 3);\n  macro.setGetArray(publicAPI, model, ['viewMatrix'], 16);\n  macro.setGet(publicAPI, model, ['faceCamera']); // Object specific methods\n\n  vtkArrowHandleRepresentation(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = macro.newInstance(extend, 'vtkArrowHandleRepresentation'); // ----------------------------------------------------------------------------\n\nvar vtkArrowHandleRepresentation$1 = {\n  newInstance: newInstance,\n  extend: extend\n};\nexport { vtkArrowHandleRepresentation$1 as default, extend, newInstance };","map":{"version":3,"names":["_defineProperty","macro","vtkActor","vtkArrow2DSource","vtkGlyphRepresentation","vtkMatrixBuilder","vtkPixelSpaceCallbackMapper","vtkConeSource","vtkSphereSource","vtkCircleSource","vtkCubeSource","vtkViewFinderSource","Constants","mat4","mat3","vec3","RenderingTypes","OrientationModes","allocateArray","ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","getOwnPropertyDescriptors","defineProperties","defineProperty","ShapeType","Shapes2D","ShapesOrientable","vtkArrowHandleRepresentation","publicAPI","model","classHierarchy","superClass","createGlyph","shape","_representationToSour","representationToSource","STAR","builder","initialValues","height","ARROWHEAD3","ARROWHEAD4","ARROWHEAD6","CONE","direction","SPHERE","CUBE","xLength","yLength","zLength","DISK","resolution","radius","lines","face","CIRCLE","VIEWFINDER","spacing","width","NONE","rep","newInstance","displayMapper","displayActor","parentProp","setMapper","setInputConnection","getOutputPort","addActor","alwaysVisibleActors","setGlyphResolution","chain","r","_pipeline","glyph","setPhiResolution","setThetaResolution","callbackProxy","coords","displayCallback","filteredList","states","getRepresentationStates","getActive","setDisplayCallback","callback","setCallback","is2DShape","includes","isOrientableShape","getOrientationRotation","viewMatrixInv","displayOrientation","Float64Array","baseDir","transformMat3","orientation","displayMatrix","buildFromDegree","rotateFromDirections","getMatrix","displayRotation","fromMat4","getCameraFacingRotation","scale3","viewMatrix","rotation","multiply","getGlyphRotation","shouldFaceCamera","faceCamera","identity","invert","orientationRotation","applyOrientation","polyData","mapper","setOrientationArray","setOrientationMode","MATRIX","getData","defaultScale3","_states$i$getScale","_states$i$getScale2","_states$i","getScale3","call","set","setDirection","setNoOrientation","requestData","inData","outData","_publicAPI$getReprese","getShape","shouldCreateGlyph","values","updateActorVisibility","renderingType","undefined","FRONT_BUFFER","ctxVisible","handleVisible","hasValidState","defaultValues","extend","assign","setGetArray","setGet","vtkArrowHandleRepresentation$1","default"],"sources":["/home/rakshith/Documents/RemoteRendering/vtk-js-react-app/node_modules/@kitware/vtk.js/Widgets/Representations/ArrowHandleRepresentation.js"],"sourcesContent":["import _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport macro from '../../macros.js';\nimport vtkActor from '../../Rendering/Core/Actor.js';\nimport vtkArrow2DSource from '../../Filters/Sources/Arrow2DSource.js';\nimport vtkGlyphRepresentation from './GlyphRepresentation.js';\nimport vtkMatrixBuilder from '../../Common/Core/MatrixBuilder.js';\nimport vtkPixelSpaceCallbackMapper from '../../Rendering/Core/PixelSpaceCallbackMapper.js';\nimport vtkConeSource from '../../Filters/Sources/ConeSource.js';\nimport vtkSphereSource from '../../Filters/Sources/SphereSource.js';\nimport vtkCircleSource from '../../Filters/Sources/CircleSource.js';\nimport vtkCubeSource from '../../Filters/Sources/CubeSource.js';\nimport vtkViewFinderSource from '../../Filters/Sources/ViewFinderSource.js';\nimport Constants from '../Widgets3D/LineWidget/Constants.js';\nimport { mat4, mat3, vec3 } from 'gl-matrix';\nimport { RenderingTypes } from '../Core/WidgetManager/Constants.js';\nimport { OrientationModes } from '../../Rendering/Core/Glyph3DMapper/Constants.js';\nimport { allocateArray } from './WidgetRepresentation.js';\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nvar ShapeType = Constants.ShapeType,\n    Shapes2D = Constants.Shapes2D,\n    ShapesOrientable = Constants.ShapesOrientable; // ----------------------------------------------------------------------------\n// vtkArrowHandleRepresentation methods\n// ----------------------------------------------------------------------------\n\nfunction vtkArrowHandleRepresentation(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkArrowHandleRepresentation');\n\n  var superClass = _objectSpread({}, publicAPI); // --------------------------------------------------------------------------\n  // Internal polydata dataset\n  // --------------------------------------------------------------------------\n\n  /**\n   * Set the shape for the glyph according to lineWidget state inputs\n   */\n\n\n  function createGlyph(shape) {\n    var _representationToSour;\n\n    var representationToSource = (_representationToSour = {}, _defineProperty(_representationToSour, ShapeType.STAR, {\n      builder: vtkArrow2DSource,\n      initialValues: {\n        shape: 'star',\n        height: 0.6\n      }\n    }), _defineProperty(_representationToSour, ShapeType.ARROWHEAD3, {\n      builder: vtkArrow2DSource,\n      initialValues: {\n        shape: 'triangle'\n      }\n    }), _defineProperty(_representationToSour, ShapeType.ARROWHEAD4, {\n      builder: vtkArrow2DSource,\n      initialValues: {\n        shape: 'arrow4points'\n      }\n    }), _defineProperty(_representationToSour, ShapeType.ARROWHEAD6, {\n      builder: vtkArrow2DSource,\n      initialValues: {\n        shape: 'arrow6points'\n      }\n    }), _defineProperty(_representationToSour, ShapeType.CONE, {\n      builder: vtkConeSource,\n      initialValues: {\n        direction: [0, 1, 0]\n      }\n    }), _defineProperty(_representationToSour, ShapeType.SPHERE, {\n      builder: vtkSphereSource\n    }), _defineProperty(_representationToSour, ShapeType.CUBE, {\n      builder: vtkCubeSource,\n      initialValues: {\n        xLength: 0.8,\n        yLength: 0.8,\n        zLength: 0.8\n      }\n    }), _defineProperty(_representationToSour, ShapeType.DISK, {\n      builder: vtkCircleSource,\n      initialValues: {\n        resolution: 30,\n        radius: 0.5,\n        direction: [0, 0, 1],\n        lines: false,\n        face: true\n      }\n    }), _defineProperty(_representationToSour, ShapeType.CIRCLE, {\n      builder: vtkCircleSource,\n      initialValues: {\n        resolution: 30,\n        radius: 0.5,\n        direction: [0, 0, 1],\n        lines: true,\n        face: false\n      }\n    }), _defineProperty(_representationToSour, ShapeType.VIEWFINDER, {\n      builder: vtkViewFinderSource,\n      initialValues: {\n        radius: 0.1,\n        spacing: 0.3,\n        width: 1.4\n      }\n    }), _defineProperty(_representationToSour, ShapeType.NONE, {\n      builder: vtkSphereSource\n    }), _representationToSour);\n    var rep = representationToSource[shape];\n    return rep.builder.newInstance(rep.initialValues);\n  } // --------------------------------------------------------------------------\n  // Generic rendering pipeline\n  // --------------------------------------------------------------------------\n  // displayActors and displayMappers are used to render objects in HTML,\n  // allowing objects to be 'rendered' internally in a VTK scene without\n  // being visible on the final output.\n\n\n  model.displayMapper = vtkPixelSpaceCallbackMapper.newInstance();\n  model.displayActor = vtkActor.newInstance({\n    parentProp: publicAPI\n  }); // model.displayActor.getProperty().setOpacity(0); // don't show in 3D\n\n  model.displayActor.setMapper(model.displayMapper);\n  model.displayMapper.setInputConnection(publicAPI.getOutputPort());\n  publicAPI.addActor(model.displayActor);\n  model.alwaysVisibleActors = [model.displayActor]; // --------------------------------------------------------------------------\n\n  publicAPI.setGlyphResolution = macro.chain(publicAPI.setGlyphResolution, function (r) {\n    return model._pipeline.glyph.setPhiResolution(r);\n  }, function (r) {\n    return model._pipeline.glyph.setThetaResolution(r);\n  }); // --------------------------------------------------------------------------\n\n  function callbackProxy(coords) {\n    if (model.displayCallback) {\n      var filteredList = [];\n      var states = publicAPI.getRepresentationStates();\n\n      for (var i = 0; i < states.length; i++) {\n        if (states[i].getActive()) {\n          filteredList.push(coords[i]);\n        }\n      }\n\n      if (filteredList.length) {\n        model.displayCallback(filteredList);\n        return;\n      }\n    }\n\n    model.displayCallback();\n  }\n\n  publicAPI.setDisplayCallback = function (callback) {\n    model.displayCallback = callback;\n    model.displayMapper.setCallback(callback ? callbackProxy : null);\n  }; // --------------------------------------------------------------------------\n\n\n  publicAPI.is2DShape = function () {\n    return Shapes2D.includes(model.shape);\n  };\n\n  publicAPI.isOrientableShape = function () {\n    return ShapesOrientable.includes(model.shape);\n  };\n  /**\n   * Returns the orientation matrix to align glyph on model.orientation.\n   * */\n\n\n  function getOrientationRotation(viewMatrixInv) {\n    var displayOrientation = new Float64Array(3);\n    var baseDir = [0, 1, 0];\n    vec3.transformMat3(displayOrientation, model.orientation, viewMatrixInv);\n    displayOrientation[2] = 0;\n    var displayMatrix = vtkMatrixBuilder.buildFromDegree().rotateFromDirections(baseDir, displayOrientation).getMatrix();\n    var displayRotation = new Float64Array(9);\n    mat3.fromMat4(displayRotation, displayMatrix);\n    return displayRotation;\n  }\n\n  function getCameraFacingRotation(scale3, displayRotation, viewMatrix) {\n    var rotation = new Float64Array(9);\n    mat3.multiply(rotation, viewMatrix, displayRotation);\n    vec3.transformMat3(scale3, scale3, rotation);\n    return rotation;\n  }\n  /**\n   * Computes the rotation matrix of the glyph. There are 2 rotations:\n   *  - a first rotation to be oriented along model.rotation\n   *  - an optional second rotation to face the camera\n   * @param {vec3} scale3 Scale of the glyph, rotated when glyph is rotated.\n   */\n\n\n  function getGlyphRotation(scale3) {\n    var shouldFaceCamera = model.faceCamera === true || model.faceCamera == null && publicAPI.is2DShape();\n    var viewMatrix = new Float64Array(9);\n    mat3.fromMat4(viewMatrix, model.viewMatrix);\n    var viewMatrixInv = mat3.identity(new Float64Array(9));\n\n    if (shouldFaceCamera) {\n      mat3.invert(viewMatrixInv, viewMatrix);\n    }\n\n    var orientationRotation = null;\n\n    if (publicAPI.isOrientableShape()) {\n      orientationRotation = getOrientationRotation(viewMatrixInv);\n    } else {\n      orientationRotation = mat3.identity(new Float64Array(9));\n    }\n\n    if (shouldFaceCamera) {\n      orientationRotation = getCameraFacingRotation(scale3, orientationRotation, viewMatrix);\n    }\n\n    return orientationRotation;\n  }\n\n  function applyOrientation(polyData, states) {\n    model._pipeline.mapper.setOrientationArray('orientation');\n\n    model._pipeline.mapper.setOrientationMode(OrientationModes.MATRIX);\n\n    var orientation = allocateArray(polyData, 'orientation', states.length, 'Float32Array', 9).getData();\n    var defaultScale3 = [1, 1, 1];\n\n    for (var i = 0; i < states.length; ++i) {\n      var _states$i$getScale, _states$i$getScale2, _states$i;\n\n      var scale3 = (_states$i$getScale = (_states$i$getScale2 = (_states$i = states[i]).getScale3) === null || _states$i$getScale2 === void 0 ? void 0 : _states$i$getScale2.call(_states$i)) !== null && _states$i$getScale !== void 0 ? _states$i$getScale : defaultScale3;\n      var rotation = getGlyphRotation(scale3);\n      orientation.set(rotation, 9 * i);\n    }\n  }\n\n  publicAPI.setDirection(applyOrientation);\n  publicAPI.setNoOrientation(applyOrientation);\n\n  publicAPI.requestData = function (inData, outData) {\n    var _publicAPI$getReprese;\n\n    // FIXME: shape should NOT be mixin, but a representation property.\n    var shape = (_publicAPI$getReprese = publicAPI.getRepresentationStates(inData[0])[0]) === null || _publicAPI$getReprese === void 0 ? void 0 : _publicAPI$getReprese.getShape();\n    var shouldCreateGlyph = model._pipeline.glyph == null;\n\n    if (model.shape !== shape && Object.values(ShapeType).includes(shape)) {\n      model.shape = shape;\n      shouldCreateGlyph = true;\n    }\n\n    if (shouldCreateGlyph && model.shape) {\n      model._pipeline.glyph = createGlyph(model.shape);\n\n      model._pipeline.mapper.setInputConnection(model._pipeline.glyph.getOutputPort(), 1);\n    }\n\n    return superClass.requestData(inData, outData);\n  };\n\n  publicAPI.updateActorVisibility = function () {\n    var renderingType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : RenderingTypes.FRONT_BUFFER;\n    var ctxVisible = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    var handleVisible = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    var hasValidState = publicAPI.getRepresentationStates().length > 0;\n    superClass.updateActorVisibility(renderingType, ctxVisible, handleVisible && hasValidState);\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\n/**\n *  'shape' default value is used first time 'shape' mixin is invalid.\n *  'faceCamera' controls wether the glyph should face camera or not:\n *    - null or undefined to leave it to shape type (i.e. 2D are facing camera,\n *    3D are not)\n *    - true to face camera\n *    - false to not face camera\n */\n\n\nfunction defaultValues(initialValues) {\n  return _objectSpread({\n    faceCamera: null,\n    orientation: [1, 0, 0],\n    shape: ShapeType.SPHERE,\n    viewMatrix: mat4.identity(new Float64Array(16))\n  }, initialValues);\n} // ----------------------------------------------------------------------------\n\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, defaultValues(initialValues));\n  vtkGlyphRepresentation.extend(publicAPI, model, initialValues);\n  macro.setGetArray(publicAPI, model, ['visibilityFlagArray'], 2);\n  macro.setGetArray(publicAPI, model, ['orientation'], 3);\n  macro.setGetArray(publicAPI, model, ['viewMatrix'], 16);\n  macro.setGet(publicAPI, model, ['faceCamera']); // Object specific methods\n\n  vtkArrowHandleRepresentation(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = macro.newInstance(extend, 'vtkArrowHandleRepresentation'); // ----------------------------------------------------------------------------\n\nvar vtkArrowHandleRepresentation$1 = {\n  newInstance: newInstance,\n  extend: extend\n};\n\nexport { vtkArrowHandleRepresentation$1 as default, extend, newInstance };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}