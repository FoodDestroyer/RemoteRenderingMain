{"ast":null,"code":"import { newInstance as newInstance$1, vtkErrorMacro as vtkErrorMacro$1 } from '../../macros.js';\nimport vtkWebGPUCellArrayMapper from './CellArrayMapper.js';\nimport vtkWebGPUBufferManager from './BufferManager.js';\nimport vtkWebGPUShaderCache from './ShaderCache.js';\nimport { registerOverride } from './ViewNodeFactory.js';\nvar BufferUsage = vtkWebGPUBufferManager.BufferUsage;\nvar vtkErrorMacro = vtkErrorMacro$1; // Vertices\n// 013 - 032 - 324 - 453\n//\n//       _.4---_.5\n//    .-*   .-*\n//   2-----3\n//   |    /|\n//   |   / |\n//   |  /  |\n//   | /   |\n//   |/    |\n//   0-----1\n//\n// coord for each points\n// 0: 000\n// 1: 100\n// 2: 001\n// 3: 101\n// 4: 011\n// 5: 111\n\nvar vtkWebGPUStickMapperVS = \"\\n//VTK::Renderer::Dec\\n\\n//VTK::Mapper::Dec\\n\\n//VTK::Color::Dec\\n\\n//VTK::IOStructs::Dec\\n\\n@vertex\\nfn main(\\n//VTK::IOStructs::Input\\n)\\n//VTK::IOStructs::Output\\n{\\n  var offsetsArray: array<vec3<f32>, 12> = array<vec3<f32>, 12>(\\n    vec3<f32>(-1.0, -1.0, -1.0),\\n    vec3<f32>(1.0, -1.0, -1.0),\\n    vec3<f32>(1.0, -1.0, 1.0),\\n\\n    vec3<f32>(-1.0, -1.0, -1.0),\\n    vec3<f32>(1.0, -1.0, 1.0),\\n    vec3<f32>(-1.0, -1.0, 1.0),\\n\\n    vec3<f32>(-1.0, -1.0, 1.0),\\n    vec3<f32>(1.0, -1.0, 1.0),\\n    vec3<f32>(1.0, 1.0, 1.0),\\n\\n    vec3<f32>(-1.0, -1.0, 1.0),\\n    vec3<f32>(1.0, 1.0, 1.0),\\n    vec3<f32>(-1.0, 1.0, 1.0)\\n  );\\n\\n  var output : vertexOutput;\\n\\n  var vertexVC: vec4<f32> = rendererUBO.SCVCMatrix * mapperUBO.BCSCMatrix * vec4<f32>(vertexBC.xyz, 1.0);\\n\\n  //VTK::Color::Impl\\n\\n  // compute the projected vertex position\\n  output.centerVC = vertexVC.xyz;\\n  output.radiusVC = radiusMC;\\n  output.lengthVC = length(orientMC);\\n  output.orientVC = (rendererUBO.WCVCNormals * vec4<f32>(normalize(orientMC), 0.0)).xyz;\\n\\n  // make sure it is pointing out of the screen\\n  if (output.orientVC.z < 0.0)\\n    {\\n    output.orientVC = -output.orientVC;\\n    }\\n\\n  // make the basis\\n  var xbase: vec3<f32>;\\n  var ybase: vec3<f32>;\\n  var dir: vec3<f32> = vec3<f32>(0.0,0.0,1.0);\\n  if (rendererUBO.cameraParallel == 0u)\\n    {\\n    dir = normalize(-vertexVC.xyz);\\n    }\\n  if (abs(dot(dir,output.orientVC)) == 1.0)\\n    {\\n    xbase = normalize(cross(vec3<f32>(0.0,1.0,0.0),output.orientVC));\\n    ybase = cross(xbase,output.orientVC);\\n    }\\n  else\\n    {\\n    xbase = normalize(cross(output.orientVC,dir));\\n    ybase = cross(output.orientVC,xbase);\\n    }\\n\\n\\n  var vertIdx: u32 = input.vertexIndex % 12u;\\n  var offsets: vec3<f32> = offsetsArray[vertIdx];\\n\\n  vertexVC = vec4<f32>(vertexVC.xyz +\\n    output.radiusVC * offsets.x * xbase +\\n    output.radiusVC * offsets.y * ybase +\\n    0.5 * output.lengthVC * offsets.z * output.orientVC, 1.0);\\n\\n  output.vertexVC = vertexVC;\\n\\n  //VTK::Position::Impl\\n\\n  return output;\\n}\\n\"; // ----------------------------------------------------------------------------\n// vtkWebGPUStickMapper methods\n// ----------------------------------------------------------------------------\n\nfunction vtkWebGPUStickMapper(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkWebGPUStickMapper');\n  var cellMapperBuildPass = publicAPI.buildPass;\n  publicAPI.buildPass = function (prepass) {\n    if (prepass) {\n      if (!model.renderable.getStatic()) {\n        model.renderable.update();\n      }\n      var poly = model.renderable.getInputData();\n      publicAPI.setCellArray(poly.getVerts());\n      publicAPI.setCurrentInput(poly);\n    }\n    cellMapperBuildPass(prepass);\n  };\n  publicAPI.replaceShaderNormal = function (hash, pipeline, vertexInput) {\n    var vDesc = pipeline.getShaderDescription('vertex');\n    if (!vDesc.hasOutput('vertexVC')) vDesc.addOutput('vec4<f32>', 'vertexVC');\n    vDesc.addOutput('vec3<f32>', 'centerVC');\n    vDesc.addOutput('vec3<f32>', 'orientVC');\n    vDesc.addOutput('f32', 'radiusVC');\n    vDesc.addOutput('f32', 'lengthVC');\n    vDesc.addBuiltinInput('u32', '@builtin(vertex_index) vertexIndex');\n    var fDesc = pipeline.getShaderDescription('fragment');\n    fDesc.addBuiltinOutput('f32', '@builtin(frag_depth) fragDepth');\n    var stickFrag = \"\\n    // compute the eye position and unit direction\\n    var vertexVC: vec4<f32>;\\n    var EyePos: vec3<f32>;\\n    var EyeDir: vec3<f32>;\\n\\n    if (rendererUBO.cameraParallel != 0u)\\n    {\\n      EyePos = vec3<f32>(input.vertexVC.x, input.vertexVC.y, input.vertexVC.z + 3.0*input.radiusVC);\\n      EyeDir = vec3<f32>(0.0, 0.0, -1.0);\\n    }\\n    else\\n    {\\n      EyeDir = input.vertexVC.xyz;\\n      EyePos = vec3<f32>(0.0,0.0,0.0);\\n      var lengthED: f32 = length(EyeDir);\\n      EyeDir = normalize(EyeDir);\\n      // we adjust the EyePos to be closer if it is too far away\\n      // to prevent floating point precision noise\\n      if (lengthED > input.radiusVC*3.0)\\n      {\\n        EyePos = input.vertexVC.xyz - EyeDir*3.0*input.radiusVC;\\n      }\\n    }\\n    // translate to Sphere center\\n    EyePos = EyePos - input.centerVC;\\n\\n    // rotate to new basis\\n    // base1, base2, orientVC\\n    var base1: vec3<f32>;\\n    if (abs(input.orientVC.z) < 0.99)\\n    {\\n      base1 = normalize(cross(input.orientVC,vec3<f32>(0.0,0.0,1.0)));\\n    }\\n    else\\n    {\\n      base1 = normalize(cross(input.orientVC,vec3<f32>(0.0,1.0,0.0)));\\n    }\\n    var base2: vec3<f32> = cross(input.orientVC,base1);\\n    EyePos = vec3<f32>(dot(EyePos,base1),dot(EyePos,base2),dot(EyePos,input.orientVC));\\n    EyeDir = vec3<f32>(dot(EyeDir,base1),dot(EyeDir,base2),dot(EyeDir,input.orientVC));\\n\\n    // scale to radius 1.0\\n    EyePos = EyePos * (1.0 / input.radiusVC);\\n\\n    // find the intersection\\n    var a: f32 = EyeDir.x*EyeDir.x + EyeDir.y*EyeDir.y;\\n    var b: f32 = 2.0*(EyePos.x*EyeDir.x + EyePos.y*EyeDir.y);\\n    var c: f32 = EyePos.x*EyePos.x + EyePos.y*EyePos.y - 1.0;\\n    var d: f32 = b*b - 4.0*a*c;\\n    var normal: vec3<f32> = vec3<f32>(0.0,0.0,1.0);\\n    if (d < 0.0) { discard; }\\n    else\\n    {\\n      var t: f32 = (-b - sqrt(d))*(0.5 / a);\\n      var tz: f32 = EyePos.z + t*EyeDir.z;\\n      var iPoint: vec3<f32> = EyePos + t*EyeDir;\\n      if (abs(iPoint.z)*input.radiusVC > input.lengthVC*0.5)\\n      {\\n        // test for end cap\\n        var t2: f32 = (-b + sqrt(d))*(0.5 / a);\\n        var tz2: f32 = EyePos.z + t2*EyeDir.z;\\n        if (tz2*input.radiusVC > input.lengthVC*0.5 || tz*input.radiusVC < -0.5*input.lengthVC) { discard; }\\n        else\\n        {\\n          normal = input.orientVC;\\n          var t3: f32 = (input.lengthVC*0.5/input.radiusVC - EyePos.z)/EyeDir.z;\\n          iPoint = EyePos + t3*EyeDir;\\n          vertexVC = vec4<f32>(input.radiusVC*(iPoint.x*base1 + iPoint.y*base2 + iPoint.z*input.orientVC) + input.centerVC, 1.0);\\n        }\\n      }\\n      else\\n      {\\n        // The normal is the iPoint.xy rotated back into VC\\n        normal = iPoint.x*base1 + iPoint.y*base2;\\n        // rescale rerotate and translate\\n        vertexVC = vec4<f32>(input.radiusVC*(normal + iPoint.z*input.orientVC) + input.centerVC, 1.0);\\n      }\\n    }\\n    // compute the pixel's depth\\n    var pos: vec4<f32> = rendererUBO.VCPCMatrix * vertexVC;\\n    output.fragDepth = pos.z / pos.w;\\n  \";\n    var code = fDesc.getCode();\n    code = vtkWebGPUShaderCache.substitute(code, '//VTK::Normal::Impl', [stickFrag]).result;\n    fDesc.setCode(code);\n  };\n  publicAPI.replaceShaderPosition = function (hash, pipeline, vertexInput) {\n    var vDesc = pipeline.getShaderDescription('vertex');\n    vDesc.addBuiltinOutput('vec4<f32>', '@builtin(position) Position');\n    var code = vDesc.getCode();\n    code = vtkWebGPUShaderCache.substitute(code, '//VTK::Position::Impl', ['  output.Position = rendererUBO.VCPCMatrix*vertexVC;']).result;\n    vDesc.setCode(code);\n  }; // compute a unique hash for a pipeline, this needs to be unique enough to\n  // capture any pipeline code changes (which includes shader changes)\n  // or vertex input changes/ bind groups/ etc\n\n  publicAPI.computePipelineHash = function () {\n    model.pipelineHash = 'stm';\n    if (model.vertexInput.hasAttribute(\"colorVI\")) {\n      model.pipelineHash += \"c\";\n    }\n    model.pipelineHash += model.renderEncoder.getPipelineHash();\n  };\n  publicAPI.updateBuffers = function () {\n    var poly = model.currentInput;\n    model.renderable.mapScalars(poly, 1.0);\n    var device = model.device;\n    var points = poly.getPoints();\n    var pointData = poly.getPointData();\n    var numPoints = points.getNumberOfPoints();\n    var pointArray = points.getData();\n    publicAPI.setNumberOfInstances(numPoints);\n    publicAPI.setNumberOfVertices(12);\n    var vertexInput = model.vertexInput;\n    var hash = \"stm\".concat(points.getMTime(), \"float32x3\");\n    if (!device.getBufferManager().hasBuffer(hash)) {\n      var buffRequest = {\n        hash: hash,\n        usage: BufferUsage.RawVertex,\n        format: 'float32x3'\n      }; // xyz v1 v2 v3\n\n      var tmpVBO = new Float32Array(numPoints * 3);\n      var pointIdx = 0;\n      var vboIdx = 0;\n      for (var id = 0; id < numPoints; ++id) {\n        pointIdx = id * 3;\n        tmpVBO[vboIdx++] = pointArray[pointIdx];\n        tmpVBO[vboIdx++] = pointArray[pointIdx + 1];\n        tmpVBO[vboIdx++] = pointArray[pointIdx + 2];\n      }\n      buffRequest.nativeArray = tmpVBO;\n      var buff = device.getBufferManager().getBuffer(buffRequest);\n      vertexInput.addBuffer(buff, ['vertexBC'], 'instance');\n    } // compute offset VBO\n\n    var scales = null;\n    if (model.renderable.getScaleArray() != null && pointData.hasArray(model.renderable.getScaleArray())) {\n      scales = pointData.getArray(model.renderable.getScaleArray()).getData();\n    }\n    var defaultRadius = model.renderable.getRadius();\n    if (scales || defaultRadius !== model._lastRadius) {\n      hash = \"stm\".concat(scales ? pointData.getArray(model.renderable.getScaleArray()).getMTime() : defaultRadius, \"float32\");\n      if (!device.getBufferManager().hasBuffer(hash)) {\n        var _buffRequest = {\n          hash: hash,\n          usage: BufferUsage.RawVertex,\n          format: 'float32'\n        };\n        var _tmpVBO = new Float32Array(numPoints);\n        var _vboIdx = 0;\n        for (var _id = 0; _id < numPoints; ++_id) {\n          var radius = model.renderable.getRadius();\n          if (scales) {\n            radius = scales[_id * 2 + 1];\n          }\n          _tmpVBO[_vboIdx++] = radius;\n        }\n        _buffRequest.nativeArray = _tmpVBO;\n        var _buff = device.getBufferManager().getBuffer(_buffRequest);\n        vertexInput.addBuffer(_buff, ['radiusMC'], 'instance');\n      }\n      model._lastRadius = defaultRadius;\n    }\n    var orientationArray = null;\n    if (model.renderable.getOrientationArray() != null && pointData.hasArray(model.renderable.getOrientationArray())) {\n      orientationArray = pointData.getArray(model.renderable.getOrientationArray()).getData();\n    } else {\n      vtkErrorMacro(['Error setting orientationArray.\\n', 'You have to specify the stick orientation']);\n    }\n    hash = \"stm\".concat(pointData.getArray(model.renderable.getOrientationArray()).getMTime(), \"float32x3\");\n    if (!device.getBufferManager().hasBuffer(hash)) {\n      var _buffRequest2 = {\n        hash: hash,\n        usage: BufferUsage.RawVertex,\n        format: 'float32x3'\n      }; // xyz v1 v2 v3\n\n      var _tmpVBO2 = new Float32Array(numPoints * 3);\n      var _pointIdx = 0;\n      var _vboIdx2 = 0;\n      for (var _id2 = 0; _id2 < numPoints; ++_id2) {\n        _pointIdx = _id2 * 3;\n        var length = model.renderable.getLength();\n        if (scales) {\n          length = scales[_id2 * 2];\n        }\n        _tmpVBO2[_vboIdx2++] = orientationArray[_pointIdx] * length;\n        _tmpVBO2[_vboIdx2++] = orientationArray[_pointIdx + 1] * length;\n        _tmpVBO2[_vboIdx2++] = orientationArray[_pointIdx + 2] * length;\n      }\n      _buffRequest2.nativeArray = _tmpVBO2;\n      var _buff2 = device.getBufferManager().getBuffer(_buffRequest2);\n      vertexInput.addBuffer(_buff2, ['orientMC'], 'instance');\n    } // deal with colors but only if modified\n\n    var haveColors = false;\n    if (model.renderable.getScalarVisibility()) {\n      var c = model.renderable.getColorMapColors();\n      if (c) {\n        hash = \"stm\".concat(c.getMTime(), \"unorm8x4\");\n        if (!device.getBufferManager().hasBuffer(hash)) {\n          var _buffRequest3 = {\n            usage: BufferUsage.RawVertex,\n            format: 'unorm8x4'\n          };\n          var colorComponents = c.getNumberOfComponents();\n          if (colorComponents !== 4) {\n            vtkErrorMacro('this should be 4');\n          }\n          var _tmpVBO3 = new Uint8Array(numPoints * 4);\n          var _vboIdx3 = 0;\n          var colorData = c.getData();\n          for (var _id3 = 0; _id3 < numPoints; ++_id3) {\n            var colorIdx = _id3 * colorComponents;\n            _tmpVBO3[_vboIdx3++] = colorData[colorIdx];\n            _tmpVBO3[_vboIdx3++] = colorData[colorIdx + 1];\n            _tmpVBO3[_vboIdx3++] = colorData[colorIdx + 2];\n            _tmpVBO3[_vboIdx3++] = colorData[colorIdx + 3];\n          }\n          _buffRequest3.nativeArray = _tmpVBO3;\n          var _buff3 = device.getBufferManager().getBuffer(_buffRequest3);\n          vertexInput.addBuffer(_buff3, ['colorVI'], 'instance');\n        }\n        haveColors = true;\n      }\n    }\n    if (!haveColors) {\n      vertexInput.removeBufferIfPresent('colorVI');\n    }\n    publicAPI.setTopology('triangle-list');\n    publicAPI.updateUBO();\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nvar DEFAULT_VALUES = {}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Inheritance\n\n  vtkWebGPUCellArrayMapper.extend(publicAPI, model, initialValues);\n  publicAPI.setVertexShaderTemplate(vtkWebGPUStickMapperVS); // Object methods\n\n  vtkWebGPUStickMapper(publicAPI, model);\n  var sr = model.shaderReplacements;\n  sr.set('replaceShaderPosition', publicAPI.replaceShaderPosition);\n  sr.set('replaceShaderNormal', publicAPI.replaceShaderNormal);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = newInstance$1(extend, 'vtkWebGPUStickMapper'); // ----------------------------------------------------------------------------\n\nvar index = {\n  newInstance: newInstance,\n  extend: extend\n}; // Register ourself to WebGPU backend if imported\n\nregisterOverride('vtkStickMapper', newInstance);\nexport { index as default, extend, newInstance };","map":{"version":3,"names":["newInstance","newInstance$1","vtkErrorMacro","vtkErrorMacro$1","vtkWebGPUCellArrayMapper","vtkWebGPUBufferManager","vtkWebGPUShaderCache","registerOverride","BufferUsage","vtkWebGPUStickMapperVS","vtkWebGPUStickMapper","publicAPI","model","classHierarchy","push","cellMapperBuildPass","buildPass","prepass","renderable","getStatic","update","poly","getInputData","setCellArray","getVerts","setCurrentInput","replaceShaderNormal","hash","pipeline","vertexInput","vDesc","getShaderDescription","hasOutput","addOutput","addBuiltinInput","fDesc","addBuiltinOutput","stickFrag","code","getCode","substitute","result","setCode","replaceShaderPosition","computePipelineHash","pipelineHash","hasAttribute","renderEncoder","getPipelineHash","updateBuffers","currentInput","mapScalars","device","points","getPoints","pointData","getPointData","numPoints","getNumberOfPoints","pointArray","getData","setNumberOfInstances","setNumberOfVertices","concat","getMTime","getBufferManager","hasBuffer","buffRequest","usage","RawVertex","format","tmpVBO","Float32Array","pointIdx","vboIdx","id","nativeArray","buff","getBuffer","addBuffer","scales","getScaleArray","hasArray","getArray","defaultRadius","getRadius","_lastRadius","_buffRequest","_tmpVBO","_vboIdx","_id","radius","_buff","orientationArray","getOrientationArray","_buffRequest2","_tmpVBO2","_pointIdx","_vboIdx2","_id2","length","getLength","_buff2","haveColors","getScalarVisibility","c","getColorMapColors","_buffRequest3","colorComponents","getNumberOfComponents","_tmpVBO3","Uint8Array","_vboIdx3","colorData","_id3","colorIdx","_buff3","removeBufferIfPresent","setTopology","updateUBO","DEFAULT_VALUES","extend","initialValues","arguments","undefined","Object","assign","setVertexShaderTemplate","sr","shaderReplacements","set","index","default"],"sources":["/home/rakshith/Documents/RemoteRendering/vtk-js-react-app/node_modules/@kitware/vtk.js/Rendering/WebGPU/StickMapper.js"],"sourcesContent":["import { newInstance as newInstance$1, vtkErrorMacro as vtkErrorMacro$1 } from '../../macros.js';\nimport vtkWebGPUCellArrayMapper from './CellArrayMapper.js';\nimport vtkWebGPUBufferManager from './BufferManager.js';\nimport vtkWebGPUShaderCache from './ShaderCache.js';\nimport { registerOverride } from './ViewNodeFactory.js';\n\nvar BufferUsage = vtkWebGPUBufferManager.BufferUsage;\nvar vtkErrorMacro = vtkErrorMacro$1; // Vertices\n// 013 - 032 - 324 - 453\n//\n//       _.4---_.5\n//    .-*   .-*\n//   2-----3\n//   |    /|\n//   |   / |\n//   |  /  |\n//   | /   |\n//   |/    |\n//   0-----1\n//\n// coord for each points\n// 0: 000\n// 1: 100\n// 2: 001\n// 3: 101\n// 4: 011\n// 5: 111\n\nvar vtkWebGPUStickMapperVS = \"\\n//VTK::Renderer::Dec\\n\\n//VTK::Mapper::Dec\\n\\n//VTK::Color::Dec\\n\\n//VTK::IOStructs::Dec\\n\\n@vertex\\nfn main(\\n//VTK::IOStructs::Input\\n)\\n//VTK::IOStructs::Output\\n{\\n  var offsetsArray: array<vec3<f32>, 12> = array<vec3<f32>, 12>(\\n    vec3<f32>(-1.0, -1.0, -1.0),\\n    vec3<f32>(1.0, -1.0, -1.0),\\n    vec3<f32>(1.0, -1.0, 1.0),\\n\\n    vec3<f32>(-1.0, -1.0, -1.0),\\n    vec3<f32>(1.0, -1.0, 1.0),\\n    vec3<f32>(-1.0, -1.0, 1.0),\\n\\n    vec3<f32>(-1.0, -1.0, 1.0),\\n    vec3<f32>(1.0, -1.0, 1.0),\\n    vec3<f32>(1.0, 1.0, 1.0),\\n\\n    vec3<f32>(-1.0, -1.0, 1.0),\\n    vec3<f32>(1.0, 1.0, 1.0),\\n    vec3<f32>(-1.0, 1.0, 1.0)\\n  );\\n\\n  var output : vertexOutput;\\n\\n  var vertexVC: vec4<f32> = rendererUBO.SCVCMatrix * mapperUBO.BCSCMatrix * vec4<f32>(vertexBC.xyz, 1.0);\\n\\n  //VTK::Color::Impl\\n\\n  // compute the projected vertex position\\n  output.centerVC = vertexVC.xyz;\\n  output.radiusVC = radiusMC;\\n  output.lengthVC = length(orientMC);\\n  output.orientVC = (rendererUBO.WCVCNormals * vec4<f32>(normalize(orientMC), 0.0)).xyz;\\n\\n  // make sure it is pointing out of the screen\\n  if (output.orientVC.z < 0.0)\\n    {\\n    output.orientVC = -output.orientVC;\\n    }\\n\\n  // make the basis\\n  var xbase: vec3<f32>;\\n  var ybase: vec3<f32>;\\n  var dir: vec3<f32> = vec3<f32>(0.0,0.0,1.0);\\n  if (rendererUBO.cameraParallel == 0u)\\n    {\\n    dir = normalize(-vertexVC.xyz);\\n    }\\n  if (abs(dot(dir,output.orientVC)) == 1.0)\\n    {\\n    xbase = normalize(cross(vec3<f32>(0.0,1.0,0.0),output.orientVC));\\n    ybase = cross(xbase,output.orientVC);\\n    }\\n  else\\n    {\\n    xbase = normalize(cross(output.orientVC,dir));\\n    ybase = cross(output.orientVC,xbase);\\n    }\\n\\n\\n  var vertIdx: u32 = input.vertexIndex % 12u;\\n  var offsets: vec3<f32> = offsetsArray[vertIdx];\\n\\n  vertexVC = vec4<f32>(vertexVC.xyz +\\n    output.radiusVC * offsets.x * xbase +\\n    output.radiusVC * offsets.y * ybase +\\n    0.5 * output.lengthVC * offsets.z * output.orientVC, 1.0);\\n\\n  output.vertexVC = vertexVC;\\n\\n  //VTK::Position::Impl\\n\\n  return output;\\n}\\n\"; // ----------------------------------------------------------------------------\n// vtkWebGPUStickMapper methods\n// ----------------------------------------------------------------------------\n\nfunction vtkWebGPUStickMapper(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkWebGPUStickMapper');\n  var cellMapperBuildPass = publicAPI.buildPass;\n\n  publicAPI.buildPass = function (prepass) {\n    if (prepass) {\n      if (!model.renderable.getStatic()) {\n        model.renderable.update();\n      }\n\n      var poly = model.renderable.getInputData();\n      publicAPI.setCellArray(poly.getVerts());\n      publicAPI.setCurrentInput(poly);\n    }\n\n    cellMapperBuildPass(prepass);\n  };\n\n  publicAPI.replaceShaderNormal = function (hash, pipeline, vertexInput) {\n    var vDesc = pipeline.getShaderDescription('vertex');\n    if (!vDesc.hasOutput('vertexVC')) vDesc.addOutput('vec4<f32>', 'vertexVC');\n    vDesc.addOutput('vec3<f32>', 'centerVC');\n    vDesc.addOutput('vec3<f32>', 'orientVC');\n    vDesc.addOutput('f32', 'radiusVC');\n    vDesc.addOutput('f32', 'lengthVC');\n    vDesc.addBuiltinInput('u32', '@builtin(vertex_index) vertexIndex');\n    var fDesc = pipeline.getShaderDescription('fragment');\n    fDesc.addBuiltinOutput('f32', '@builtin(frag_depth) fragDepth');\n    var stickFrag = \"\\n    // compute the eye position and unit direction\\n    var vertexVC: vec4<f32>;\\n    var EyePos: vec3<f32>;\\n    var EyeDir: vec3<f32>;\\n\\n    if (rendererUBO.cameraParallel != 0u)\\n    {\\n      EyePos = vec3<f32>(input.vertexVC.x, input.vertexVC.y, input.vertexVC.z + 3.0*input.radiusVC);\\n      EyeDir = vec3<f32>(0.0, 0.0, -1.0);\\n    }\\n    else\\n    {\\n      EyeDir = input.vertexVC.xyz;\\n      EyePos = vec3<f32>(0.0,0.0,0.0);\\n      var lengthED: f32 = length(EyeDir);\\n      EyeDir = normalize(EyeDir);\\n      // we adjust the EyePos to be closer if it is too far away\\n      // to prevent floating point precision noise\\n      if (lengthED > input.radiusVC*3.0)\\n      {\\n        EyePos = input.vertexVC.xyz - EyeDir*3.0*input.radiusVC;\\n      }\\n    }\\n    // translate to Sphere center\\n    EyePos = EyePos - input.centerVC;\\n\\n    // rotate to new basis\\n    // base1, base2, orientVC\\n    var base1: vec3<f32>;\\n    if (abs(input.orientVC.z) < 0.99)\\n    {\\n      base1 = normalize(cross(input.orientVC,vec3<f32>(0.0,0.0,1.0)));\\n    }\\n    else\\n    {\\n      base1 = normalize(cross(input.orientVC,vec3<f32>(0.0,1.0,0.0)));\\n    }\\n    var base2: vec3<f32> = cross(input.orientVC,base1);\\n    EyePos = vec3<f32>(dot(EyePos,base1),dot(EyePos,base2),dot(EyePos,input.orientVC));\\n    EyeDir = vec3<f32>(dot(EyeDir,base1),dot(EyeDir,base2),dot(EyeDir,input.orientVC));\\n\\n    // scale to radius 1.0\\n    EyePos = EyePos * (1.0 / input.radiusVC);\\n\\n    // find the intersection\\n    var a: f32 = EyeDir.x*EyeDir.x + EyeDir.y*EyeDir.y;\\n    var b: f32 = 2.0*(EyePos.x*EyeDir.x + EyePos.y*EyeDir.y);\\n    var c: f32 = EyePos.x*EyePos.x + EyePos.y*EyePos.y - 1.0;\\n    var d: f32 = b*b - 4.0*a*c;\\n    var normal: vec3<f32> = vec3<f32>(0.0,0.0,1.0);\\n    if (d < 0.0) { discard; }\\n    else\\n    {\\n      var t: f32 = (-b - sqrt(d))*(0.5 / a);\\n      var tz: f32 = EyePos.z + t*EyeDir.z;\\n      var iPoint: vec3<f32> = EyePos + t*EyeDir;\\n      if (abs(iPoint.z)*input.radiusVC > input.lengthVC*0.5)\\n      {\\n        // test for end cap\\n        var t2: f32 = (-b + sqrt(d))*(0.5 / a);\\n        var tz2: f32 = EyePos.z + t2*EyeDir.z;\\n        if (tz2*input.radiusVC > input.lengthVC*0.5 || tz*input.radiusVC < -0.5*input.lengthVC) { discard; }\\n        else\\n        {\\n          normal = input.orientVC;\\n          var t3: f32 = (input.lengthVC*0.5/input.radiusVC - EyePos.z)/EyeDir.z;\\n          iPoint = EyePos + t3*EyeDir;\\n          vertexVC = vec4<f32>(input.radiusVC*(iPoint.x*base1 + iPoint.y*base2 + iPoint.z*input.orientVC) + input.centerVC, 1.0);\\n        }\\n      }\\n      else\\n      {\\n        // The normal is the iPoint.xy rotated back into VC\\n        normal = iPoint.x*base1 + iPoint.y*base2;\\n        // rescale rerotate and translate\\n        vertexVC = vec4<f32>(input.radiusVC*(normal + iPoint.z*input.orientVC) + input.centerVC, 1.0);\\n      }\\n    }\\n    // compute the pixel's depth\\n    var pos: vec4<f32> = rendererUBO.VCPCMatrix * vertexVC;\\n    output.fragDepth = pos.z / pos.w;\\n  \";\n    var code = fDesc.getCode();\n    code = vtkWebGPUShaderCache.substitute(code, '//VTK::Normal::Impl', [stickFrag]).result;\n    fDesc.setCode(code);\n  };\n\n  publicAPI.replaceShaderPosition = function (hash, pipeline, vertexInput) {\n    var vDesc = pipeline.getShaderDescription('vertex');\n    vDesc.addBuiltinOutput('vec4<f32>', '@builtin(position) Position');\n    var code = vDesc.getCode();\n    code = vtkWebGPUShaderCache.substitute(code, '//VTK::Position::Impl', ['  output.Position = rendererUBO.VCPCMatrix*vertexVC;']).result;\n    vDesc.setCode(code);\n  }; // compute a unique hash for a pipeline, this needs to be unique enough to\n  // capture any pipeline code changes (which includes shader changes)\n  // or vertex input changes/ bind groups/ etc\n\n\n  publicAPI.computePipelineHash = function () {\n    model.pipelineHash = 'stm';\n\n    if (model.vertexInput.hasAttribute(\"colorVI\")) {\n      model.pipelineHash += \"c\";\n    }\n\n    model.pipelineHash += model.renderEncoder.getPipelineHash();\n  };\n\n  publicAPI.updateBuffers = function () {\n    var poly = model.currentInput;\n    model.renderable.mapScalars(poly, 1.0);\n    var device = model.device;\n    var points = poly.getPoints();\n    var pointData = poly.getPointData();\n    var numPoints = points.getNumberOfPoints();\n    var pointArray = points.getData();\n    publicAPI.setNumberOfInstances(numPoints);\n    publicAPI.setNumberOfVertices(12);\n    var vertexInput = model.vertexInput;\n    var hash = \"stm\".concat(points.getMTime(), \"float32x3\");\n\n    if (!device.getBufferManager().hasBuffer(hash)) {\n      var buffRequest = {\n        hash: hash,\n        usage: BufferUsage.RawVertex,\n        format: 'float32x3'\n      }; // xyz v1 v2 v3\n\n      var tmpVBO = new Float32Array(numPoints * 3);\n      var pointIdx = 0;\n      var vboIdx = 0;\n\n      for (var id = 0; id < numPoints; ++id) {\n        pointIdx = id * 3;\n        tmpVBO[vboIdx++] = pointArray[pointIdx];\n        tmpVBO[vboIdx++] = pointArray[pointIdx + 1];\n        tmpVBO[vboIdx++] = pointArray[pointIdx + 2];\n      }\n\n      buffRequest.nativeArray = tmpVBO;\n      var buff = device.getBufferManager().getBuffer(buffRequest);\n      vertexInput.addBuffer(buff, ['vertexBC'], 'instance');\n    } // compute offset VBO\n\n\n    var scales = null;\n\n    if (model.renderable.getScaleArray() != null && pointData.hasArray(model.renderable.getScaleArray())) {\n      scales = pointData.getArray(model.renderable.getScaleArray()).getData();\n    }\n\n    var defaultRadius = model.renderable.getRadius();\n\n    if (scales || defaultRadius !== model._lastRadius) {\n      hash = \"stm\".concat(scales ? pointData.getArray(model.renderable.getScaleArray()).getMTime() : defaultRadius, \"float32\");\n\n      if (!device.getBufferManager().hasBuffer(hash)) {\n        var _buffRequest = {\n          hash: hash,\n          usage: BufferUsage.RawVertex,\n          format: 'float32'\n        };\n\n        var _tmpVBO = new Float32Array(numPoints);\n\n        var _vboIdx = 0;\n\n        for (var _id = 0; _id < numPoints; ++_id) {\n          var radius = model.renderable.getRadius();\n\n          if (scales) {\n            radius = scales[_id * 2 + 1];\n          }\n\n          _tmpVBO[_vboIdx++] = radius;\n        }\n\n        _buffRequest.nativeArray = _tmpVBO;\n\n        var _buff = device.getBufferManager().getBuffer(_buffRequest);\n\n        vertexInput.addBuffer(_buff, ['radiusMC'], 'instance');\n      }\n\n      model._lastRadius = defaultRadius;\n    }\n\n    var orientationArray = null;\n\n    if (model.renderable.getOrientationArray() != null && pointData.hasArray(model.renderable.getOrientationArray())) {\n      orientationArray = pointData.getArray(model.renderable.getOrientationArray()).getData();\n    } else {\n      vtkErrorMacro(['Error setting orientationArray.\\n', 'You have to specify the stick orientation']);\n    }\n\n    hash = \"stm\".concat(pointData.getArray(model.renderable.getOrientationArray()).getMTime(), \"float32x3\");\n\n    if (!device.getBufferManager().hasBuffer(hash)) {\n      var _buffRequest2 = {\n        hash: hash,\n        usage: BufferUsage.RawVertex,\n        format: 'float32x3'\n      }; // xyz v1 v2 v3\n\n      var _tmpVBO2 = new Float32Array(numPoints * 3);\n\n      var _pointIdx = 0;\n      var _vboIdx2 = 0;\n\n      for (var _id2 = 0; _id2 < numPoints; ++_id2) {\n        _pointIdx = _id2 * 3;\n        var length = model.renderable.getLength();\n\n        if (scales) {\n          length = scales[_id2 * 2];\n        }\n\n        _tmpVBO2[_vboIdx2++] = orientationArray[_pointIdx] * length;\n        _tmpVBO2[_vboIdx2++] = orientationArray[_pointIdx + 1] * length;\n        _tmpVBO2[_vboIdx2++] = orientationArray[_pointIdx + 2] * length;\n      }\n\n      _buffRequest2.nativeArray = _tmpVBO2;\n\n      var _buff2 = device.getBufferManager().getBuffer(_buffRequest2);\n\n      vertexInput.addBuffer(_buff2, ['orientMC'], 'instance');\n    } // deal with colors but only if modified\n\n\n    var haveColors = false;\n\n    if (model.renderable.getScalarVisibility()) {\n      var c = model.renderable.getColorMapColors();\n\n      if (c) {\n        hash = \"stm\".concat(c.getMTime(), \"unorm8x4\");\n\n        if (!device.getBufferManager().hasBuffer(hash)) {\n          var _buffRequest3 = {\n            usage: BufferUsage.RawVertex,\n            format: 'unorm8x4'\n          };\n          var colorComponents = c.getNumberOfComponents();\n\n          if (colorComponents !== 4) {\n            vtkErrorMacro('this should be 4');\n          }\n\n          var _tmpVBO3 = new Uint8Array(numPoints * 4);\n\n          var _vboIdx3 = 0;\n          var colorData = c.getData();\n\n          for (var _id3 = 0; _id3 < numPoints; ++_id3) {\n            var colorIdx = _id3 * colorComponents;\n            _tmpVBO3[_vboIdx3++] = colorData[colorIdx];\n            _tmpVBO3[_vboIdx3++] = colorData[colorIdx + 1];\n            _tmpVBO3[_vboIdx3++] = colorData[colorIdx + 2];\n            _tmpVBO3[_vboIdx3++] = colorData[colorIdx + 3];\n          }\n\n          _buffRequest3.nativeArray = _tmpVBO3;\n\n          var _buff3 = device.getBufferManager().getBuffer(_buffRequest3);\n\n          vertexInput.addBuffer(_buff3, ['colorVI'], 'instance');\n        }\n\n        haveColors = true;\n      }\n    }\n\n    if (!haveColors) {\n      vertexInput.removeBufferIfPresent('colorVI');\n    }\n\n    publicAPI.setTopology('triangle-list');\n    publicAPI.updateUBO();\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\n\nvar DEFAULT_VALUES = {}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Inheritance\n\n  vtkWebGPUCellArrayMapper.extend(publicAPI, model, initialValues);\n  publicAPI.setVertexShaderTemplate(vtkWebGPUStickMapperVS); // Object methods\n\n  vtkWebGPUStickMapper(publicAPI, model);\n  var sr = model.shaderReplacements;\n  sr.set('replaceShaderPosition', publicAPI.replaceShaderPosition);\n  sr.set('replaceShaderNormal', publicAPI.replaceShaderNormal);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = newInstance$1(extend, 'vtkWebGPUStickMapper'); // ----------------------------------------------------------------------------\n\nvar index = {\n  newInstance: newInstance,\n  extend: extend\n}; // Register ourself to WebGPU backend if imported\n\nregisterOverride('vtkStickMapper', newInstance);\n\nexport { index as default, extend, newInstance };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}