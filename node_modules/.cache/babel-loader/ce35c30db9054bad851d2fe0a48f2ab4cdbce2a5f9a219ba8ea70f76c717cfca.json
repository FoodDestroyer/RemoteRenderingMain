{"ast":null,"code":"import macro from '../../macros.js';\nimport { e as distance2BetweenPoints } from '../Core/Math/index.js';\nvar vtkErrorMacro = macro.vtkErrorMacro;\nvar OCTREENODE_INSERTPOINT = [function (points, pointIdx, coords) {\n  return pointIdx;\n}, function (points, pointIdx, coords) {\n  points.setTuple(pointIdx, coords);\n  return pointIdx;\n}, function (points, pointIdx, coords) {\n  return points.insertNextTuple(coords);\n}]; // Given the index (0 ~ 7) of a child node, the spatial bounding axis (0 ~ 2\n// for x, y, and z), and the value (0 ~ 1 for min and max) to access, this LUT\n// allows for rapid assignment of its spatial bounding box --- MinBounds[3]\n// and MaxBounds[3], with each specific value or entry of this LUT pointing to\n// MinBounds[3] for 0, center point for 1, or MaxBounds[3] for 2.\n\nvar OCTREE_CHILD_BOUNDS_LUT = [[[0, 1], [0, 1], [0, 1]], [[1, 2], [0, 1], [0, 1]], [[0, 1], [1, 2], [0, 1]], [[1, 2], [1, 2], [0, 1]], [[0, 1], [0, 1], [1, 2]], [[1, 2], [0, 1], [1, 2]], [[0, 1], [1, 2], [1, 2]], [[1, 2], [1, 2], [1, 2]]];\nfunction vtkIncrementalOctreeNode(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkIncrementalOctreeNode'); //------------------------------------------------------------------------------\n\n  publicAPI.createPointIdSet = function (initSize, growSize) {\n    if (model.pointIdSet == null) {\n      model.pointIdSet = []; // TODO: use initSize and growSize.\n      // model.pointIdSet.allocate(initSize, growSize);\n    }\n  }; //------------------------------------------------------------------------------\n\n  publicAPI.setBounds = function (x1, x2, y1, y2, z1, z2) {\n    if (model.minBounds == null) model.minBounds = [];\n    if (model.maxBounds == null) model.maxBounds = [];\n    if (model.minDataBounds == null) model.minDataBounds = [];\n    if (model.maxDataBounds == null) model.maxDataBounds = [];\n    model.minBounds[0] = x1;\n    model.maxBounds[0] = x2;\n    model.minBounds[1] = y1;\n    model.maxBounds[1] = y2;\n    model.minBounds[2] = z1;\n    model.maxBounds[2] = z2;\n    model.minDataBounds[0] = x2;\n    model.maxDataBounds[0] = x1;\n    model.minDataBounds[1] = y2;\n    model.maxDataBounds[1] = y1;\n    model.minDataBounds[2] = z2;\n    model.maxDataBounds[2] = z1;\n  }; //------------------------------------------------------------------------------\n\n  publicAPI.getBounds = function (bounds) {\n    bounds[0] = model.minBounds[0];\n    bounds[1] = model.maxBounds[0];\n    bounds[2] = model.minBounds[1];\n    bounds[3] = model.maxBounds[1];\n    bounds[4] = model.minBounds[2];\n    bounds[5] = model.maxBounds[2];\n  };\n  publicAPI.getChildIndex = function (point) {\n    return Number(point[0] > model.children[0].getMaxBoundsByReference()[0]) + (\n    // eslint-disable-next-line no-bitwise\n    Number(point[1] > model.children[0].getMaxBoundsByReference()[1]) << 1) + (\n    // eslint-disable-next-line no-bitwise\n    Number(point[2] > model.children[0].getMaxBoundsByReference()[2]) << 2);\n  };\n  publicAPI.containsPoint = function (pnt) {\n    return model.minBounds[0] < pnt[0] && pnt[0] <= model.maxBounds[0] && model.minBounds[1] < pnt[1] && pnt[1] <= model.maxBounds[1] && model.minBounds[2] < pnt[2] && pnt[2] <= model.maxBounds[2] ? 1 : 0;\n  };\n  publicAPI.containsPointByData = function (pnt) {\n    return model.minDataBounds[0] <= pnt[0] && pnt[0] <= model.maxDataBounds[0] && model.minDataBounds[1] <= pnt[1] && pnt[1] <= model.maxDataBounds[1] && model.minDataBounds[2] <= pnt[2] && pnt[2] <= model.maxDataBounds[2] ? 1 : 0;\n  }; //------------------------------------------------------------------------------\n\n  publicAPI.updateCounterAndDataBounds = function (point, nHits, updateData) {\n    model.numberOfPoints += nHits;\n    if (!updateData) return false;\n    var updated = false;\n    if (point[0] < model.minDataBounds[0]) {\n      updated = true;\n      model.minDataBounds[0] = point[0];\n    }\n    if (point[0] > model.maxDataBounds[0]) {\n      updated = true;\n      model.maxDataBounds[0] = point[0];\n    }\n    if (point[1] < model.minDataBounds[1]) {\n      updated = true;\n      model.minDataBounds[1] = point[1];\n    }\n    if (point[1] > model.maxDataBounds[1]) {\n      updated = true;\n      model.maxDataBounds[1] = point[1];\n    }\n    if (point[2] < model.minDataBounds[2]) {\n      updated = true;\n      model.minDataBounds[2] = point[2];\n    }\n    if (point[2] > model.maxDataBounds[2]) {\n      updated = true;\n      model.maxDataBounds[2] = point[2];\n    }\n    return updated;\n  }; //------------------------------------------------------------------------------\n\n  publicAPI.updateCounterAndDataBoundsRecursively = function (point, nHits, updateData, endNode) {\n    var updated = publicAPI.updateCounterAndDataBounds(point, nHits, updateData);\n    return model.parent === endNode ? updated : model.parent.updateCounterAndDataBoundsRecursively(point, nHits, updated, endNode);\n  }; //------------------------------------------------------------------------------\n\n  publicAPI.containsDuplicatePointsOnly = function (point) {\n    return model.minDataBounds[0] === point[0] && point[0] === model.maxDataBounds[0] && model.minDataBounds[1] === point[1] && point[1] === model.maxDataBounds[1] && model.minDataBounds[2] === point[2] && point[2] === model.maxDataBounds[2];\n  }; //------------------------------------------------------------------------------\n\n  publicAPI.isLeaf = function () {\n    return model.children == null;\n  }; //------------------------------------------------------------------------------\n\n  publicAPI.getChild = function (i) {\n    return model.children[i];\n  }; //------------------------------------------------------------------------------\n\n  /* eslint-disable no-use-before-define */\n\n  publicAPI.separateExactlyDuplicatePointsFromNewInsertion = function (points, pntIds, newPnt, pntIdx, maxPts, ptMode) {\n    // the number of points already maintained in this leaf node\n    // >= maxPts AND all of them are exactly duplicate with one another\n    //           BUT the new point is not a duplicate of them any more\n    var pointIdx = pntIdx;\n    var i;\n    var dupPnt = [0.0, 0.0, 0.0];\n    var octMin = [0.0, 0.0, 0.0];\n    var octMid = [0.0, 0.0, 0.0];\n    var octMax = [0.0, 0.0, 0.0];\n    var boxPtr = [null, null, null];\n    var ocNode = null;\n    var duplic = publicAPI;\n    var single = publicAPI; // the coordinate of the duplicate points: note pntIds == model.pointIdSet\n\n    points.getPoint(pntIds[0], dupPnt);\n    while (duplic === single) {\n      // as long as separation has not been achieved\n      // update the current (in recursion) node and access the bounding box info\n      ocNode = duplic;\n      octMid[0] = (ocNode.minBounds[0] + ocNode.maxBounds[0]) * 0.5;\n      octMid[1] = (ocNode.minBounds[1] + ocNode.maxBounds[1]) * 0.5;\n      octMid[2] = (ocNode.minBounds[2] + ocNode.maxBounds[2]) * 0.5;\n      boxPtr[0] = ocNode.minBounds;\n      boxPtr[1] = octMid;\n      boxPtr[2] = ocNode.maxBounds; // create eight child nodes\n      // FIXME: May be too slow to use vtk newInstance()\n\n      ocNode.children = [newInstance(), newInstance(), newInstance(), newInstance(), newInstance(), newInstance(), newInstance(), newInstance()];\n      for (i = 0; i < 8; i++) {\n        // x-bound: axis 0\n        octMin[0] = boxPtr[OCTREE_CHILD_BOUNDS_LUT[i][0][0]][0];\n        octMax[0] = boxPtr[OCTREE_CHILD_BOUNDS_LUT[i][0][1]][0]; // y-bound: axis 1\n\n        octMin[1] = boxPtr[OCTREE_CHILD_BOUNDS_LUT[i][1][0]][1];\n        octMax[1] = boxPtr[OCTREE_CHILD_BOUNDS_LUT[i][1][1]][1]; // z-bound: axis 2\n\n        octMin[2] = boxPtr[OCTREE_CHILD_BOUNDS_LUT[i][2][0]][2];\n        octMax[2] = boxPtr[OCTREE_CHILD_BOUNDS_LUT[i][2][1]][2];\n        ocNode.children[i] = newInstance();\n        ocNode.children[i].setParent(ocNode);\n        ocNode.children[i].setBounds(octMin[0], octMax[0], octMin[1], octMax[1], octMin[2], octMax[2]);\n      } // determine the leaf node of the duplicate points & that of the new point\n\n      duplic = ocNode.children[ocNode.getChildIndex(dupPnt)];\n      single = ocNode.children[ocNode.getChildIndex(newPnt)];\n    } // Now the duplicate points have been separated from the new point //\n    // create a vtkIdList object for the new point\n    // update the counter and the data bounding box until the root node\n    // (including the root node)\n\n    pointIdx = OCTREENODE_INSERTPOINT[ptMode](points, pointIdx, newPnt); // eslint-disable-next-line no-bitwise\n\n    single.createPointIdSet(maxPts >> 2, maxPts >> 1);\n    single.getPointIdSet().push(pointIdx);\n    single.updateCounterAndDataBoundsRecursively(newPnt, 1, 1, null); // We just need to reference pntIds while un-registering it from 'this'.\n    // This avoids deep-copying point ids from pntIds to duplic's PointIdSet.\n    // update the counter and the data bounding box, but until 'this' node\n    // (excluding 'this' node)\n\n    duplic.setPointIdSet(pntIds);\n    duplic.updateCounterAndDataBoundsRecursively(dupPnt, pntIds.length, 1, publicAPI);\n    return pointIdx;\n  };\n  /* eslint-enable no-use-before-define */\n  //------------------------------------------------------------------------------\n\n  publicAPI.createChildNodes = function (points, pntIds, newPnt, pntIdx, maxPts, ptMode, numberOfNodes) {\n    // There are two scenarios for which this function is invoked.\n    //\n    // (1) the number of points already maintained in this leaf node\n    //     == maxPts AND not all of them are exactly duplicate\n    //               AND the new point is not a duplicate of them all\n    // (2) the number of points already maintained in this leaf node\n    //     >= maxPts AND all of them are exactly duplicate with one another\n    //               BUT the new point is not a duplicate of them any more\n    // address case (2) first if necessary\n    var nbNodes = numberOfNodes;\n    var pointIdx = pntIdx;\n    var sample = [];\n    points.getPoint(pntIds[0], sample);\n    if (publicAPI.containsDuplicatePointsOnly(sample)) {\n      pointIdx = publicAPI.separateExactlyDuplicatePointsFromNewInsertion(points, pntIds, newPnt, pointIdx, maxPts, ptMode);\n      return {\n        success: false,\n        nbNodes: nbNodes,\n        pointIdx: pointIdx\n      };\n    } // then address case (1) below\n\n    var i;\n    var target;\n    var dvidId = -1; // index of the sub-dividing octant, if any\n\n    var fullId = -1; // index of the full octant, if any\n\n    var numIds = [0, 0, 0, 0, 0, 0, 0, 0];\n    var octMin = [];\n    var octMax = [];\n    var tempPt = [];\n    var tempId;\n    var octMid = [(model.minBounds[0] + model.maxBounds[0]) * 0.5, (model.minBounds[1] + model.maxBounds[1]) * 0.5, (model.minBounds[2] + model.maxBounds[2]) * 0.5];\n    var boxPtr = [model.minBounds, octMid, model.maxBounds]; // create eight child nodes\n\n    model.children = [];\n    for (i = 0; i < 8; i++) {\n      // x-bound: axis 0\n      octMin[0] = boxPtr[OCTREE_CHILD_BOUNDS_LUT[i][0][0]][0];\n      octMax[0] = boxPtr[OCTREE_CHILD_BOUNDS_LUT[i][0][1]][0]; // y-bound: axis 1\n\n      octMin[1] = boxPtr[OCTREE_CHILD_BOUNDS_LUT[i][1][0]][1];\n      octMax[1] = boxPtr[OCTREE_CHILD_BOUNDS_LUT[i][1][1]][1]; // z-bound: axis 2\n\n      octMin[2] = boxPtr[OCTREE_CHILD_BOUNDS_LUT[i][2][0]][2];\n      octMax[2] = boxPtr[OCTREE_CHILD_BOUNDS_LUT[i][2][1]][2]; // This call internally sets the cener and default data bounding box, too.\n      // eslint-disable-next-line no-use-before-define\n\n      model.children[i] = newInstance(); // model.children[i].iD = nbNodes++;\n\n      model.children[i].setParent(publicAPI);\n      model.children[i].setBounds(octMin[0], octMax[0], octMin[1], octMax[1], octMin[2], octMax[2]); // allocate a list of point-indices (size = 2^n) for index registration\n      // eslint-disable-next-line no-bitwise\n\n      model.children[i].createPointIdSet(maxPts >> 2, maxPts >> 1);\n    }\n    boxPtr[0] = null;\n    boxPtr[1] = null;\n    boxPtr[2] = null; // distribute the available point-indices to the eight child nodes\n\n    for (i = 0; i < maxPts; i++) {\n      tempId = pntIds[i];\n      points.getPoint(tempId, tempPt);\n      target = publicAPI.getChildIndex(tempPt);\n      model.children[target].getPointIdSet().push(tempId);\n      model.children[target].updateCounterAndDataBounds(tempPt);\n      numIds[target]++;\n    } // locate the full child, just if any\n\n    for (i = 0; i < 8; i++) {\n      if (numIds[i] === maxPts) {\n        fullId = i;\n        break;\n      }\n    }\n    target = publicAPI.getChildIndex(newPnt);\n    if (fullId === target) {\n      // The fact is that we are going to insert the new point to an already\n      // full octant (child node). Thus we need to further divide this child\n      // to avoid the overflow problem.\n      var _model$children$targe = model.children[target].createChildNodes(points, pntIds, newPnt, pointIdx, maxPts, ptMode, nbNodes);\n      nbNodes = _model$children$targe.numberOfNodes;\n      pointIdx = _model$children$targe.pointIdx;\n      dvidId = fullId;\n    } else {\n      // the initial division is a success\n      pointIdx = OCTREENODE_INSERTPOINT[ptMode](points, pointIdx, newPnt);\n      model.children[target].getPointIdSet().push(pointIdx);\n      model.children[target].updateCounterAndDataBoundsRecursively(newPnt, 1, 1, null); // NOTE: The counter below might reach the threshold, though we delay the\n      // sub-division of this child node until the next point insertion occurs.\n\n      numIds[target]++;\n    } // Now it is time to reclaim those un-used vtkIdList objects, of which each\n    // either is empty or still needs to be deleted due to further division of\n    // the child node. This post-deallocation of the un-used vtkIdList objects\n    // (of some child nodes) is based on the assumption that retrieving the\n    // 'maxPts' points from vtkPoints and the associated 'maxPts' point-indices\n    // from vtkIdList is more expensive than reclaiming at most 8 vtkIdList\n    // objects at hand.\n\n    for (i = 0; i < 8; i++) {\n      if (numIds[i] === 0 || i === dvidId) {\n        model.children[i].getPointIdSet().length = 0;\n      }\n    } // notify vtkIncrementalOctreeNode::InsertPoint() to destroy pntIds\n\n    return {\n      success: true,\n      numberOfNodes: nbNodes,\n      pointIdx: pointIdx\n    };\n  }; //------------------------------------------------------------------------------\n\n  publicAPI.insertPoint = function (points, newPnt, maxPts, pntId, ptMode, numberOfNodes) {\n    var nbNodes = 0;\n    var pointIdx = pntId;\n    if (model.pointIdSet) {\n      // there has been at least one point index\n      if (model.pointIdSet.length < maxPts || publicAPI.containsDuplicatePointsOnly(newPnt)) {\n        // this leaf node is not full or\n        // this leaf node is full, but of all exactly duplicate points\n        // and the point under check is another duplicate of these points\n        pointIdx = OCTREENODE_INSERTPOINT[ptMode](points, pointIdx, newPnt);\n        model.pointIdSet.push(pointIdx);\n        publicAPI.updateCounterAndDataBoundsRecursively(newPnt, 1, 1, null);\n      } else {\n        // overflow: divide this node and delete the list of point-indices.\n        // Note that the number of exactly duplicate points might be greater\n        // than or equal to maxPts.\n        var _publicAPI$createChil = publicAPI.createChildNodes(points, model.pointIdSet, newPnt, pointIdx, maxPts, ptMode, numberOfNodes);\n        nbNodes = _publicAPI$createChil.numberOfNodes;\n        pointIdx = _publicAPI$createChil.pointIdx;\n        model.pointIdSet = null;\n      }\n    } else {\n      // There has been no any point index registered in this leaf node\n      pointIdx = OCTREENODE_INSERTPOINT[ptMode](points, pointIdx, newPnt);\n      model.pointIdSet = [];\n      model.pointIdSet.push(pointIdx);\n      publicAPI.updateCounterAndDataBoundsRecursively(newPnt, 1, 1, null);\n    }\n    return {\n      numberOfNodes: numberOfNodes + nbNodes,\n      pointIdx: pointIdx\n    };\n  }; //------------------------------------------------------------------------------\n\n  publicAPI.getDistance2ToBoundary = function (point, closest, innerOnly, rootNode, checkData) {\n    // It is mandatory that GetMinDataBounds() and GetMaxDataBounds() be used.\n    // Direct access to MinDataBounds and MaxDataBounds might incur problems.\n    var thisMin = null;\n    var thisMax = null;\n    var rootMin = null;\n    var rootMax = null; // TODO: Check\n    // let minDist = VTK_DOUBLE_MAX;\n\n    var minDist = Number.MAX_VALUE; // minimum distance to the boundaries\n\n    if (checkData) {\n      thisMin = publicAPI.getMinDataBounds();\n      thisMax = publicAPI.getMaxDataBounds();\n      rootMin = rootNode.getMinDataBounds();\n      rootMax = rootNode.getMaxDataBounds();\n    } else {\n      thisMin = model.minBounds;\n      thisMax = model.maxBounds;\n      rootMin = rootNode.getMinBounds();\n      rootMax = rootNode.getMaxBounds();\n    }\n    var minFace = 0; // index of the face with min distance to the point\n\n    var beXless = Number(point[0] < thisMin[0]);\n    var beXmore = Number(point[0] > thisMax[0]);\n    var beYless = Number(point[1] < thisMin[1]);\n    var beYmore = Number(point[1] > thisMax[1]);\n    var beZless = Number(point[2] < thisMin[2]);\n    var beZmore = Number(point[2] > thisMax[2]);\n    var withinX = Number(!beXless && !beXmore);\n    var withinY = Number(!beYless && !beYmore);\n    var withinZ = Number(!beZless && !beZmore); // eslint-disable-next-line no-bitwise\n\n    var xyzFlag = (withinZ << 2) + (withinY << 1) + withinX;\n    switch (xyzFlag) {\n      case 0:\n        {\n          // withinZ = 0; withinY = 0;  withinX = 0\n          // closest to a corner\n          closest[0] = beXless ? thisMin[0] : thisMax[0];\n          closest[1] = beYless ? thisMin[1] : thisMax[1];\n          closest[2] = beZless ? thisMin[2] : thisMax[2];\n          minDist = distance2BetweenPoints(point, closest);\n          break;\n        }\n      case 1:\n        {\n          // withinZ = 0; withinY = 0; withinX = 1\n          // closest to an x-aligned edge\n          closest[0] = point[0];\n          closest[1] = beYless ? thisMin[1] : thisMax[1];\n          closest[2] = beZless ? thisMin[2] : thisMax[2];\n          minDist = distance2BetweenPoints(point, closest);\n          break;\n        }\n      case 2:\n        {\n          // withinZ = 0; withinY = 1; withinX = 0\n          // closest to a y-aligned edge\n          closest[0] = beXless ? thisMin[0] : thisMax[0];\n          closest[1] = point[1];\n          closest[2] = beZless ? thisMin[2] : thisMax[2];\n          minDist = distance2BetweenPoints(point, closest);\n          break;\n        }\n      case 3:\n        {\n          // withinZ = 0; withinY = 1; withinX = 1\n          // closest to a z-face\n          if (beZless) {\n            minDist = thisMin[2] - point[2];\n            closest[2] = thisMin[2];\n          } else {\n            minDist = point[2] - thisMax[2];\n            closest[2] = thisMax[2];\n          }\n          minDist *= minDist;\n          closest[0] = point[0];\n          closest[1] = point[1];\n          break;\n        }\n      case 4:\n        {\n          // withinZ = 1; withinY = 0; withinX = 0\n          // cloest to a z-aligned edge\n          closest[0] = beXless ? thisMin[0] : thisMax[0];\n          closest[1] = beYless ? thisMin[1] : thisMax[1];\n          closest[2] = point[2];\n          minDist = distance2BetweenPoints(point, closest);\n          break;\n        }\n      case 5:\n        {\n          // withinZ = 1; withinY = 0; withinX = 1\n          // closest to a y-face\n          if (beYless) {\n            minDist = thisMin[1] - point[1];\n            closest[1] = thisMin[1];\n          } else {\n            minDist = point[1] - thisMax[1];\n            closest[1] = thisMax[1];\n          }\n          minDist *= minDist;\n          closest[0] = point[0];\n          closest[2] = point[2];\n          break;\n        }\n      case 6:\n        {\n          // withinZ = 1; withinY = 1; withinX = 0\n          // closest to an x-face\n          if (beXless) {\n            minDist = thisMin[0] - point[0];\n            closest[0] = thisMin[0];\n          } else {\n            minDist = point[0] - thisMax[0];\n            closest[0] = thisMax[0];\n          }\n          minDist *= minDist;\n          closest[1] = point[1];\n          closest[2] = point[2];\n          break;\n        }\n      case 7:\n        {\n          // withinZ = 1; withinY = 1;  withinZ = 1\n          // point is inside the box\n          if (innerOnly) {\n            // check only inner boundaries\n            var faceDst;\n            faceDst = point[0] - thisMin[0]; // x-min face\n\n            if (thisMin[0] !== rootMin[0] && faceDst < minDist) {\n              minFace = 0;\n              minDist = faceDst;\n            }\n            faceDst = thisMax[0] - point[0]; // x-max face\n\n            if (thisMax[0] !== rootMax[0] && faceDst < minDist) {\n              minFace = 1;\n              minDist = faceDst;\n            }\n            faceDst = point[1] - thisMin[1]; // y-min face\n\n            if (thisMin[1] !== rootMin[1] && faceDst < minDist) {\n              minFace = 2;\n              minDist = faceDst;\n            }\n            faceDst = thisMax[1] - point[1]; // y-max face\n\n            if (thisMax[1] !== rootMax[1] && faceDst < minDist) {\n              minFace = 3;\n              minDist = faceDst;\n            }\n            faceDst = point[2] - thisMin[2]; // z-min face\n\n            if (thisMin[2] !== rootMin[2] && faceDst < minDist) {\n              minFace = 4;\n              minDist = faceDst;\n            }\n            faceDst = thisMax[2] - point[2]; // z-max face\n\n            if (thisMax[2] !== rootMax[2] && faceDst < minDist) {\n              minFace = 5;\n              minDist = faceDst;\n            }\n          } else {\n            // check all boundaries\n            var tmpDist = [point[0] - thisMin[0], thisMax[0] - point[0], point[1] - thisMin[1], thisMax[1] - point[1], point[2] - thisMin[2], thisMax[2] - point[2]];\n            for (var i = 0; i < 6; i++) {\n              if (tmpDist[i] < minDist) {\n                minFace = i;\n                minDist = tmpDist[i];\n              }\n            }\n          } // no square operation if no any inner boundary\n\n          if (minDist !== Number.MAX_VALUE) {\n            minDist *= minDist;\n          }\n          closest[0] = point[0];\n          closest[1] = point[1];\n          closest[2] = point[2]; // minFace: the quad with the min distance to the point\n          // 0: x-min face  ===>  xyzIndx = 0:  x  and  minFace & 1 = 0:  thisMin\n          // 1: x-max face  ===>  xyzIndx = 0:  x  and  minFace & 1 = 1:  thisMax\n          // 2: y-min face  ===>  xyzIndx = 1:  y  and  minFace & 1 = 0:  thisMin\n          // 3: y-max face  ===>  xyzIndx = 1:  y  and  minFace & 1 = 1:  thisMax\n          // 4: z-min face  ===>  xyzIndx = 2:  z  and  minFace & 1 = 0:  thisMin\n          // 5: z-max face  ===>  xyzIndx = 2:  z  and  minFace & 1 = 1:  thisMax\n\n          var pMinMax = [thisMin, thisMax]; // eslint-disable-next-line no-bitwise\n\n          var xyzIndx = minFace >> 1; // eslint-disable-next-line no-bitwise\n\n          closest[xyzIndx] = pMinMax[minFace & 1][xyzIndx];\n          break;\n        }\n      default:\n        vtkErrorMacro('unexpected case in getDistance2ToBoundary');\n    }\n    return minDist;\n  }; //------------------------------------------------------------------------------\n\n  publicAPI.getDistance2ToInnerBoundary = function (point, rootNode) {\n    var dummy = [];\n    return publicAPI.getDistance2ToBoundary(point, dummy, 0, rootNode, 0);\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nvar DEFAULT_VALUES = {\n  pointIdSet: null,\n  minBounds: null,\n  maxBounds: null,\n  minDataBounds: null,\n  maxDataBounds: null,\n  parent: null,\n  children: null\n}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Make this a VTK object\n\n  macro.obj(publicAPI, model);\n  macro.setGetArray(publicAPI, model, ['minBounds', 'maxBounds', 'minDataBounds', 'maxDataBounds'], 6);\n  macro.get(publicAPI, model, ['pointIdSet', 'numberOfPoints']); // TODO: No get?\n\n  macro.set(publicAPI, model, ['parent']); // Object specific methods\n\n  vtkIncrementalOctreeNode(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = macro.newInstance(extend, 'vtkIncrementalOctreeNode'); // ----------------------------------------------------------------------------\n\nvar vtkIncrementalOctreeNode$1 = {\n  newInstance: newInstance,\n  extend: extend\n};\nexport { vtkIncrementalOctreeNode$1 as default, extend, newInstance };","map":{"version":3,"names":["macro","e","distance2BetweenPoints","vtkErrorMacro","OCTREENODE_INSERTPOINT","points","pointIdx","coords","setTuple","insertNextTuple","OCTREE_CHILD_BOUNDS_LUT","vtkIncrementalOctreeNode","publicAPI","model","classHierarchy","push","createPointIdSet","initSize","growSize","pointIdSet","setBounds","x1","x2","y1","y2","z1","z2","minBounds","maxBounds","minDataBounds","maxDataBounds","getBounds","bounds","getChildIndex","point","Number","children","getMaxBoundsByReference","containsPoint","pnt","containsPointByData","updateCounterAndDataBounds","nHits","updateData","numberOfPoints","updated","updateCounterAndDataBoundsRecursively","endNode","parent","containsDuplicatePointsOnly","isLeaf","getChild","i","separateExactlyDuplicatePointsFromNewInsertion","pntIds","newPnt","pntIdx","maxPts","ptMode","dupPnt","octMin","octMid","octMax","boxPtr","ocNode","duplic","single","getPoint","newInstance","setParent","getPointIdSet","setPointIdSet","length","createChildNodes","numberOfNodes","nbNodes","sample","success","target","dvidId","fullId","numIds","tempPt","tempId","_model$children$targe","insertPoint","pntId","_publicAPI$createChil","getDistance2ToBoundary","closest","innerOnly","rootNode","checkData","thisMin","thisMax","rootMin","rootMax","minDist","MAX_VALUE","getMinDataBounds","getMaxDataBounds","getMinBounds","getMaxBounds","minFace","beXless","beXmore","beYless","beYmore","beZless","beZmore","withinX","withinY","withinZ","xyzFlag","faceDst","tmpDist","pMinMax","xyzIndx","getDistance2ToInnerBoundary","dummy","DEFAULT_VALUES","extend","initialValues","arguments","undefined","Object","assign","obj","setGetArray","get","set","vtkIncrementalOctreeNode$1","default"],"sources":["/home/rakshith/Documents/RemoteRendering/vtk-js-react-app/node_modules/@kitware/vtk.js/Common/DataModel/IncrementalOctreeNode.js"],"sourcesContent":["import macro from '../../macros.js';\nimport { e as distance2BetweenPoints } from '../Core/Math/index.js';\n\nvar vtkErrorMacro = macro.vtkErrorMacro;\nvar OCTREENODE_INSERTPOINT = [function (points, pointIdx, coords) {\n  return pointIdx;\n}, function (points, pointIdx, coords) {\n  points.setTuple(pointIdx, coords);\n  return pointIdx;\n}, function (points, pointIdx, coords) {\n  return points.insertNextTuple(coords);\n}]; // Given the index (0 ~ 7) of a child node, the spatial bounding axis (0 ~ 2\n// for x, y, and z), and the value (0 ~ 1 for min and max) to access, this LUT\n// allows for rapid assignment of its spatial bounding box --- MinBounds[3]\n// and MaxBounds[3], with each specific value or entry of this LUT pointing to\n// MinBounds[3] for 0, center point for 1, or MaxBounds[3] for 2.\n\nvar OCTREE_CHILD_BOUNDS_LUT = [[[0, 1], [0, 1], [0, 1]], [[1, 2], [0, 1], [0, 1]], [[0, 1], [1, 2], [0, 1]], [[1, 2], [1, 2], [0, 1]], [[0, 1], [0, 1], [1, 2]], [[1, 2], [0, 1], [1, 2]], [[0, 1], [1, 2], [1, 2]], [[1, 2], [1, 2], [1, 2]]];\n\nfunction vtkIncrementalOctreeNode(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkIncrementalOctreeNode'); //------------------------------------------------------------------------------\n\n  publicAPI.createPointIdSet = function (initSize, growSize) {\n    if (model.pointIdSet == null) {\n      model.pointIdSet = []; // TODO: use initSize and growSize.\n      // model.pointIdSet.allocate(initSize, growSize);\n    }\n  }; //------------------------------------------------------------------------------\n\n\n  publicAPI.setBounds = function (x1, x2, y1, y2, z1, z2) {\n    if (model.minBounds == null) model.minBounds = [];\n    if (model.maxBounds == null) model.maxBounds = [];\n    if (model.minDataBounds == null) model.minDataBounds = [];\n    if (model.maxDataBounds == null) model.maxDataBounds = [];\n    model.minBounds[0] = x1;\n    model.maxBounds[0] = x2;\n    model.minBounds[1] = y1;\n    model.maxBounds[1] = y2;\n    model.minBounds[2] = z1;\n    model.maxBounds[2] = z2;\n    model.minDataBounds[0] = x2;\n    model.maxDataBounds[0] = x1;\n    model.minDataBounds[1] = y2;\n    model.maxDataBounds[1] = y1;\n    model.minDataBounds[2] = z2;\n    model.maxDataBounds[2] = z1;\n  }; //------------------------------------------------------------------------------\n\n\n  publicAPI.getBounds = function (bounds) {\n    bounds[0] = model.minBounds[0];\n    bounds[1] = model.maxBounds[0];\n    bounds[2] = model.minBounds[1];\n    bounds[3] = model.maxBounds[1];\n    bounds[4] = model.minBounds[2];\n    bounds[5] = model.maxBounds[2];\n  };\n\n  publicAPI.getChildIndex = function (point) {\n    return Number(point[0] > model.children[0].getMaxBoundsByReference()[0]) + ( // eslint-disable-next-line no-bitwise\n    Number(point[1] > model.children[0].getMaxBoundsByReference()[1]) << 1) + ( // eslint-disable-next-line no-bitwise\n    Number(point[2] > model.children[0].getMaxBoundsByReference()[2]) << 2);\n  };\n\n  publicAPI.containsPoint = function (pnt) {\n    return model.minBounds[0] < pnt[0] && pnt[0] <= model.maxBounds[0] && model.minBounds[1] < pnt[1] && pnt[1] <= model.maxBounds[1] && model.minBounds[2] < pnt[2] && pnt[2] <= model.maxBounds[2] ? 1 : 0;\n  };\n\n  publicAPI.containsPointByData = function (pnt) {\n    return model.minDataBounds[0] <= pnt[0] && pnt[0] <= model.maxDataBounds[0] && model.minDataBounds[1] <= pnt[1] && pnt[1] <= model.maxDataBounds[1] && model.minDataBounds[2] <= pnt[2] && pnt[2] <= model.maxDataBounds[2] ? 1 : 0;\n  }; //------------------------------------------------------------------------------\n\n\n  publicAPI.updateCounterAndDataBounds = function (point, nHits, updateData) {\n    model.numberOfPoints += nHits;\n    if (!updateData) return false;\n    var updated = false;\n\n    if (point[0] < model.minDataBounds[0]) {\n      updated = true;\n      model.minDataBounds[0] = point[0];\n    }\n\n    if (point[0] > model.maxDataBounds[0]) {\n      updated = true;\n      model.maxDataBounds[0] = point[0];\n    }\n\n    if (point[1] < model.minDataBounds[1]) {\n      updated = true;\n      model.minDataBounds[1] = point[1];\n    }\n\n    if (point[1] > model.maxDataBounds[1]) {\n      updated = true;\n      model.maxDataBounds[1] = point[1];\n    }\n\n    if (point[2] < model.minDataBounds[2]) {\n      updated = true;\n      model.minDataBounds[2] = point[2];\n    }\n\n    if (point[2] > model.maxDataBounds[2]) {\n      updated = true;\n      model.maxDataBounds[2] = point[2];\n    }\n\n    return updated;\n  }; //------------------------------------------------------------------------------\n\n\n  publicAPI.updateCounterAndDataBoundsRecursively = function (point, nHits, updateData, endNode) {\n    var updated = publicAPI.updateCounterAndDataBounds(point, nHits, updateData);\n    return model.parent === endNode ? updated : model.parent.updateCounterAndDataBoundsRecursively(point, nHits, updated, endNode);\n  }; //------------------------------------------------------------------------------\n\n\n  publicAPI.containsDuplicatePointsOnly = function (point) {\n    return model.minDataBounds[0] === point[0] && point[0] === model.maxDataBounds[0] && model.minDataBounds[1] === point[1] && point[1] === model.maxDataBounds[1] && model.minDataBounds[2] === point[2] && point[2] === model.maxDataBounds[2];\n  }; //------------------------------------------------------------------------------\n\n\n  publicAPI.isLeaf = function () {\n    return model.children == null;\n  }; //------------------------------------------------------------------------------\n\n\n  publicAPI.getChild = function (i) {\n    return model.children[i];\n  }; //------------------------------------------------------------------------------\n\n  /* eslint-disable no-use-before-define */\n\n\n  publicAPI.separateExactlyDuplicatePointsFromNewInsertion = function (points, pntIds, newPnt, pntIdx, maxPts, ptMode) {\n    // the number of points already maintained in this leaf node\n    // >= maxPts AND all of them are exactly duplicate with one another\n    //           BUT the new point is not a duplicate of them any more\n    var pointIdx = pntIdx;\n    var i;\n    var dupPnt = [0.0, 0.0, 0.0];\n    var octMin = [0.0, 0.0, 0.0];\n    var octMid = [0.0, 0.0, 0.0];\n    var octMax = [0.0, 0.0, 0.0];\n    var boxPtr = [null, null, null];\n    var ocNode = null;\n    var duplic = publicAPI;\n    var single = publicAPI; // the coordinate of the duplicate points: note pntIds == model.pointIdSet\n\n    points.getPoint(pntIds[0], dupPnt);\n\n    while (duplic === single) {\n      // as long as separation has not been achieved\n      // update the current (in recursion) node and access the bounding box info\n      ocNode = duplic;\n      octMid[0] = (ocNode.minBounds[0] + ocNode.maxBounds[0]) * 0.5;\n      octMid[1] = (ocNode.minBounds[1] + ocNode.maxBounds[1]) * 0.5;\n      octMid[2] = (ocNode.minBounds[2] + ocNode.maxBounds[2]) * 0.5;\n      boxPtr[0] = ocNode.minBounds;\n      boxPtr[1] = octMid;\n      boxPtr[2] = ocNode.maxBounds; // create eight child nodes\n      // FIXME: May be too slow to use vtk newInstance()\n\n      ocNode.children = [newInstance(), newInstance(), newInstance(), newInstance(), newInstance(), newInstance(), newInstance(), newInstance()];\n\n      for (i = 0; i < 8; i++) {\n        // x-bound: axis 0\n        octMin[0] = boxPtr[OCTREE_CHILD_BOUNDS_LUT[i][0][0]][0];\n        octMax[0] = boxPtr[OCTREE_CHILD_BOUNDS_LUT[i][0][1]][0]; // y-bound: axis 1\n\n        octMin[1] = boxPtr[OCTREE_CHILD_BOUNDS_LUT[i][1][0]][1];\n        octMax[1] = boxPtr[OCTREE_CHILD_BOUNDS_LUT[i][1][1]][1]; // z-bound: axis 2\n\n        octMin[2] = boxPtr[OCTREE_CHILD_BOUNDS_LUT[i][2][0]][2];\n        octMax[2] = boxPtr[OCTREE_CHILD_BOUNDS_LUT[i][2][1]][2];\n        ocNode.children[i] = newInstance();\n        ocNode.children[i].setParent(ocNode);\n        ocNode.children[i].setBounds(octMin[0], octMax[0], octMin[1], octMax[1], octMin[2], octMax[2]);\n      } // determine the leaf node of the duplicate points & that of the new point\n\n\n      duplic = ocNode.children[ocNode.getChildIndex(dupPnt)];\n      single = ocNode.children[ocNode.getChildIndex(newPnt)];\n    } // Now the duplicate points have been separated from the new point //\n    // create a vtkIdList object for the new point\n    // update the counter and the data bounding box until the root node\n    // (including the root node)\n\n\n    pointIdx = OCTREENODE_INSERTPOINT[ptMode](points, pointIdx, newPnt); // eslint-disable-next-line no-bitwise\n\n    single.createPointIdSet(maxPts >> 2, maxPts >> 1);\n    single.getPointIdSet().push(pointIdx);\n    single.updateCounterAndDataBoundsRecursively(newPnt, 1, 1, null); // We just need to reference pntIds while un-registering it from 'this'.\n    // This avoids deep-copying point ids from pntIds to duplic's PointIdSet.\n    // update the counter and the data bounding box, but until 'this' node\n    // (excluding 'this' node)\n\n    duplic.setPointIdSet(pntIds);\n    duplic.updateCounterAndDataBoundsRecursively(dupPnt, pntIds.length, 1, publicAPI);\n    return pointIdx;\n  };\n  /* eslint-enable no-use-before-define */\n  //------------------------------------------------------------------------------\n\n\n  publicAPI.createChildNodes = function (points, pntIds, newPnt, pntIdx, maxPts, ptMode, numberOfNodes) {\n    // There are two scenarios for which this function is invoked.\n    //\n    // (1) the number of points already maintained in this leaf node\n    //     == maxPts AND not all of them are exactly duplicate\n    //               AND the new point is not a duplicate of them all\n    // (2) the number of points already maintained in this leaf node\n    //     >= maxPts AND all of them are exactly duplicate with one another\n    //               BUT the new point is not a duplicate of them any more\n    // address case (2) first if necessary\n    var nbNodes = numberOfNodes;\n    var pointIdx = pntIdx;\n    var sample = [];\n    points.getPoint(pntIds[0], sample);\n\n    if (publicAPI.containsDuplicatePointsOnly(sample)) {\n      pointIdx = publicAPI.separateExactlyDuplicatePointsFromNewInsertion(points, pntIds, newPnt, pointIdx, maxPts, ptMode);\n      return {\n        success: false,\n        nbNodes: nbNodes,\n        pointIdx: pointIdx\n      };\n    } // then address case (1) below\n\n\n    var i;\n    var target;\n    var dvidId = -1; // index of the sub-dividing octant, if any\n\n    var fullId = -1; // index of the full octant, if any\n\n    var numIds = [0, 0, 0, 0, 0, 0, 0, 0];\n    var octMin = [];\n    var octMax = [];\n    var tempPt = [];\n    var tempId;\n    var octMid = [(model.minBounds[0] + model.maxBounds[0]) * 0.5, (model.minBounds[1] + model.maxBounds[1]) * 0.5, (model.minBounds[2] + model.maxBounds[2]) * 0.5];\n    var boxPtr = [model.minBounds, octMid, model.maxBounds]; // create eight child nodes\n\n    model.children = [];\n\n    for (i = 0; i < 8; i++) {\n      // x-bound: axis 0\n      octMin[0] = boxPtr[OCTREE_CHILD_BOUNDS_LUT[i][0][0]][0];\n      octMax[0] = boxPtr[OCTREE_CHILD_BOUNDS_LUT[i][0][1]][0]; // y-bound: axis 1\n\n      octMin[1] = boxPtr[OCTREE_CHILD_BOUNDS_LUT[i][1][0]][1];\n      octMax[1] = boxPtr[OCTREE_CHILD_BOUNDS_LUT[i][1][1]][1]; // z-bound: axis 2\n\n      octMin[2] = boxPtr[OCTREE_CHILD_BOUNDS_LUT[i][2][0]][2];\n      octMax[2] = boxPtr[OCTREE_CHILD_BOUNDS_LUT[i][2][1]][2]; // This call internally sets the cener and default data bounding box, too.\n      // eslint-disable-next-line no-use-before-define\n\n      model.children[i] = newInstance(); // model.children[i].iD = nbNodes++;\n\n      model.children[i].setParent(publicAPI);\n      model.children[i].setBounds(octMin[0], octMax[0], octMin[1], octMax[1], octMin[2], octMax[2]); // allocate a list of point-indices (size = 2^n) for index registration\n      // eslint-disable-next-line no-bitwise\n\n      model.children[i].createPointIdSet(maxPts >> 2, maxPts >> 1);\n    }\n\n    boxPtr[0] = null;\n    boxPtr[1] = null;\n    boxPtr[2] = null; // distribute the available point-indices to the eight child nodes\n\n    for (i = 0; i < maxPts; i++) {\n      tempId = pntIds[i];\n      points.getPoint(tempId, tempPt);\n      target = publicAPI.getChildIndex(tempPt);\n      model.children[target].getPointIdSet().push(tempId);\n      model.children[target].updateCounterAndDataBounds(tempPt);\n      numIds[target]++;\n    } // locate the full child, just if any\n\n\n    for (i = 0; i < 8; i++) {\n      if (numIds[i] === maxPts) {\n        fullId = i;\n        break;\n      }\n    }\n\n    target = publicAPI.getChildIndex(newPnt);\n\n    if (fullId === target) {\n      // The fact is that we are going to insert the new point to an already\n      // full octant (child node). Thus we need to further divide this child\n      // to avoid the overflow problem.\n      var _model$children$targe = model.children[target].createChildNodes(points, pntIds, newPnt, pointIdx, maxPts, ptMode, nbNodes);\n\n      nbNodes = _model$children$targe.numberOfNodes;\n      pointIdx = _model$children$targe.pointIdx;\n      dvidId = fullId;\n    } else {\n      // the initial division is a success\n      pointIdx = OCTREENODE_INSERTPOINT[ptMode](points, pointIdx, newPnt);\n      model.children[target].getPointIdSet().push(pointIdx);\n      model.children[target].updateCounterAndDataBoundsRecursively(newPnt, 1, 1, null); // NOTE: The counter below might reach the threshold, though we delay the\n      // sub-division of this child node until the next point insertion occurs.\n\n      numIds[target]++;\n    } // Now it is time to reclaim those un-used vtkIdList objects, of which each\n    // either is empty or still needs to be deleted due to further division of\n    // the child node. This post-deallocation of the un-used vtkIdList objects\n    // (of some child nodes) is based on the assumption that retrieving the\n    // 'maxPts' points from vtkPoints and the associated 'maxPts' point-indices\n    // from vtkIdList is more expensive than reclaiming at most 8 vtkIdList\n    // objects at hand.\n\n\n    for (i = 0; i < 8; i++) {\n      if (numIds[i] === 0 || i === dvidId) {\n        model.children[i].getPointIdSet().length = 0;\n      }\n    } // notify vtkIncrementalOctreeNode::InsertPoint() to destroy pntIds\n\n\n    return {\n      success: true,\n      numberOfNodes: nbNodes,\n      pointIdx: pointIdx\n    };\n  }; //------------------------------------------------------------------------------\n\n\n  publicAPI.insertPoint = function (points, newPnt, maxPts, pntId, ptMode, numberOfNodes) {\n    var nbNodes = 0;\n    var pointIdx = pntId;\n\n    if (model.pointIdSet) {\n      // there has been at least one point index\n      if (model.pointIdSet.length < maxPts || publicAPI.containsDuplicatePointsOnly(newPnt)) {\n        // this leaf node is not full or\n        // this leaf node is full, but of all exactly duplicate points\n        // and the point under check is another duplicate of these points\n        pointIdx = OCTREENODE_INSERTPOINT[ptMode](points, pointIdx, newPnt);\n        model.pointIdSet.push(pointIdx);\n        publicAPI.updateCounterAndDataBoundsRecursively(newPnt, 1, 1, null);\n      } else {\n        // overflow: divide this node and delete the list of point-indices.\n        // Note that the number of exactly duplicate points might be greater\n        // than or equal to maxPts.\n        var _publicAPI$createChil = publicAPI.createChildNodes(points, model.pointIdSet, newPnt, pointIdx, maxPts, ptMode, numberOfNodes);\n\n        nbNodes = _publicAPI$createChil.numberOfNodes;\n        pointIdx = _publicAPI$createChil.pointIdx;\n        model.pointIdSet = null;\n      }\n    } else {\n      // There has been no any point index registered in this leaf node\n      pointIdx = OCTREENODE_INSERTPOINT[ptMode](points, pointIdx, newPnt);\n      model.pointIdSet = [];\n      model.pointIdSet.push(pointIdx);\n      publicAPI.updateCounterAndDataBoundsRecursively(newPnt, 1, 1, null);\n    }\n\n    return {\n      numberOfNodes: numberOfNodes + nbNodes,\n      pointIdx: pointIdx\n    };\n  }; //------------------------------------------------------------------------------\n\n\n  publicAPI.getDistance2ToBoundary = function (point, closest, innerOnly, rootNode, checkData) {\n    // It is mandatory that GetMinDataBounds() and GetMaxDataBounds() be used.\n    // Direct access to MinDataBounds and MaxDataBounds might incur problems.\n    var thisMin = null;\n    var thisMax = null;\n    var rootMin = null;\n    var rootMax = null; // TODO: Check\n    // let minDist = VTK_DOUBLE_MAX;\n\n    var minDist = Number.MAX_VALUE; // minimum distance to the boundaries\n\n    if (checkData) {\n      thisMin = publicAPI.getMinDataBounds();\n      thisMax = publicAPI.getMaxDataBounds();\n      rootMin = rootNode.getMinDataBounds();\n      rootMax = rootNode.getMaxDataBounds();\n    } else {\n      thisMin = model.minBounds;\n      thisMax = model.maxBounds;\n      rootMin = rootNode.getMinBounds();\n      rootMax = rootNode.getMaxBounds();\n    }\n\n    var minFace = 0; // index of the face with min distance to the point\n\n    var beXless = Number(point[0] < thisMin[0]);\n    var beXmore = Number(point[0] > thisMax[0]);\n    var beYless = Number(point[1] < thisMin[1]);\n    var beYmore = Number(point[1] > thisMax[1]);\n    var beZless = Number(point[2] < thisMin[2]);\n    var beZmore = Number(point[2] > thisMax[2]);\n    var withinX = Number(!beXless && !beXmore);\n    var withinY = Number(!beYless && !beYmore);\n    var withinZ = Number(!beZless && !beZmore); // eslint-disable-next-line no-bitwise\n\n    var xyzFlag = (withinZ << 2) + (withinY << 1) + withinX;\n\n    switch (xyzFlag) {\n      case 0:\n        {\n          // withinZ = 0; withinY = 0;  withinX = 0\n          // closest to a corner\n          closest[0] = beXless ? thisMin[0] : thisMax[0];\n          closest[1] = beYless ? thisMin[1] : thisMax[1];\n          closest[2] = beZless ? thisMin[2] : thisMax[2];\n          minDist = distance2BetweenPoints(point, closest);\n          break;\n        }\n\n      case 1:\n        {\n          // withinZ = 0; withinY = 0; withinX = 1\n          // closest to an x-aligned edge\n          closest[0] = point[0];\n          closest[1] = beYless ? thisMin[1] : thisMax[1];\n          closest[2] = beZless ? thisMin[2] : thisMax[2];\n          minDist = distance2BetweenPoints(point, closest);\n          break;\n        }\n\n      case 2:\n        {\n          // withinZ = 0; withinY = 1; withinX = 0\n          // closest to a y-aligned edge\n          closest[0] = beXless ? thisMin[0] : thisMax[0];\n          closest[1] = point[1];\n          closest[2] = beZless ? thisMin[2] : thisMax[2];\n          minDist = distance2BetweenPoints(point, closest);\n          break;\n        }\n\n      case 3:\n        {\n          // withinZ = 0; withinY = 1; withinX = 1\n          // closest to a z-face\n          if (beZless) {\n            minDist = thisMin[2] - point[2];\n            closest[2] = thisMin[2];\n          } else {\n            minDist = point[2] - thisMax[2];\n            closest[2] = thisMax[2];\n          }\n\n          minDist *= minDist;\n          closest[0] = point[0];\n          closest[1] = point[1];\n          break;\n        }\n\n      case 4:\n        {\n          // withinZ = 1; withinY = 0; withinX = 0\n          // cloest to a z-aligned edge\n          closest[0] = beXless ? thisMin[0] : thisMax[0];\n          closest[1] = beYless ? thisMin[1] : thisMax[1];\n          closest[2] = point[2];\n          minDist = distance2BetweenPoints(point, closest);\n          break;\n        }\n\n      case 5:\n        {\n          // withinZ = 1; withinY = 0; withinX = 1\n          // closest to a y-face\n          if (beYless) {\n            minDist = thisMin[1] - point[1];\n            closest[1] = thisMin[1];\n          } else {\n            minDist = point[1] - thisMax[1];\n            closest[1] = thisMax[1];\n          }\n\n          minDist *= minDist;\n          closest[0] = point[0];\n          closest[2] = point[2];\n          break;\n        }\n\n      case 6:\n        {\n          // withinZ = 1; withinY = 1; withinX = 0\n          // closest to an x-face\n          if (beXless) {\n            minDist = thisMin[0] - point[0];\n            closest[0] = thisMin[0];\n          } else {\n            minDist = point[0] - thisMax[0];\n            closest[0] = thisMax[0];\n          }\n\n          minDist *= minDist;\n          closest[1] = point[1];\n          closest[2] = point[2];\n          break;\n        }\n\n      case 7:\n        {\n          // withinZ = 1; withinY = 1;  withinZ = 1\n          // point is inside the box\n          if (innerOnly) {\n            // check only inner boundaries\n            var faceDst;\n            faceDst = point[0] - thisMin[0]; // x-min face\n\n            if (thisMin[0] !== rootMin[0] && faceDst < minDist) {\n              minFace = 0;\n              minDist = faceDst;\n            }\n\n            faceDst = thisMax[0] - point[0]; // x-max face\n\n            if (thisMax[0] !== rootMax[0] && faceDst < minDist) {\n              minFace = 1;\n              minDist = faceDst;\n            }\n\n            faceDst = point[1] - thisMin[1]; // y-min face\n\n            if (thisMin[1] !== rootMin[1] && faceDst < minDist) {\n              minFace = 2;\n              minDist = faceDst;\n            }\n\n            faceDst = thisMax[1] - point[1]; // y-max face\n\n            if (thisMax[1] !== rootMax[1] && faceDst < minDist) {\n              minFace = 3;\n              minDist = faceDst;\n            }\n\n            faceDst = point[2] - thisMin[2]; // z-min face\n\n            if (thisMin[2] !== rootMin[2] && faceDst < minDist) {\n              minFace = 4;\n              minDist = faceDst;\n            }\n\n            faceDst = thisMax[2] - point[2]; // z-max face\n\n            if (thisMax[2] !== rootMax[2] && faceDst < minDist) {\n              minFace = 5;\n              minDist = faceDst;\n            }\n          } else {\n            // check all boundaries\n            var tmpDist = [point[0] - thisMin[0], thisMax[0] - point[0], point[1] - thisMin[1], thisMax[1] - point[1], point[2] - thisMin[2], thisMax[2] - point[2]];\n\n            for (var i = 0; i < 6; i++) {\n              if (tmpDist[i] < minDist) {\n                minFace = i;\n                minDist = tmpDist[i];\n              }\n            }\n          } // no square operation if no any inner boundary\n\n\n          if (minDist !== Number.MAX_VALUE) {\n            minDist *= minDist;\n          }\n\n          closest[0] = point[0];\n          closest[1] = point[1];\n          closest[2] = point[2]; // minFace: the quad with the min distance to the point\n          // 0: x-min face  ===>  xyzIndx = 0:  x  and  minFace & 1 = 0:  thisMin\n          // 1: x-max face  ===>  xyzIndx = 0:  x  and  minFace & 1 = 1:  thisMax\n          // 2: y-min face  ===>  xyzIndx = 1:  y  and  minFace & 1 = 0:  thisMin\n          // 3: y-max face  ===>  xyzIndx = 1:  y  and  minFace & 1 = 1:  thisMax\n          // 4: z-min face  ===>  xyzIndx = 2:  z  and  minFace & 1 = 0:  thisMin\n          // 5: z-max face  ===>  xyzIndx = 2:  z  and  minFace & 1 = 1:  thisMax\n\n          var pMinMax = [thisMin, thisMax]; // eslint-disable-next-line no-bitwise\n\n          var xyzIndx = minFace >> 1; // eslint-disable-next-line no-bitwise\n\n          closest[xyzIndx] = pMinMax[minFace & 1][xyzIndx];\n          break;\n        }\n\n      default:\n        vtkErrorMacro('unexpected case in getDistance2ToBoundary');\n    }\n\n    return minDist;\n  }; //------------------------------------------------------------------------------\n\n\n  publicAPI.getDistance2ToInnerBoundary = function (point, rootNode) {\n    var dummy = [];\n    return publicAPI.getDistance2ToBoundary(point, dummy, 0, rootNode, 0);\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\n\nvar DEFAULT_VALUES = {\n  pointIdSet: null,\n  minBounds: null,\n  maxBounds: null,\n  minDataBounds: null,\n  maxDataBounds: null,\n  parent: null,\n  children: null\n}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Make this a VTK object\n\n  macro.obj(publicAPI, model);\n  macro.setGetArray(publicAPI, model, ['minBounds', 'maxBounds', 'minDataBounds', 'maxDataBounds'], 6);\n  macro.get(publicAPI, model, ['pointIdSet', 'numberOfPoints']); // TODO: No get?\n\n  macro.set(publicAPI, model, ['parent']); // Object specific methods\n\n  vtkIncrementalOctreeNode(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = macro.newInstance(extend, 'vtkIncrementalOctreeNode'); // ----------------------------------------------------------------------------\n\nvar vtkIncrementalOctreeNode$1 = {\n  newInstance: newInstance,\n  extend: extend\n};\n\nexport { vtkIncrementalOctreeNode$1 as default, extend, newInstance };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}