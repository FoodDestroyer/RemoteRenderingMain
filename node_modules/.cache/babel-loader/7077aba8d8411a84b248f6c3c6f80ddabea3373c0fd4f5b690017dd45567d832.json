{"ast":null,"code":"import macro from '../../macros.js';\nimport vtkDataArray from '../../Common/Core/DataArray.js';\nimport vtkEdgeLocator from '../../Common/DataModel/EdgeLocator.js';\nimport vtkPolyData from '../../Common/DataModel/PolyData.js';\nimport { l as normalize } from '../../Common/Core/Math/index.js';\nimport vtkCaseTable from './ImageMarchingCubes/caseTable.js';\nvar vtkErrorMacro = macro.vtkErrorMacro,\n  vtkDebugMacro = macro.vtkDebugMacro; // ----------------------------------------------------------------------------\n// vtkImageMarchingCubes methods\n// ----------------------------------------------------------------------------\n\nfunction vtkImageMarchingCubes(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkImageMarchingCubes');\n  var ids = [];\n  var voxelScalars = [];\n  var voxelGradients = [];\n  var voxelPts = [];\n  var edgeLocator = vtkEdgeLocator.newInstance(); // Retrieve scalars and voxel coordinates. i-j-k is origin of voxel.\n\n  publicAPI.getVoxelScalars = function (i, j, k, slice, dims, origin, spacing, s) {\n    // First get the indices for the voxel\n    ids[0] = k * slice + j * dims[0] + i; // i, j, k\n\n    ids[1] = ids[0] + 1; // i+1, j, k\n\n    ids[2] = ids[0] + dims[0]; // i, j+1, k\n\n    ids[3] = ids[2] + 1; // i+1, j+1, k\n\n    ids[4] = ids[0] + slice; // i, j, k+1\n\n    ids[5] = ids[4] + 1; // i+1, j, k+1\n\n    ids[6] = ids[4] + dims[0]; // i, j+1, k+1\n\n    ids[7] = ids[6] + 1; // i+1, j+1, k+1\n    // Now retrieve the scalars\n\n    for (var ii = 0; ii < 8; ++ii) {\n      voxelScalars[ii] = s[ids[ii]];\n    }\n  }; // Retrieve voxel coordinates. i-j-k is origin of voxel.\n\n  publicAPI.getVoxelPoints = function (i, j, k, origin, spacing) {\n    // (i,i+1),(j,j+1),(k,k+1) - i varies fastest; then j; then k\n    voxelPts[0] = origin[0] + i * spacing[0]; // 0\n\n    voxelPts[1] = origin[1] + j * spacing[1];\n    voxelPts[2] = origin[2] + k * spacing[2];\n    voxelPts[3] = voxelPts[0] + spacing[0]; // 1\n\n    voxelPts[4] = voxelPts[1];\n    voxelPts[5] = voxelPts[2];\n    voxelPts[6] = voxelPts[0]; // 2\n\n    voxelPts[7] = voxelPts[1] + spacing[1];\n    voxelPts[8] = voxelPts[2];\n    voxelPts[9] = voxelPts[3]; // 3\n\n    voxelPts[10] = voxelPts[7];\n    voxelPts[11] = voxelPts[2];\n    voxelPts[12] = voxelPts[0]; // 4\n\n    voxelPts[13] = voxelPts[1];\n    voxelPts[14] = voxelPts[2] + spacing[2];\n    voxelPts[15] = voxelPts[3]; // 5\n\n    voxelPts[16] = voxelPts[1];\n    voxelPts[17] = voxelPts[14];\n    voxelPts[18] = voxelPts[0]; // 6\n\n    voxelPts[19] = voxelPts[7];\n    voxelPts[20] = voxelPts[14];\n    voxelPts[21] = voxelPts[3]; // 7\n\n    voxelPts[22] = voxelPts[7];\n    voxelPts[23] = voxelPts[14];\n  }; // Compute point gradient at i-j-k location\n\n  publicAPI.getPointGradient = function (i, j, k, dims, slice, spacing, s, g) {\n    var sp;\n    var sm; // x-direction\n\n    if (i === 0) {\n      sp = s[i + 1 + j * dims[0] + k * slice];\n      sm = s[i + j * dims[0] + k * slice];\n      g[0] = (sm - sp) / spacing[0];\n    } else if (i === dims[0] - 1) {\n      sp = s[i + j * dims[0] + k * slice];\n      sm = s[i - 1 + j * dims[0] + k * slice];\n      g[0] = (sm - sp) / spacing[0];\n    } else {\n      sp = s[i + 1 + j * dims[0] + k * slice];\n      sm = s[i - 1 + j * dims[0] + k * slice];\n      g[0] = 0.5 * (sm - sp) / spacing[0];\n    } // y-direction\n\n    if (j === 0) {\n      sp = s[i + (j + 1) * dims[0] + k * slice];\n      sm = s[i + j * dims[0] + k * slice];\n      g[1] = (sm - sp) / spacing[1];\n    } else if (j === dims[1] - 1) {\n      sp = s[i + j * dims[0] + k * slice];\n      sm = s[i + (j - 1) * dims[0] + k * slice];\n      g[1] = (sm - sp) / spacing[1];\n    } else {\n      sp = s[i + (j + 1) * dims[0] + k * slice];\n      sm = s[i + (j - 1) * dims[0] + k * slice];\n      g[1] = 0.5 * (sm - sp) / spacing[1];\n    } // z-direction\n\n    if (k === 0) {\n      sp = s[i + j * dims[0] + (k + 1) * slice];\n      sm = s[i + j * dims[0] + k * slice];\n      g[2] = (sm - sp) / spacing[2];\n    } else if (k === dims[2] - 1) {\n      sp = s[i + j * dims[0] + k * slice];\n      sm = s[i + j * dims[0] + (k - 1) * slice];\n      g[2] = (sm - sp) / spacing[2];\n    } else {\n      sp = s[i + j * dims[0] + (k + 1) * slice];\n      sm = s[i + j * dims[0] + (k - 1) * slice];\n      g[2] = 0.5 * (sm - sp) / spacing[2];\n    }\n  }; // Compute voxel gradient values. I-j-k is origin point of voxel.\n\n  publicAPI.getVoxelGradients = function (i, j, k, dims, slice, spacing, scalars) {\n    var g = [];\n    publicAPI.getPointGradient(i, j, k, dims, slice, spacing, scalars, g);\n    voxelGradients[0] = g[0];\n    voxelGradients[1] = g[1];\n    voxelGradients[2] = g[2];\n    publicAPI.getPointGradient(i + 1, j, k, dims, slice, spacing, scalars, g);\n    voxelGradients[3] = g[0];\n    voxelGradients[4] = g[1];\n    voxelGradients[5] = g[2];\n    publicAPI.getPointGradient(i, j + 1, k, dims, slice, spacing, scalars, g);\n    voxelGradients[6] = g[0];\n    voxelGradients[7] = g[1];\n    voxelGradients[8] = g[2];\n    publicAPI.getPointGradient(i + 1, j + 1, k, dims, slice, spacing, scalars, g);\n    voxelGradients[9] = g[0];\n    voxelGradients[10] = g[1];\n    voxelGradients[11] = g[2];\n    publicAPI.getPointGradient(i, j, k + 1, dims, slice, spacing, scalars, g);\n    voxelGradients[12] = g[0];\n    voxelGradients[13] = g[1];\n    voxelGradients[14] = g[2];\n    publicAPI.getPointGradient(i + 1, j, k + 1, dims, slice, spacing, scalars, g);\n    voxelGradients[15] = g[0];\n    voxelGradients[16] = g[1];\n    voxelGradients[17] = g[2];\n    publicAPI.getPointGradient(i, j + 1, k + 1, dims, slice, spacing, scalars, g);\n    voxelGradients[18] = g[0];\n    voxelGradients[19] = g[1];\n    voxelGradients[20] = g[2];\n    publicAPI.getPointGradient(i + 1, j + 1, k + 1, dims, slice, spacing, scalars, g);\n    voxelGradients[21] = g[0];\n    voxelGradients[22] = g[1];\n    voxelGradients[23] = g[2];\n  };\n  publicAPI.produceTriangles = function (cVal, i, j, k, extent, slice, dims, origin, spacing, scalars, points, tris, normals) {\n    var CASE_MASK = [1, 2, 4, 8, 16, 32, 64, 128];\n    var VERT_MAP = [0, 1, 3, 2, 4, 5, 7, 6];\n    var xyz = [];\n    var n = [];\n    var pId;\n    publicAPI.getVoxelScalars(i, j, k, slice, dims, origin, spacing, scalars);\n    var index = 0;\n    for (var idx = 0; idx < 8; idx++) {\n      if (voxelScalars[VERT_MAP[idx]] >= cVal) {\n        index |= CASE_MASK[idx]; // eslint-disable-line no-bitwise\n      }\n    }\n\n    var voxelTris = vtkCaseTable.getCase(index);\n    if (voxelTris[0] < 0) {\n      return; // don't get the voxel coordinates, nothing to do\n    }\n\n    publicAPI.getVoxelPoints(i + extent[0], j + extent[2], k + extent[4], origin, spacing);\n    if (model.computeNormals) {\n      publicAPI.getVoxelGradients(i, j, k, dims, slice, spacing, scalars);\n    }\n    for (var _idx = 0; voxelTris[_idx] >= 0; _idx += 3) {\n      tris.push(3);\n      for (var eid = 0; eid < 3; eid++) {\n        var edgeVerts = vtkCaseTable.getEdge(voxelTris[_idx + eid]);\n        pId = undefined;\n        if (model.mergePoints) {\n          var _edgeLocator$isInsert;\n          pId = (_edgeLocator$isInsert = edgeLocator.isInsertedEdge(ids[edgeVerts[0]], ids[edgeVerts[1]])) === null || _edgeLocator$isInsert === void 0 ? void 0 : _edgeLocator$isInsert.value;\n        }\n        if (pId === undefined) {\n          var t = (cVal - voxelScalars[edgeVerts[0]]) / (voxelScalars[edgeVerts[1]] - voxelScalars[edgeVerts[0]]);\n          var x0 = voxelPts.slice(edgeVerts[0] * 3, (edgeVerts[0] + 1) * 3);\n          var x1 = voxelPts.slice(edgeVerts[1] * 3, (edgeVerts[1] + 1) * 3);\n          xyz[0] = x0[0] + t * (x1[0] - x0[0]);\n          xyz[1] = x0[1] + t * (x1[1] - x0[1]);\n          xyz[2] = x0[2] + t * (x1[2] - x0[2]);\n          pId = points.length / 3;\n          points.push(xyz[0], xyz[1], xyz[2]);\n          if (model.computeNormals) {\n            var n0 = voxelGradients.slice(edgeVerts[0] * 3, (edgeVerts[0] + 1) * 3);\n            var n1 = voxelGradients.slice(edgeVerts[1] * 3, (edgeVerts[1] + 1) * 3);\n            n[0] = n0[0] + t * (n1[0] - n0[0]);\n            n[1] = n0[1] + t * (n1[1] - n0[1]);\n            n[2] = n0[2] + t * (n1[2] - n0[2]);\n            normalize(n);\n            normals.push(n[0], n[1], n[2]);\n          }\n          if (model.mergePoints) {\n            edgeLocator.insertEdge(ids[edgeVerts[0]], ids[edgeVerts[1]], pId);\n          }\n        }\n        tris.push(pId);\n      }\n    }\n  };\n  publicAPI.requestData = function (inData, outData) {\n    // implement requestData\n    var input = inData[0];\n    if (!input) {\n      vtkErrorMacro('Invalid or missing input');\n      return;\n    }\n    console.time('mcubes'); // Retrieve output and volume data\n\n    var origin = input.getOrigin();\n    var spacing = input.getSpacing();\n    var dims = input.getDimensions();\n    var s = input.getPointData().getScalars().getData(); // Points - dynamic array\n\n    var pBuffer = []; // Cells - dynamic array\n\n    var tBuffer = []; // Normals\n\n    var nBuffer = []; // Loop over all voxels, determine case and process\n\n    var extent = input.getExtent();\n    var slice = dims[0] * dims[1];\n    for (var k = 0; k < dims[2] - 1; ++k) {\n      for (var j = 0; j < dims[1] - 1; ++j) {\n        for (var i = 0; i < dims[0] - 1; ++i) {\n          publicAPI.produceTriangles(model.contourValue, i, j, k, extent, slice, dims, origin, spacing, s, pBuffer, tBuffer, nBuffer);\n        }\n      }\n    }\n    edgeLocator.initialize(); // Update output\n\n    var polydata = vtkPolyData.newInstance();\n    polydata.getPoints().setData(new Float32Array(pBuffer), 3);\n    polydata.getPolys().setData(new Uint32Array(tBuffer));\n    if (model.computeNormals) {\n      var nData = new Float32Array(nBuffer);\n      var normals = vtkDataArray.newInstance({\n        numberOfComponents: 3,\n        values: nData,\n        name: 'Normals'\n      });\n      polydata.getPointData().setNormals(normals);\n    }\n    outData[0] = polydata;\n    vtkDebugMacro('Produced output');\n    console.timeEnd('mcubes');\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nvar DEFAULT_VALUES = {\n  contourValue: 0,\n  computeNormals: false,\n  mergePoints: false\n}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Make this a VTK object\n\n  macro.obj(publicAPI, model); // Also make it an algorithm with one input and one output\n\n  macro.algo(publicAPI, model, 1, 1);\n  macro.setGet(publicAPI, model, ['contourValue', 'computeNormals', 'mergePoints']); // Object specific methods\n\n  macro.algo(publicAPI, model, 1, 1);\n  vtkImageMarchingCubes(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = macro.newInstance(extend, 'vtkImageMarchingCubes'); // ----------------------------------------------------------------------------\n\nvar vtkImageMarchingCubes$1 = {\n  newInstance: newInstance,\n  extend: extend\n};\nexport { vtkImageMarchingCubes$1 as default, extend, newInstance };","map":{"version":3,"names":["macro","vtkDataArray","vtkEdgeLocator","vtkPolyData","l","normalize","vtkCaseTable","vtkErrorMacro","vtkDebugMacro","vtkImageMarchingCubes","publicAPI","model","classHierarchy","push","ids","voxelScalars","voxelGradients","voxelPts","edgeLocator","newInstance","getVoxelScalars","i","j","k","slice","dims","origin","spacing","s","ii","getVoxelPoints","getPointGradient","g","sp","sm","getVoxelGradients","scalars","produceTriangles","cVal","extent","points","tris","normals","CASE_MASK","VERT_MAP","xyz","n","pId","index","idx","voxelTris","getCase","computeNormals","_idx","eid","edgeVerts","getEdge","undefined","mergePoints","_edgeLocator$isInsert","isInsertedEdge","value","t","x0","x1","length","n0","n1","insertEdge","requestData","inData","outData","input","console","time","getOrigin","getSpacing","getDimensions","getPointData","getScalars","getData","pBuffer","tBuffer","nBuffer","getExtent","contourValue","initialize","polydata","getPoints","setData","Float32Array","getPolys","Uint32Array","nData","numberOfComponents","values","name","setNormals","timeEnd","DEFAULT_VALUES","extend","initialValues","arguments","Object","assign","obj","algo","setGet","vtkImageMarchingCubes$1","default"],"sources":["/home/rakshith/Documents/RemoteRendering/vtk-js-react-app/node_modules/@kitware/vtk.js/Filters/General/ImageMarchingCubes.js"],"sourcesContent":["import macro from '../../macros.js';\nimport vtkDataArray from '../../Common/Core/DataArray.js';\nimport vtkEdgeLocator from '../../Common/DataModel/EdgeLocator.js';\nimport vtkPolyData from '../../Common/DataModel/PolyData.js';\nimport { l as normalize } from '../../Common/Core/Math/index.js';\nimport vtkCaseTable from './ImageMarchingCubes/caseTable.js';\n\nvar vtkErrorMacro = macro.vtkErrorMacro,\n    vtkDebugMacro = macro.vtkDebugMacro; // ----------------------------------------------------------------------------\n// vtkImageMarchingCubes methods\n// ----------------------------------------------------------------------------\n\nfunction vtkImageMarchingCubes(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkImageMarchingCubes');\n  var ids = [];\n  var voxelScalars = [];\n  var voxelGradients = [];\n  var voxelPts = [];\n  var edgeLocator = vtkEdgeLocator.newInstance(); // Retrieve scalars and voxel coordinates. i-j-k is origin of voxel.\n\n  publicAPI.getVoxelScalars = function (i, j, k, slice, dims, origin, spacing, s) {\n    // First get the indices for the voxel\n    ids[0] = k * slice + j * dims[0] + i; // i, j, k\n\n    ids[1] = ids[0] + 1; // i+1, j, k\n\n    ids[2] = ids[0] + dims[0]; // i, j+1, k\n\n    ids[3] = ids[2] + 1; // i+1, j+1, k\n\n    ids[4] = ids[0] + slice; // i, j, k+1\n\n    ids[5] = ids[4] + 1; // i+1, j, k+1\n\n    ids[6] = ids[4] + dims[0]; // i, j+1, k+1\n\n    ids[7] = ids[6] + 1; // i+1, j+1, k+1\n    // Now retrieve the scalars\n\n    for (var ii = 0; ii < 8; ++ii) {\n      voxelScalars[ii] = s[ids[ii]];\n    }\n  }; // Retrieve voxel coordinates. i-j-k is origin of voxel.\n\n\n  publicAPI.getVoxelPoints = function (i, j, k, origin, spacing) {\n    // (i,i+1),(j,j+1),(k,k+1) - i varies fastest; then j; then k\n    voxelPts[0] = origin[0] + i * spacing[0]; // 0\n\n    voxelPts[1] = origin[1] + j * spacing[1];\n    voxelPts[2] = origin[2] + k * spacing[2];\n    voxelPts[3] = voxelPts[0] + spacing[0]; // 1\n\n    voxelPts[4] = voxelPts[1];\n    voxelPts[5] = voxelPts[2];\n    voxelPts[6] = voxelPts[0]; // 2\n\n    voxelPts[7] = voxelPts[1] + spacing[1];\n    voxelPts[8] = voxelPts[2];\n    voxelPts[9] = voxelPts[3]; // 3\n\n    voxelPts[10] = voxelPts[7];\n    voxelPts[11] = voxelPts[2];\n    voxelPts[12] = voxelPts[0]; // 4\n\n    voxelPts[13] = voxelPts[1];\n    voxelPts[14] = voxelPts[2] + spacing[2];\n    voxelPts[15] = voxelPts[3]; // 5\n\n    voxelPts[16] = voxelPts[1];\n    voxelPts[17] = voxelPts[14];\n    voxelPts[18] = voxelPts[0]; // 6\n\n    voxelPts[19] = voxelPts[7];\n    voxelPts[20] = voxelPts[14];\n    voxelPts[21] = voxelPts[3]; // 7\n\n    voxelPts[22] = voxelPts[7];\n    voxelPts[23] = voxelPts[14];\n  }; // Compute point gradient at i-j-k location\n\n\n  publicAPI.getPointGradient = function (i, j, k, dims, slice, spacing, s, g) {\n    var sp;\n    var sm; // x-direction\n\n    if (i === 0) {\n      sp = s[i + 1 + j * dims[0] + k * slice];\n      sm = s[i + j * dims[0] + k * slice];\n      g[0] = (sm - sp) / spacing[0];\n    } else if (i === dims[0] - 1) {\n      sp = s[i + j * dims[0] + k * slice];\n      sm = s[i - 1 + j * dims[0] + k * slice];\n      g[0] = (sm - sp) / spacing[0];\n    } else {\n      sp = s[i + 1 + j * dims[0] + k * slice];\n      sm = s[i - 1 + j * dims[0] + k * slice];\n      g[0] = 0.5 * (sm - sp) / spacing[0];\n    } // y-direction\n\n\n    if (j === 0) {\n      sp = s[i + (j + 1) * dims[0] + k * slice];\n      sm = s[i + j * dims[0] + k * slice];\n      g[1] = (sm - sp) / spacing[1];\n    } else if (j === dims[1] - 1) {\n      sp = s[i + j * dims[0] + k * slice];\n      sm = s[i + (j - 1) * dims[0] + k * slice];\n      g[1] = (sm - sp) / spacing[1];\n    } else {\n      sp = s[i + (j + 1) * dims[0] + k * slice];\n      sm = s[i + (j - 1) * dims[0] + k * slice];\n      g[1] = 0.5 * (sm - sp) / spacing[1];\n    } // z-direction\n\n\n    if (k === 0) {\n      sp = s[i + j * dims[0] + (k + 1) * slice];\n      sm = s[i + j * dims[0] + k * slice];\n      g[2] = (sm - sp) / spacing[2];\n    } else if (k === dims[2] - 1) {\n      sp = s[i + j * dims[0] + k * slice];\n      sm = s[i + j * dims[0] + (k - 1) * slice];\n      g[2] = (sm - sp) / spacing[2];\n    } else {\n      sp = s[i + j * dims[0] + (k + 1) * slice];\n      sm = s[i + j * dims[0] + (k - 1) * slice];\n      g[2] = 0.5 * (sm - sp) / spacing[2];\n    }\n  }; // Compute voxel gradient values. I-j-k is origin point of voxel.\n\n\n  publicAPI.getVoxelGradients = function (i, j, k, dims, slice, spacing, scalars) {\n    var g = [];\n    publicAPI.getPointGradient(i, j, k, dims, slice, spacing, scalars, g);\n    voxelGradients[0] = g[0];\n    voxelGradients[1] = g[1];\n    voxelGradients[2] = g[2];\n    publicAPI.getPointGradient(i + 1, j, k, dims, slice, spacing, scalars, g);\n    voxelGradients[3] = g[0];\n    voxelGradients[4] = g[1];\n    voxelGradients[5] = g[2];\n    publicAPI.getPointGradient(i, j + 1, k, dims, slice, spacing, scalars, g);\n    voxelGradients[6] = g[0];\n    voxelGradients[7] = g[1];\n    voxelGradients[8] = g[2];\n    publicAPI.getPointGradient(i + 1, j + 1, k, dims, slice, spacing, scalars, g);\n    voxelGradients[9] = g[0];\n    voxelGradients[10] = g[1];\n    voxelGradients[11] = g[2];\n    publicAPI.getPointGradient(i, j, k + 1, dims, slice, spacing, scalars, g);\n    voxelGradients[12] = g[0];\n    voxelGradients[13] = g[1];\n    voxelGradients[14] = g[2];\n    publicAPI.getPointGradient(i + 1, j, k + 1, dims, slice, spacing, scalars, g);\n    voxelGradients[15] = g[0];\n    voxelGradients[16] = g[1];\n    voxelGradients[17] = g[2];\n    publicAPI.getPointGradient(i, j + 1, k + 1, dims, slice, spacing, scalars, g);\n    voxelGradients[18] = g[0];\n    voxelGradients[19] = g[1];\n    voxelGradients[20] = g[2];\n    publicAPI.getPointGradient(i + 1, j + 1, k + 1, dims, slice, spacing, scalars, g);\n    voxelGradients[21] = g[0];\n    voxelGradients[22] = g[1];\n    voxelGradients[23] = g[2];\n  };\n\n  publicAPI.produceTriangles = function (cVal, i, j, k, extent, slice, dims, origin, spacing, scalars, points, tris, normals) {\n    var CASE_MASK = [1, 2, 4, 8, 16, 32, 64, 128];\n    var VERT_MAP = [0, 1, 3, 2, 4, 5, 7, 6];\n    var xyz = [];\n    var n = [];\n    var pId;\n    publicAPI.getVoxelScalars(i, j, k, slice, dims, origin, spacing, scalars);\n    var index = 0;\n\n    for (var idx = 0; idx < 8; idx++) {\n      if (voxelScalars[VERT_MAP[idx]] >= cVal) {\n        index |= CASE_MASK[idx]; // eslint-disable-line no-bitwise\n      }\n    }\n\n    var voxelTris = vtkCaseTable.getCase(index);\n\n    if (voxelTris[0] < 0) {\n      return; // don't get the voxel coordinates, nothing to do\n    }\n\n    publicAPI.getVoxelPoints(i + extent[0], j + extent[2], k + extent[4], origin, spacing);\n\n    if (model.computeNormals) {\n      publicAPI.getVoxelGradients(i, j, k, dims, slice, spacing, scalars);\n    }\n\n    for (var _idx = 0; voxelTris[_idx] >= 0; _idx += 3) {\n      tris.push(3);\n\n      for (var eid = 0; eid < 3; eid++) {\n        var edgeVerts = vtkCaseTable.getEdge(voxelTris[_idx + eid]);\n        pId = undefined;\n\n        if (model.mergePoints) {\n          var _edgeLocator$isInsert;\n\n          pId = (_edgeLocator$isInsert = edgeLocator.isInsertedEdge(ids[edgeVerts[0]], ids[edgeVerts[1]])) === null || _edgeLocator$isInsert === void 0 ? void 0 : _edgeLocator$isInsert.value;\n        }\n\n        if (pId === undefined) {\n          var t = (cVal - voxelScalars[edgeVerts[0]]) / (voxelScalars[edgeVerts[1]] - voxelScalars[edgeVerts[0]]);\n          var x0 = voxelPts.slice(edgeVerts[0] * 3, (edgeVerts[0] + 1) * 3);\n          var x1 = voxelPts.slice(edgeVerts[1] * 3, (edgeVerts[1] + 1) * 3);\n          xyz[0] = x0[0] + t * (x1[0] - x0[0]);\n          xyz[1] = x0[1] + t * (x1[1] - x0[1]);\n          xyz[2] = x0[2] + t * (x1[2] - x0[2]);\n          pId = points.length / 3;\n          points.push(xyz[0], xyz[1], xyz[2]);\n\n          if (model.computeNormals) {\n            var n0 = voxelGradients.slice(edgeVerts[0] * 3, (edgeVerts[0] + 1) * 3);\n            var n1 = voxelGradients.slice(edgeVerts[1] * 3, (edgeVerts[1] + 1) * 3);\n            n[0] = n0[0] + t * (n1[0] - n0[0]);\n            n[1] = n0[1] + t * (n1[1] - n0[1]);\n            n[2] = n0[2] + t * (n1[2] - n0[2]);\n            normalize(n);\n            normals.push(n[0], n[1], n[2]);\n          }\n\n          if (model.mergePoints) {\n            edgeLocator.insertEdge(ids[edgeVerts[0]], ids[edgeVerts[1]], pId);\n          }\n        }\n\n        tris.push(pId);\n      }\n    }\n  };\n\n  publicAPI.requestData = function (inData, outData) {\n    // implement requestData\n    var input = inData[0];\n\n    if (!input) {\n      vtkErrorMacro('Invalid or missing input');\n      return;\n    }\n\n    console.time('mcubes'); // Retrieve output and volume data\n\n    var origin = input.getOrigin();\n    var spacing = input.getSpacing();\n    var dims = input.getDimensions();\n    var s = input.getPointData().getScalars().getData(); // Points - dynamic array\n\n    var pBuffer = []; // Cells - dynamic array\n\n    var tBuffer = []; // Normals\n\n    var nBuffer = []; // Loop over all voxels, determine case and process\n\n    var extent = input.getExtent();\n    var slice = dims[0] * dims[1];\n\n    for (var k = 0; k < dims[2] - 1; ++k) {\n      for (var j = 0; j < dims[1] - 1; ++j) {\n        for (var i = 0; i < dims[0] - 1; ++i) {\n          publicAPI.produceTriangles(model.contourValue, i, j, k, extent, slice, dims, origin, spacing, s, pBuffer, tBuffer, nBuffer);\n        }\n      }\n    }\n\n    edgeLocator.initialize(); // Update output\n\n    var polydata = vtkPolyData.newInstance();\n    polydata.getPoints().setData(new Float32Array(pBuffer), 3);\n    polydata.getPolys().setData(new Uint32Array(tBuffer));\n\n    if (model.computeNormals) {\n      var nData = new Float32Array(nBuffer);\n      var normals = vtkDataArray.newInstance({\n        numberOfComponents: 3,\n        values: nData,\n        name: 'Normals'\n      });\n      polydata.getPointData().setNormals(normals);\n    }\n\n    outData[0] = polydata;\n    vtkDebugMacro('Produced output');\n    console.timeEnd('mcubes');\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\n\nvar DEFAULT_VALUES = {\n  contourValue: 0,\n  computeNormals: false,\n  mergePoints: false\n}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Make this a VTK object\n\n  macro.obj(publicAPI, model); // Also make it an algorithm with one input and one output\n\n  macro.algo(publicAPI, model, 1, 1);\n  macro.setGet(publicAPI, model, ['contourValue', 'computeNormals', 'mergePoints']); // Object specific methods\n\n  macro.algo(publicAPI, model, 1, 1);\n  vtkImageMarchingCubes(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = macro.newInstance(extend, 'vtkImageMarchingCubes'); // ----------------------------------------------------------------------------\n\nvar vtkImageMarchingCubes$1 = {\n  newInstance: newInstance,\n  extend: extend\n};\n\nexport { vtkImageMarchingCubes$1 as default, extend, newInstance };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}