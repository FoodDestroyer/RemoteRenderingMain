{"ast":null,"code":"import _slicedToArray from '@babel/runtime/helpers/slicedToArray';\nimport _toConsumableArray from '@babel/runtime/helpers/toConsumableArray';\nimport { create } from 'xmlbuilder2';\nimport { decompressSync } from 'fflate';\nimport DataAccessHelper from '../Core/DataAccessHelper.js';\nimport Base64 from '../../Common/Core/Base64.js';\nimport macro from '../../macros.js';\nimport vtkDataArray from '../../Common/Core/DataArray.js';\nimport vtkStringArray from '../../Common/Core/StringArray.js';\nimport BinaryHelper from '../Core/BinaryHelper.js';\nimport '../Core/DataAccessHelper/LiteHttpDataAccessHelper.js';\n\n// import 'vtk.js/Sources/IO/Core/DataAccessHelper/HttpDataAccessHelper'; // HTTP + zip\n// import 'vtk.js/Sources/IO/Core/DataAccessHelper/HtmlDataAccessHelper'; // html + base64 + zip\n// import 'vtk.js/Sources/IO/Core/DataAccessHelper/JSZipDataAccessHelper'; // zip\n// ----------------------------------------------------------------------------\n// Global methods\n// ----------------------------------------------------------------------------\n\nfunction findAllTags(node, tagName) {\n  return _toConsumableArray(node.getElementsByTagName(tagName));\n}\nfunction findFirstTag(node, tagName) {\n  return findAllTags(node, tagName)[0];\n}\nfunction parseXML(xmlStr) {\n  // see xmlbuilder2 docs on the object format\n  return create(xmlStr);\n}\nfunction extractAppendedData(buffer) {\n  // search for appended data tag\n  var prefixRegex = /^\\s*<AppendedData\\s+encoding=\"raw\">\\s*_/m;\n  var suffixRegex = /\\n\\s*<\\/AppendedData>/m;\n  return BinaryHelper.extractBinary(buffer, prefixRegex, suffixRegex);\n} // ----------------------------------------------------------------------------\n\nvar TYPED_ARRAY = {\n  Int8: Int8Array,\n  UInt8: Uint8Array,\n  Int16: Int16Array,\n  UInt16: Uint16Array,\n  Int32: Int32Array,\n  UInt32: Uint32Array,\n  Int64: Int32Array,\n  // Not supported with JavaScript will cause error in binary\n  UInt64: Uint32Array,\n  // Not supported with JavaScript will cause error in binary\n  Float32: Float32Array,\n  Float64: Float64Array\n}; // ----------------------------------------------------------------------------\n\nvar TYPED_ARRAY_BYTES = {\n  Int8: 1,\n  UInt8: 1,\n  Int16: 2,\n  UInt16: 2,\n  Int32: 4,\n  UInt32: 4,\n  Int64: 8,\n  // Not supported with JavaScript will cause error in binary\n  UInt64: 8,\n  // Not supported with JavaScript will cause error in binary\n  Float32: 4,\n  Float64: 8\n}; // ----------------------------------------------------------------------------\n\nfunction integer64to32(array) {\n  var maxIdx = array.length - 1; // Skip last\n\n  return array.filter(function (v, i) {\n    return i < maxIdx && i % 2 === 0;\n  });\n} // ----------------------------------------------------------------------------\n\n/**\n * Reads the data of a length-prefixed blob.\n *\n * Int64 headers and values are not supported.\n *\n * @param {Uint8Array} uint8 a uint8 view of the length-prefixed blob.\n * @param {string} dataType\n * @param {string} headerType either UInt64 or UInt32\n */\n\nfunction readLengthPrefixedData(uint8, dataType, headerType) {\n  if (!['UInt64', 'UInt32'].includes(headerType)) {\n    throw new Error(\"Cannot handle a header type of \".concat(headerType));\n  }\n  var HeaderTypedArray = TYPED_ARRAY[headerType];\n  var DataTypedArray = TYPED_ARRAY[dataType];\n  var dataFallbackTo32 = false;\n  if (headerType === 'UInt64') {\n    HeaderTypedArray = TYPED_ARRAY.UInt32;\n  }\n  if (/^U?Int64$/.test(dataType)) {\n    dataFallbackTo32 = true;\n    DataTypedArray = TYPED_ARRAY[dataType.replace('64', '32')];\n  }\n  var byteOffset = uint8.byteOffset;\n  var dataWordSize = TYPED_ARRAY_BYTES[dataType];\n  var headerWordSize = TYPED_ARRAY_BYTES[headerType]; // slice if offset is not word aligned\n\n  var header;\n  if (byteOffset % headerWordSize === 0) {\n    header = new HeaderTypedArray(uint8.buffer, byteOffset, 1);\n  } else {\n    header = new HeaderTypedArray(uint8.buffer.slice(byteOffset, byteOffset + headerWordSize));\n  }\n  var dataByteLength = Number(header[0]); // read values\n\n  var values;\n  var arraySize = dataByteLength / dataWordSize;\n  if (dataFallbackTo32) {\n    // We are reading int64 data with an int32 typed array.\n    arraySize *= 2;\n  } // slice if offset is not word aligned\n\n  var dataOffset = byteOffset + headerWordSize;\n  if (dataOffset % dataWordSize === 0) {\n    values = new DataTypedArray(uint8.buffer, dataOffset, arraySize);\n  } else {\n    values = new DataTypedArray(uint8.buffer.slice(dataOffset, dataOffset + dataByteLength));\n  }\n  if (dataFallbackTo32) {\n    // remove higher order 32 bits\n    values = integer64to32(values);\n  }\n  return values;\n} // ----------------------------------------------------------------------------\n\nfunction readerHeader(uint8, headerType) {\n  // We do not handle endianness or if more than 32 bits are needed to encode the data\n  if (headerType === 'UInt64') {\n    var _offset = 8;\n    var _uint = new Uint32Array(uint8.buffer, 0, 6);\n    var _nbBlocks = _uint[0];\n    var _s = _uint[2];\n    var _s2 = _uint[4];\n    var _resultArray = [_offset, _nbBlocks, _s, _s2];\n    _uint = new Uint32Array(uint8.buffer, 3 * 8, _nbBlocks * 2);\n    for (var i = 0; i < _nbBlocks; i++) {\n      _resultArray.push(_uint[i * 2]);\n    }\n    return _resultArray;\n  } // UInt32\n\n  var uint32 = new Uint32Array(uint8.buffer, 0, 3);\n  var offset = 4;\n  var nbBlocks = uint32[0];\n  var s1 = uint32[1];\n  var s2 = uint32[2];\n  var resultArray = [offset, nbBlocks, s1, s2];\n  uint32 = new Uint32Array(uint8.buffer, 3 * 4, nbBlocks);\n  for (var _i = 0; _i < nbBlocks; _i++) {\n    resultArray.push(uint32[_i]);\n  }\n  return resultArray;\n} // ----------------------------------------------------------------------------\n\n/**\n * Given the return value of readerHeader, return header byte length.\n */\n\nfunction getHeaderByteLength(header, headerType) {\n  // ignore the first number, which isn't actually part of the header.\n  var _header = _slicedToArray(header, 1),\n    headerWordSize = _header[0];\n  return (header.length - 1) * headerWordSize;\n} // ----------------------------------------------------------------------------\n\nfunction uncompressBlock(compressedUint8, output) {\n  var uncompressedBlock = decompressSync(compressedUint8);\n  output.uint8.set(uncompressedBlock, output.offset);\n  output.offset += uncompressedBlock.length;\n} // ----------------------------------------------------------------------------\n\nfunction decompressZLib(bytes, headerType) {\n  // ----------------------------------------------------------------------\n  // Layout of the data\n  // header[N, s1, s2, blockSize1, ..., blockSizeN], [padding???], block[compressedData], ..., block[compressedData]\n  // [header] N, s1 and s2 are uint 32 or 64 (defined by header_type=\"UInt64\" attribute on the root node)\n  // [header] s1: uncompress size of each block except the last one\n  // [header] s2: uncompress size of the last blocks\n  // [header] blockSize: size of the block in compressed space that represent to bloc to inflate in zlib. (This also give the offset to the next block)\n  // ----------------------------------------------------------------------\n  // Header reading: [offset, numBlocks, s1, s2]\n  var header = readerHeader(bytes, headerType);\n  var nbBlocks = header[1];\n  var s1 = header[2];\n  var s2 = header[3];\n  var dataByteLength = 0;\n  if (nbBlocks > 0) {\n    // If the last block's size is labeled as 0, that means the last block\n    // really has size header[2].\n    if (s2 === 0) {\n      dataByteLength = nbBlocks * s1;\n    } else {\n      dataByteLength = (nbBlocks - 1) * s1 + s2;\n    }\n  }\n  var buffer = new ArrayBuffer(dataByteLength);\n  var output = {\n    offset: 0,\n    uint8: new Uint8Array(buffer)\n  };\n  var offset = getHeaderByteLength(header); // Starting from end of the data header, find the zlib header, which starts with 0x78.\n  // This accounts for any padding between the header and the compressed data.\n\n  while (offset < bytes.length && bytes[offset] !== 0x78) {\n    offset++;\n  }\n  for (var i = 0; i < nbBlocks; i++) {\n    var blockSize = header[4 + i];\n    var compressedBlock = new Uint8Array(bytes.buffer, offset, blockSize);\n    uncompressBlock(compressedBlock, output);\n    offset += blockSize;\n  }\n  return output.uint8;\n} // ----------------------------------------------------------------------------\n\nfunction processDataArray(size, dataArrayElem, compressor, byteOrder, headerType, binaryBuffer) {\n  var dataType = dataArrayElem.getAttribute('type');\n  var name = dataArrayElem.getAttribute('Name');\n  var format = dataArrayElem.getAttribute('format'); // binary, ascii, appended\n\n  var numberOfComponents = Number(dataArrayElem.getAttribute('NumberOfComponents') || '1');\n  var values = null;\n  if (format === 'ascii') {\n    values = new TYPED_ARRAY[dataType](size * numberOfComponents);\n    var offset = 0;\n    dataArrayElem.firstChild.nodeValue.split(/[\\\\t \\\\n]+/).forEach(function (token) {\n      if (token.trim().length) {\n        values[offset++] = Number(token);\n      }\n    });\n  } else if (format === 'binary') {\n    var uint8 = new Uint8Array(Base64.toArrayBuffer(dataArrayElem.firstChild.nodeValue.trim()));\n    if (compressor === 'vtkZLibDataCompressor') {\n      var data = decompressZLib(uint8, headerType);\n      values = new TYPED_ARRAY[dataType](data.buffer); // Handle (u)int64 hoping for no overflow...\n\n      if (/^U?Int64$/.test(dataType)) {\n        values = integer64to32(values);\n      }\n    } else {\n      values = new TYPED_ARRAY[dataType](uint8.buffer, TYPED_ARRAY_BYTES[headerType]); // Handle (u)int64 hoping no overflow...\n\n      if (dataType.indexOf('Int64') !== -1) {\n        values = integer64to32(values);\n      }\n    }\n  } else if (format === 'appended') {\n    var _offset2 = Number(dataArrayElem.getAttribute('offset'));\n    values = readLengthPrefixedData(new Uint8Array(binaryBuffer, _offset2), dataType, headerType);\n  } else {\n    console.error('Format not supported', format);\n  }\n  return {\n    name: name,\n    values: values,\n    numberOfComponents: numberOfComponents\n  };\n} // ----------------------------------------------------------------------------\n\nfunction decodeStringArrayFromBytes(bytes) {\n  var decoder = new TextDecoder();\n  var decoded = decoder.decode(bytes); // strings are null-terminated\n\n  return decoded.split('\\x00').slice(0, -1);\n} // ----------------------------------------------------------------------------\n\nfunction processStringArray(stringArrayElem, compressor, byteOrder, headerType, binaryBuffer) {\n  var name = stringArrayElem.getAttribute('Name');\n  var format = stringArrayElem.getAttribute('format'); // binary, ascii, appended\n\n  var numberOfComponents = Number(stringArrayElem.getAttribute('NumberOfComponents') || '1');\n  var numberOfTuples = Number(stringArrayElem.getAttribute('NumberOfTuples') || '1');\n  var nbStrings = numberOfTuples * numberOfComponents;\n  var strings = [];\n  if (format === 'ascii') {\n    var tokens = stringArrayElem.firstChild.nodeValue.trim().split(/\\s+/);\n    var tokIdx = 0;\n    var strChars = [];\n    while (strings.length < nbStrings) {\n      var token = Number(tokens[tokIdx++]);\n      if (token === 0) {\n        strings.push(strChars.join(''));\n        strChars.length = 0;\n      } else {\n        strChars.push(String.fromCharCode(token));\n      }\n    }\n  } else if (format === 'binary') {\n    var uint8 = new Uint8Array(Base64.toArrayBuffer(stringArrayElem.firstChild.nodeValue.trim()));\n    if (compressor === 'vtkZLibDataCompressor') {\n      var decompressed = decompressZLib(uint8, headerType);\n      strings.push.apply(strings, _toConsumableArray(decodeStringArrayFromBytes(decompressed)));\n    } else {\n      var strData = readLengthPrefixedData(uint8, 'UInt8', headerType);\n      strings.push.apply(strings, _toConsumableArray(decodeStringArrayFromBytes(strData)));\n    }\n  } else if (format === 'appended') {\n    var offset = Number(stringArrayElem.getAttribute('offset'));\n    var values = readLengthPrefixedData(new Uint8Array(binaryBuffer, offset), 'UInt8', headerType);\n    strings.push.apply(strings, _toConsumableArray(decodeStringArrayFromBytes(values)));\n  } else {\n    macro.vtkErrorMacro(\"Format not supported: \".concat(format));\n  }\n  return {\n    name: name,\n    values: strings,\n    numberOfComponents: numberOfComponents\n  };\n} // ----------------------------------------------------------------------------\n\nfunction processCells(size, containerElem, compressor, byteOrder, headerType, binaryBuffer) {\n  var arrayElems = {};\n  var dataArrayElems = containerElem.getElementsByTagName('DataArray');\n  for (var elIdx = 0; elIdx < dataArrayElems.length; elIdx++) {\n    var el = dataArrayElems[elIdx];\n    arrayElems[el.getAttribute('Name')] = el;\n  }\n  var offsets = processDataArray(size, arrayElems.offsets, compressor, byteOrder, headerType, binaryBuffer).values;\n  var connectivitySize = offsets[offsets.length - 1];\n  var connectivity = processDataArray(connectivitySize, arrayElems.connectivity, compressor, byteOrder, headerType, binaryBuffer).values;\n  var values = new Uint32Array(size + connectivitySize);\n  var writeOffset = 0;\n  var previousOffset = 0;\n  offsets.forEach(function (v) {\n    var cellSize = v - previousOffset;\n    values[writeOffset++] = cellSize;\n    for (var i = 0; i < cellSize; i++) {\n      values[writeOffset++] = connectivity[previousOffset + i];\n    } // save previous offset\n\n    previousOffset = v;\n  });\n  return values;\n} // ----------------------------------------------------------------------------\n\nfunction processFieldData(size, fieldElem, fieldContainer, compressor, byteOrder, headerType, binaryBuffer) {\n  if (fieldElem) {\n    var attributes = ['Scalars', 'Vectors', 'Normals', 'Tensors', 'TCoords'];\n    var nameBinding = {};\n    attributes.forEach(function (attrName) {\n      var arrayName = fieldElem.getAttribute(attrName);\n      if (arrayName) {\n        nameBinding[arrayName] = fieldContainer[\"set\".concat(attrName)];\n      }\n    });\n    var dataArrayElems = fieldElem.getElementsByTagName('DataArray');\n    var nbArrays = dataArrayElems.length;\n    for (var idx = 0; idx < nbArrays; idx++) {\n      var array = dataArrayElems[idx];\n      var dataArray = vtkDataArray.newInstance(processDataArray(size, array, compressor, byteOrder, headerType, binaryBuffer));\n      var name = dataArray.getName();\n      (nameBinding[name] || fieldContainer.addArray)(dataArray);\n    }\n  }\n} // ----------------------------------------------------------------------------\n\nfunction handleFieldDataArrays(fieldDataElem, compressor, byteOrder, headerType, binaryBuffer) {\n  var dataArrays = _toConsumableArray(fieldDataElem.getElementsByTagName('DataArray')).map(function (daElem) {\n    return vtkDataArray.newInstance(processDataArray(Number(daElem.getAttribute('NumberOfTuples')), daElem, compressor, byteOrder, headerType, binaryBuffer));\n  });\n  var stringArrays = _toConsumableArray(fieldDataElem.getElementsByTagName('Array')).filter(function (elem) {\n    return elem.getAttribute('type') === 'String';\n  }).map(function (arrElem) {\n    var sa = vtkStringArray.newInstance(processStringArray(arrElem, compressor, byteOrder, headerType, binaryBuffer));\n    return sa;\n  });\n  return [].concat(_toConsumableArray(dataArrays), _toConsumableArray(stringArrays));\n} // ----------------------------------------------------------------------------\n// vtkXMLReader methods\n// ----------------------------------------------------------------------------\n\nfunction vtkXMLReader(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkXMLReader'); // Create default dataAccessHelper if not available\n\n  if (!model.dataAccessHelper) {\n    model.dataAccessHelper = DataAccessHelper.get('http');\n  } // Internal method to fetch Array\n\n  function fetchData(url) {\n    var option = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return model.dataAccessHelper.fetchBinary(url, option);\n  } // Set DataSet url\n\n  publicAPI.setUrl = function (url) {\n    var option = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    model.url = url; // Remove the file in the URL\n\n    var path = url.split('/');\n    path.pop();\n    model.baseURL = path.join('/'); // Fetch metadata\n\n    return publicAPI.loadData(option);\n  }; // Fetch the actual data arrays\n\n  publicAPI.loadData = function () {\n    var option = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return fetchData(model.url, option).then(publicAPI.parseAsArrayBuffer);\n  };\n  publicAPI.parseAsArrayBuffer = function (arrayBuffer) {\n    if (!arrayBuffer) {\n      return false;\n    }\n    if (arrayBuffer !== model.rawDataBuffer) {\n      publicAPI.modified();\n    } else {\n      return true;\n    }\n    var _extractAppendedData = extractAppendedData(arrayBuffer),\n      content = _extractAppendedData.text,\n      binaryBuffer = _extractAppendedData.binaryBuffer;\n    model.rawDataBuffer = arrayBuffer;\n    model.binaryBuffer = binaryBuffer; // Parse data here...\n\n    var doc = parseXML(content);\n    var root = doc.root();\n    var rootElem = root.node;\n    var type = rootElem.getAttribute('type');\n    var compressor = rootElem.getAttribute('compressor');\n    var byteOrder = rootElem.getAttribute('byte_order'); // default to UInt32. I think version 0.1 vtp/vti files default to UInt32.\n\n    var headerType = rootElem.getAttribute('header_type') || 'UInt32';\n    if (compressor && compressor !== 'vtkZLibDataCompressor') {\n      console.error('Invalid compressor', compressor);\n      return false;\n    }\n    if (byteOrder && byteOrder !== 'LittleEndian') {\n      console.error('Only LittleEndian encoding is supported');\n      return false;\n    }\n    if (type !== model.dataType) {\n      console.error('Invalid data type', type, 'expecting', model.dataType);\n      return false;\n    } // appended format\n\n    if (findFirstTag(rootElem, 'AppendedData')) {\n      var appendedDataElem = findFirstTag(rootElem, 'AppendedData');\n      var encoding = appendedDataElem.getAttribute('encoding');\n      var arrays = root.filter(function (xmlNode) {\n        var node = xmlNode.node;\n        return node.nodeType === Node.ELEMENT_NODE && node.getAttribute('format') === 'appended' && node.hasAttribute('offset');\n      }, false, true).map(function (xmlNode) {\n        return {\n          node: xmlNode.node,\n          offset: Number(xmlNode.node.getAttribute('offset'))\n        };\n      }); // sort dataElems by increasing offset\n\n      arrays.sort(function (a, b) {\n        return a.offset - b.offset;\n      });\n      var appendedBuffer = model.binaryBuffer;\n      if (encoding === 'base64') {\n        // substr(1) is to remove the '_' prefix\n        appendedBuffer = appendedDataElem.textContent.trim().substr(1);\n      } // get data array chunks\n\n      var dataArrays = [];\n      for (var i = 0; i < arrays.length; ++i) {\n        var offset = arrays[i].offset;\n        var nextOffset = 0;\n        if (i === arrays.length - 1) {\n          nextOffset = appendedBuffer.length || appendedBuffer.byteLength;\n        } else {\n          nextOffset = arrays[i + 1].offset;\n        }\n        if (encoding === 'base64') {\n          dataArrays.push(new Uint8Array(Base64.toArrayBuffer(appendedBuffer.substring(offset, nextOffset))));\n        } else {\n          // encoding === 'raw'\n          // Need to slice the ArrayBuffer so readerHeader() works properly\n          dataArrays.push(new Uint8Array(appendedBuffer.slice(offset, nextOffset)));\n        }\n      }\n      if (compressor === 'vtkZLibDataCompressor') {\n        for (var arrayidx = 0; arrayidx < dataArrays.length; ++arrayidx) {\n          var dataArray = dataArrays[arrayidx];\n          var uncompressed = decompressZLib(dataArray, headerType);\n          var data = new Uint8Array(uncompressed.length + TYPED_ARRAY_BYTES[headerType]); // set length header\n          // TODO this does not work for lengths that are greater than the max Uint32 value.\n\n          new TYPED_ARRAY[headerType](data.buffer, 0, 1)[0] = uncompressed.length;\n          data.set(uncompressed, TYPED_ARRAY_BYTES[headerType]);\n          dataArrays[arrayidx] = data;\n        }\n      }\n      var bufferLength = dataArrays.reduce(function (acc, arr) {\n        return acc + arr.length;\n      }, 0);\n      var buffer = new ArrayBuffer(bufferLength);\n      var view = new Uint8Array(buffer);\n      for (var _i2 = 0, _offset3 = 0; _i2 < dataArrays.length; ++_i2) {\n        // set correct offsets\n        arrays[_i2].node.setAttribute('offset', _offset3); // set final buffer data\n\n        view.set(dataArrays[_i2], _offset3);\n        _offset3 += dataArrays[_i2].length;\n      }\n      model.binaryBuffer = buffer;\n      if (!model.binaryBuffer) {\n        console.error('Processing appended data format: requires binaryBuffer to parse');\n        return false;\n      }\n    }\n    publicAPI.parseXML(rootElem, type, compressor, byteOrder, headerType);\n    var datasetElem = rootElem.getElementsByTagName(type)[0];\n    var fieldDataElem = datasetElem.getElementsByTagName('FieldData')[0];\n    if (fieldDataElem) {\n      var fieldDataArrays = handleFieldDataArrays(fieldDataElem, compressor, byteOrder, headerType, model.binaryBuffer);\n      for (var _i3 = 0; _i3 < model.output.length; _i3++) {\n        var fieldData = model.output[_i3].getFieldData();\n        for (var j = 0; j < fieldDataArrays.length; j++) {\n          fieldData.addArray(fieldDataArrays[j]);\n        }\n      }\n    }\n    return true;\n  };\n  publicAPI.requestData = function (inData, outData) {\n    publicAPI.parseAsArrayBuffer(model.rawDataBuffer);\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nvar DEFAULT_VALUES = {// baseURL: null,\n  // dataAccessHelper: null,\n  // url: null,\n}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Build VTK API\n\n  macro.obj(publicAPI, model);\n  macro.get(publicAPI, model, ['url', 'baseURL']);\n  macro.setGet(publicAPI, model, ['dataAccessHelper']);\n  macro.algo(publicAPI, model, 0, 1); // vtkXMLReader methods\n\n  vtkXMLReader(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar vtkXMLReader$1 = {\n  extend: extend,\n  processDataArray: processDataArray,\n  processFieldData: processFieldData,\n  processCells: processCells\n};\nexport { vtkXMLReader$1 as default, extend, findAllTags, findFirstTag };","map":{"version":3,"names":["_slicedToArray","_toConsumableArray","create","decompressSync","DataAccessHelper","Base64","macro","vtkDataArray","vtkStringArray","BinaryHelper","findAllTags","node","tagName","getElementsByTagName","findFirstTag","parseXML","xmlStr","extractAppendedData","buffer","prefixRegex","suffixRegex","extractBinary","TYPED_ARRAY","Int8","Int8Array","UInt8","Uint8Array","Int16","Int16Array","UInt16","Uint16Array","Int32","Int32Array","UInt32","Uint32Array","Int64","UInt64","Float32","Float32Array","Float64","Float64Array","TYPED_ARRAY_BYTES","integer64to32","array","maxIdx","length","filter","v","i","readLengthPrefixedData","uint8","dataType","headerType","includes","Error","concat","HeaderTypedArray","DataTypedArray","dataFallbackTo32","test","replace","byteOffset","dataWordSize","headerWordSize","header","slice","dataByteLength","Number","values","arraySize","dataOffset","readerHeader","_offset","_uint","_nbBlocks","_s","_s2","_resultArray","push","uint32","offset","nbBlocks","s1","s2","resultArray","_i","getHeaderByteLength","_header","uncompressBlock","compressedUint8","output","uncompressedBlock","set","decompressZLib","bytes","ArrayBuffer","blockSize","compressedBlock","processDataArray","size","dataArrayElem","compressor","byteOrder","binaryBuffer","getAttribute","name","format","numberOfComponents","firstChild","nodeValue","split","forEach","token","trim","toArrayBuffer","data","indexOf","_offset2","console","error","decodeStringArrayFromBytes","decoder","TextDecoder","decoded","decode","processStringArray","stringArrayElem","numberOfTuples","nbStrings","strings","tokens","tokIdx","strChars","join","String","fromCharCode","decompressed","apply","strData","vtkErrorMacro","processCells","containerElem","arrayElems","dataArrayElems","elIdx","el","offsets","connectivitySize","connectivity","writeOffset","previousOffset","cellSize","processFieldData","fieldElem","fieldContainer","attributes","nameBinding","attrName","arrayName","nbArrays","idx","dataArray","newInstance","getName","addArray","handleFieldDataArrays","fieldDataElem","dataArrays","map","daElem","stringArrays","elem","arrElem","sa","vtkXMLReader","publicAPI","model","classHierarchy","dataAccessHelper","get","fetchData","url","option","arguments","undefined","fetchBinary","setUrl","path","pop","baseURL","loadData","then","parseAsArrayBuffer","arrayBuffer","rawDataBuffer","modified","_extractAppendedData","content","text","doc","root","rootElem","type","appendedDataElem","encoding","arrays","xmlNode","nodeType","Node","ELEMENT_NODE","hasAttribute","sort","a","b","appendedBuffer","textContent","substr","nextOffset","byteLength","substring","arrayidx","uncompressed","bufferLength","reduce","acc","arr","view","_i2","_offset3","setAttribute","datasetElem","fieldDataArrays","_i3","fieldData","getFieldData","j","requestData","inData","outData","DEFAULT_VALUES","extend","initialValues","Object","assign","obj","setGet","algo","vtkXMLReader$1","default"],"sources":["/home/rakshith/Documents/RemoteRendering/vtk-js-react-app/node_modules/@kitware/vtk.js/IO/XML/XMLReader.js"],"sourcesContent":["import _slicedToArray from '@babel/runtime/helpers/slicedToArray';\nimport _toConsumableArray from '@babel/runtime/helpers/toConsumableArray';\nimport { create } from 'xmlbuilder2';\nimport { decompressSync } from 'fflate';\nimport DataAccessHelper from '../Core/DataAccessHelper.js';\nimport Base64 from '../../Common/Core/Base64.js';\nimport macro from '../../macros.js';\nimport vtkDataArray from '../../Common/Core/DataArray.js';\nimport vtkStringArray from '../../Common/Core/StringArray.js';\nimport BinaryHelper from '../Core/BinaryHelper.js';\nimport '../Core/DataAccessHelper/LiteHttpDataAccessHelper.js';\n\n// import 'vtk.js/Sources/IO/Core/DataAccessHelper/HttpDataAccessHelper'; // HTTP + zip\n// import 'vtk.js/Sources/IO/Core/DataAccessHelper/HtmlDataAccessHelper'; // html + base64 + zip\n// import 'vtk.js/Sources/IO/Core/DataAccessHelper/JSZipDataAccessHelper'; // zip\n// ----------------------------------------------------------------------------\n// Global methods\n// ----------------------------------------------------------------------------\n\nfunction findAllTags(node, tagName) {\n  return _toConsumableArray(node.getElementsByTagName(tagName));\n}\nfunction findFirstTag(node, tagName) {\n  return findAllTags(node, tagName)[0];\n}\n\nfunction parseXML(xmlStr) {\n  // see xmlbuilder2 docs on the object format\n  return create(xmlStr);\n}\n\nfunction extractAppendedData(buffer) {\n  // search for appended data tag\n  var prefixRegex = /^\\s*<AppendedData\\s+encoding=\"raw\">\\s*_/m;\n  var suffixRegex = /\\n\\s*<\\/AppendedData>/m;\n  return BinaryHelper.extractBinary(buffer, prefixRegex, suffixRegex);\n} // ----------------------------------------------------------------------------\n\n\nvar TYPED_ARRAY = {\n  Int8: Int8Array,\n  UInt8: Uint8Array,\n  Int16: Int16Array,\n  UInt16: Uint16Array,\n  Int32: Int32Array,\n  UInt32: Uint32Array,\n  Int64: Int32Array,\n  // Not supported with JavaScript will cause error in binary\n  UInt64: Uint32Array,\n  // Not supported with JavaScript will cause error in binary\n  Float32: Float32Array,\n  Float64: Float64Array\n}; // ----------------------------------------------------------------------------\n\nvar TYPED_ARRAY_BYTES = {\n  Int8: 1,\n  UInt8: 1,\n  Int16: 2,\n  UInt16: 2,\n  Int32: 4,\n  UInt32: 4,\n  Int64: 8,\n  // Not supported with JavaScript will cause error in binary\n  UInt64: 8,\n  // Not supported with JavaScript will cause error in binary\n  Float32: 4,\n  Float64: 8\n}; // ----------------------------------------------------------------------------\n\nfunction integer64to32(array) {\n  var maxIdx = array.length - 1; // Skip last\n\n  return array.filter(function (v, i) {\n    return i < maxIdx && i % 2 === 0;\n  });\n} // ----------------------------------------------------------------------------\n\n/**\n * Reads the data of a length-prefixed blob.\n *\n * Int64 headers and values are not supported.\n *\n * @param {Uint8Array} uint8 a uint8 view of the length-prefixed blob.\n * @param {string} dataType\n * @param {string} headerType either UInt64 or UInt32\n */\n\n\nfunction readLengthPrefixedData(uint8, dataType, headerType) {\n  if (!['UInt64', 'UInt32'].includes(headerType)) {\n    throw new Error(\"Cannot handle a header type of \".concat(headerType));\n  }\n\n  var HeaderTypedArray = TYPED_ARRAY[headerType];\n  var DataTypedArray = TYPED_ARRAY[dataType];\n  var dataFallbackTo32 = false;\n\n  if (headerType === 'UInt64') {\n    HeaderTypedArray = TYPED_ARRAY.UInt32;\n  }\n\n  if (/^U?Int64$/.test(dataType)) {\n    dataFallbackTo32 = true;\n    DataTypedArray = TYPED_ARRAY[dataType.replace('64', '32')];\n  }\n\n  var byteOffset = uint8.byteOffset;\n  var dataWordSize = TYPED_ARRAY_BYTES[dataType];\n  var headerWordSize = TYPED_ARRAY_BYTES[headerType]; // slice if offset is not word aligned\n\n  var header;\n\n  if (byteOffset % headerWordSize === 0) {\n    header = new HeaderTypedArray(uint8.buffer, byteOffset, 1);\n  } else {\n    header = new HeaderTypedArray(uint8.buffer.slice(byteOffset, byteOffset + headerWordSize));\n  }\n\n  var dataByteLength = Number(header[0]); // read values\n\n  var values;\n  var arraySize = dataByteLength / dataWordSize;\n\n  if (dataFallbackTo32) {\n    // We are reading int64 data with an int32 typed array.\n    arraySize *= 2;\n  } // slice if offset is not word aligned\n\n\n  var dataOffset = byteOffset + headerWordSize;\n\n  if (dataOffset % dataWordSize === 0) {\n    values = new DataTypedArray(uint8.buffer, dataOffset, arraySize);\n  } else {\n    values = new DataTypedArray(uint8.buffer.slice(dataOffset, dataOffset + dataByteLength));\n  }\n\n  if (dataFallbackTo32) {\n    // remove higher order 32 bits\n    values = integer64to32(values);\n  }\n\n  return values;\n} // ----------------------------------------------------------------------------\n\n\nfunction readerHeader(uint8, headerType) {\n  // We do not handle endianness or if more than 32 bits are needed to encode the data\n  if (headerType === 'UInt64') {\n    var _offset = 8;\n\n    var _uint = new Uint32Array(uint8.buffer, 0, 6);\n\n    var _nbBlocks = _uint[0];\n    var _s = _uint[2];\n    var _s2 = _uint[4];\n    var _resultArray = [_offset, _nbBlocks, _s, _s2];\n    _uint = new Uint32Array(uint8.buffer, 3 * 8, _nbBlocks * 2);\n\n    for (var i = 0; i < _nbBlocks; i++) {\n      _resultArray.push(_uint[i * 2]);\n    }\n\n    return _resultArray;\n  } // UInt32\n\n\n  var uint32 = new Uint32Array(uint8.buffer, 0, 3);\n  var offset = 4;\n  var nbBlocks = uint32[0];\n  var s1 = uint32[1];\n  var s2 = uint32[2];\n  var resultArray = [offset, nbBlocks, s1, s2];\n  uint32 = new Uint32Array(uint8.buffer, 3 * 4, nbBlocks);\n\n  for (var _i = 0; _i < nbBlocks; _i++) {\n    resultArray.push(uint32[_i]);\n  }\n\n  return resultArray;\n} // ----------------------------------------------------------------------------\n\n/**\n * Given the return value of readerHeader, return header byte length.\n */\n\n\nfunction getHeaderByteLength(header, headerType) {\n  // ignore the first number, which isn't actually part of the header.\n  var _header = _slicedToArray(header, 1),\n      headerWordSize = _header[0];\n\n  return (header.length - 1) * headerWordSize;\n} // ----------------------------------------------------------------------------\n\n\nfunction uncompressBlock(compressedUint8, output) {\n  var uncompressedBlock = decompressSync(compressedUint8);\n  output.uint8.set(uncompressedBlock, output.offset);\n  output.offset += uncompressedBlock.length;\n} // ----------------------------------------------------------------------------\n\n\nfunction decompressZLib(bytes, headerType) {\n  // ----------------------------------------------------------------------\n  // Layout of the data\n  // header[N, s1, s2, blockSize1, ..., blockSizeN], [padding???], block[compressedData], ..., block[compressedData]\n  // [header] N, s1 and s2 are uint 32 or 64 (defined by header_type=\"UInt64\" attribute on the root node)\n  // [header] s1: uncompress size of each block except the last one\n  // [header] s2: uncompress size of the last blocks\n  // [header] blockSize: size of the block in compressed space that represent to bloc to inflate in zlib. (This also give the offset to the next block)\n  // ----------------------------------------------------------------------\n  // Header reading: [offset, numBlocks, s1, s2]\n  var header = readerHeader(bytes, headerType);\n  var nbBlocks = header[1];\n  var s1 = header[2];\n  var s2 = header[3];\n  var dataByteLength = 0;\n\n  if (nbBlocks > 0) {\n    // If the last block's size is labeled as 0, that means the last block\n    // really has size header[2].\n    if (s2 === 0) {\n      dataByteLength = nbBlocks * s1;\n    } else {\n      dataByteLength = (nbBlocks - 1) * s1 + s2;\n    }\n  }\n\n  var buffer = new ArrayBuffer(dataByteLength);\n  var output = {\n    offset: 0,\n    uint8: new Uint8Array(buffer)\n  };\n  var offset = getHeaderByteLength(header); // Starting from end of the data header, find the zlib header, which starts with 0x78.\n  // This accounts for any padding between the header and the compressed data.\n\n  while (offset < bytes.length && bytes[offset] !== 0x78) {\n    offset++;\n  }\n\n  for (var i = 0; i < nbBlocks; i++) {\n    var blockSize = header[4 + i];\n    var compressedBlock = new Uint8Array(bytes.buffer, offset, blockSize);\n    uncompressBlock(compressedBlock, output);\n    offset += blockSize;\n  }\n\n  return output.uint8;\n} // ----------------------------------------------------------------------------\n\n\nfunction processDataArray(size, dataArrayElem, compressor, byteOrder, headerType, binaryBuffer) {\n  var dataType = dataArrayElem.getAttribute('type');\n  var name = dataArrayElem.getAttribute('Name');\n  var format = dataArrayElem.getAttribute('format'); // binary, ascii, appended\n\n  var numberOfComponents = Number(dataArrayElem.getAttribute('NumberOfComponents') || '1');\n  var values = null;\n\n  if (format === 'ascii') {\n    values = new TYPED_ARRAY[dataType](size * numberOfComponents);\n    var offset = 0;\n    dataArrayElem.firstChild.nodeValue.split(/[\\\\t \\\\n]+/).forEach(function (token) {\n      if (token.trim().length) {\n        values[offset++] = Number(token);\n      }\n    });\n  } else if (format === 'binary') {\n    var uint8 = new Uint8Array(Base64.toArrayBuffer(dataArrayElem.firstChild.nodeValue.trim()));\n\n    if (compressor === 'vtkZLibDataCompressor') {\n      var data = decompressZLib(uint8, headerType);\n      values = new TYPED_ARRAY[dataType](data.buffer); // Handle (u)int64 hoping for no overflow...\n\n      if (/^U?Int64$/.test(dataType)) {\n        values = integer64to32(values);\n      }\n    } else {\n      values = new TYPED_ARRAY[dataType](uint8.buffer, TYPED_ARRAY_BYTES[headerType]); // Handle (u)int64 hoping no overflow...\n\n      if (dataType.indexOf('Int64') !== -1) {\n        values = integer64to32(values);\n      }\n    }\n  } else if (format === 'appended') {\n    var _offset2 = Number(dataArrayElem.getAttribute('offset'));\n\n    values = readLengthPrefixedData(new Uint8Array(binaryBuffer, _offset2), dataType, headerType);\n  } else {\n    console.error('Format not supported', format);\n  }\n\n  return {\n    name: name,\n    values: values,\n    numberOfComponents: numberOfComponents\n  };\n} // ----------------------------------------------------------------------------\n\n\nfunction decodeStringArrayFromBytes(bytes) {\n  var decoder = new TextDecoder();\n  var decoded = decoder.decode(bytes); // strings are null-terminated\n\n  return decoded.split('\\x00').slice(0, -1);\n} // ----------------------------------------------------------------------------\n\n\nfunction processStringArray(stringArrayElem, compressor, byteOrder, headerType, binaryBuffer) {\n  var name = stringArrayElem.getAttribute('Name');\n  var format = stringArrayElem.getAttribute('format'); // binary, ascii, appended\n\n  var numberOfComponents = Number(stringArrayElem.getAttribute('NumberOfComponents') || '1');\n  var numberOfTuples = Number(stringArrayElem.getAttribute('NumberOfTuples') || '1');\n  var nbStrings = numberOfTuples * numberOfComponents;\n  var strings = [];\n\n  if (format === 'ascii') {\n    var tokens = stringArrayElem.firstChild.nodeValue.trim().split(/\\s+/);\n    var tokIdx = 0;\n    var strChars = [];\n\n    while (strings.length < nbStrings) {\n      var token = Number(tokens[tokIdx++]);\n\n      if (token === 0) {\n        strings.push(strChars.join(''));\n        strChars.length = 0;\n      } else {\n        strChars.push(String.fromCharCode(token));\n      }\n    }\n  } else if (format === 'binary') {\n    var uint8 = new Uint8Array(Base64.toArrayBuffer(stringArrayElem.firstChild.nodeValue.trim()));\n\n    if (compressor === 'vtkZLibDataCompressor') {\n      var decompressed = decompressZLib(uint8, headerType);\n      strings.push.apply(strings, _toConsumableArray(decodeStringArrayFromBytes(decompressed)));\n    } else {\n      var strData = readLengthPrefixedData(uint8, 'UInt8', headerType);\n      strings.push.apply(strings, _toConsumableArray(decodeStringArrayFromBytes(strData)));\n    }\n  } else if (format === 'appended') {\n    var offset = Number(stringArrayElem.getAttribute('offset'));\n    var values = readLengthPrefixedData(new Uint8Array(binaryBuffer, offset), 'UInt8', headerType);\n    strings.push.apply(strings, _toConsumableArray(decodeStringArrayFromBytes(values)));\n  } else {\n    macro.vtkErrorMacro(\"Format not supported: \".concat(format));\n  }\n\n  return {\n    name: name,\n    values: strings,\n    numberOfComponents: numberOfComponents\n  };\n} // ----------------------------------------------------------------------------\n\n\nfunction processCells(size, containerElem, compressor, byteOrder, headerType, binaryBuffer) {\n  var arrayElems = {};\n  var dataArrayElems = containerElem.getElementsByTagName('DataArray');\n\n  for (var elIdx = 0; elIdx < dataArrayElems.length; elIdx++) {\n    var el = dataArrayElems[elIdx];\n    arrayElems[el.getAttribute('Name')] = el;\n  }\n\n  var offsets = processDataArray(size, arrayElems.offsets, compressor, byteOrder, headerType, binaryBuffer).values;\n  var connectivitySize = offsets[offsets.length - 1];\n  var connectivity = processDataArray(connectivitySize, arrayElems.connectivity, compressor, byteOrder, headerType, binaryBuffer).values;\n  var values = new Uint32Array(size + connectivitySize);\n  var writeOffset = 0;\n  var previousOffset = 0;\n  offsets.forEach(function (v) {\n    var cellSize = v - previousOffset;\n    values[writeOffset++] = cellSize;\n\n    for (var i = 0; i < cellSize; i++) {\n      values[writeOffset++] = connectivity[previousOffset + i];\n    } // save previous offset\n\n\n    previousOffset = v;\n  });\n  return values;\n} // ----------------------------------------------------------------------------\n\n\nfunction processFieldData(size, fieldElem, fieldContainer, compressor, byteOrder, headerType, binaryBuffer) {\n  if (fieldElem) {\n    var attributes = ['Scalars', 'Vectors', 'Normals', 'Tensors', 'TCoords'];\n    var nameBinding = {};\n    attributes.forEach(function (attrName) {\n      var arrayName = fieldElem.getAttribute(attrName);\n\n      if (arrayName) {\n        nameBinding[arrayName] = fieldContainer[\"set\".concat(attrName)];\n      }\n    });\n    var dataArrayElems = fieldElem.getElementsByTagName('DataArray');\n    var nbArrays = dataArrayElems.length;\n\n    for (var idx = 0; idx < nbArrays; idx++) {\n      var array = dataArrayElems[idx];\n      var dataArray = vtkDataArray.newInstance(processDataArray(size, array, compressor, byteOrder, headerType, binaryBuffer));\n      var name = dataArray.getName();\n      (nameBinding[name] || fieldContainer.addArray)(dataArray);\n    }\n  }\n} // ----------------------------------------------------------------------------\n\n\nfunction handleFieldDataArrays(fieldDataElem, compressor, byteOrder, headerType, binaryBuffer) {\n  var dataArrays = _toConsumableArray(fieldDataElem.getElementsByTagName('DataArray')).map(function (daElem) {\n    return vtkDataArray.newInstance(processDataArray(Number(daElem.getAttribute('NumberOfTuples')), daElem, compressor, byteOrder, headerType, binaryBuffer));\n  });\n\n  var stringArrays = _toConsumableArray(fieldDataElem.getElementsByTagName('Array')).filter(function (elem) {\n    return elem.getAttribute('type') === 'String';\n  }).map(function (arrElem) {\n    var sa = vtkStringArray.newInstance(processStringArray(arrElem, compressor, byteOrder, headerType, binaryBuffer));\n    return sa;\n  });\n\n  return [].concat(_toConsumableArray(dataArrays), _toConsumableArray(stringArrays));\n} // ----------------------------------------------------------------------------\n// vtkXMLReader methods\n// ----------------------------------------------------------------------------\n\n\nfunction vtkXMLReader(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkXMLReader'); // Create default dataAccessHelper if not available\n\n  if (!model.dataAccessHelper) {\n    model.dataAccessHelper = DataAccessHelper.get('http');\n  } // Internal method to fetch Array\n\n\n  function fetchData(url) {\n    var option = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return model.dataAccessHelper.fetchBinary(url, option);\n  } // Set DataSet url\n\n\n  publicAPI.setUrl = function (url) {\n    var option = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    model.url = url; // Remove the file in the URL\n\n    var path = url.split('/');\n    path.pop();\n    model.baseURL = path.join('/'); // Fetch metadata\n\n    return publicAPI.loadData(option);\n  }; // Fetch the actual data arrays\n\n\n  publicAPI.loadData = function () {\n    var option = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return fetchData(model.url, option).then(publicAPI.parseAsArrayBuffer);\n  };\n\n  publicAPI.parseAsArrayBuffer = function (arrayBuffer) {\n    if (!arrayBuffer) {\n      return false;\n    }\n\n    if (arrayBuffer !== model.rawDataBuffer) {\n      publicAPI.modified();\n    } else {\n      return true;\n    }\n\n    var _extractAppendedData = extractAppendedData(arrayBuffer),\n        content = _extractAppendedData.text,\n        binaryBuffer = _extractAppendedData.binaryBuffer;\n\n    model.rawDataBuffer = arrayBuffer;\n    model.binaryBuffer = binaryBuffer; // Parse data here...\n\n    var doc = parseXML(content);\n    var root = doc.root();\n    var rootElem = root.node;\n    var type = rootElem.getAttribute('type');\n    var compressor = rootElem.getAttribute('compressor');\n    var byteOrder = rootElem.getAttribute('byte_order'); // default to UInt32. I think version 0.1 vtp/vti files default to UInt32.\n\n    var headerType = rootElem.getAttribute('header_type') || 'UInt32';\n\n    if (compressor && compressor !== 'vtkZLibDataCompressor') {\n      console.error('Invalid compressor', compressor);\n      return false;\n    }\n\n    if (byteOrder && byteOrder !== 'LittleEndian') {\n      console.error('Only LittleEndian encoding is supported');\n      return false;\n    }\n\n    if (type !== model.dataType) {\n      console.error('Invalid data type', type, 'expecting', model.dataType);\n      return false;\n    } // appended format\n\n\n    if (findFirstTag(rootElem, 'AppendedData')) {\n      var appendedDataElem = findFirstTag(rootElem, 'AppendedData');\n      var encoding = appendedDataElem.getAttribute('encoding');\n      var arrays = root.filter(function (xmlNode) {\n        var node = xmlNode.node;\n        return node.nodeType === Node.ELEMENT_NODE && node.getAttribute('format') === 'appended' && node.hasAttribute('offset');\n      }, false, true).map(function (xmlNode) {\n        return {\n          node: xmlNode.node,\n          offset: Number(xmlNode.node.getAttribute('offset'))\n        };\n      }); // sort dataElems by increasing offset\n\n      arrays.sort(function (a, b) {\n        return a.offset - b.offset;\n      });\n      var appendedBuffer = model.binaryBuffer;\n\n      if (encoding === 'base64') {\n        // substr(1) is to remove the '_' prefix\n        appendedBuffer = appendedDataElem.textContent.trim().substr(1);\n      } // get data array chunks\n\n\n      var dataArrays = [];\n\n      for (var i = 0; i < arrays.length; ++i) {\n        var offset = arrays[i].offset;\n        var nextOffset = 0;\n\n        if (i === arrays.length - 1) {\n          nextOffset = appendedBuffer.length || appendedBuffer.byteLength;\n        } else {\n          nextOffset = arrays[i + 1].offset;\n        }\n\n        if (encoding === 'base64') {\n          dataArrays.push(new Uint8Array(Base64.toArrayBuffer(appendedBuffer.substring(offset, nextOffset))));\n        } else {\n          // encoding === 'raw'\n          // Need to slice the ArrayBuffer so readerHeader() works properly\n          dataArrays.push(new Uint8Array(appendedBuffer.slice(offset, nextOffset)));\n        }\n      }\n\n      if (compressor === 'vtkZLibDataCompressor') {\n        for (var arrayidx = 0; arrayidx < dataArrays.length; ++arrayidx) {\n          var dataArray = dataArrays[arrayidx];\n          var uncompressed = decompressZLib(dataArray, headerType);\n          var data = new Uint8Array(uncompressed.length + TYPED_ARRAY_BYTES[headerType]); // set length header\n          // TODO this does not work for lengths that are greater than the max Uint32 value.\n\n          new TYPED_ARRAY[headerType](data.buffer, 0, 1)[0] = uncompressed.length;\n          data.set(uncompressed, TYPED_ARRAY_BYTES[headerType]);\n          dataArrays[arrayidx] = data;\n        }\n      }\n\n      var bufferLength = dataArrays.reduce(function (acc, arr) {\n        return acc + arr.length;\n      }, 0);\n      var buffer = new ArrayBuffer(bufferLength);\n      var view = new Uint8Array(buffer);\n\n      for (var _i2 = 0, _offset3 = 0; _i2 < dataArrays.length; ++_i2) {\n        // set correct offsets\n        arrays[_i2].node.setAttribute('offset', _offset3); // set final buffer data\n\n\n        view.set(dataArrays[_i2], _offset3);\n        _offset3 += dataArrays[_i2].length;\n      }\n\n      model.binaryBuffer = buffer;\n\n      if (!model.binaryBuffer) {\n        console.error('Processing appended data format: requires binaryBuffer to parse');\n        return false;\n      }\n    }\n\n    publicAPI.parseXML(rootElem, type, compressor, byteOrder, headerType);\n    var datasetElem = rootElem.getElementsByTagName(type)[0];\n    var fieldDataElem = datasetElem.getElementsByTagName('FieldData')[0];\n\n    if (fieldDataElem) {\n      var fieldDataArrays = handleFieldDataArrays(fieldDataElem, compressor, byteOrder, headerType, model.binaryBuffer);\n\n      for (var _i3 = 0; _i3 < model.output.length; _i3++) {\n        var fieldData = model.output[_i3].getFieldData();\n\n        for (var j = 0; j < fieldDataArrays.length; j++) {\n          fieldData.addArray(fieldDataArrays[j]);\n        }\n      }\n    }\n\n    return true;\n  };\n\n  publicAPI.requestData = function (inData, outData) {\n    publicAPI.parseAsArrayBuffer(model.rawDataBuffer);\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\n\nvar DEFAULT_VALUES = {// baseURL: null,\n  // dataAccessHelper: null,\n  // url: null,\n}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Build VTK API\n\n  macro.obj(publicAPI, model);\n  macro.get(publicAPI, model, ['url', 'baseURL']);\n  macro.setGet(publicAPI, model, ['dataAccessHelper']);\n  macro.algo(publicAPI, model, 0, 1); // vtkXMLReader methods\n\n  vtkXMLReader(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar vtkXMLReader$1 = {\n  extend: extend,\n  processDataArray: processDataArray,\n  processFieldData: processFieldData,\n  processCells: processCells\n};\n\nexport { vtkXMLReader$1 as default, extend, findAllTags, findFirstTag };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}