{"ast":null,"code":"import _toConsumableArray from '@babel/runtime/helpers/toConsumableArray';\nimport macro from '../../macros.js';\nimport vtkCellArray from '../../Common/Core/CellArray.js';\nimport vtkLine from '../../Common/DataModel/Line.js';\nimport { d as dot, j as cross, n as norm, t as jacobi, l as normalize, k as add } from '../../Common/Core/Math/index.js';\nimport vtkMatrixBuilder from '../../Common/Core/MatrixBuilder.js';\nimport vtkOBBNode from './OBBTree/OBBNode.js';\nimport vtkPoints from '../../Common/Core/Points.js';\nimport { CellType } from '../../Common/DataModel/CellTypes/Constants.js';\nimport vtkPolyData from '../../Common/DataModel/PolyData.js';\nimport vtkTriangle from '../../Common/DataModel/Triangle.js';\nimport { pushArray, getCellTriangles } from './OBBTree/helper.js';\nimport { mat4, vec4 } from 'gl-matrix';\nvar vtkErrorMacro = macro.vtkErrorMacro;\nvar VTK_DOUBLE_MAX = Number.MAX_SAFE_INTEGER; // ----------------------------------------------------------------------------\n// vtkOBBTree methods\n// ----------------------------------------------------------------------------\n\nfunction vtkOBBTree(publicAPI, model) {\n  // Set our classname\n  model.classHierarchy.push('vtkOBBTree');\n  /**\n   * Compute an OBB from the list of cells given.  This used to be\n   * public but should not have been.  A public call has been added\n   * so that the functionality can be accessed.\n   * @param {Array} cells\n   * @param {Array[3]} corner\n   * @param {Array[3]} max\n   * @param {Array[3]} mid\n   * @param {Array[3]} min\n   * @param {Array[3]} size\n   */\n\n  function computeOBB(cells, corner, max, mid, min, size) {\n    model.OBBCount++;\n    model.pointsList = []; //\n    // Compute mean & moments\n    //\n\n    var numCells = cells.length;\n    var mean = [0, 0, 0];\n    var totMass = 0.0;\n    var a0 = [0, 0, 0];\n    var a1 = [0, 0, 0];\n    var a2 = [0, 0, 0];\n    var a = [0, 0, 0, 0, 0, 0, 0, 0, 0];\n    var dp0 = [0, 0, 0];\n    var dp1 = [0, 0, 0];\n    var c = [0, 0, 0];\n    var triMass = 0;\n    if (!model.dataset.getCells()) {\n      model.dataset.buildCells();\n    }\n    for (var i = 0; i < numCells; i++) {\n      var cellId = cells[i];\n      var type = model.dataset.getCells().getCellType(cellId);\n      var ptIds = model.dataset.getCellPoints(cellId).cellPointIds;\n      var _numPts = ptIds.length;\n      for (var j = 0; j < _numPts - 2; j++) {\n        var cellsIds = getCellTriangles(ptIds, type, j);\n        var pId = cellsIds.ptId0;\n        var qId = cellsIds.ptId1;\n        var rId = cellsIds.ptId2;\n        if (pId < 0) {\n          // eslint-disable-next-line no-continue\n          continue;\n        }\n        var p = [];\n        var q = [];\n        var r = [];\n        model.dataset.getPoints().getPoint(pId, p);\n        model.dataset.getPoints().getPoint(qId, q);\n        model.dataset.getPoints().getPoint(rId, r); // p, q, and r are the oriented triangle points.\n        // Compute the components of the moment of inertia tensor.\n\n        for (var k = 0; k < 3; k++) {\n          // two edge vectors\n          dp0[k] = q[k] - p[k];\n          dp1[k] = r[k] - p[k]; // centroid\n\n          c[k] = (p[k] + q[k] + r[k]) / 3;\n        }\n        var xp = cross(dp0, dp1, []);\n        triMass = 0.5 * norm(xp);\n        totMass += triMass;\n        for (var _k = 0; _k < 3; _k++) {\n          mean[_k] += triMass * c[_k];\n        } // on-diagonal terms\n\n        a0[0] += triMass * (9 * c[0] * c[0] + p[0] * p[0] + q[0] * q[0] + r[0] * r[0]) / 12;\n        a1[1] += triMass * (9 * c[1] * c[1] + p[1] * p[1] + q[1] * q[1] + r[1] * r[1]) / 12;\n        a2[2] += triMass * (9 * c[2] * c[2] + p[2] * p[2] + q[2] * q[2] + r[2] * r[2]) / 12; // off-diagonal terms\n\n        a0[1] += triMass * (9 * c[0] * c[1] + p[0] * p[1] + q[0] * q[1] + r[0] * r[1]) / 12;\n        a0[2] += triMass * (9 * c[0] * c[2] + p[0] * p[2] + q[0] * q[2] + r[0] * r[2]) / 12;\n        a1[2] += triMass * (9 * c[1] * c[2] + p[1] * p[2] + q[1] * q[2] + r[1] * r[2]) / 12;\n      } // end foreach triangle\n      // While computing cell moments, gather all the cell's\n      // point coordinates into a single list.\n\n      for (var _j = 0; _j < _numPts; _j++) {\n        if (model.insertedPoints[ptIds[_j]] !== model.OBBCount) {\n          model.insertedPoints[ptIds[_j]] = model.OBBCount;\n          var pt = [];\n          model.dataset.getPoints().getPoint(ptIds[_j], pt);\n          model.pointsList.push(pt);\n        }\n      } // for all points of this cell\n    } // end foreach cell\n    // normalize data\n\n    for (var _i = 0; _i < 3; _i++) {\n      mean[_i] /= totMass;\n    } // matrix is symmetric\n\n    a1[0] = a0[1];\n    a2[0] = a0[2];\n    a2[1] = a1[2];\n    a = [a0[0], a0[1], a0[2], a1[0], a1[1], a1[2], a2[0], a2[1], a2[2]]; // get covariance from moments\n\n    for (var _i2 = 0; _i2 < 3; _i2++) {\n      for (var _j2 = 0; _j2 < 3; _j2++) {\n        a[_i2 * 3 + _j2] = a[_i2 * 3 + _j2] / totMass - mean[_i2] * mean[_j2];\n      }\n    } //\n    // Extract axes (i.e., eigenvectors) from covariance matrix.\n    //\n\n    var v = [0, 0, 0, 0, 0, 0, 0, 0, 0];\n    jacobi(a, size, v);\n    max[0] = v[0];\n    max[1] = v[3];\n    max[2] = v[6];\n    mid[0] = v[1];\n    mid[1] = v[4];\n    mid[2] = v[7];\n    min[0] = v[2];\n    min[1] = v[5];\n    min[2] = v[8];\n    for (var _i3 = 0; _i3 < 3; _i3++) {\n      a[_i3] = mean[_i3] + max[_i3];\n      a[3 + _i3] = mean[_i3] + mid[_i3];\n      a[6 + _i3] = mean[_i3] + min[_i3];\n    } //\n    // Create oriented bounding box by projecting points onto eigenvectors.\n    //\n\n    var tMin = [VTK_DOUBLE_MAX, VTK_DOUBLE_MAX, VTK_DOUBLE_MAX];\n    var tMax = [-VTK_DOUBLE_MAX, -VTK_DOUBLE_MAX, -VTK_DOUBLE_MAX];\n    var numPts = model.pointsList.length;\n    for (var ptId = 0; ptId < numPts; ptId++) {\n      var _p = model.pointsList[ptId];\n      for (var _i4 = 0; _i4 < 3; _i4++) {\n        var out = vtkLine.distanceToLine(_p, mean, a.slice(3 * _i4, 3 * (_i4 + 1)), []);\n        if (out.t < tMin[_i4]) {\n          tMin[_i4] = out.t;\n        }\n        if (out.t > tMax[_i4]) {\n          tMax[_i4] = out.t;\n        }\n      }\n    } // for all points\n\n    for (var _i5 = 0; _i5 < 3; _i5++) {\n      corner[_i5] = mean[_i5] + tMin[0] * max[_i5] + tMin[1] * mid[_i5] + tMin[2] * min[_i5];\n      max[_i5] *= tMax[0] - tMin[0];\n      mid[_i5] *= tMax[1] - tMin[1];\n      min[_i5] *= tMax[2] - tMin[2];\n    }\n  }\n  /**\n   * Build the OBB tree\n   * @param {Array} cells\n   * @param {vtkOBBNode} obbNode\n   * @param {Number} level\n   */\n\n  function buildTree(cells, obbNode, level) {\n    var numCells = cells.length;\n    if (level > model.level) {\n      model.level = level;\n    }\n    var axes = obbNode.getAxes();\n    var corner = obbNode.getCorner();\n    var size = [0, 0, 0];\n    computeOBB(cells, corner, axes[0], axes[1], axes[2], size);\n    obbNode.setAxes(axes);\n    obbNode.setCorner(corner); // Check whether to continue recursing; if so, create two children and\n    // assign cells to appropriate child.\n\n    if (level < model.maxLevel && numCells > model.numberOfCellsPerNode) {\n      var LHlist = [];\n      var RHlist = [];\n      var p = [0, 0, 0];\n      var n = [0, 0, 0]; // loop over three split planes to find acceptable one\n\n      for (var i = 0; i < 3; i++) {\n        // compute split point\n        p[i] = corner[i] + axes[0][i] / 2 + axes[1][i] / 2 + axes[2][i] / 2;\n      }\n      var splitPlane = 0;\n      var splitAcceptable = 0;\n      var bestRatio = 1;\n      var foundBestSplit = 0;\n      var bestPlane = 0;\n      for (; !splitAcceptable && splitPlane < 3;) {\n        // compute split normal\n        for (var _i6 = 0; _i6 < 3; _i6++) {\n          n[_i6] = axes[splitPlane][_i6];\n        }\n        normalize(n); // traverse cells, assigning to appropriate child list as necessary\n\n        var _loop = function _loop(_i7) {\n          var cellId = cells[_i7];\n          var pointsIDs = model.dataset.getCellPoints(cellId).cellPointIds;\n          var cellPts = [];\n          pointsIDs.forEach(function (id) {\n            var pt = [];\n            model.dataset.getPoints().getPoint(pointsIDs[id], pt);\n            cellPts.push(pt);\n          });\n          var c = [0, 0, 0];\n          var numPts = cellPts.length;\n          var negative = 0;\n          var positive = 0;\n          for (var j = 0; j < numPts; j++) {\n            var ptId = pointsIDs[j];\n            var x = model.dataset.getPoints().getPoint(ptId);\n            var val = n[0] * (x[0] - p[0]) + n[1] * (x[1] - p[1]) + n[2] * (x[2] - p[2]);\n            c[0] += x[0];\n            c[1] += x[1];\n            c[2] += x[2];\n            if (val < 0.0) {\n              negative = 1;\n            } else {\n              positive = 1;\n            }\n          }\n          if (negative && positive) {\n            // Use centroid to decide straddle cases\n            c[0] /= numPts;\n            c[1] /= numPts;\n            c[2] /= numPts;\n            var _val = n[0] * (c[0] - p[0]) + n[1] * (c[1] - p[1]) + n[2] * (c[2] - p[2]);\n            if (_val < 0.0) {\n              LHlist.push(cellId);\n            } else {\n              RHlist.push(cellId);\n            }\n          } else if (negative) {\n            LHlist.push(cellId);\n          } else {\n            RHlist.push(cellId);\n          }\n        };\n        for (var _i7 = 0; _i7 < numCells; _i7++) {\n          _loop(_i7);\n        } // for all cells\n        // evaluate this split\n\n        var numInLHnode = LHlist.length;\n        var numInRHnode = RHlist.length;\n        var ratio = Math.abs((numInRHnode - numInLHnode) / numCells); // see whether we've found acceptable split plane\n\n        if (ratio < 0.6 || foundBestSplit) {\n          // accept right off the bat\n          splitAcceptable = 1;\n        } else {\n          // not a great split try another\n          LHlist = [];\n          RHlist = [];\n          if (ratio < bestRatio) {\n            bestRatio = ratio;\n            bestPlane = splitPlane;\n          }\n          if (++splitPlane === 3 && bestRatio < 0.95) {\n            // at closing time, even the ugly ones look good\n            splitPlane = bestPlane;\n            foundBestSplit = 1;\n          }\n        } // try another split\n      } // for each split\n\n      if (splitAcceptable) {\n        // otherwise recursion terminates\n        var LHnode = vtkOBBNode.newInstance();\n        var RHnode = vtkOBBNode.newInstance();\n        obbNode.setKids([LHnode, RHnode]);\n        LHnode.setParent(obbNode);\n        RHnode.setParent(obbNode);\n        cells.length = 0;\n        buildTree(LHlist, LHnode, level + 1);\n        buildTree(RHlist, RHnode, level + 1);\n      } else {\n        // free up local objects\n        LHlist = [];\n        RHlist = [];\n      }\n    } // if should build tree\n\n    if (cells && model.retainCellLists) {\n      obbNode.setCells(cells);\n    } else if (cells) {\n      cells.length = 0;\n    }\n  }\n  function generatePolygons(obbNode, level, repLevel, points, cells) {\n    if (level === repLevel || repLevel < 0 && obbNode.getKids()) {\n      var nbPoints = points.getNumberOfPoints();\n      var newPoints = [];\n      var newCells = [];\n      var cubeIds = [];\n      newPoints.push.apply(newPoints, _toConsumableArray(obbNode.getCorner()));\n      cubeIds[0] = nbPoints++;\n      var x = [];\n      newPoints.push.apply(newPoints, _toConsumableArray(add(obbNode.getCorner(), obbNode.getAxis(0), x)));\n      cubeIds[1] = nbPoints++;\n      var y = [];\n      newPoints.push.apply(newPoints, _toConsumableArray(add(obbNode.getCorner(), obbNode.getAxis(1), y)));\n      cubeIds[2] = nbPoints++;\n      var xy = [];\n      newPoints.push.apply(newPoints, _toConsumableArray(add(x, obbNode.getAxis(1), xy)));\n      cubeIds[3] = nbPoints++;\n      var z = [];\n      newPoints.push.apply(newPoints, _toConsumableArray(add(obbNode.getCorner(), obbNode.getAxis(2), z)));\n      cubeIds[4] = nbPoints++;\n      var xz = [];\n      newPoints.push.apply(newPoints, _toConsumableArray(add(x, obbNode.getAxis(2), xz)));\n      cubeIds[5] = nbPoints++;\n      var yz = [];\n      newPoints.push.apply(newPoints, _toConsumableArray(add(y, obbNode.getAxis(2), yz)));\n      cubeIds[6] = nbPoints++;\n      var xyz = [];\n      newPoints.push.apply(newPoints, _toConsumableArray(add(xy, obbNode.getAxis(2), xyz)));\n      cubeIds[7] = nbPoints++;\n      newCells.push(4, cubeIds[0], cubeIds[2], cubeIds[3], cubeIds[1]);\n      newCells.push(4, cubeIds[0], cubeIds[1], cubeIds[5], cubeIds[4]);\n      newCells.push(4, cubeIds[0], cubeIds[4], cubeIds[6], cubeIds[2]);\n      newCells.push(4, cubeIds[1], cubeIds[3], cubeIds[7], cubeIds[5]);\n      newCells.push(4, cubeIds[4], cubeIds[5], cubeIds[7], cubeIds[6]);\n      newCells.push(4, cubeIds[2], cubeIds[6], cubeIds[7], cubeIds[3]);\n      points.setData(pushArray(points.getData(), newPoints));\n      cells.setData(pushArray(cells.getData(), newCells));\n    } else if ((level < repLevel || repLevel < 0) && obbNode.getKids()) {\n      generatePolygons(obbNode.getKids()[0], level + 1, repLevel, points, cells);\n      generatePolygons(obbNode.getKids()[1], level + 1, repLevel, points, cells);\n    }\n  }\n  /**\n   * Transform the whole OBB tree by using input transform\n   * @param {Transform} transform vtkjs Transform object\n   */\n\n  publicAPI.transform = function (transform) {\n    // Setup matrix used to transform vectors\n    var matrix = mat4.create();\n    mat4.copy(matrix, transform.getMatrix());\n    matrix[12] = 0;\n    matrix[13] = 0;\n    matrix[14] = 0;\n    matrix[15] = 1;\n    var transformVector = vtkMatrixBuilder.buildFromRadian().setMatrix(matrix);\n    var obbStack = new Array(model.level + 1);\n    obbStack[0] = model.tree;\n    var depth = 1;\n    while (depth > 0) {\n      depth -= 1;\n      var node = obbStack[depth];\n      var corner = node.getCorner();\n      var max = node.getAxis(0);\n      var mid = node.getAxis(1);\n      var min = node.getAxis(2);\n      transform.apply(corner);\n      transformVector.apply(max);\n      transformVector.apply(mid);\n      transformVector.apply(min);\n      node.setCorner(corner);\n      node.setAxes([max, mid, min]);\n      if (node.getKids() !== null) {\n        // push kids onto stack\n        obbStack[depth] = node.getKids()[0];\n        obbStack[depth + 1] = node.getKids()[1];\n        depth += 2;\n      }\n    }\n  };\n  /**\n   * Deep copy input node into class attribute tree\n   * @param {vtkOBBNode} tree\n   * @returns\n   */\n\n  publicAPI.deepCopy = function (tree) {\n    if (!tree) {\n      return;\n    }\n    publicAPI.setLevel(tree.getLevel());\n    publicAPI.setRetainCellLists(tree.getRetainCellLists());\n    publicAPI.setDataset(tree.getDataset());\n    publicAPI.setAutomatic(tree.getAutomatic());\n    publicAPI.setNumberOfCellsPerNode(tree.getNumberOfCellsPerNode());\n    publicAPI.setTolerance(tree.getTolerance());\n    var root = tree.getTree();\n    if (root) {\n      model.tree = vtkOBBNode.newInstance();\n      model.tree.deepCopy(root);\n    }\n  };\n  /**\n   * A method to compute the OBB of a dataset without having to go through the\n   * Execute method; It does set\n   * @param {vtkPolyData} input\n   * @param {Array[3]} corner\n   * @param {Array[3]} max\n   * @param {Array[3]} mid\n   * @param {Array[3]} min\n   * @param {Array[3]} size\n   */\n\n  publicAPI.computeOBBFromDataset = function (input, corner, max, mid, min, size) {\n    if (!input) {\n      return;\n    }\n    var numPts = input.getPoints().getNumberOfPoints();\n    var numCells = input.getNumberOfCells();\n    if (numPts < 1 || numCells < 1) {\n      vtkErrorMacro(\"Can't compute OBB - no data available!\");\n      return;\n    }\n    model.dataset = input;\n    model.OBBCount = 0;\n    model.insertedPoints = Array.from({\n      length: numPts\n    }, function (_) {\n      return 0;\n    });\n    model.pointsList = [];\n    var cellList = Array.from({\n      length: numCells\n    }, function (_, i) {\n      return i;\n    });\n    computeOBB(cellList, corner, max, mid, min, size);\n  };\n  /**\n   * Returns true if nodeB and nodeA are disjoint after optional\n   * transformation of nodeB with matrix XformBtoA\n   * @param {vtkOBBNode} nodeA\n   * @param {vtkOBBNode} nodeB\n   * @param {mat4} XformBtoA\n   */\n\n  publicAPI.disjointOBBNodes = function (nodeA, nodeB, XformBtoA) {\n    if (!nodeA || !nodeB) {\n      return 5; // A and B are disjoint\n    }\n\n    var input = new Array(4);\n    var output = new Array(4);\n    var eps = model.tolerance;\n    var pA = nodeA;\n    var pB = vtkOBBNode.newInstance();\n    var dotAB = [0, 0, 0, 0, 0, 0, 0, 0, 0];\n    if (XformBtoA) {\n      // Here we assume that XformBtoA is an orthogonal matrix\n      input[0] = nodeB.getCorner()[0];\n      input[1] = nodeB.getCorner()[1];\n      input[2] = nodeB.getCorner()[2];\n      input[3] = 1.0;\n      vec4.transformMat4(output, input, XformBtoA);\n      pB.setCorner([output[0] / output[3], output[1] / output[3], output[2] / output[3]]); // Clean this up when the bug input MultiplyVectors is fixed!\n\n      for (var ii = 0; ii < 3; ii++) {\n        pB.getAxis(0)[ii] = nodeB.getCorner()[ii] + nodeB.getAxis(0)[ii];\n        pB.getAxis(1)[ii] = nodeB.getCorner()[ii] + nodeB.getAxis(1)[ii];\n        pB.getAxis(2)[ii] = nodeB.getCorner()[ii] + nodeB.getAxis(2)[ii];\n      }\n      for (var _ii = 0; _ii < 3; _ii++) {\n        input[0] = pB.getAxis(_ii)[0];\n        input[1] = pB.getAxis(_ii)[1];\n        input[2] = pB.getAxis(_ii)[2];\n        input[3] = 1.0;\n        vec4.transformMat4(output, input, XformBtoA);\n        pB.getAxis(_ii)[0] = output[0] / output[3];\n        pB.getAxis(_ii)[1] = output[1] / output[3];\n        pB.getAxis(_ii)[2] = output[2] / output[3];\n      }\n      for (var _ii2 = 0; _ii2 < 3; _ii2++) {\n        pB.getAxis(0)[_ii2] = pB.getAxis(0)[_ii2] - pB.getCorner()[_ii2];\n        pB.getAxis(1)[_ii2] = pB.getAxis(1)[_ii2] - pB.getCorner()[_ii2];\n        pB.getAxis(2)[_ii2] = pB.getAxis(2)[_ii2] - pB.getCorner()[_ii2];\n      }\n    } else {\n      pB = nodeB;\n    }\n    var centerA = [0, 0, 0];\n    var centerB = [0, 0, 0];\n    var AtoB = [0, 0, 0];\n    for (var _ii3 = 0; _ii3 < 3; _ii3++) {\n      centerA[_ii3] = pA.getCorner()[_ii3] + 0.5 * (pA.getAxis(0)[_ii3] + pA.getAxis(1)[_ii3] + pA.getAxis(2)[_ii3]);\n      centerB[_ii3] = pB.getCorner()[_ii3] + 0.5 * (pB.getAxis(0)[_ii3] + pB.getAxis(1)[_ii3] + pB.getAxis(2)[_ii3]);\n      AtoB[_ii3] = centerB[_ii3] - centerA[_ii3];\n    } // Project maximal and minimal corners onto line between centers\n\n    var rangeAmin = dot(pA.getCorner(), AtoB);\n    var rangeAmax = rangeAmin;\n    var rangeBmin = dot(pB.getCorner(), AtoB);\n    var rangeBmax = rangeBmin;\n    var dotA = 0;\n    var dotB = 0;\n    for (var _ii4 = 0; _ii4 < 3; _ii4++) {\n      // compute A range\n      dotA = dot(pA.getAxis(_ii4), AtoB);\n      if (dotA > 0) {\n        rangeAmax += dotA;\n      } else {\n        rangeAmin += dotA;\n      } // compute B range\n\n      dotB = dot(pB.getAxis(_ii4), AtoB);\n      if (dotB > 0) {\n        rangeBmax += dotB;\n      } else {\n        rangeBmin += dotB;\n      }\n    }\n    if (rangeAmax + eps < rangeBmin || rangeBmax + eps < rangeAmin) {\n      return 1; // A and B are Disjoint by the 1st test.\n    } // now check for a separation plane parallel to the faces of B\n\n    for (var _ii5 = 0; _ii5 < 3; _ii5++) {\n      // plane is normal to pB.getAxis(ii)\n      // computing B range is easy...\n      rangeBmin = dot(pB.getCorner(), pB.getAxis(_ii5));\n      rangeBmax = rangeBmin;\n      rangeBmax += dot(pB.getAxis(_ii5), pB.getAxis(_ii5)); // compute A range...\n\n      rangeAmin = dot(pA.getCorner(), pB.getAxis(_ii5));\n      rangeAmax = rangeAmin;\n      for (var jj = 0; jj < 3; jj++) {\n        // (note: we are saving all 9 dotproducts for future use)\n        dotA = dot(pB.getAxis(_ii5), pA.getAxis(jj));\n        dotAB[_ii5 * 3 + jj] = dotA;\n        if (dotA > 0) {\n          rangeAmax += dotA;\n        } else {\n          rangeAmin += dotA;\n        }\n      }\n      if (rangeAmax + eps < rangeBmin || rangeBmax + eps < rangeAmin) {\n        return 2; // A and B are Disjoint by the 3rd test.\n      }\n    } // now check for a separation plane parallel to the faces of A\n\n    for (var _ii6 = 0; _ii6 < 3; _ii6++) {\n      // plane is normal to pA.getAxis(ii)\n      // computing A range is easy...\n      rangeAmin = dot(pA.getCorner(), pA.getAxis(_ii6));\n      rangeAmax = rangeAmin;\n      rangeAmax += dot(pA.getAxis(_ii6), pA.getAxis(_ii6)); // compute B range...\n\n      rangeBmin = dot(pB.getCorner(), pA.getAxis(_ii6));\n      rangeBmax = rangeBmin;\n      for (var _jj = 0; _jj < 3; _jj++) {\n        // (note: we are using the 9 dotproducts computed earlier)\n        dotB = dotAB[_jj * 3 + _ii6];\n        if (dotB > 0) {\n          rangeBmax += dotB;\n        } else {\n          rangeBmin += dotB;\n        }\n      }\n      if (rangeAmax + eps < rangeBmin || rangeBmax + eps < rangeAmin) {\n        return 3; // A and B are Disjoint by the 2nd test.\n      }\n    } // Bad luck: now we must look for a separation plane parallel\n    // to one edge from A and one edge from B.\n\n    for (var _ii7 = 0; _ii7 < 3; _ii7++) {\n      for (var _jj2 = 0; _jj2 < 3; _jj2++) {\n        // the plane is normal to pA.getAxis(ii) X pB.getAxis(jj)\n        cross(pA.getAxis(_ii7), pB.getAxis(_jj2), AtoB);\n        rangeAmin = dot(pA.getCorner(), AtoB);\n        rangeAmax = rangeAmin;\n        rangeBmin = dot(pB.getCorner(), AtoB);\n        rangeBmax = rangeBmin;\n        for (var kk = 0; kk < 3; kk++) {\n          // compute A range\n          dotA = dot(pA.getAxis(kk), AtoB);\n          if (dotA > 0) {\n            rangeAmax += dotA;\n          } else {\n            rangeAmin += dotA;\n          } // compute B range\n\n          dotB = dot(pB.getAxis(kk), AtoB);\n          if (dotB > 0) {\n            rangeBmax += dotB;\n          } else {\n            rangeBmin += dotB;\n          }\n        }\n        if (rangeAmax + eps < rangeBmin || rangeBmax + eps < rangeAmin) {\n          return 4; // A and B are Disjoint by the 4th test.\n        }\n      }\n    } // if we fall through to here, the OBB's overlap\n\n    return 0;\n  };\n  /**\n   * Intersect this OBBTree with OBBTreeB (as transformed) and\n   * call processing function for each intersecting leaf node pair.\n   * If the processing function returns a negative integer, terminate.\n   * For each intersecting leaf node pair, call callback.\n   * OBBTreeB is optionally transformed by XformBtoA before testing\n   * @param {vtkOBBTree} obbTreeB\n   * @param {mat4|null|undefined} XformBtoA\n   * @param {function|null|undefined} callback Compared function that takes in argument:\n   * nodeA (vtkOBBNode), nodeB (vtkOBBNode), XForm (mat4), arg\n   */\n\n  publicAPI.intersectWithOBBTree = function (obbTreeB, XformBtoA) {\n    var onIntersect = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function () {\n      return -1;\n    };\n    var maxDepth = model.level;\n    var minDepth = obbTreeB.getLevel();\n    if (minDepth > maxDepth) {\n      minDepth = maxDepth;\n      maxDepth = obbTreeB.getLevel();\n    }\n    var maxStackDepth = 3 * minDepth + 2 * (maxDepth - minDepth) + 1;\n    var OBBStackA = new Array(maxStackDepth);\n    var OBBStackB = new Array(maxStackDepth);\n    OBBStackA[0] = model.tree;\n    OBBStackB[0] = obbTreeB.getTree();\n    var depth = 1;\n    var count = 0;\n    var returnValue = 0; // simulate recursion without overhead of real recursion.\n\n    while (depth > 0 && returnValue > -1) {\n      depth--;\n      var nodeA = OBBStackA[depth];\n      var nodeB = OBBStackB[depth];\n      if (!publicAPI.disjointOBBNodes(nodeA, nodeB, XformBtoA)) {\n        // Collision\n        if (!nodeA.getKids()) {\n          if (!nodeB.getKids()) {\n            returnValue = onIntersect(nodeA, nodeB, XformBtoA);\n            count += Math.abs(returnValue);\n          } else {\n            // A is a leaf, but B goes deeper.\n            OBBStackA[depth] = nodeA;\n            OBBStackB[depth] = nodeB.getKids()[0];\n            OBBStackA[depth + 1] = nodeA;\n            OBBStackB[depth + 1] = nodeB.getKids()[1];\n            depth += 2;\n          }\n        } else if (!nodeB.getKids()) {\n          // B is a leaf, but A goes deeper.\n          OBBStackB[depth] = nodeB;\n          OBBStackA[depth] = nodeA.getKids()[0];\n          OBBStackB[depth + 1] = nodeB;\n          OBBStackA[depth + 1] = nodeA.getKids()[1];\n          depth += 2;\n        } else {\n          // neither A nor B are leaves. Go to the next level.\n          OBBStackA[depth] = nodeA.getKids()[0];\n          OBBStackB[depth] = nodeB.getKids()[0];\n          OBBStackA[depth + 1] = nodeA.getKids()[1];\n          OBBStackB[depth + 1] = nodeB.getKids()[0];\n          OBBStackA[depth + 2] = nodeA.getKids()[0];\n          OBBStackB[depth + 2] = nodeB.getKids()[1];\n          OBBStackA[depth + 3] = nodeA.getKids()[1];\n          OBBStackB[depth + 3] = nodeB.getKids()[1];\n          depth += 4;\n        }\n      }\n    }\n    return count;\n  };\n  publicAPI.triangleIntersectsNode = function (nodeA, p0, p1, p2, XformBtoA) {\n    var eps = model.tolerance;\n    var pA = nodeA;\n    var pB = [_toConsumableArray(p0), _toConsumableArray(p1), _toConsumableArray(p2)];\n    if (XformBtoA) {\n      // Here we assume that XformBtoA is an orthogonal matrix\n      var input = [0, 0, 0, 1];\n      var output = [];\n      for (var ii = 0; ii < 3; ii++) {\n        input[0] = pB[ii][0];\n        input[1] = pB[ii][1];\n        input[2] = pB[ii][2];\n        vec4.transformMat4(output, input, XformBtoA);\n        pB[ii][0] = output[0] / output[3];\n        pB[ii][1] = output[1] / output[3];\n        pB[ii][2] = output[2] / output[3];\n      }\n    } // now check for a separation plane parallel to the triangle\n\n    var v0 = [];\n    var v1 = [];\n    for (var _ii8 = 0; _ii8 < 3; _ii8++) {\n      // plane is normal to the triangle\n      v0[_ii8] = pB[1][_ii8] - pB[0][_ii8];\n      v1[_ii8] = pB[2][_ii8] - pB[0][_ii8];\n    }\n    var xprod = cross(v0, v1, []); // computing B range is easy...\n\n    var rangeBmax = dot(pB[0], xprod);\n    var rangeBmin = rangeBmax; // compute A range...\n\n    var rangeAmax = dot(pA.getCorner(), xprod);\n    var rangeAmin = rangeAmax;\n    var dotA;\n    for (var jj = 0; jj < 3; jj++) {\n      dotA = dot(xprod, pA.getAxis(jj));\n      if (dotA > 0) {\n        rangeAmax += dotA;\n      } else {\n        rangeAmin += dotA;\n      }\n    }\n    if (rangeAmax + eps < rangeBmin || rangeBmax + eps < rangeAmin) {\n      return 0; // A and B are Disjoint by the 1st test.\n    } // now check for a separation plane parallel to the faces of A\n\n    for (var _ii9 = 0; _ii9 < 3; _ii9++) {\n      // plane is normal to pA->Axes[ii]\n      // computing A range is easy...\n      rangeAmax = dot(pA.getCorner(), pA.getAxis(_ii9));\n      rangeAmin = rangeAmax;\n      rangeAmax += dot(pA.getAxis(_ii9), pA.getAxis(_ii9)); // compute B range...\n\n      rangeBmax = dot(pB[0], pA.getAxis(_ii9));\n      rangeBmin = rangeBmax;\n      var _dotB = dot(pB[1], pA.getAxis(_ii9));\n      if (_dotB > rangeBmax) {\n        rangeBmax = _dotB;\n      } else {\n        rangeBmin = _dotB;\n      }\n      _dotB = dot(pB[2], pA.getAxis(_ii9));\n      if (_dotB > rangeBmax) {\n        rangeBmax = _dotB;\n      } else if (_dotB < rangeBmin) {\n        rangeBmin = _dotB;\n      }\n      if (rangeAmax + eps < rangeBmin || rangeBmax + eps < rangeAmin) {\n        return 0; // A and B are Disjoint by the 2nd test.\n      }\n    } // Bad luck: now we must look for a separation plane parallel\n    // to one edge from A and one edge from B.\n\n    var AtoB = [];\n    var dotB;\n    for (var _ii10 = 0; _ii10 < 3; _ii10++) {\n      for (var _jj3 = 0; _jj3 < 3; _jj3++) {\n        // the plane is normal to pA->Axes[ii] X (pB[jj+1]-pB[jj])\n        v0[0] = pB[(_jj3 + 1) % 3][0] - pB[_jj3][0];\n        v0[1] = pB[(_jj3 + 1) % 3][1] - pB[_jj3][1];\n        v0[2] = pB[(_jj3 + 1) % 3][2] - pB[_jj3][2];\n        cross(pA.getAxis(_ii10), v0, AtoB);\n        rangeAmax = dot(pA.getCorner(), AtoB);\n        rangeAmin = rangeAmax;\n        rangeBmax = dot(pB[_jj3], AtoB);\n        rangeBmin = rangeBmax;\n        for (var kk = 0; kk < 3; kk++) {\n          // compute A range\n          dotA = dot(pA.getAxis(kk), AtoB);\n          if (dotA > 0) {\n            rangeAmax += dotA;\n          } else {\n            rangeAmin += dotA;\n          }\n        } // compute B range\n\n        dotB = dot(pB[(_jj3 + 2) % 3], AtoB);\n        if (dotB > rangeBmax) {\n          rangeBmax = dotB;\n        } else {\n          rangeBmin = dotB;\n        }\n        if (rangeAmax + eps < rangeBmin || rangeBmax + eps < rangeAmin) {\n          return 0; // A and B are Disjoint by the 3rd test.\n        }\n      }\n    } // if we fall through to here, the OBB overlaps the triangle.\n\n    return 1;\n  };\n  /**\n   *\n   * @param {*} info must be an object with { obbTree1, intersectionLines }\n   * @param {*} node0\n   * @param {*} node1\n   * @param {*} transform\n   * @returns the number of intersection lines found\n   */\n\n  publicAPI.findTriangleIntersections = function (info, node0, node1, transform) {\n    // Set up local structures to hold Impl array information\n    // vtkOBBTree* obbTree1 = info->OBBTree1;\n    // vtkCellArray* intersectionLines = info->IntersectionLines;\n    // vtkIdTypeArray* intersectionSurfaceId = info->SurfaceId;\n    // vtkIdTypeArray* intersectionCellIds0 = info->CellIds[0];\n    // vtkIdTypeArray* intersectionCellIds1 = info->CellIds[1];\n    // vtkPointLocator* pointMerger = info->PointMerger;\n    // double tolerance = info->Tolerance;\n    var mesh0 = publicAPI.getDataset();\n    var mesh1 = info.obbTree1.getDataset();\n    var pointOffset = info.intersectionLines.getPoints().getNumberOfPoints();\n    var intersectionPoints = [];\n    var intersectionLines = []; // The number of cells in OBBTree\n\n    var numCells0 = node0.getCells().length;\n    for (var id0 = 0; id0 < numCells0; id0++) {\n      var cellId0 = node0.getCells()[id0];\n      var type0 = mesh0.getCellType(cellId0); // Make sure the cell is a triangle\n\n      if (type0 === CellType.VTK_TRIANGLE) {\n        var _mesh0$getCellPoints = mesh0.getCellPoints(cellId0),\n          triPtIds0 = _mesh0$getCellPoints.cellPointIds;\n        var triPts0 = [[], [], []];\n        for (var id = 0; id < triPtIds0.length; id++) {\n          mesh0.getPoints().getPoint(triPtIds0[id], triPts0[id]);\n        }\n        if (info.obbTree1.triangleIntersectsNode(node1, triPts0[0], triPts0[1], triPts0[2], transform)) {\n          var numCells1 = node1.getCells().length;\n          for (var id1 = 0; id1 < numCells1; id1++) {\n            var cellId1 = node1.getCells()[id1];\n            var type1 = mesh1.getCellType(cellId1);\n            if (type1 === CellType.VTK_TRIANGLE) {\n              // See if the two cells actually intersect. If they do,\n              // add an entry into the intersection maps and add an\n              // intersection line.\n              var _mesh1$getCellPoints = mesh1.getCellPoints(cellId1),\n                triPtIds1 = _mesh1$getCellPoints.cellPointIds;\n              var triPts1 = [[], [], []];\n              for (var _id = 0; _id < triPtIds1.length; _id++) {\n                mesh1.getPoints().getPoint(triPtIds1[_id], triPts1[_id]);\n              }\n              var _vtkTriangle$intersec = vtkTriangle.intersectWithTriangle.apply(vtkTriangle, triPts0.concat(triPts1, [model.tolerance])),\n                intersect = _vtkTriangle$intersec.intersect,\n                coplanar = _vtkTriangle$intersec.coplanar,\n                outpt0 = _vtkTriangle$intersec.pt1,\n                outpt1 = _vtkTriangle$intersec.pt2;\n              if (intersect && !coplanar) {\n                var pointId = intersectionPoints.length / 3;\n                intersectionPoints.push.apply(intersectionPoints, _toConsumableArray(outpt0).concat(_toConsumableArray(outpt1)));\n                intersectionLines.push(2, pointOffset + pointId, pointOffset + pointId + 1);\n              } // If actual intersection, add point and cell to edge, line,\n              // and surface maps!\n\n              /*\n              if (coplanar) {\n                // Coplanar triangle intersection is not handled.\n                // This intersection will not be included in the output. TODO\n                // vtkDebugMacro(<<\"Coplanar\");\n                intersects = false;\n                continue;\n              }\n              if (intersects)\n              {\n                vtkIdType lineId = info.intersectionLines->GetNumberOfCells();\n                   vtkIdType ptId0, ptId1;\n                int unique[2];\n                unique[0] = pointMerger->InsertUniquePoint(outpt0, ptId0);\n                unique[1] = pointMerger->InsertUniquePoint(outpt1, ptId1);\n                   int addline = 1;\n                if (ptId0 == ptId1)\n                {\n                  addline = 0;\n                }\n                   if (ptId0 == ptId1 && surfaceid[0] != surfaceid[1])\n                {\n                  intersectionSurfaceId->InsertValue(ptId0, 3);\n                }\n                else\n                {\n                  if (unique[0])\n                  {\n                    intersectionSurfaceId->InsertValue(ptId0, surfaceid[0]);\n                  }\n                  else\n                  {\n                    if (intersectionSurfaceId->GetValue(ptId0) != 3)\n                    {\n                      intersectionSurfaceId->InsertValue(ptId0, surfaceid[0]);\n                    }\n                  }\n                  if (unique[1])\n                  {\n                    intersectionSurfaceId->InsertValue(ptId1, surfaceid[1]);\n                  }\n                  else\n                  {\n                    if (intersectionSurfaceId->GetValue(ptId1) != 3)\n                    {\n                      intersectionSurfaceId->InsertValue(ptId1, surfaceid[1]);\n                    }\n                  }\n                }\n                   info->IntersectionPtsMap[0]->insert(std::make_pair(ptId0, cellId0));\n                info->IntersectionPtsMap[1]->insert(std::make_pair(ptId0, cellId1));\n                info->IntersectionPtsMap[0]->insert(std::make_pair(ptId1, cellId0));\n                info->IntersectionPtsMap[1]->insert(std::make_pair(ptId1, cellId1));\n                   // Check to see if duplicate line. Line can only be a duplicate\n                // line if both points are not unique and they don't\n                // equal each other\n                if (!unique[0] && !unique[1] && ptId0 != ptId1)\n                {\n                  vtkSmartPointer<vtkPolyData> lineTest = vtkSmartPointer<vtkPolyData>::New();\n                  lineTest->SetPoints(pointMerger->GetPoints());\n                  lineTest->SetLines(intersectionLines);\n                  lineTest->BuildLinks();\n                  int newLine = info->CheckLine(lineTest, ptId0, ptId1);\n                  if (newLine == 0)\n                  {\n                    addline = 0;\n                  }\n                }\n                if (addline)\n                {\n                  // If the line is new and does not consist of two identical\n                  // points, add the line to the intersection and update\n                  // mapping information\n                  intersectionLines->InsertNextCell(2);\n                  intersectionLines->InsertCellPoint(ptId0);\n                  intersectionLines->InsertCellPoint(ptId1);\n                     intersectionCellIds0->InsertNextValue(cellId0);\n                  intersectionCellIds1->InsertNextValue(cellId1);\n                     info->PointCellIds[0]->InsertValue(ptId0, cellId0);\n                  info->PointCellIds[0]->InsertValue(ptId1, cellId0);\n                  info->PointCellIds[1]->InsertValue(ptId0, cellId1);\n                  info->PointCellIds[1]->InsertValue(ptId1, cellId1);\n                     info->IntersectionMap[0]->insert(std::make_pair(cellId0, lineId));\n                  info->IntersectionMap[1]->insert(std::make_pair(cellId1, lineId));\n                     // Check which edges of cellId0 and cellId1 outpt0 and\n                  // outpt1 are on, if any.\n                  int isOnEdge = 0;\n                  int m0p0 = 0, m0p1 = 0, m1p0 = 0, m1p1 = 0;\n                  for (vtkIdType edgeId = 0; edgeId < 3; edgeId++)\n                  {\n                    isOnEdge = info->AddToPointEdgeMap(\n                      0, ptId0, outpt0, mesh0, cellId0, edgeId, lineId, triPtIds0);\n                    if (isOnEdge != -1)\n                    {\n                      m0p0++;\n                    }\n                    isOnEdge = info->AddToPointEdgeMap(\n                      0, ptId1, outpt1, mesh0, cellId0, edgeId, lineId, triPtIds0);\n                    if (isOnEdge != -1)\n                    {\n                      m0p1++;\n                    }\n                    isOnEdge = info->AddToPointEdgeMap(\n                      1, ptId0, outpt0, mesh1, cellId1, edgeId, lineId, triPtIds1);\n                    if (isOnEdge != -1)\n                    {\n                      m1p0++;\n                    }\n                    isOnEdge = info->AddToPointEdgeMap(\n                      1, ptId1, outpt1, mesh1, cellId1, edgeId, lineId, triPtIds1);\n                    if (isOnEdge != -1)\n                    {\n                      m1p1++;\n                    }\n                  }\n                  // Special cases caught by tolerance and not from the Point\n                  // Merger\n                  if (m0p0 > 0 && m1p0 > 0)\n                  {\n                    intersectionSurfaceId->InsertValue(ptId0, 3);\n                  }\n                  if (m0p1 > 0 && m1p1 > 0)\n                  {\n                    intersectionSurfaceId->InsertValue(ptId1, 3);\n                  }\n                }\n                // Add information about origin surface to std::maps for\n                // checks later\n                if (intersectionSurfaceId->GetValue(ptId0) == 1)\n                {\n                  info->IntersectionPtsMap[0]->insert(std::make_pair(ptId0, cellId0));\n                }\n                else if (intersectionSurfaceId->GetValue(ptId0) == 2)\n                {\n                  info->IntersectionPtsMap[1]->insert(std::make_pair(ptId0, cellId1));\n                }\n                else\n                {\n                  info->IntersectionPtsMap[0]->insert(std::make_pair(ptId0, cellId0));\n                  info->IntersectionPtsMap[1]->insert(std::make_pair(ptId0, cellId1));\n                }\n                if (intersectionSurfaceId->GetValue(ptId1) == 1)\n                {\n                  info->IntersectionPtsMap[0]->insert(std::make_pair(ptId1, cellId0));\n                }\n                else if (intersectionSurfaceId->GetValue(ptId1) == 2)\n                {\n                  info->IntersectionPtsMap[1]->insert(std::make_pair(ptId1, cellId1));\n                }\n                else\n                {\n                  info->IntersectionPtsMap[0]->insert(std::make_pair(ptId1, cellId0));\n                  info->IntersectionPtsMap[1]->insert(std::make_pair(ptId1, cellId1));\n                }\n              }\n              */\n            }\n          }\n        }\n      }\n    }\n\n    if (intersectionPoints.length) {\n      var points = vtkPoints.newInstance();\n      points.setData(pushArray(info.intersectionLines.getPoints().getData(), intersectionPoints));\n      info.intersectionLines.setPoints(points);\n      var lines = vtkCellArray.newInstance();\n      lines.setData(pushArray(info.intersectionLines.getLines().getData(), intersectionLines));\n      info.intersectionLines.setLines(lines);\n    }\n    return intersectionLines.length / 3;\n  };\n  /**\n   * Create polygonal representation for OBB tree at specified level. If\n   * level < 0, then the leaf OBB nodes will be gathered. The aspect ratio (ar)\n   * and line diameter (d) are used to control the building of the\n   * representation. If a OBB node edge ratio's are greater than ar, then the\n   * dimension of the OBB is collapsed (OBB->plane->line). A \"line\" OBB will be\n   * represented either as two crossed polygons, or as a line, depending on\n   * the relative diameter of the OBB compared to the diameter (d).\n   * @param {Number} level Level of the representation\n   * @returns {vtkPolyData}\n   */\n\n  publicAPI.generateRepresentation = function (level) {\n    if (!model.tree) {\n      vtkErrorMacro('No tree to generate representation for');\n      return null;\n    }\n    var points = vtkPoints.newInstance();\n    var polys = vtkCellArray.newInstance();\n    generatePolygons(model.tree, 0, level, points, polys);\n    var output = vtkPolyData.newInstance();\n    output.setPoints(points);\n    output.setPolys(polys);\n    return output;\n  };\n  publicAPI.buildLocator = function () {\n    if (model.dataset === null) {\n      vtkErrorMacro(\"Can't build OBB tree - no data available!\");\n      return;\n    }\n    var numPts = model.dataset.getPoints().getNumberOfPoints();\n    var numCells = model.dataset.getNumberOfCells();\n    if (numPts < 1 || numCells < 1) {\n      vtkErrorMacro(\"Can't build OBB tree - no data available!\");\n      return;\n    }\n    model.OBBCount = 0; // Initialize an array of numPts elements set to value 0\n\n    model.insertedPoints = Array.from({\n      length: numPts\n    }, function (_) {\n      return 0;\n    });\n    model.pointsList = [];\n    var cellList = Array.from({\n      length: numCells\n    }, function (_, i) {\n      return i;\n    });\n    model.tree = vtkOBBNode.newInstance();\n    model.level = 0;\n    buildTree(cellList, model.tree, 0);\n    model.insertedPoints = [];\n    model.pointsList = [];\n    publicAPI.modified();\n  };\n} // ----------------------------------------------------------------------------\n\nvar DEFAULT_VALUES = {\n  tolerance: 0.01,\n  automatic: true,\n  numberOfCellsPerNode: 32,\n  dataset: null,\n  tree: null,\n  pointsList: [],\n  insertedPoints: [],\n  OBBCount: 0,\n  level: 8,\n  maxLevel: 8,\n  retainCellLists: 1\n}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Build VTK API\n\n  macro.setGet(publicAPI, model, ['tolerance', 'automatic', 'numberOfCellsPerNode', 'dataset', 'tree', 'maxLevel', 'level', 'retainCellLists']); // Make this a VTK object\n\n  macro.obj(publicAPI, model); // Object specific methods\n\n  vtkOBBTree(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = macro.newInstance(extend, 'vtkOBBTree'); // ----------------------------------------------------------------------------\n\nvar vtkOBBTree$1 = {\n  newInstance: newInstance,\n  extend: extend\n};\nexport { vtkOBBTree$1 as default, extend, newInstance };","map":{"version":3,"names":["_toConsumableArray","macro","vtkCellArray","vtkLine","d","dot","j","cross","n","norm","t","jacobi","l","normalize","k","add","vtkMatrixBuilder","vtkOBBNode","vtkPoints","CellType","vtkPolyData","vtkTriangle","pushArray","getCellTriangles","mat4","vec4","vtkErrorMacro","VTK_DOUBLE_MAX","Number","MAX_SAFE_INTEGER","vtkOBBTree","publicAPI","model","classHierarchy","push","computeOBB","cells","corner","max","mid","min","size","OBBCount","pointsList","numCells","length","mean","totMass","a0","a1","a2","a","dp0","dp1","c","triMass","dataset","getCells","buildCells","i","cellId","type","getCellType","ptIds","getCellPoints","cellPointIds","_numPts","cellsIds","pId","ptId0","qId","ptId1","rId","ptId2","p","q","r","getPoints","getPoint","xp","_k","_j","insertedPoints","pt","_i","_i2","_j2","v","_i3","tMin","tMax","numPts","ptId","_p","_i4","out","distanceToLine","slice","_i5","buildTree","obbNode","level","axes","getAxes","getCorner","setAxes","setCorner","maxLevel","numberOfCellsPerNode","LHlist","RHlist","splitPlane","splitAcceptable","bestRatio","foundBestSplit","bestPlane","_i6","_loop","_i7","pointsIDs","cellPts","forEach","id","negative","positive","x","val","_val","numInLHnode","numInRHnode","ratio","Math","abs","LHnode","newInstance","RHnode","setKids","setParent","retainCellLists","setCells","generatePolygons","repLevel","points","getKids","nbPoints","getNumberOfPoints","newPoints","newCells","cubeIds","apply","getAxis","y","xy","z","xz","yz","xyz","setData","getData","transform","matrix","create","copy","getMatrix","transformVector","buildFromRadian","setMatrix","obbStack","Array","tree","depth","node","deepCopy","setLevel","getLevel","setRetainCellLists","getRetainCellLists","setDataset","getDataset","setAutomatic","getAutomatic","setNumberOfCellsPerNode","getNumberOfCellsPerNode","setTolerance","getTolerance","root","getTree","computeOBBFromDataset","input","getNumberOfCells","from","_","cellList","disjointOBBNodes","nodeA","nodeB","XformBtoA","output","eps","tolerance","pA","pB","dotAB","transformMat4","ii","_ii","_ii2","centerA","centerB","AtoB","_ii3","rangeAmin","rangeAmax","rangeBmin","rangeBmax","dotA","dotB","_ii4","_ii5","jj","_ii6","_jj","_ii7","_jj2","kk","intersectWithOBBTree","obbTreeB","onIntersect","arguments","undefined","maxDepth","minDepth","maxStackDepth","OBBStackA","OBBStackB","count","returnValue","triangleIntersectsNode","p0","p1","p2","v0","v1","_ii8","xprod","_ii9","_dotB","_ii10","_jj3","findTriangleIntersections","info","node0","node1","mesh0","mesh1","obbTree1","pointOffset","intersectionLines","intersectionPoints","numCells0","id0","cellId0","type0","VTK_TRIANGLE","_mesh0$getCellPoints","triPtIds0","triPts0","numCells1","id1","cellId1","type1","_mesh1$getCellPoints","triPtIds1","triPts1","_id","_vtkTriangle$intersec","intersectWithTriangle","concat","intersect","coplanar","outpt0","pt1","outpt1","pt2","pointId","setPoints","lines","getLines","setLines","generateRepresentation","polys","setPolys","buildLocator","modified","DEFAULT_VALUES","automatic","extend","initialValues","Object","assign","setGet","obj","vtkOBBTree$1","default"],"sources":["/home/rakshith/Documents/RemoteRendering/vtk-js-react-app/node_modules/@kitware/vtk.js/Filters/General/OBBTree.js"],"sourcesContent":["import _toConsumableArray from '@babel/runtime/helpers/toConsumableArray';\nimport macro from '../../macros.js';\nimport vtkCellArray from '../../Common/Core/CellArray.js';\nimport vtkLine from '../../Common/DataModel/Line.js';\nimport { d as dot, j as cross, n as norm, t as jacobi, l as normalize, k as add } from '../../Common/Core/Math/index.js';\nimport vtkMatrixBuilder from '../../Common/Core/MatrixBuilder.js';\nimport vtkOBBNode from './OBBTree/OBBNode.js';\nimport vtkPoints from '../../Common/Core/Points.js';\nimport { CellType } from '../../Common/DataModel/CellTypes/Constants.js';\nimport vtkPolyData from '../../Common/DataModel/PolyData.js';\nimport vtkTriangle from '../../Common/DataModel/Triangle.js';\nimport { pushArray, getCellTriangles } from './OBBTree/helper.js';\nimport { mat4, vec4 } from 'gl-matrix';\n\nvar vtkErrorMacro = macro.vtkErrorMacro;\nvar VTK_DOUBLE_MAX = Number.MAX_SAFE_INTEGER; // ----------------------------------------------------------------------------\n// vtkOBBTree methods\n// ----------------------------------------------------------------------------\n\nfunction vtkOBBTree(publicAPI, model) {\n  // Set our classname\n  model.classHierarchy.push('vtkOBBTree');\n  /**\n   * Compute an OBB from the list of cells given.  This used to be\n   * public but should not have been.  A public call has been added\n   * so that the functionality can be accessed.\n   * @param {Array} cells\n   * @param {Array[3]} corner\n   * @param {Array[3]} max\n   * @param {Array[3]} mid\n   * @param {Array[3]} min\n   * @param {Array[3]} size\n   */\n\n  function computeOBB(cells, corner, max, mid, min, size) {\n    model.OBBCount++;\n    model.pointsList = []; //\n    // Compute mean & moments\n    //\n\n    var numCells = cells.length;\n    var mean = [0, 0, 0];\n    var totMass = 0.0;\n    var a0 = [0, 0, 0];\n    var a1 = [0, 0, 0];\n    var a2 = [0, 0, 0];\n    var a = [0, 0, 0, 0, 0, 0, 0, 0, 0];\n    var dp0 = [0, 0, 0];\n    var dp1 = [0, 0, 0];\n    var c = [0, 0, 0];\n    var triMass = 0;\n\n    if (!model.dataset.getCells()) {\n      model.dataset.buildCells();\n    }\n\n    for (var i = 0; i < numCells; i++) {\n      var cellId = cells[i];\n      var type = model.dataset.getCells().getCellType(cellId);\n      var ptIds = model.dataset.getCellPoints(cellId).cellPointIds;\n      var _numPts = ptIds.length;\n\n      for (var j = 0; j < _numPts - 2; j++) {\n        var cellsIds = getCellTriangles(ptIds, type, j);\n        var pId = cellsIds.ptId0;\n        var qId = cellsIds.ptId1;\n        var rId = cellsIds.ptId2;\n\n        if (pId < 0) {\n          // eslint-disable-next-line no-continue\n          continue;\n        }\n\n        var p = [];\n        var q = [];\n        var r = [];\n        model.dataset.getPoints().getPoint(pId, p);\n        model.dataset.getPoints().getPoint(qId, q);\n        model.dataset.getPoints().getPoint(rId, r); // p, q, and r are the oriented triangle points.\n        // Compute the components of the moment of inertia tensor.\n\n        for (var k = 0; k < 3; k++) {\n          // two edge vectors\n          dp0[k] = q[k] - p[k];\n          dp1[k] = r[k] - p[k]; // centroid\n\n          c[k] = (p[k] + q[k] + r[k]) / 3;\n        }\n\n        var xp = cross(dp0, dp1, []);\n        triMass = 0.5 * norm(xp);\n        totMass += triMass;\n\n        for (var _k = 0; _k < 3; _k++) {\n          mean[_k] += triMass * c[_k];\n        } // on-diagonal terms\n\n\n        a0[0] += triMass * (9 * c[0] * c[0] + p[0] * p[0] + q[0] * q[0] + r[0] * r[0]) / 12;\n        a1[1] += triMass * (9 * c[1] * c[1] + p[1] * p[1] + q[1] * q[1] + r[1] * r[1]) / 12;\n        a2[2] += triMass * (9 * c[2] * c[2] + p[2] * p[2] + q[2] * q[2] + r[2] * r[2]) / 12; // off-diagonal terms\n\n        a0[1] += triMass * (9 * c[0] * c[1] + p[0] * p[1] + q[0] * q[1] + r[0] * r[1]) / 12;\n        a0[2] += triMass * (9 * c[0] * c[2] + p[0] * p[2] + q[0] * q[2] + r[0] * r[2]) / 12;\n        a1[2] += triMass * (9 * c[1] * c[2] + p[1] * p[2] + q[1] * q[2] + r[1] * r[2]) / 12;\n      } // end foreach triangle\n      // While computing cell moments, gather all the cell's\n      // point coordinates into a single list.\n\n\n      for (var _j = 0; _j < _numPts; _j++) {\n        if (model.insertedPoints[ptIds[_j]] !== model.OBBCount) {\n          model.insertedPoints[ptIds[_j]] = model.OBBCount;\n          var pt = [];\n          model.dataset.getPoints().getPoint(ptIds[_j], pt);\n          model.pointsList.push(pt);\n        }\n      } // for all points of this cell\n\n    } // end foreach cell\n    // normalize data\n\n\n    for (var _i = 0; _i < 3; _i++) {\n      mean[_i] /= totMass;\n    } // matrix is symmetric\n\n\n    a1[0] = a0[1];\n    a2[0] = a0[2];\n    a2[1] = a1[2];\n    a = [a0[0], a0[1], a0[2], a1[0], a1[1], a1[2], a2[0], a2[1], a2[2]]; // get covariance from moments\n\n    for (var _i2 = 0; _i2 < 3; _i2++) {\n      for (var _j2 = 0; _j2 < 3; _j2++) {\n        a[_i2 * 3 + _j2] = a[_i2 * 3 + _j2] / totMass - mean[_i2] * mean[_j2];\n      }\n    } //\n    // Extract axes (i.e., eigenvectors) from covariance matrix.\n    //\n\n\n    var v = [0, 0, 0, 0, 0, 0, 0, 0, 0];\n    jacobi(a, size, v);\n    max[0] = v[0];\n    max[1] = v[3];\n    max[2] = v[6];\n    mid[0] = v[1];\n    mid[1] = v[4];\n    mid[2] = v[7];\n    min[0] = v[2];\n    min[1] = v[5];\n    min[2] = v[8];\n\n    for (var _i3 = 0; _i3 < 3; _i3++) {\n      a[_i3] = mean[_i3] + max[_i3];\n      a[3 + _i3] = mean[_i3] + mid[_i3];\n      a[6 + _i3] = mean[_i3] + min[_i3];\n    } //\n    // Create oriented bounding box by projecting points onto eigenvectors.\n    //\n\n\n    var tMin = [VTK_DOUBLE_MAX, VTK_DOUBLE_MAX, VTK_DOUBLE_MAX];\n    var tMax = [-VTK_DOUBLE_MAX, -VTK_DOUBLE_MAX, -VTK_DOUBLE_MAX];\n    var numPts = model.pointsList.length;\n\n    for (var ptId = 0; ptId < numPts; ptId++) {\n      var _p = model.pointsList[ptId];\n\n      for (var _i4 = 0; _i4 < 3; _i4++) {\n        var out = vtkLine.distanceToLine(_p, mean, a.slice(3 * _i4, 3 * (_i4 + 1)), []);\n\n        if (out.t < tMin[_i4]) {\n          tMin[_i4] = out.t;\n        }\n\n        if (out.t > tMax[_i4]) {\n          tMax[_i4] = out.t;\n        }\n      }\n    } // for all points\n\n\n    for (var _i5 = 0; _i5 < 3; _i5++) {\n      corner[_i5] = mean[_i5] + tMin[0] * max[_i5] + tMin[1] * mid[_i5] + tMin[2] * min[_i5];\n      max[_i5] *= tMax[0] - tMin[0];\n      mid[_i5] *= tMax[1] - tMin[1];\n      min[_i5] *= tMax[2] - tMin[2];\n    }\n  }\n  /**\n   * Build the OBB tree\n   * @param {Array} cells\n   * @param {vtkOBBNode} obbNode\n   * @param {Number} level\n   */\n\n\n  function buildTree(cells, obbNode, level) {\n    var numCells = cells.length;\n\n    if (level > model.level) {\n      model.level = level;\n    }\n\n    var axes = obbNode.getAxes();\n    var corner = obbNode.getCorner();\n    var size = [0, 0, 0];\n    computeOBB(cells, corner, axes[0], axes[1], axes[2], size);\n    obbNode.setAxes(axes);\n    obbNode.setCorner(corner); // Check whether to continue recursing; if so, create two children and\n    // assign cells to appropriate child.\n\n    if (level < model.maxLevel && numCells > model.numberOfCellsPerNode) {\n      var LHlist = [];\n      var RHlist = [];\n      var p = [0, 0, 0];\n      var n = [0, 0, 0]; // loop over three split planes to find acceptable one\n\n      for (var i = 0; i < 3; i++) {\n        // compute split point\n        p[i] = corner[i] + axes[0][i] / 2 + axes[1][i] / 2 + axes[2][i] / 2;\n      }\n\n      var splitPlane = 0;\n      var splitAcceptable = 0;\n      var bestRatio = 1;\n      var foundBestSplit = 0;\n      var bestPlane = 0;\n\n      for (; !splitAcceptable && splitPlane < 3;) {\n        // compute split normal\n        for (var _i6 = 0; _i6 < 3; _i6++) {\n          n[_i6] = axes[splitPlane][_i6];\n        }\n\n        normalize(n); // traverse cells, assigning to appropriate child list as necessary\n\n        var _loop = function _loop(_i7) {\n          var cellId = cells[_i7];\n          var pointsIDs = model.dataset.getCellPoints(cellId).cellPointIds;\n          var cellPts = [];\n          pointsIDs.forEach(function (id) {\n            var pt = [];\n            model.dataset.getPoints().getPoint(pointsIDs[id], pt);\n            cellPts.push(pt);\n          });\n          var c = [0, 0, 0];\n          var numPts = cellPts.length;\n          var negative = 0;\n          var positive = 0;\n\n          for (var j = 0; j < numPts; j++) {\n            var ptId = pointsIDs[j];\n            var x = model.dataset.getPoints().getPoint(ptId);\n            var val = n[0] * (x[0] - p[0]) + n[1] * (x[1] - p[1]) + n[2] * (x[2] - p[2]);\n            c[0] += x[0];\n            c[1] += x[1];\n            c[2] += x[2];\n\n            if (val < 0.0) {\n              negative = 1;\n            } else {\n              positive = 1;\n            }\n          }\n\n          if (negative && positive) {\n            // Use centroid to decide straddle cases\n            c[0] /= numPts;\n            c[1] /= numPts;\n            c[2] /= numPts;\n\n            var _val = n[0] * (c[0] - p[0]) + n[1] * (c[1] - p[1]) + n[2] * (c[2] - p[2]);\n\n            if (_val < 0.0) {\n              LHlist.push(cellId);\n            } else {\n              RHlist.push(cellId);\n            }\n          } else if (negative) {\n            LHlist.push(cellId);\n          } else {\n            RHlist.push(cellId);\n          }\n        };\n\n        for (var _i7 = 0; _i7 < numCells; _i7++) {\n          _loop(_i7);\n        } // for all cells\n        // evaluate this split\n\n\n        var numInLHnode = LHlist.length;\n        var numInRHnode = RHlist.length;\n        var ratio = Math.abs((numInRHnode - numInLHnode) / numCells); // see whether we've found acceptable split plane\n\n        if (ratio < 0.6 || foundBestSplit) {\n          // accept right off the bat\n          splitAcceptable = 1;\n        } else {\n          // not a great split try another\n          LHlist = [];\n          RHlist = [];\n\n          if (ratio < bestRatio) {\n            bestRatio = ratio;\n            bestPlane = splitPlane;\n          }\n\n          if (++splitPlane === 3 && bestRatio < 0.95) {\n            // at closing time, even the ugly ones look good\n            splitPlane = bestPlane;\n            foundBestSplit = 1;\n          }\n        } // try another split\n\n      } // for each split\n\n\n      if (splitAcceptable) {\n        // otherwise recursion terminates\n        var LHnode = vtkOBBNode.newInstance();\n        var RHnode = vtkOBBNode.newInstance();\n        obbNode.setKids([LHnode, RHnode]);\n        LHnode.setParent(obbNode);\n        RHnode.setParent(obbNode);\n        cells.length = 0;\n        buildTree(LHlist, LHnode, level + 1);\n        buildTree(RHlist, RHnode, level + 1);\n      } else {\n        // free up local objects\n        LHlist = [];\n        RHlist = [];\n      }\n    } // if should build tree\n\n\n    if (cells && model.retainCellLists) {\n      obbNode.setCells(cells);\n    } else if (cells) {\n      cells.length = 0;\n    }\n  }\n\n  function generatePolygons(obbNode, level, repLevel, points, cells) {\n    if (level === repLevel || repLevel < 0 && obbNode.getKids()) {\n      var nbPoints = points.getNumberOfPoints();\n      var newPoints = [];\n      var newCells = [];\n      var cubeIds = [];\n      newPoints.push.apply(newPoints, _toConsumableArray(obbNode.getCorner()));\n      cubeIds[0] = nbPoints++;\n      var x = [];\n      newPoints.push.apply(newPoints, _toConsumableArray(add(obbNode.getCorner(), obbNode.getAxis(0), x)));\n      cubeIds[1] = nbPoints++;\n      var y = [];\n      newPoints.push.apply(newPoints, _toConsumableArray(add(obbNode.getCorner(), obbNode.getAxis(1), y)));\n      cubeIds[2] = nbPoints++;\n      var xy = [];\n      newPoints.push.apply(newPoints, _toConsumableArray(add(x, obbNode.getAxis(1), xy)));\n      cubeIds[3] = nbPoints++;\n      var z = [];\n      newPoints.push.apply(newPoints, _toConsumableArray(add(obbNode.getCorner(), obbNode.getAxis(2), z)));\n      cubeIds[4] = nbPoints++;\n      var xz = [];\n      newPoints.push.apply(newPoints, _toConsumableArray(add(x, obbNode.getAxis(2), xz)));\n      cubeIds[5] = nbPoints++;\n      var yz = [];\n      newPoints.push.apply(newPoints, _toConsumableArray(add(y, obbNode.getAxis(2), yz)));\n      cubeIds[6] = nbPoints++;\n      var xyz = [];\n      newPoints.push.apply(newPoints, _toConsumableArray(add(xy, obbNode.getAxis(2), xyz)));\n      cubeIds[7] = nbPoints++;\n      newCells.push(4, cubeIds[0], cubeIds[2], cubeIds[3], cubeIds[1]);\n      newCells.push(4, cubeIds[0], cubeIds[1], cubeIds[5], cubeIds[4]);\n      newCells.push(4, cubeIds[0], cubeIds[4], cubeIds[6], cubeIds[2]);\n      newCells.push(4, cubeIds[1], cubeIds[3], cubeIds[7], cubeIds[5]);\n      newCells.push(4, cubeIds[4], cubeIds[5], cubeIds[7], cubeIds[6]);\n      newCells.push(4, cubeIds[2], cubeIds[6], cubeIds[7], cubeIds[3]);\n      points.setData(pushArray(points.getData(), newPoints));\n      cells.setData(pushArray(cells.getData(), newCells));\n    } else if ((level < repLevel || repLevel < 0) && obbNode.getKids()) {\n      generatePolygons(obbNode.getKids()[0], level + 1, repLevel, points, cells);\n      generatePolygons(obbNode.getKids()[1], level + 1, repLevel, points, cells);\n    }\n  }\n  /**\n   * Transform the whole OBB tree by using input transform\n   * @param {Transform} transform vtkjs Transform object\n   */\n\n\n  publicAPI.transform = function (transform) {\n    // Setup matrix used to transform vectors\n    var matrix = mat4.create();\n    mat4.copy(matrix, transform.getMatrix());\n    matrix[12] = 0;\n    matrix[13] = 0;\n    matrix[14] = 0;\n    matrix[15] = 1;\n    var transformVector = vtkMatrixBuilder.buildFromRadian().setMatrix(matrix);\n    var obbStack = new Array(model.level + 1);\n    obbStack[0] = model.tree;\n    var depth = 1;\n\n    while (depth > 0) {\n      depth -= 1;\n      var node = obbStack[depth];\n      var corner = node.getCorner();\n      var max = node.getAxis(0);\n      var mid = node.getAxis(1);\n      var min = node.getAxis(2);\n      transform.apply(corner);\n      transformVector.apply(max);\n      transformVector.apply(mid);\n      transformVector.apply(min);\n      node.setCorner(corner);\n      node.setAxes([max, mid, min]);\n\n      if (node.getKids() !== null) {\n        // push kids onto stack\n        obbStack[depth] = node.getKids()[0];\n        obbStack[depth + 1] = node.getKids()[1];\n        depth += 2;\n      }\n    }\n  };\n  /**\n   * Deep copy input node into class attribute tree\n   * @param {vtkOBBNode} tree\n   * @returns\n   */\n\n\n  publicAPI.deepCopy = function (tree) {\n    if (!tree) {\n      return;\n    }\n\n    publicAPI.setLevel(tree.getLevel());\n    publicAPI.setRetainCellLists(tree.getRetainCellLists());\n    publicAPI.setDataset(tree.getDataset());\n    publicAPI.setAutomatic(tree.getAutomatic());\n    publicAPI.setNumberOfCellsPerNode(tree.getNumberOfCellsPerNode());\n    publicAPI.setTolerance(tree.getTolerance());\n    var root = tree.getTree();\n\n    if (root) {\n      model.tree = vtkOBBNode.newInstance();\n      model.tree.deepCopy(root);\n    }\n  };\n  /**\n   * A method to compute the OBB of a dataset without having to go through the\n   * Execute method; It does set\n   * @param {vtkPolyData} input\n   * @param {Array[3]} corner\n   * @param {Array[3]} max\n   * @param {Array[3]} mid\n   * @param {Array[3]} min\n   * @param {Array[3]} size\n   */\n\n\n  publicAPI.computeOBBFromDataset = function (input, corner, max, mid, min, size) {\n    if (!input) {\n      return;\n    }\n\n    var numPts = input.getPoints().getNumberOfPoints();\n    var numCells = input.getNumberOfCells();\n\n    if (numPts < 1 || numCells < 1) {\n      vtkErrorMacro(\"Can't compute OBB - no data available!\");\n      return;\n    }\n\n    model.dataset = input;\n    model.OBBCount = 0;\n    model.insertedPoints = Array.from({\n      length: numPts\n    }, function (_) {\n      return 0;\n    });\n    model.pointsList = [];\n    var cellList = Array.from({\n      length: numCells\n    }, function (_, i) {\n      return i;\n    });\n    computeOBB(cellList, corner, max, mid, min, size);\n  };\n  /**\n   * Returns true if nodeB and nodeA are disjoint after optional\n   * transformation of nodeB with matrix XformBtoA\n   * @param {vtkOBBNode} nodeA\n   * @param {vtkOBBNode} nodeB\n   * @param {mat4} XformBtoA\n   */\n\n\n  publicAPI.disjointOBBNodes = function (nodeA, nodeB, XformBtoA) {\n    if (!nodeA || !nodeB) {\n      return 5; // A and B are disjoint\n    }\n\n    var input = new Array(4);\n    var output = new Array(4);\n    var eps = model.tolerance;\n    var pA = nodeA;\n    var pB = vtkOBBNode.newInstance();\n    var dotAB = [0, 0, 0, 0, 0, 0, 0, 0, 0];\n\n    if (XformBtoA) {\n      // Here we assume that XformBtoA is an orthogonal matrix\n      input[0] = nodeB.getCorner()[0];\n      input[1] = nodeB.getCorner()[1];\n      input[2] = nodeB.getCorner()[2];\n      input[3] = 1.0;\n      vec4.transformMat4(output, input, XformBtoA);\n      pB.setCorner([output[0] / output[3], output[1] / output[3], output[2] / output[3]]); // Clean this up when the bug input MultiplyVectors is fixed!\n\n      for (var ii = 0; ii < 3; ii++) {\n        pB.getAxis(0)[ii] = nodeB.getCorner()[ii] + nodeB.getAxis(0)[ii];\n        pB.getAxis(1)[ii] = nodeB.getCorner()[ii] + nodeB.getAxis(1)[ii];\n        pB.getAxis(2)[ii] = nodeB.getCorner()[ii] + nodeB.getAxis(2)[ii];\n      }\n\n      for (var _ii = 0; _ii < 3; _ii++) {\n        input[0] = pB.getAxis(_ii)[0];\n        input[1] = pB.getAxis(_ii)[1];\n        input[2] = pB.getAxis(_ii)[2];\n        input[3] = 1.0;\n        vec4.transformMat4(output, input, XformBtoA);\n        pB.getAxis(_ii)[0] = output[0] / output[3];\n        pB.getAxis(_ii)[1] = output[1] / output[3];\n        pB.getAxis(_ii)[2] = output[2] / output[3];\n      }\n\n      for (var _ii2 = 0; _ii2 < 3; _ii2++) {\n        pB.getAxis(0)[_ii2] = pB.getAxis(0)[_ii2] - pB.getCorner()[_ii2];\n        pB.getAxis(1)[_ii2] = pB.getAxis(1)[_ii2] - pB.getCorner()[_ii2];\n        pB.getAxis(2)[_ii2] = pB.getAxis(2)[_ii2] - pB.getCorner()[_ii2];\n      }\n    } else {\n      pB = nodeB;\n    }\n\n    var centerA = [0, 0, 0];\n    var centerB = [0, 0, 0];\n    var AtoB = [0, 0, 0];\n\n    for (var _ii3 = 0; _ii3 < 3; _ii3++) {\n      centerA[_ii3] = pA.getCorner()[_ii3] + 0.5 * (pA.getAxis(0)[_ii3] + pA.getAxis(1)[_ii3] + pA.getAxis(2)[_ii3]);\n      centerB[_ii3] = pB.getCorner()[_ii3] + 0.5 * (pB.getAxis(0)[_ii3] + pB.getAxis(1)[_ii3] + pB.getAxis(2)[_ii3]);\n      AtoB[_ii3] = centerB[_ii3] - centerA[_ii3];\n    } // Project maximal and minimal corners onto line between centers\n\n\n    var rangeAmin = dot(pA.getCorner(), AtoB);\n    var rangeAmax = rangeAmin;\n    var rangeBmin = dot(pB.getCorner(), AtoB);\n    var rangeBmax = rangeBmin;\n    var dotA = 0;\n    var dotB = 0;\n\n    for (var _ii4 = 0; _ii4 < 3; _ii4++) {\n      // compute A range\n      dotA = dot(pA.getAxis(_ii4), AtoB);\n\n      if (dotA > 0) {\n        rangeAmax += dotA;\n      } else {\n        rangeAmin += dotA;\n      } // compute B range\n\n\n      dotB = dot(pB.getAxis(_ii4), AtoB);\n\n      if (dotB > 0) {\n        rangeBmax += dotB;\n      } else {\n        rangeBmin += dotB;\n      }\n    }\n\n    if (rangeAmax + eps < rangeBmin || rangeBmax + eps < rangeAmin) {\n      return 1; // A and B are Disjoint by the 1st test.\n    } // now check for a separation plane parallel to the faces of B\n\n\n    for (var _ii5 = 0; _ii5 < 3; _ii5++) {\n      // plane is normal to pB.getAxis(ii)\n      // computing B range is easy...\n      rangeBmin = dot(pB.getCorner(), pB.getAxis(_ii5));\n      rangeBmax = rangeBmin;\n      rangeBmax += dot(pB.getAxis(_ii5), pB.getAxis(_ii5)); // compute A range...\n\n      rangeAmin = dot(pA.getCorner(), pB.getAxis(_ii5));\n      rangeAmax = rangeAmin;\n\n      for (var jj = 0; jj < 3; jj++) {\n        // (note: we are saving all 9 dotproducts for future use)\n        dotA = dot(pB.getAxis(_ii5), pA.getAxis(jj));\n        dotAB[_ii5 * 3 + jj] = dotA;\n\n        if (dotA > 0) {\n          rangeAmax += dotA;\n        } else {\n          rangeAmin += dotA;\n        }\n      }\n\n      if (rangeAmax + eps < rangeBmin || rangeBmax + eps < rangeAmin) {\n        return 2; // A and B are Disjoint by the 3rd test.\n      }\n    } // now check for a separation plane parallel to the faces of A\n\n\n    for (var _ii6 = 0; _ii6 < 3; _ii6++) {\n      // plane is normal to pA.getAxis(ii)\n      // computing A range is easy...\n      rangeAmin = dot(pA.getCorner(), pA.getAxis(_ii6));\n      rangeAmax = rangeAmin;\n      rangeAmax += dot(pA.getAxis(_ii6), pA.getAxis(_ii6)); // compute B range...\n\n      rangeBmin = dot(pB.getCorner(), pA.getAxis(_ii6));\n      rangeBmax = rangeBmin;\n\n      for (var _jj = 0; _jj < 3; _jj++) {\n        // (note: we are using the 9 dotproducts computed earlier)\n        dotB = dotAB[_jj * 3 + _ii6];\n\n        if (dotB > 0) {\n          rangeBmax += dotB;\n        } else {\n          rangeBmin += dotB;\n        }\n      }\n\n      if (rangeAmax + eps < rangeBmin || rangeBmax + eps < rangeAmin) {\n        return 3; // A and B are Disjoint by the 2nd test.\n      }\n    } // Bad luck: now we must look for a separation plane parallel\n    // to one edge from A and one edge from B.\n\n\n    for (var _ii7 = 0; _ii7 < 3; _ii7++) {\n      for (var _jj2 = 0; _jj2 < 3; _jj2++) {\n        // the plane is normal to pA.getAxis(ii) X pB.getAxis(jj)\n        cross(pA.getAxis(_ii7), pB.getAxis(_jj2), AtoB);\n        rangeAmin = dot(pA.getCorner(), AtoB);\n        rangeAmax = rangeAmin;\n        rangeBmin = dot(pB.getCorner(), AtoB);\n        rangeBmax = rangeBmin;\n\n        for (var kk = 0; kk < 3; kk++) {\n          // compute A range\n          dotA = dot(pA.getAxis(kk), AtoB);\n\n          if (dotA > 0) {\n            rangeAmax += dotA;\n          } else {\n            rangeAmin += dotA;\n          } // compute B range\n\n\n          dotB = dot(pB.getAxis(kk), AtoB);\n\n          if (dotB > 0) {\n            rangeBmax += dotB;\n          } else {\n            rangeBmin += dotB;\n          }\n        }\n\n        if (rangeAmax + eps < rangeBmin || rangeBmax + eps < rangeAmin) {\n          return 4; // A and B are Disjoint by the 4th test.\n        }\n      }\n    } // if we fall through to here, the OBB's overlap\n\n\n    return 0;\n  };\n  /**\n   * Intersect this OBBTree with OBBTreeB (as transformed) and\n   * call processing function for each intersecting leaf node pair.\n   * If the processing function returns a negative integer, terminate.\n   * For each intersecting leaf node pair, call callback.\n   * OBBTreeB is optionally transformed by XformBtoA before testing\n   * @param {vtkOBBTree} obbTreeB\n   * @param {mat4|null|undefined} XformBtoA\n   * @param {function|null|undefined} callback Compared function that takes in argument:\n   * nodeA (vtkOBBNode), nodeB (vtkOBBNode), XForm (mat4), arg\n   */\n\n\n  publicAPI.intersectWithOBBTree = function (obbTreeB, XformBtoA) {\n    var onIntersect = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function () {\n      return -1;\n    };\n    var maxDepth = model.level;\n    var minDepth = obbTreeB.getLevel();\n\n    if (minDepth > maxDepth) {\n      minDepth = maxDepth;\n      maxDepth = obbTreeB.getLevel();\n    }\n\n    var maxStackDepth = 3 * minDepth + 2 * (maxDepth - minDepth) + 1;\n    var OBBStackA = new Array(maxStackDepth);\n    var OBBStackB = new Array(maxStackDepth);\n    OBBStackA[0] = model.tree;\n    OBBStackB[0] = obbTreeB.getTree();\n    var depth = 1;\n    var count = 0;\n    var returnValue = 0; // simulate recursion without overhead of real recursion.\n\n    while (depth > 0 && returnValue > -1) {\n      depth--;\n      var nodeA = OBBStackA[depth];\n      var nodeB = OBBStackB[depth];\n\n      if (!publicAPI.disjointOBBNodes(nodeA, nodeB, XformBtoA)) {\n        // Collision\n        if (!nodeA.getKids()) {\n          if (!nodeB.getKids()) {\n            returnValue = onIntersect(nodeA, nodeB, XformBtoA);\n            count += Math.abs(returnValue);\n          } else {\n            // A is a leaf, but B goes deeper.\n            OBBStackA[depth] = nodeA;\n            OBBStackB[depth] = nodeB.getKids()[0];\n            OBBStackA[depth + 1] = nodeA;\n            OBBStackB[depth + 1] = nodeB.getKids()[1];\n            depth += 2;\n          }\n        } else if (!nodeB.getKids()) {\n          // B is a leaf, but A goes deeper.\n          OBBStackB[depth] = nodeB;\n          OBBStackA[depth] = nodeA.getKids()[0];\n          OBBStackB[depth + 1] = nodeB;\n          OBBStackA[depth + 1] = nodeA.getKids()[1];\n          depth += 2;\n        } else {\n          // neither A nor B are leaves. Go to the next level.\n          OBBStackA[depth] = nodeA.getKids()[0];\n          OBBStackB[depth] = nodeB.getKids()[0];\n          OBBStackA[depth + 1] = nodeA.getKids()[1];\n          OBBStackB[depth + 1] = nodeB.getKids()[0];\n          OBBStackA[depth + 2] = nodeA.getKids()[0];\n          OBBStackB[depth + 2] = nodeB.getKids()[1];\n          OBBStackA[depth + 3] = nodeA.getKids()[1];\n          OBBStackB[depth + 3] = nodeB.getKids()[1];\n          depth += 4;\n        }\n      }\n    }\n\n    return count;\n  };\n\n  publicAPI.triangleIntersectsNode = function (nodeA, p0, p1, p2, XformBtoA) {\n    var eps = model.tolerance;\n    var pA = nodeA;\n    var pB = [_toConsumableArray(p0), _toConsumableArray(p1), _toConsumableArray(p2)];\n\n    if (XformBtoA) {\n      // Here we assume that XformBtoA is an orthogonal matrix\n      var input = [0, 0, 0, 1];\n      var output = [];\n\n      for (var ii = 0; ii < 3; ii++) {\n        input[0] = pB[ii][0];\n        input[1] = pB[ii][1];\n        input[2] = pB[ii][2];\n        vec4.transformMat4(output, input, XformBtoA);\n        pB[ii][0] = output[0] / output[3];\n        pB[ii][1] = output[1] / output[3];\n        pB[ii][2] = output[2] / output[3];\n      }\n    } // now check for a separation plane parallel to the triangle\n\n\n    var v0 = [];\n    var v1 = [];\n\n    for (var _ii8 = 0; _ii8 < 3; _ii8++) {\n      // plane is normal to the triangle\n      v0[_ii8] = pB[1][_ii8] - pB[0][_ii8];\n      v1[_ii8] = pB[2][_ii8] - pB[0][_ii8];\n    }\n\n    var xprod = cross(v0, v1, []); // computing B range is easy...\n\n    var rangeBmax = dot(pB[0], xprod);\n    var rangeBmin = rangeBmax; // compute A range...\n\n    var rangeAmax = dot(pA.getCorner(), xprod);\n    var rangeAmin = rangeAmax;\n    var dotA;\n\n    for (var jj = 0; jj < 3; jj++) {\n      dotA = dot(xprod, pA.getAxis(jj));\n\n      if (dotA > 0) {\n        rangeAmax += dotA;\n      } else {\n        rangeAmin += dotA;\n      }\n    }\n\n    if (rangeAmax + eps < rangeBmin || rangeBmax + eps < rangeAmin) {\n      return 0; // A and B are Disjoint by the 1st test.\n    } // now check for a separation plane parallel to the faces of A\n\n\n    for (var _ii9 = 0; _ii9 < 3; _ii9++) {\n      // plane is normal to pA->Axes[ii]\n      // computing A range is easy...\n      rangeAmax = dot(pA.getCorner(), pA.getAxis(_ii9));\n      rangeAmin = rangeAmax;\n      rangeAmax += dot(pA.getAxis(_ii9), pA.getAxis(_ii9)); // compute B range...\n\n      rangeBmax = dot(pB[0], pA.getAxis(_ii9));\n      rangeBmin = rangeBmax;\n\n      var _dotB = dot(pB[1], pA.getAxis(_ii9));\n\n      if (_dotB > rangeBmax) {\n        rangeBmax = _dotB;\n      } else {\n        rangeBmin = _dotB;\n      }\n\n      _dotB = dot(pB[2], pA.getAxis(_ii9));\n\n      if (_dotB > rangeBmax) {\n        rangeBmax = _dotB;\n      } else if (_dotB < rangeBmin) {\n        rangeBmin = _dotB;\n      }\n\n      if (rangeAmax + eps < rangeBmin || rangeBmax + eps < rangeAmin) {\n        return 0; // A and B are Disjoint by the 2nd test.\n      }\n    } // Bad luck: now we must look for a separation plane parallel\n    // to one edge from A and one edge from B.\n\n\n    var AtoB = [];\n    var dotB;\n\n    for (var _ii10 = 0; _ii10 < 3; _ii10++) {\n      for (var _jj3 = 0; _jj3 < 3; _jj3++) {\n        // the plane is normal to pA->Axes[ii] X (pB[jj+1]-pB[jj])\n        v0[0] = pB[(_jj3 + 1) % 3][0] - pB[_jj3][0];\n        v0[1] = pB[(_jj3 + 1) % 3][1] - pB[_jj3][1];\n        v0[2] = pB[(_jj3 + 1) % 3][2] - pB[_jj3][2];\n        cross(pA.getAxis(_ii10), v0, AtoB);\n        rangeAmax = dot(pA.getCorner(), AtoB);\n        rangeAmin = rangeAmax;\n        rangeBmax = dot(pB[_jj3], AtoB);\n        rangeBmin = rangeBmax;\n\n        for (var kk = 0; kk < 3; kk++) {\n          // compute A range\n          dotA = dot(pA.getAxis(kk), AtoB);\n\n          if (dotA > 0) {\n            rangeAmax += dotA;\n          } else {\n            rangeAmin += dotA;\n          }\n        } // compute B range\n\n\n        dotB = dot(pB[(_jj3 + 2) % 3], AtoB);\n\n        if (dotB > rangeBmax) {\n          rangeBmax = dotB;\n        } else {\n          rangeBmin = dotB;\n        }\n\n        if (rangeAmax + eps < rangeBmin || rangeBmax + eps < rangeAmin) {\n          return 0; // A and B are Disjoint by the 3rd test.\n        }\n      }\n    } // if we fall through to here, the OBB overlaps the triangle.\n\n\n    return 1;\n  };\n  /**\n   *\n   * @param {*} info must be an object with { obbTree1, intersectionLines }\n   * @param {*} node0\n   * @param {*} node1\n   * @param {*} transform\n   * @returns the number of intersection lines found\n   */\n\n\n  publicAPI.findTriangleIntersections = function (info, node0, node1, transform) {\n    // Set up local structures to hold Impl array information\n    // vtkOBBTree* obbTree1 = info->OBBTree1;\n    // vtkCellArray* intersectionLines = info->IntersectionLines;\n    // vtkIdTypeArray* intersectionSurfaceId = info->SurfaceId;\n    // vtkIdTypeArray* intersectionCellIds0 = info->CellIds[0];\n    // vtkIdTypeArray* intersectionCellIds1 = info->CellIds[1];\n    // vtkPointLocator* pointMerger = info->PointMerger;\n    // double tolerance = info->Tolerance;\n    var mesh0 = publicAPI.getDataset();\n    var mesh1 = info.obbTree1.getDataset();\n    var pointOffset = info.intersectionLines.getPoints().getNumberOfPoints();\n    var intersectionPoints = [];\n    var intersectionLines = []; // The number of cells in OBBTree\n\n    var numCells0 = node0.getCells().length;\n\n    for (var id0 = 0; id0 < numCells0; id0++) {\n      var cellId0 = node0.getCells()[id0];\n      var type0 = mesh0.getCellType(cellId0); // Make sure the cell is a triangle\n\n      if (type0 === CellType.VTK_TRIANGLE) {\n        var _mesh0$getCellPoints = mesh0.getCellPoints(cellId0),\n            triPtIds0 = _mesh0$getCellPoints.cellPointIds;\n\n        var triPts0 = [[], [], []];\n\n        for (var id = 0; id < triPtIds0.length; id++) {\n          mesh0.getPoints().getPoint(triPtIds0[id], triPts0[id]);\n        }\n\n        if (info.obbTree1.triangleIntersectsNode(node1, triPts0[0], triPts0[1], triPts0[2], transform)) {\n          var numCells1 = node1.getCells().length;\n\n          for (var id1 = 0; id1 < numCells1; id1++) {\n            var cellId1 = node1.getCells()[id1];\n            var type1 = mesh1.getCellType(cellId1);\n\n            if (type1 === CellType.VTK_TRIANGLE) {\n              // See if the two cells actually intersect. If they do,\n              // add an entry into the intersection maps and add an\n              // intersection line.\n              var _mesh1$getCellPoints = mesh1.getCellPoints(cellId1),\n                  triPtIds1 = _mesh1$getCellPoints.cellPointIds;\n\n              var triPts1 = [[], [], []];\n\n              for (var _id = 0; _id < triPtIds1.length; _id++) {\n                mesh1.getPoints().getPoint(triPtIds1[_id], triPts1[_id]);\n              }\n\n              var _vtkTriangle$intersec = vtkTriangle.intersectWithTriangle.apply(vtkTriangle, triPts0.concat(triPts1, [model.tolerance])),\n                  intersect = _vtkTriangle$intersec.intersect,\n                  coplanar = _vtkTriangle$intersec.coplanar,\n                  outpt0 = _vtkTriangle$intersec.pt1,\n                  outpt1 = _vtkTriangle$intersec.pt2;\n\n              if (intersect && !coplanar) {\n                var pointId = intersectionPoints.length / 3;\n                intersectionPoints.push.apply(intersectionPoints, _toConsumableArray(outpt0).concat(_toConsumableArray(outpt1)));\n                intersectionLines.push(2, pointOffset + pointId, pointOffset + pointId + 1);\n              } // If actual intersection, add point and cell to edge, line,\n              // and surface maps!\n\n              /*\n              if (coplanar) {\n                // Coplanar triangle intersection is not handled.\n                // This intersection will not be included in the output. TODO\n                // vtkDebugMacro(<<\"Coplanar\");\n                intersects = false;\n                continue;\n              }\n              if (intersects)\n              {\n                vtkIdType lineId = info.intersectionLines->GetNumberOfCells();\n                   vtkIdType ptId0, ptId1;\n                int unique[2];\n                unique[0] = pointMerger->InsertUniquePoint(outpt0, ptId0);\n                unique[1] = pointMerger->InsertUniquePoint(outpt1, ptId1);\n                   int addline = 1;\n                if (ptId0 == ptId1)\n                {\n                  addline = 0;\n                }\n                   if (ptId0 == ptId1 && surfaceid[0] != surfaceid[1])\n                {\n                  intersectionSurfaceId->InsertValue(ptId0, 3);\n                }\n                else\n                {\n                  if (unique[0])\n                  {\n                    intersectionSurfaceId->InsertValue(ptId0, surfaceid[0]);\n                  }\n                  else\n                  {\n                    if (intersectionSurfaceId->GetValue(ptId0) != 3)\n                    {\n                      intersectionSurfaceId->InsertValue(ptId0, surfaceid[0]);\n                    }\n                  }\n                  if (unique[1])\n                  {\n                    intersectionSurfaceId->InsertValue(ptId1, surfaceid[1]);\n                  }\n                  else\n                  {\n                    if (intersectionSurfaceId->GetValue(ptId1) != 3)\n                    {\n                      intersectionSurfaceId->InsertValue(ptId1, surfaceid[1]);\n                    }\n                  }\n                }\n                   info->IntersectionPtsMap[0]->insert(std::make_pair(ptId0, cellId0));\n                info->IntersectionPtsMap[1]->insert(std::make_pair(ptId0, cellId1));\n                info->IntersectionPtsMap[0]->insert(std::make_pair(ptId1, cellId0));\n                info->IntersectionPtsMap[1]->insert(std::make_pair(ptId1, cellId1));\n                   // Check to see if duplicate line. Line can only be a duplicate\n                // line if both points are not unique and they don't\n                // equal each other\n                if (!unique[0] && !unique[1] && ptId0 != ptId1)\n                {\n                  vtkSmartPointer<vtkPolyData> lineTest = vtkSmartPointer<vtkPolyData>::New();\n                  lineTest->SetPoints(pointMerger->GetPoints());\n                  lineTest->SetLines(intersectionLines);\n                  lineTest->BuildLinks();\n                  int newLine = info->CheckLine(lineTest, ptId0, ptId1);\n                  if (newLine == 0)\n                  {\n                    addline = 0;\n                  }\n                }\n                if (addline)\n                {\n                  // If the line is new and does not consist of two identical\n                  // points, add the line to the intersection and update\n                  // mapping information\n                  intersectionLines->InsertNextCell(2);\n                  intersectionLines->InsertCellPoint(ptId0);\n                  intersectionLines->InsertCellPoint(ptId1);\n                     intersectionCellIds0->InsertNextValue(cellId0);\n                  intersectionCellIds1->InsertNextValue(cellId1);\n                     info->PointCellIds[0]->InsertValue(ptId0, cellId0);\n                  info->PointCellIds[0]->InsertValue(ptId1, cellId0);\n                  info->PointCellIds[1]->InsertValue(ptId0, cellId1);\n                  info->PointCellIds[1]->InsertValue(ptId1, cellId1);\n                     info->IntersectionMap[0]->insert(std::make_pair(cellId0, lineId));\n                  info->IntersectionMap[1]->insert(std::make_pair(cellId1, lineId));\n                     // Check which edges of cellId0 and cellId1 outpt0 and\n                  // outpt1 are on, if any.\n                  int isOnEdge = 0;\n                  int m0p0 = 0, m0p1 = 0, m1p0 = 0, m1p1 = 0;\n                  for (vtkIdType edgeId = 0; edgeId < 3; edgeId++)\n                  {\n                    isOnEdge = info->AddToPointEdgeMap(\n                      0, ptId0, outpt0, mesh0, cellId0, edgeId, lineId, triPtIds0);\n                    if (isOnEdge != -1)\n                    {\n                      m0p0++;\n                    }\n                    isOnEdge = info->AddToPointEdgeMap(\n                      0, ptId1, outpt1, mesh0, cellId0, edgeId, lineId, triPtIds0);\n                    if (isOnEdge != -1)\n                    {\n                      m0p1++;\n                    }\n                    isOnEdge = info->AddToPointEdgeMap(\n                      1, ptId0, outpt0, mesh1, cellId1, edgeId, lineId, triPtIds1);\n                    if (isOnEdge != -1)\n                    {\n                      m1p0++;\n                    }\n                    isOnEdge = info->AddToPointEdgeMap(\n                      1, ptId1, outpt1, mesh1, cellId1, edgeId, lineId, triPtIds1);\n                    if (isOnEdge != -1)\n                    {\n                      m1p1++;\n                    }\n                  }\n                  // Special cases caught by tolerance and not from the Point\n                  // Merger\n                  if (m0p0 > 0 && m1p0 > 0)\n                  {\n                    intersectionSurfaceId->InsertValue(ptId0, 3);\n                  }\n                  if (m0p1 > 0 && m1p1 > 0)\n                  {\n                    intersectionSurfaceId->InsertValue(ptId1, 3);\n                  }\n                }\n                // Add information about origin surface to std::maps for\n                // checks later\n                if (intersectionSurfaceId->GetValue(ptId0) == 1)\n                {\n                  info->IntersectionPtsMap[0]->insert(std::make_pair(ptId0, cellId0));\n                }\n                else if (intersectionSurfaceId->GetValue(ptId0) == 2)\n                {\n                  info->IntersectionPtsMap[1]->insert(std::make_pair(ptId0, cellId1));\n                }\n                else\n                {\n                  info->IntersectionPtsMap[0]->insert(std::make_pair(ptId0, cellId0));\n                  info->IntersectionPtsMap[1]->insert(std::make_pair(ptId0, cellId1));\n                }\n                if (intersectionSurfaceId->GetValue(ptId1) == 1)\n                {\n                  info->IntersectionPtsMap[0]->insert(std::make_pair(ptId1, cellId0));\n                }\n                else if (intersectionSurfaceId->GetValue(ptId1) == 2)\n                {\n                  info->IntersectionPtsMap[1]->insert(std::make_pair(ptId1, cellId1));\n                }\n                else\n                {\n                  info->IntersectionPtsMap[0]->insert(std::make_pair(ptId1, cellId0));\n                  info->IntersectionPtsMap[1]->insert(std::make_pair(ptId1, cellId1));\n                }\n              }\n              */\n\n            }\n          }\n        }\n      }\n    }\n\n    if (intersectionPoints.length) {\n      var points = vtkPoints.newInstance();\n      points.setData(pushArray(info.intersectionLines.getPoints().getData(), intersectionPoints));\n      info.intersectionLines.setPoints(points);\n      var lines = vtkCellArray.newInstance();\n      lines.setData(pushArray(info.intersectionLines.getLines().getData(), intersectionLines));\n      info.intersectionLines.setLines(lines);\n    }\n\n    return intersectionLines.length / 3;\n  };\n  /**\n   * Create polygonal representation for OBB tree at specified level. If\n   * level < 0, then the leaf OBB nodes will be gathered. The aspect ratio (ar)\n   * and line diameter (d) are used to control the building of the\n   * representation. If a OBB node edge ratio's are greater than ar, then the\n   * dimension of the OBB is collapsed (OBB->plane->line). A \"line\" OBB will be\n   * represented either as two crossed polygons, or as a line, depending on\n   * the relative diameter of the OBB compared to the diameter (d).\n   * @param {Number} level Level of the representation\n   * @returns {vtkPolyData}\n   */\n\n\n  publicAPI.generateRepresentation = function (level) {\n    if (!model.tree) {\n      vtkErrorMacro('No tree to generate representation for');\n      return null;\n    }\n\n    var points = vtkPoints.newInstance();\n    var polys = vtkCellArray.newInstance();\n    generatePolygons(model.tree, 0, level, points, polys);\n    var output = vtkPolyData.newInstance();\n    output.setPoints(points);\n    output.setPolys(polys);\n    return output;\n  };\n\n  publicAPI.buildLocator = function () {\n    if (model.dataset === null) {\n      vtkErrorMacro(\"Can't build OBB tree - no data available!\");\n      return;\n    }\n\n    var numPts = model.dataset.getPoints().getNumberOfPoints();\n    var numCells = model.dataset.getNumberOfCells();\n\n    if (numPts < 1 || numCells < 1) {\n      vtkErrorMacro(\"Can't build OBB tree - no data available!\");\n      return;\n    }\n\n    model.OBBCount = 0; // Initialize an array of numPts elements set to value 0\n\n    model.insertedPoints = Array.from({\n      length: numPts\n    }, function (_) {\n      return 0;\n    });\n    model.pointsList = [];\n    var cellList = Array.from({\n      length: numCells\n    }, function (_, i) {\n      return i;\n    });\n    model.tree = vtkOBBNode.newInstance();\n    model.level = 0;\n    buildTree(cellList, model.tree, 0);\n    model.insertedPoints = [];\n    model.pointsList = [];\n    publicAPI.modified();\n  };\n} // ----------------------------------------------------------------------------\n\n\nvar DEFAULT_VALUES = {\n  tolerance: 0.01,\n  automatic: true,\n  numberOfCellsPerNode: 32,\n  dataset: null,\n  tree: null,\n  pointsList: [],\n  insertedPoints: [],\n  OBBCount: 0,\n  level: 8,\n  maxLevel: 8,\n  retainCellLists: 1\n}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Build VTK API\n\n  macro.setGet(publicAPI, model, ['tolerance', 'automatic', 'numberOfCellsPerNode', 'dataset', 'tree', 'maxLevel', 'level', 'retainCellLists']); // Make this a VTK object\n\n  macro.obj(publicAPI, model); // Object specific methods\n\n  vtkOBBTree(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = macro.newInstance(extend, 'vtkOBBTree'); // ----------------------------------------------------------------------------\n\nvar vtkOBBTree$1 = {\n  newInstance: newInstance,\n  extend: extend\n};\n\nexport { vtkOBBTree$1 as default, extend, newInstance };\n"],"mappings":"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KAAK,CAAChI,WAAW,EAAEqP,OAAO,CAACW,MAAM,CAACJ,OAAO,EAAE,CAACjP,KAAK,CAACuK,SAAS,CAAC,CAAC,CAAC;gBACxH+E,SAAS,GAAGH,qBAAqB,CAACG,SAAS;gBAC3CC,QAAQ,GAAGJ,qBAAqB,CAACI,QAAQ;gBACzCC,MAAM,GAAGL,qBAAqB,CAACM,GAAG;gBAClCC,MAAM,GAAGP,qBAAqB,CAACQ,GAAG;cAEtC,IAAIL,SAAS,IAAI,CAACC,QAAQ,EAAE;gBAC1B,IAAIK,OAAO,GAAG1B,kBAAkB,CAACrN,MAAM,GAAG,CAAC;gBAC3CqN,kBAAkB,CAAChO,IAAI,CAACmH,KAAK,CAAC6G,kBAAkB,EAAElQ,kBAAkB,CAACwR,MAAM,CAAC,CAACH,MAAM,CAACrR,kBAAkB,CAAC0R,MAAM,CAAC,CAAC,CAAC;gBAChHzB,iBAAiB,CAAC/N,IAAI,CAAC,CAAC,EAAE8N,WAAW,GAAG4B,OAAO,EAAE5B,WAAW,GAAG4B,OAAO,GAAG,CAAC,CAAC;cAC7E,CAAC,CAAC;cACF;;cAEA;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA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"},"metadata":{},"sourceType":"module","externalDependencies":[]}