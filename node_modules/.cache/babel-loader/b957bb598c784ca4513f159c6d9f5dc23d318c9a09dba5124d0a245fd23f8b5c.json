{"ast":null,"code":"import Md5 from 'spark-md5';\nimport macro from '../../macros.js';\nimport vtkShaderProgram from './ShaderProgram.js';\nvar SET_GET_FIELDS = ['lastShaderBound', 'context', '_openGLRenderWindow']; // ----------------------------------------------------------------------------\n// vtkShaderCache methods\n// ----------------------------------------------------------------------------\n\nfunction vtkShaderCache(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkShaderCache');\n  publicAPI.replaceShaderValues = function (VSSource, FSSource, GSSource) {\n    // first handle renaming any Fragment shader inputs\n    // if we have a geometry shader. By default fragment shaders\n    // assume their inputs come from a Vertex Shader. When we\n    // have a Geometry shader we rename the frament shader inputs\n    // to come from the geometry shader\n    var nFSSource = FSSource;\n    if (GSSource.length > 0) {\n      nFSSource = vtkShaderProgram.substitute(nFSSource, 'VSOut', 'GSOut').result;\n    }\n    var gl2 = model._openGLRenderWindow.getWebgl2();\n    var fragDepthString = '\\n';\n    var version = '#version 100\\n';\n    if (gl2) {\n      version = '#version 300 es\\n' + '#define attribute in\\n' + '#define textureCube texture\\n' + '#define texture2D texture\\n' + '#define textureCubeLod textureLod\\n' + '#define texture2DLod textureLod\\n';\n    } else {\n      model.context.getExtension('OES_standard_derivatives');\n      if (model.context.getExtension('EXT_frag_depth')) {\n        fragDepthString = '#extension GL_EXT_frag_depth : enable\\n';\n      }\n      if (model.context.getExtension('EXT_shader_texture_lod')) {\n        fragDepthString += '#extension GL_EXT_shader_texture_lod : enable\\n' + '#define textureCubeLod textureCubeLodEXT\\n' + '#define texture2DLod texture2DLodEXT';\n      }\n    }\n    nFSSource = vtkShaderProgram.substitute(nFSSource, '//VTK::System::Dec', [\"\".concat(version, \"\\n\"), gl2 ? '' : '#extension GL_OES_standard_derivatives : enable\\n', fragDepthString, '#ifdef GL_FRAGMENT_PRECISION_HIGH', 'precision highp float;', 'precision highp int;', '#else', 'precision mediump float;', 'precision mediump int;', '#endif']).result;\n    var nVSSource = vtkShaderProgram.substitute(VSSource, '//VTK::System::Dec', [\"\".concat(version, \"\\n\"), '#ifdef GL_FRAGMENT_PRECISION_HIGH', 'precision highp float;', 'precision highp int;', '#else', 'precision mediump float;', 'precision mediump int;', '#endif']).result;\n    if (gl2) {\n      nVSSource = vtkShaderProgram.substitute(nVSSource, 'varying', 'out').result;\n      nFSSource = vtkShaderProgram.substitute(nFSSource, 'varying', 'in').result;\n      var shaderOutputs = '';\n      var outputCount = 0;\n      while (nFSSource.includes(\"gl_FragData[\".concat(outputCount, \"]\"))) {\n        nFSSource = vtkShaderProgram.substitute(nFSSource, \"gl_FragData\\\\[\".concat(outputCount, \"\\\\]\"), \"fragOutput\".concat(outputCount)).result;\n        shaderOutputs += \"layout(location = \".concat(outputCount, \") out vec4 fragOutput\").concat(outputCount, \";\\n\");\n        outputCount++;\n      }\n      nFSSource = vtkShaderProgram.substitute(nFSSource, '//VTK::Output::Dec', shaderOutputs).result;\n    } // nFSSource = ShaderProgram.substitute(nFSSource, 'gl_FragData\\\\[0\\\\]',\n    //   'gl_FragColor').result;\n\n    var nGSSource = vtkShaderProgram.substitute(GSSource, '//VTK::System::Dec', version).result;\n    return {\n      VSSource: nVSSource,\n      FSSource: nFSSource,\n      GSSource: nGSSource\n    };\n  }; // return NULL if there is an issue\n\n  publicAPI.readyShaderProgramArray = function (vertexCode, fragmentCode, geometryCode) {\n    var data = publicAPI.replaceShaderValues(vertexCode, fragmentCode, geometryCode);\n    var shader = publicAPI.getShaderProgram(data.VSSource, data.FSSource, data.GSSource);\n    return publicAPI.readyShaderProgram(shader);\n  };\n  publicAPI.readyShaderProgram = function (shader) {\n    if (!shader) {\n      return null;\n    } // compile if needed\n\n    if (!shader.getCompiled() && !shader.compileShader()) {\n      return null;\n    } // bind if needed\n\n    if (!publicAPI.bindShader(shader)) {\n      return null;\n    }\n    return shader;\n  };\n  publicAPI.getShaderProgram = function (vertexCode, fragmentCode, geometryCode) {\n    // compute the MD5 and the check the map\n    var hashInput = \"\".concat(vertexCode).concat(fragmentCode).concat(geometryCode);\n    var result = Md5.hash(hashInput); // does it already exist?\n\n    if (!(result in model.shaderPrograms)) {\n      // create one\n      var sps = vtkShaderProgram.newInstance();\n      sps.setContext(model.context);\n      sps.getVertexShader().setSource(vertexCode);\n      sps.getFragmentShader().setSource(fragmentCode);\n      if (geometryCode) {\n        sps.getGeometryShader().setSource(geometryCode);\n      }\n      sps.setMd5Hash(result);\n      model.shaderPrograms[result] = sps;\n      return sps;\n    }\n    return model.shaderPrograms[result];\n  };\n  publicAPI.releaseGraphicsResources = function (win) {\n    // NOTE:\n    // In the current implementation as of October 26th, if a shader\n    // program is created by ShaderCache then it should make sure\n    // that it releases the graphics resources used by these programs.\n    // It is not wisely for callers to do that since then they would\n    // have to loop over all the programs were in use and invoke\n    // release graphics resources individually.\n    publicAPI.releaseCurrentShader();\n    Object.keys(model.shaderPrograms).map(function (key) {\n      return model.shaderPrograms[key];\n    }).forEach(function (sp) {\n      return sp.releaseGraphicsResources(win);\n    });\n  };\n  publicAPI.releaseGraphicsResources = function () {\n    // release prior shader\n    if (model.astShaderBound) {\n      model.lastShaderBound.release();\n      model.lastShaderBound = null;\n    }\n  };\n  publicAPI.bindShader = function (shader) {\n    if (model.lastShaderBound === shader) {\n      return 1;\n    } // release prior shader\n\n    if (model.lastShaderBound) {\n      model.lastShaderBound.release();\n    }\n    shader.bind();\n    model.lastShaderBound = shader;\n    return 1;\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nvar DEFAULT_VALUES = {\n  lastShaderBound: null,\n  shaderPrograms: null,\n  context: null // _openGLRenderWindow: null,\n}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Internal objects\n\n  model.shaderPrograms = {}; // Build VTK API\n\n  macro.obj(publicAPI, model);\n  macro.setGet(publicAPI, model, SET_GET_FIELDS);\n  macro.moveToProtected(publicAPI, model, ['openGLRenderWindow']); // Object methods\n\n  vtkShaderCache(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = macro.newInstance(extend, 'vtkShaderCache'); // ----------------------------------------------------------------------------\n\nvar vtkShaderCache$1 = {\n  newInstance: newInstance,\n  extend: extend\n};\nexport { vtkShaderCache$1 as default, extend, newInstance };","map":{"version":3,"names":["Md5","macro","vtkShaderProgram","SET_GET_FIELDS","vtkShaderCache","publicAPI","model","classHierarchy","push","replaceShaderValues","VSSource","FSSource","GSSource","nFSSource","length","substitute","result","gl2","_openGLRenderWindow","getWebgl2","fragDepthString","version","context","getExtension","concat","nVSSource","shaderOutputs","outputCount","includes","nGSSource","readyShaderProgramArray","vertexCode","fragmentCode","geometryCode","data","shader","getShaderProgram","readyShaderProgram","getCompiled","compileShader","bindShader","hashInput","hash","shaderPrograms","sps","newInstance","setContext","getVertexShader","setSource","getFragmentShader","getGeometryShader","setMd5Hash","releaseGraphicsResources","win","releaseCurrentShader","Object","keys","map","key","forEach","sp","astShaderBound","lastShaderBound","release","bind","DEFAULT_VALUES","extend","initialValues","arguments","undefined","assign","obj","setGet","moveToProtected","vtkShaderCache$1","default"],"sources":["/home/rakshith/Documents/RemoteRendering/vtk-js-react-app/node_modules/@kitware/vtk.js/Rendering/OpenGL/ShaderCache.js"],"sourcesContent":["import Md5 from 'spark-md5';\nimport macro from '../../macros.js';\nimport vtkShaderProgram from './ShaderProgram.js';\n\nvar SET_GET_FIELDS = ['lastShaderBound', 'context', '_openGLRenderWindow']; // ----------------------------------------------------------------------------\n// vtkShaderCache methods\n// ----------------------------------------------------------------------------\n\nfunction vtkShaderCache(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkShaderCache');\n\n  publicAPI.replaceShaderValues = function (VSSource, FSSource, GSSource) {\n    // first handle renaming any Fragment shader inputs\n    // if we have a geometry shader. By default fragment shaders\n    // assume their inputs come from a Vertex Shader. When we\n    // have a Geometry shader we rename the frament shader inputs\n    // to come from the geometry shader\n    var nFSSource = FSSource;\n\n    if (GSSource.length > 0) {\n      nFSSource = vtkShaderProgram.substitute(nFSSource, 'VSOut', 'GSOut').result;\n    }\n\n    var gl2 = model._openGLRenderWindow.getWebgl2();\n\n    var fragDepthString = '\\n';\n    var version = '#version 100\\n';\n\n    if (gl2) {\n      version = '#version 300 es\\n' + '#define attribute in\\n' + '#define textureCube texture\\n' + '#define texture2D texture\\n' + '#define textureCubeLod textureLod\\n' + '#define texture2DLod textureLod\\n';\n    } else {\n      model.context.getExtension('OES_standard_derivatives');\n\n      if (model.context.getExtension('EXT_frag_depth')) {\n        fragDepthString = '#extension GL_EXT_frag_depth : enable\\n';\n      }\n\n      if (model.context.getExtension('EXT_shader_texture_lod')) {\n        fragDepthString += '#extension GL_EXT_shader_texture_lod : enable\\n' + '#define textureCubeLod textureCubeLodEXT\\n' + '#define texture2DLod texture2DLodEXT';\n      }\n    }\n\n    nFSSource = vtkShaderProgram.substitute(nFSSource, '//VTK::System::Dec', [\"\".concat(version, \"\\n\"), gl2 ? '' : '#extension GL_OES_standard_derivatives : enable\\n', fragDepthString, '#ifdef GL_FRAGMENT_PRECISION_HIGH', 'precision highp float;', 'precision highp int;', '#else', 'precision mediump float;', 'precision mediump int;', '#endif']).result;\n    var nVSSource = vtkShaderProgram.substitute(VSSource, '//VTK::System::Dec', [\"\".concat(version, \"\\n\"), '#ifdef GL_FRAGMENT_PRECISION_HIGH', 'precision highp float;', 'precision highp int;', '#else', 'precision mediump float;', 'precision mediump int;', '#endif']).result;\n\n    if (gl2) {\n      nVSSource = vtkShaderProgram.substitute(nVSSource, 'varying', 'out').result;\n      nFSSource = vtkShaderProgram.substitute(nFSSource, 'varying', 'in').result;\n      var shaderOutputs = '';\n      var outputCount = 0;\n\n      while (nFSSource.includes(\"gl_FragData[\".concat(outputCount, \"]\"))) {\n        nFSSource = vtkShaderProgram.substitute(nFSSource, \"gl_FragData\\\\[\".concat(outputCount, \"\\\\]\"), \"fragOutput\".concat(outputCount)).result;\n        shaderOutputs += \"layout(location = \".concat(outputCount, \") out vec4 fragOutput\").concat(outputCount, \";\\n\");\n        outputCount++;\n      }\n\n      nFSSource = vtkShaderProgram.substitute(nFSSource, '//VTK::Output::Dec', shaderOutputs).result;\n    } // nFSSource = ShaderProgram.substitute(nFSSource, 'gl_FragData\\\\[0\\\\]',\n    //   'gl_FragColor').result;\n\n\n    var nGSSource = vtkShaderProgram.substitute(GSSource, '//VTK::System::Dec', version).result;\n    return {\n      VSSource: nVSSource,\n      FSSource: nFSSource,\n      GSSource: nGSSource\n    };\n  }; // return NULL if there is an issue\n\n\n  publicAPI.readyShaderProgramArray = function (vertexCode, fragmentCode, geometryCode) {\n    var data = publicAPI.replaceShaderValues(vertexCode, fragmentCode, geometryCode);\n    var shader = publicAPI.getShaderProgram(data.VSSource, data.FSSource, data.GSSource);\n    return publicAPI.readyShaderProgram(shader);\n  };\n\n  publicAPI.readyShaderProgram = function (shader) {\n    if (!shader) {\n      return null;\n    } // compile if needed\n\n\n    if (!shader.getCompiled() && !shader.compileShader()) {\n      return null;\n    } // bind if needed\n\n\n    if (!publicAPI.bindShader(shader)) {\n      return null;\n    }\n\n    return shader;\n  };\n\n  publicAPI.getShaderProgram = function (vertexCode, fragmentCode, geometryCode) {\n    // compute the MD5 and the check the map\n    var hashInput = \"\".concat(vertexCode).concat(fragmentCode).concat(geometryCode);\n    var result = Md5.hash(hashInput); // does it already exist?\n\n    if (!(result in model.shaderPrograms)) {\n      // create one\n      var sps = vtkShaderProgram.newInstance();\n      sps.setContext(model.context);\n      sps.getVertexShader().setSource(vertexCode);\n      sps.getFragmentShader().setSource(fragmentCode);\n\n      if (geometryCode) {\n        sps.getGeometryShader().setSource(geometryCode);\n      }\n\n      sps.setMd5Hash(result);\n      model.shaderPrograms[result] = sps;\n      return sps;\n    }\n\n    return model.shaderPrograms[result];\n  };\n\n  publicAPI.releaseGraphicsResources = function (win) {\n    // NOTE:\n    // In the current implementation as of October 26th, if a shader\n    // program is created by ShaderCache then it should make sure\n    // that it releases the graphics resources used by these programs.\n    // It is not wisely for callers to do that since then they would\n    // have to loop over all the programs were in use and invoke\n    // release graphics resources individually.\n    publicAPI.releaseCurrentShader();\n    Object.keys(model.shaderPrograms).map(function (key) {\n      return model.shaderPrograms[key];\n    }).forEach(function (sp) {\n      return sp.releaseGraphicsResources(win);\n    });\n  };\n\n  publicAPI.releaseGraphicsResources = function () {\n    // release prior shader\n    if (model.astShaderBound) {\n      model.lastShaderBound.release();\n      model.lastShaderBound = null;\n    }\n  };\n\n  publicAPI.bindShader = function (shader) {\n    if (model.lastShaderBound === shader) {\n      return 1;\n    } // release prior shader\n\n\n    if (model.lastShaderBound) {\n      model.lastShaderBound.release();\n    }\n\n    shader.bind();\n    model.lastShaderBound = shader;\n    return 1;\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\n\nvar DEFAULT_VALUES = {\n  lastShaderBound: null,\n  shaderPrograms: null,\n  context: null // _openGLRenderWindow: null,\n\n}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Internal objects\n\n  model.shaderPrograms = {}; // Build VTK API\n\n  macro.obj(publicAPI, model);\n  macro.setGet(publicAPI, model, SET_GET_FIELDS);\n  macro.moveToProtected(publicAPI, model, ['openGLRenderWindow']); // Object methods\n\n  vtkShaderCache(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = macro.newInstance(extend, 'vtkShaderCache'); // ----------------------------------------------------------------------------\n\nvar vtkShaderCache$1 = {\n  newInstance: newInstance,\n  extend: extend\n};\n\nexport { vtkShaderCache$1 as default, extend, newInstance };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}