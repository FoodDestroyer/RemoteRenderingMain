{"ast":null,"code":"import macro from '../../macros.js';\nimport vtkOpenGLFramebuffer from './Framebuffer.js';\nimport vtkRenderPass from '../SceneGraph/RenderPass.js';\nimport vtkOpenGLOrderIndependentTranslucentPass from './OrderIndependentTranslucentPass.js';\nfunction vtkForwardPass(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkForwardPass'); // this pass implements a forward rendering pipeline\n  // if both volumes and opaque geometry are present\n  // it will mix the two together by capturing a zbuffer\n  // first\n\n  publicAPI.traverse = function (viewNode) {\n    var parent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    if (model.deleted) {\n      return;\n    } // we just render our delegates in order\n\n    model._currentParent = parent; // build\n\n    publicAPI.setCurrentOperation('buildPass');\n    viewNode.traverse(publicAPI);\n    var numlayers = viewNode.getRenderable().getNumberOfLayers(); // iterate over renderers\n\n    var renderers = viewNode.getChildren();\n    for (var i = 0; i < numlayers; i++) {\n      for (var index = 0; index < renderers.length; index++) {\n        var renNode = renderers[index];\n        var ren = viewNode.getRenderable().getRenderers()[index];\n        if (ren.getDraw() && ren.getLayer() === i) {\n          // check for both opaque and volume actors\n          model.opaqueActorCount = 0;\n          model.translucentActorCount = 0;\n          model.volumeCount = 0;\n          model.overlayActorCount = 0;\n          publicAPI.setCurrentOperation('queryPass');\n          renNode.traverse(publicAPI); // do we need to capture a zbuffer?\n\n          if ((model.opaqueActorCount > 0 || model.translucentActorCount > 0) && model.volumeCount > 0 || model.depthRequested) {\n            var size = viewNode.getFramebufferSize(); // make sure the framebuffer is setup\n\n            if (model.framebuffer === null) {\n              model.framebuffer = vtkOpenGLFramebuffer.newInstance();\n            }\n            model.framebuffer.setOpenGLRenderWindow(viewNode);\n            model.framebuffer.saveCurrentBindingsAndBuffers();\n            var fbSize = model.framebuffer.getSize();\n            if (fbSize === null || fbSize[0] !== size[0] || fbSize[1] !== size[1]) {\n              model.framebuffer.create(size[0], size[1]);\n              model.framebuffer.populateFramebuffer();\n            }\n            model.framebuffer.bind(); // opaqueZBufferPass only renders opaque actors\n            // zBufferPass renders both translucent and opaque actors\n            // we want to be able to pick translucent actors\n\n            publicAPI.setCurrentOperation('zBufferPass');\n            renNode.traverse(publicAPI);\n            model.framebuffer.restorePreviousBindingsAndBuffers(); // reset now that we have done it\n\n            model.depthRequested = false;\n          }\n          publicAPI.setCurrentOperation('cameraPass');\n          renNode.traverse(publicAPI);\n          if (model.opaqueActorCount > 0) {\n            publicAPI.setCurrentOperation('opaquePass');\n            renNode.traverse(publicAPI);\n          }\n          if (model.translucentActorCount > 0) {\n            if (!model.translucentPass) {\n              model.translucentPass = vtkOpenGLOrderIndependentTranslucentPass.newInstance();\n            }\n            model.translucentPass.traverse(viewNode, renNode, publicAPI);\n          }\n          if (model.volumeCount > 0) {\n            publicAPI.setCurrentOperation('volumePass');\n            renNode.traverse(publicAPI);\n          }\n          if (model.overlayActorCount > 0) {\n            publicAPI.setCurrentOperation('overlayPass');\n            renNode.traverse(publicAPI);\n          }\n        }\n      }\n    }\n  };\n  publicAPI.getZBufferTexture = function () {\n    if (model.framebuffer) {\n      return model.framebuffer.getColorTexture();\n    }\n    return null;\n  };\n  publicAPI.requestDepth = function () {\n    model.depthRequested = true;\n  };\n  publicAPI.incrementOpaqueActorCount = function () {\n    return model.opaqueActorCount++;\n  };\n  publicAPI.incrementTranslucentActorCount = function () {\n    return model.translucentActorCount++;\n  };\n  publicAPI.incrementVolumeCount = function () {\n    return model.volumeCount++;\n  };\n  publicAPI.incrementOverlayActorCount = function () {\n    return model.overlayActorCount++;\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nvar DEFAULT_VALUES = {\n  opaqueActorCount: 0,\n  translucentActorCount: 0,\n  volumeCount: 0,\n  overlayActorCount: 0,\n  framebuffer: null,\n  depthRequested: false\n}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Build VTK API\n\n  vtkRenderPass.extend(publicAPI, model, initialValues);\n  macro.get(publicAPI, model, ['framebuffer', 'opaqueActorCount', 'translucentActorCount', 'volumeCount']); // Object methods\n\n  vtkForwardPass(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = macro.newInstance(extend, 'vtkForwardPass'); // ----------------------------------------------------------------------------\n\nvar vtkForwardPass$1 = {\n  newInstance: newInstance,\n  extend: extend\n};\nexport { vtkForwardPass$1 as default, extend, newInstance };","map":{"version":3,"names":["macro","vtkOpenGLFramebuffer","vtkRenderPass","vtkOpenGLOrderIndependentTranslucentPass","vtkForwardPass","publicAPI","model","classHierarchy","push","traverse","viewNode","parent","arguments","length","undefined","deleted","_currentParent","setCurrentOperation","numlayers","getRenderable","getNumberOfLayers","renderers","getChildren","i","index","renNode","ren","getRenderers","getDraw","getLayer","opaqueActorCount","translucentActorCount","volumeCount","overlayActorCount","depthRequested","size","getFramebufferSize","framebuffer","newInstance","setOpenGLRenderWindow","saveCurrentBindingsAndBuffers","fbSize","getSize","create","populateFramebuffer","bind","restorePreviousBindingsAndBuffers","translucentPass","getZBufferTexture","getColorTexture","requestDepth","incrementOpaqueActorCount","incrementTranslucentActorCount","incrementVolumeCount","incrementOverlayActorCount","DEFAULT_VALUES","extend","initialValues","Object","assign","get","vtkForwardPass$1","default"],"sources":["/home/rakshith/Documents/RemoteRendering/vtk-js-react-app/node_modules/@kitware/vtk.js/Rendering/OpenGL/ForwardPass.js"],"sourcesContent":["import macro from '../../macros.js';\nimport vtkOpenGLFramebuffer from './Framebuffer.js';\nimport vtkRenderPass from '../SceneGraph/RenderPass.js';\nimport vtkOpenGLOrderIndependentTranslucentPass from './OrderIndependentTranslucentPass.js';\n\nfunction vtkForwardPass(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkForwardPass'); // this pass implements a forward rendering pipeline\n  // if both volumes and opaque geometry are present\n  // it will mix the two together by capturing a zbuffer\n  // first\n\n  publicAPI.traverse = function (viewNode) {\n    var parent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n    if (model.deleted) {\n      return;\n    } // we just render our delegates in order\n\n\n    model._currentParent = parent; // build\n\n    publicAPI.setCurrentOperation('buildPass');\n    viewNode.traverse(publicAPI);\n    var numlayers = viewNode.getRenderable().getNumberOfLayers(); // iterate over renderers\n\n    var renderers = viewNode.getChildren();\n\n    for (var i = 0; i < numlayers; i++) {\n      for (var index = 0; index < renderers.length; index++) {\n        var renNode = renderers[index];\n        var ren = viewNode.getRenderable().getRenderers()[index];\n\n        if (ren.getDraw() && ren.getLayer() === i) {\n          // check for both opaque and volume actors\n          model.opaqueActorCount = 0;\n          model.translucentActorCount = 0;\n          model.volumeCount = 0;\n          model.overlayActorCount = 0;\n          publicAPI.setCurrentOperation('queryPass');\n          renNode.traverse(publicAPI); // do we need to capture a zbuffer?\n\n          if ((model.opaqueActorCount > 0 || model.translucentActorCount > 0) && model.volumeCount > 0 || model.depthRequested) {\n            var size = viewNode.getFramebufferSize(); // make sure the framebuffer is setup\n\n            if (model.framebuffer === null) {\n              model.framebuffer = vtkOpenGLFramebuffer.newInstance();\n            }\n\n            model.framebuffer.setOpenGLRenderWindow(viewNode);\n            model.framebuffer.saveCurrentBindingsAndBuffers();\n            var fbSize = model.framebuffer.getSize();\n\n            if (fbSize === null || fbSize[0] !== size[0] || fbSize[1] !== size[1]) {\n              model.framebuffer.create(size[0], size[1]);\n              model.framebuffer.populateFramebuffer();\n            }\n\n            model.framebuffer.bind(); // opaqueZBufferPass only renders opaque actors\n            // zBufferPass renders both translucent and opaque actors\n            // we want to be able to pick translucent actors\n\n            publicAPI.setCurrentOperation('zBufferPass');\n            renNode.traverse(publicAPI);\n            model.framebuffer.restorePreviousBindingsAndBuffers(); // reset now that we have done it\n\n            model.depthRequested = false;\n          }\n\n          publicAPI.setCurrentOperation('cameraPass');\n          renNode.traverse(publicAPI);\n\n          if (model.opaqueActorCount > 0) {\n            publicAPI.setCurrentOperation('opaquePass');\n            renNode.traverse(publicAPI);\n          }\n\n          if (model.translucentActorCount > 0) {\n            if (!model.translucentPass) {\n              model.translucentPass = vtkOpenGLOrderIndependentTranslucentPass.newInstance();\n            }\n\n            model.translucentPass.traverse(viewNode, renNode, publicAPI);\n          }\n\n          if (model.volumeCount > 0) {\n            publicAPI.setCurrentOperation('volumePass');\n            renNode.traverse(publicAPI);\n          }\n\n          if (model.overlayActorCount > 0) {\n            publicAPI.setCurrentOperation('overlayPass');\n            renNode.traverse(publicAPI);\n          }\n        }\n      }\n    }\n  };\n\n  publicAPI.getZBufferTexture = function () {\n    if (model.framebuffer) {\n      return model.framebuffer.getColorTexture();\n    }\n\n    return null;\n  };\n\n  publicAPI.requestDepth = function () {\n    model.depthRequested = true;\n  };\n\n  publicAPI.incrementOpaqueActorCount = function () {\n    return model.opaqueActorCount++;\n  };\n\n  publicAPI.incrementTranslucentActorCount = function () {\n    return model.translucentActorCount++;\n  };\n\n  publicAPI.incrementVolumeCount = function () {\n    return model.volumeCount++;\n  };\n\n  publicAPI.incrementOverlayActorCount = function () {\n    return model.overlayActorCount++;\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\n\nvar DEFAULT_VALUES = {\n  opaqueActorCount: 0,\n  translucentActorCount: 0,\n  volumeCount: 0,\n  overlayActorCount: 0,\n  framebuffer: null,\n  depthRequested: false\n}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Build VTK API\n\n  vtkRenderPass.extend(publicAPI, model, initialValues);\n  macro.get(publicAPI, model, ['framebuffer', 'opaqueActorCount', 'translucentActorCount', 'volumeCount']); // Object methods\n\n  vtkForwardPass(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = macro.newInstance(extend, 'vtkForwardPass'); // ----------------------------------------------------------------------------\n\nvar vtkForwardPass$1 = {\n  newInstance: newInstance,\n  extend: extend\n};\n\nexport { vtkForwardPass$1 as default, extend, newInstance };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}